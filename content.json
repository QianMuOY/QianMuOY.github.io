{"meta":{"title":"qianmu's blog","subtitle":"","description":"","author":"qianmu","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2023-03-20T05:14:50.000Z","updated":"2023-03-20T05:15:55.058Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-03-20T05:14:26.000Z","updated":"2023-03-20T05:16:34.634Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"link","date":"2023-03-20T05:49:33.000Z","updated":"2023-03-20T05:50:00.871Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""}],"posts":[{"title":"面向对象","slug":"面向对象","date":"2023-03-22T12:42:09.000Z","updated":"2023-03-22T12:45:12.496Z","comments":true,"path":"2023/03/22/面向对象/","link":"","permalink":"http://example.com/2023/03/22/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"explicit关键字，作为返回值时加上不调用拷贝构造函数。作为类关键字防止被拷贝。 多态父类指针指向子类对象 父类提供virtual 虚函数，子类对象实现 析构函数加virtual，可以调用子类的析构函数 构造函数前不能加virtual，因为构造函数执行后，虚表才出现 运算符重载 类中，++i比i++效率高，因为后者还要调用构造函数 工厂模式用父类指针作为返回值，在返回值创建子类对象 单体模式sizeof、_countof_tscanf_s( _T(“%d”), v1, _countof(v1)); sizeof 数据类型大小与数据大小相乘，实际的数据大小 countof 数据大小，实际上的数据数量 结构体对齐大小为4，1，8，按最大的对齐 如上，实际上为16。double占8，另外两个加起来用8 重载函数名一样，参数类型不同，参数数量不同 与返回值类型无关 使用const，发生重载。 const是常对象调用的。 菱形继承一个派生类D是由多继承产生的，它的多个基类B、C继承了同一个基类A。造成派生类D中具有多份A类的属性，属于一种不合理的现象 会让高层的基类在底层的派生类中拥有多份成员，造成二义性。 解决方法：使用作用域、利用虚继承 在使用时加上作用域 但是不能解决多次拷贝的问题 虚继承 给所有函数都加上virtual 继承时使用虚继承 使用虚继承时，第一成员是一个指针，指向一个结构体，里面第二成员是一个十六进制偏移。偏移值是父类到子类的偏移。 虚继承中，父类指针只能访问子类对象被继承的部分。因为在定义的时候，有一个偏移指向对应的数据。 虚表将父类中函数定义为虚函数后，会出现一个虚表指针（4或8）在上述结构体的第一成员（第二成员是到子类的偏移），指向一个数组。数组中存放的都是函数，如果孩子实现了这个函数，就会放入孩子的。如果孩子的没实现，就会放入自己的。 类A是基类，类B继承类A，类C又继承类B。类A，类B，类C，假设在子类有实现，其对象模型如下图所示。 若菱形继承，两个父类均有对虚函数的实现，而子类没有对虚函数的实现，就会出现二义性问题。一般来说，子类都会进行实现，不会出现这种问题。 经常在父类的析构函数前加virtual，是为了在释放内存时使用子类的析构函数。 纯虚类父类使用纯虚函数virtual void show() = 0;它不会实例化一个对象，在子类继承的时候也会把纯虚函数继承，它强制性要求，派生类必须实现某个接口，不然无法实例化对象","categories":[],"tags":[]},{"title":"智能指针","slug":"智能指针","date":"2023-03-22T12:38:10.000Z","updated":"2023-03-22T12:41:17.019Z","comments":true,"path":"2023/03/22/智能指针/","link":"","permalink":"http://example.com/2023/03/22/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/","excerpt":"","text":"智能指针 c++11std::unique_ptr&lt;T&gt; ：独占资源所有权的指针。当我们独占资源的所有权的时候，可以使用 std::unique_ptr 对资源进行管理——离开 unique_ptr 对象的作用域时，会自动释放资源。 std::unique_ptr 是 move-only 的。 12std::unique_ptr&lt;int&gt; uptr = std::make_unique&lt;int&gt;(200);std::unique_ptr&lt;int&gt; uptr1 = uptr; // 编译错误，std::unique_ptr&lt;T&gt; 是 move-only 的 std::unique_ptr 可以指向一个数组。 可以自定义 deleter。 12345678910&#123; struct FileCloser &#123; void operator()(FILE* fp) const &#123; if (fp != nullptr) &#123; fclose(fp); &#125; &#125; &#125;; std::unique_ptr&lt;FILE, FileCloser&gt; uptr(fopen(&quot;test_file.txt&quot;, &quot;w&quot;));&#125; 123456&#123; std::unique_ptr&lt;FILE, std::function&lt;void(FILE*)&gt;&gt; uptr( fopen(&quot;test_file.txt&quot;, &quot;w&quot;), [](FILE* fp) &#123; fclose(fp); &#125;);&#125; std::shared_ptr&lt;T&gt; ：共享资源所有权的指针。其实就是对资源做引用计数——当引用计数为 0 的时候，自动释放资源。 1234567891011&#123; std::shared_ptr&lt;int&gt; sptr = std::make_shared&lt;int&gt;(200); assert(sptr.use_count() == 1); // 此时引用计数为 1 &#123; std::shared_ptr&lt;int&gt; sptr1 = sptr; assert(sptr.get() == sptr1.get()); assert(sptr.use_count() == 2); // sptr 和 sptr1 共享资源，引用计数为 2 &#125; assert(sptr.use_count() == 1); // sptr1 已经释放&#125;// use_count 为 0 时自动释放内存 也可以指向数组和自定义 deleter。 12345678910111213141516171819&#123; // C++20 才支持 std::make_shared&lt;int[]&gt; // std::shared_ptr&lt;int[]&gt; sptr = std::make_shared&lt;int[]&gt;(100); std::shared_ptr&lt;int[]&gt; sptr(new int[10]); for (int i = 0; i &lt; 10; i++) &#123; sptr[i] = i * i; &#125; for (int i = 0; i &lt; 10; i++) &#123; std::cout &lt;&lt; sptr[i] &lt;&lt; std::endl; &#125; &#125;&#123; std::shared_ptr&lt;FILE&gt; sptr( fopen(&quot;test_file.txt&quot;, &quot;w&quot;), [](FILE* fp) &#123; std::cout &lt;&lt; &quot;close &quot; &lt;&lt; fp &lt;&lt; std::endl; fclose(fp); &#125;);&#125; 一个 shared_ptr 对象的内存开销要比裸指针和无自定义 deleter 的 unique_ptr 对象略大。 shared_ptr 需要维护的信息有两部分： 指向共享资源的指针。 引用计数等共享资源的控制信息——实现上是维护一个指向控制信息的指针。 所以，shared_ptr 对象需要保存两个指针。shared_ptr 的 的 deleter 是保存在控制信息中，所以，是否有自定义 deleter 不影响 shared_ptr 对象的大小。 不能去掉 shared_ptr 对象中指向共享资源的指针。 因为 shared_ptr 对象中的指针指向的对象不一定和控制块中的指针指向的对象一样。（由于多态的存在，有可能指向父类对象）。 12345678910111213141516struct Fruit &#123; int juice;&#125;;struct Vegetable &#123; int fiber;&#125;;struct Tomato : public Fruit, Vegetable &#123; int sauce;&#125;; // 由于继承的存在，shared_ptr 可能指向基类对象std::shared_ptr&lt;Tomato&gt; tomato = std::make_shared&lt;Tomato&gt;();std::shared_ptr&lt;Fruit&gt; fruit = tomato;std::shared_ptr&lt;Vegetable&gt; vegetable = tomato; std::shared_ptr 支持 aliasing constructor。 Aliasing constructor，简单说就是构造出来的 shared_ptr 对象和参数 r 指向同一个控制块（会影响 r 指向的资源的生命周期），但是指向共享资源的指针是参数 ptr。看下面这个例子。 1234567891011using Vec = std::vector&lt;int&gt;;std::shared_ptr&lt;int&gt; GetSPtr() &#123; auto elts = &#123;0, 1, 2, 3, 4&#125;; std::shared_ptr&lt;Vec&gt; pvec = std::make_shared&lt;Vec&gt;(elts); return std::shared_ptr&lt;int&gt;(pvec, &amp;(*pvec)[2]);&#125;std::shared_ptr&lt;int&gt; sptr = GetSPtr();for (int i = -2; i &lt; 3; ++i) &#123; printf(&quot;%d\\n&quot;, sptr.get()[i]);&#125; 使用 std::shared_ptr 时，会涉及两次内存分配：一次分配共享资源对象；一次分配控制块。C++ 标准库提供了 std::make_shared 函数来创建一个 shared_ptr 对象，只需要一次内存分配。 这种情况下，不用通过控制块中的指针，我们也能知道共享资源的位置——这个指针也可以省略掉。 成员函数获取 this 的 shared_ptr 的正确的做法是继承 std::enable_shared_from_this。 123456789101112class Bar : public std::enable_shared_from_this&lt;Bar&gt; &#123; public: std::shared_ptr&lt;Bar&gt; GetSPtr() &#123; return shared_from_this(); &#125;&#125;;auto sptr1 = std::make_shared&lt;Bar&gt;();assert(sptr1.use_count() == 1);auto sptr2 = sptr1-&gt;GetSPtr();assert(sptr1.use_count() == 2);assert(sptr2.use_count() == 2); 一般情况下，继承了 std::enable_shared_from_this 的子类，成员变量中增加了一个指向 this 的 weak_ptr。这个 weak_ptr 在第一次创建 shared_ptr 的时候会被初始化，指向 this。 似乎继承了 std::enable_shared_from_this 的类都被强制必须通过 shared_ptr 进行管理。如果没有创建shared_ptr 直接调用shared_from_this()方法，将会报错。 std::weak_ptr&lt;T&gt; ：共享资源的观察者，需要和 std::shared_ptr 一起使用，不影响资源的生命周期。std::weak_ptr 要与 std::shared_ptr 一起使用。 一个 std::weak_ptr 对象看做是 std::shared_ptr 对象管理的资源的观察者，它不影响共享资源的生命周期： 如果需要使用 weak_ptr 正在观察的资源，可以将 weak_ptr 提升为 shared_ptr。 当 shared_ptr 管理的资源被释放时，weak_ptr 会自动变成 nullptr。 123456789101112131415void Observe(std::weak_ptr&lt;int&gt; wptr) &#123; if (auto sptr = wptr.lock()) &#123; std::cout &lt;&lt; &quot;value: &quot; &lt;&lt; *sptr &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;wptr lock fail&quot; &lt;&lt; std::endl; &#125;&#125;std::weak_ptr&lt;int&gt; wptr;&#123; auto sptr = std::make_shared&lt;int&gt;(111); wptr = sptr; Observe(wptr); // sptr 指向的资源没被释放，wptr 可以成功提升为 shared_ptr&#125;Observe(wptr); // sptr 指向的资源已被释放，wptr 无法提升为 shared_ptr 当 shared_ptr 析构并释放共享资源的时候，只要 weak_ptr 对象还存在，控制块就会保留，weak_ptr 可以通过控制块观察到对象是否存活。","categories":[],"tags":[]},{"title":"c++20","slug":"c-20","date":"2023-03-22T12:35:37.000Z","updated":"2023-03-22T12:37:09.207Z","comments":true,"path":"2023/03/22/c-20/","link":"","permalink":"http://example.com/2023/03/22/c-20/","excerpt":"","text":"语法糖语法糖是指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。 C++也有很多语法糖，比如运算符重载、lambda表达式、auto类型推导等。这些语法糖可以让我们的代码更简洁、更易读、更高效。例如，下面两种写法是等价的： 12345678int sum = 0;for (int i = 0; i &lt; 10; i++) &#123; sum += i;&#125;int sum = 0;for (auto i : &#123;0,1,2,3,4,5,6,7,8,9&#125;) &#123; sum += i;&#125; c++11、20新特性大多数都是语法糖 c++20C++20有很多新的特性，其中最重要的四个是概念、范围、协程和模块。概念可以让我们定义泛型函数或类的约束条件，范围可以让我们更方便地操作容器和迭代器，协程可以让我们编写异步代码，模块可以让我们更高效地组织代码[。除此之外，C++20还有一些其他的新特性，比如三向比较运算符、指定初始化、日历和时区功能等。 概念概念是一种用来约束模板类型的语法糖。我们可以用concept关键字来定义一个概念，然后用requires关键字来指定一个模板参数必须满足某个概念。例如，我们可以定义一个Integral概念，表示一个类型必须是整数类型 1234567template&lt;typename T&gt;concept Integral = std::is_integral_v&lt;T&gt;;// 然后我们可以用这个概念来约束一个函数模板的参数类型template&lt;Integral T&gt;T add(T a, T b) &#123; return a + b;&#125; 这样，如果我们传入非整数类型的参数，就会在编译时报错。 概念可以自定义，使用requires关键字 12345template&lt;typename T&gt;concept Sortable = requires(T a) &#123; &#123; std::sort(a.begin(), a.end()) &#125; -&gt; std::same_as&lt;void&gt;;&#125;;// 这个概念要求T类型有begin()和end()方法，并且可以用std::sort函数进行排序 标准库中提供了上百种常用的概念，放在和等头文件中。比较常用的一些有：std::same_as, std::derived_from, std::convertible_to, std::floating_point等 12345#include &lt;concepts&gt;template&lt;std::integral T&gt;T add(T a, T b) &#123; return a + b;&#125; 范围范围是C++20加入的一个重要的库功能，它提供了描述范围和对范围的操作的统一接口1。一个范围是可以循环访问的任何东西，比如一个容器或者一个数组2。我们可以用begin()和end()函数来获取一个范围的起始和终止位置3。我们也可以用基于范围的for语句来遍历一个范围中的所有元素。例如，我们可以这样打印一个vector中的所有元素： 12345678#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123; std::vector&lt;int&gt; v = &#123;1, 2, 3, 4, 5&#125;; for (auto x : v) &#123; std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; &#125;&#125; 自定义的类型，满足range概念，都可以使用范围的特性。即它可以用begin()和end()函数来获取其起始和终止位置。这两个函数返回的对象必须是迭代器或者哨兵。迭代器是可以用++和*操作符来遍历元素的对象，哨兵是可以用&#x3D;&#x3D;操作符来判断是否到达范围的末尾的对象 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;ranges&gt;#include &lt;iostream&gt;class IntRange &#123;public: IntRange(int a, int b) : a_(a), b_(b) &#123;&#125; // 迭代器 class Iterator &#123; public: Iterator(int x) : x_(x) &#123;&#125; int operator*() const &#123; return x_; &#125; Iterator&amp; operator++() &#123; ++x_; return *this; &#125; bool operator==(const Iterator&amp; other) const &#123; return x_ == other.x_; &#125; bool operator!=(const Iterator&amp; other) const &#123; return !(*this == other); &#125; private: int x_; &#125;; // 哨兵 class Sentinel &#123; public: Sentinel(int y) : y_(y) &#123;&#125; bool operator==(const Iterator&amp; iter) const &#123; return *iter == y_; &#125; bool operator!=(const Iterator&amp; iter) const &#123; return !(*this == iter); &#125; private: int y_; &#125;; // begin()和end()函数 Iterator begin() const &#123; return Iterator(a_); &#125; Sentinel end() const &#123; return Sentinel(b_); &#125;private: int a_, b_;&#125;;int main() &#123; IntRange r(1,5); for (auto x : r) &#123; std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; &#125;&#125; 协程协程是一种可以在执行过程中被挂起和恢复的函数。它可以用来实现异步编程，提高性能和并发度。 C++20中引入了三个新的关键字，co_await，co_yield和co_return，用来标记一个函数是协程。这些关键字只是语法糖，编译器会将协程的上下文打包成一个对象，并让未执行完的协程先返回给调用者。要实现一个C++20协程，还需要提供两个鸭子类型，promise type和awaiter type，分别用来管理协程的生命周期和等待机制。 例如，我们可以实现一个简单的生成器协程，它每次产生一个整数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;coroutine&gt;#include &lt;iostream&gt;// promise typestruct Generator &#123; struct promise_type &#123; int current_value; std::suspend_always yield_value(int value) &#123; this-&gt;current_value = value; return &#123;&#125;; &#125; std::suspend_always initial_suspend() &#123; return &#123;&#125;; &#125; std::suspend_always final_suspend() noexcept &#123; return &#123;&#125;; &#125; Generator get_return_object() &#123; return Generator&#123;std::coroutine_handle&lt;promise_type&gt;::from_promise(*this)&#125;; &#125; void unhandled_exception() &#123;&#125; &#125;; // awaiter type bool move_next() &#123; p.resume(); return !p.done(); &#125; int current_value() &#123; return p.promise().current_value; &#125;private: std::coroutine_handle&lt;promise_type&gt; p;&#125;;// 协程函数Generator generator(int start = 0) &#123; int i = start; while (true) &#123; co_yield i++; &#125;&#125;int main() &#123; auto g = generator(1); for (int i = 0; i &lt; 10; ++i) &#123; g.move_next(); std::cout &lt;&lt; g.current_value() &lt;&lt; &quot; &quot;; &#125;&#125; 使用协程实现异步网络编程的主要优点是可以用同步的语法写出异步的代码，提高代码的可读性和可维护性1。要使用协程实现异步网络编程，需要以下几个步骤： 使用标准库中提供的std::jthread或std::thread创建一个或多个工作线程，用来执行协程任务。 使用标准库中提供的std::coroutine_handle或自定义的协程句柄类型，管理协程的生命周期和调度。 使用标准库中提供的std::future或自定义的awaiter类型，等待异步操作完成并获取结果。 使用标准库中提供的std::sync_wait或自定义的同步等待函数，等待所有协程任务完成后退出程序。 例如，我们可以使用一个简单的网络框架ZED3，它提供了一些基本的异步IO操作，并封装了协程句柄和awaiter类型。我们可以用以下代码实现一个简单的回显服务器： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;zed/net.hpp&gt;#include &lt;iostream&gt;using namespace zed;int main() &#123; // 创建一个io_context对象 io_context ctx; // 创建一个工作线程 std::jthread th([&amp;ctx]() &#123; ctx.run(); &#125;); // 创建一个tcp服务器 tcp_server server(ctx); // 绑定端口 server.bind(8080); // 开始监听 server.listen(); while (true) &#123; try &#123; // 接受连接，并返回一个tcp_socket对象 auto socket = co_await server.accept(); std::cout &lt;&lt; &quot;New connection from &quot; &lt;&lt; socket.remote_endpoint() &lt;&lt; &quot;\\n&quot;; while (true) &#123; // 接收数据，并返回接收到的字节数 auto n = co_await socket.recv(); if (n == 0) break; // 连接断开 std::cout &lt;&lt; &quot;Received &quot; &lt;&lt; n &lt;&lt; &quot; bytes\\n&quot;; // 发送数据，并返回发送出去的字节数 auto m = co_await socket.send(n); std::cout &lt;&lt; &quot;Sent &quot; &lt;&lt; m &lt;&lt; &quot; bytes\\n&quot;; &#125; std::cout &lt;&lt; &quot;Connection closed\\n&quot;; &#125; catch (const std::exception&amp; e) &#123; std::cerr &lt;&lt; e.what() &lt;&lt; &quot;\\n&quot;; &#125; &#125;&#125; 模块C++20模块是一种新的代码组织和重用的方式，它可以替代传统的头文件和翻译单元。模块可以提高编译速度，避免宏污染，隐藏实现细节，简化依赖关系等优点。要使用模块，需要以下几个步骤： 在源文件中使用module关键字声明一个模块，并指定模块名。 在源文件中使用export关键字导出需要对外提供的符号。 在其他源文件中使用import关键字导入需要使用的模块。 使用支持模块的编译器编译源文件，并生成相应的模块接口文件和目标文件。 例如，我们可以用以下代码定义一个名为hello的模块： 123456// hello.cppmmodule hello; // 声明一个名为hello的模块export void say_hello(); // 导出一个名为say_hello的函数void say_hello() &#123; std::cout &lt;&lt; &quot;Hello, world!\\n&quot;;&#125; 然后我们可以在另一个源文件中导入并使用这个模块： 12345// main.cppimport hello; // 导入hello模块int main() &#123; say_hello(); // 调用say_hello函数&#125; 子模块是一种在逻辑上划分模块的方法，它可以让用户选择性地导入模块的一部分或全部内容。子模块的命名规则中允许点存在于模块名字当中，但点并不代表语法上的从属关系，而只是帮助程序员理解模块间的逻辑关系。 例如，我们可以用以下代码定义一个名为hello.sub_a的子模块： 123456// hello.sub_a.cppmexport module hello.sub_a; // 声明一个名为hello.sub_a的子模块export void say_hello_sub_a(); // 导出一个名为say_hello_sub_a的函数void say_hello_sub_a() &#123; std::cout &lt;&lt; &quot;Hello, sub a!\\n&quot;;&#125; 然后我们可以在另一个源文件中定义一个名为hello.sub_b的子模块： 123456// hello.sub_b.cppmexport module hello.sub_b; // 声明一个名为hello.sub_b的子模块export void say_hello_sub_b(); // 导出一个名为say_hello_sub_b的函数void say_hello_sub_b() &#123; std::cout &lt;&lt; &quot;Hello, sub b!\\n&quot;;&#125; 最后我们可以在另一个源文件中定义一个名为hello的父模块，它导出了两个子模块： 1234// hello.cppmexport module hello; // 声明一个名为hello的父模块export import hello.sub_a; // 导出并导入hello.sub_a子模块export import hello.sub_b; // 导出并导入hello.sub_b子模块 这样，用户就可以根据需要导入不同的子模块或父模块： 123456// main.cppimport hello; // 导入hello父模块，相当于同时导入了两个子模块int main() &#123; say_hello_sub_a(); // 调用say_hello_sub_a函数 say_hello_sub_b(); // 调用say_hello_sub_b函数&#125; 命名空间冲突是指不同的模块或源文件中定义了相同的名称，导致编译器无法区分它们的含义。C++20 模块提供了一些方法来避免或解决命名空间冲突： 使用不同的模块名字来区分不同的模块，例如 hello.sub_a 和 hello.sub_b 就是两个不同的模块，即使它们都定义了 say_hello 函数，也不会发生冲突。 使用限定名字来指定模块中的名称，例如 hello.sub_a::say_hello 和 hello.sub_b::say_hello 就可以明确地区分两个模块中的函数。 使用 using 声明或 using 指令来引入需要的名称，但要注意避免引入重复或冲突的名称。例如: 1234567// main.cppimport hello; // 导入hello父模块using hello.sub_a::say_hello; // 引入hello.sub_a中的say_hello函数int main() &#123; say_hello(); // 调用hello.sub_a中的say_hello函数 hello.sub_b::say_hello(); // 调用hello.sub_b中的say_hello函数&#125; 使用 export 关键字来控制哪些名称被导出到其他模块或源文件，以减少暴露给外部的名称。例如： 123456789101112// math.cppmexport module math; // 声明一个名为math的模块namespace detail &#123; // 定义一个未导出的命名空间detail int add(int x, int y) &#123; return x + y; &#125; // 定义一个未导出的函数add&#125;export int sum(int x, int y) &#123; return detail::add(x, y); &#125; // 定义并导出一个函数sum，它调用了detail命名空间中的add函数// main.cppimport math; // 导入math模块int main() &#123; int s = math::sum(1, 2); // 调用math模块中导出的sum函数 int a = math::detail::add(1, 2); // 错误：math模块没有导出detail命名空间或add函数","categories":[],"tags":[]},{"title":"引用","slug":"引用","date":"2023-03-22T11:39:05.000Z","updated":"2023-03-22T12:37:53.941Z","comments":true,"path":"2023/03/22/引用/","link":"","permalink":"http://example.com/2023/03/22/%E5%BC%95%E7%94%A8/","excerpt":"","text":"指针与引用引用必须要初始化。 指针会根据编译器不同而变化，32位4字节，64位8字节 引用根据被引用的数据类型变化 int*&amp; 指针的引用 以指针来判断。 右值引用 c++11 左值：可以长时间保存，可以存在于&#x3D;左边的值，可以取地址； 右值：临时值，不能存在于&#x3D;左边的值，不可以取地址。 左值引用，实际上是取地址赋给新的变量。必须初始化。 常引用，用于引用部分右值，不可进行更改。实际上是使用一个临时变量与一块临时内存进行存储，必须初始化。可以引用左与右。 右值引用原理相近，临时内存的地址无法获取，但是可以对临时内存里面的内容进行修改。 12int&amp;&amp; v1 = 10;v1++; 右值引用是C++11新特性，之所以引入右值引用，是为了提高效率。如下面所示： 1234567891011121314151617181920212223242526272829303132333435363738394041class A&#123;public: A(size_t N):m_p(new char[N]) &#123; &#125; A(const A &amp; a) &#123; if (this != &amp;a) &#123; delete[]m_p; m_p = new char[strlen(m_p) + 1]; memcpy(m_p, a.m_p, strlen(m_p) + 1); &#125; &#125; ~A() &#123; delete []m_p; &#125; private: char *m_p = nullptr;&#125;; A createA(size_t N)&#123; return A(100);&#125; void func(A a)&#123; //&#125; int main()&#123; func(createA(100)); system(&quot;pause&quot;); return 0;&#125; 这里会导致大量得调用A得构造函数，不考虑编译优化，原本执行如下： 123456createA(100)，执行A(100)调用A(size_t)构造函数一次；退出createA，临时构造得A(100)，释放调用析构函数一次；赋给返回值会调用一次拷贝构造函数一次；返回值传入func中形参会调用拷贝构造函数一次；func运行完成后形参释放，调用A析构函数一次；返回值使用完成释放，调用A析构函数一次； 从上面可以看出有大量得构造、析构调用 ，但是我们做的工作无非就是临时构造一个A(100)给func使用而已。那么可否将临时A(100)始终一份给到func使用呢？答案就是右值引用。如下： 1234567891011121314151617181920212223242526272829303132class A&#123;public: A(size_t N):m_p(new char[N]) &#123; &#125; ~A() &#123; delete []m_p; &#125; private: char *m_p = nullptr;&#125;; A&amp;&amp; createA(size_t N)&#123; return (A&amp;&amp;)A(100);&#125; void func(A&amp;&amp; a)&#123; //&#125; int main()&#123; func(createA(100)); system(&quot;pause&quot;); return 0;&#125; 我们将临时A(100)强制转换为了右值引用，同时func形参也是右值引用，也就是将临时对象延长到了func中，中间避免了其他构造和析构调用，提高了效率。 ​ 注意到我们将A得拷贝构造函数去掉了，因为已经用不到。如果原版写法，去掉拷贝构造函数会崩溃，因为会自动调用默认拷贝构造函数，是浅拷贝，中间临时对象会提前删除公共内存，后面对象再次释放是就会重复删除内存导致崩溃。 这就是移动。它可以让你将一个对象的资源（如内存、文件句柄等）从一个临时的右值转移给另一个对象，而不需要进行深拷贝这样可以提高性能，避免不必要的内存分配和释放 std::move可以转换左值引用为右值引用。实现原理实际上就是强制转换 123456789int main()&#123; int a = 3; int &amp;&amp;t = std::move(a); int &amp;&amp;t2 = std::move(3); system(&quot;pause&quot;); return 0;&#125; 12345678910int main()&#123; int a = 3; int &amp;&amp;t = (int &amp;&amp;)a; t = 9; cout &lt;&lt; a &lt;&lt; endl; // a = 9 system(&quot;pause&quot;); return 0;&#125; std::unique_ptr不能相等，因为他们是不可以拷贝的，因此不可以左值赋给左值。使用移动，把左值转换成右值，就可以让二者相等。 通用引用通用引用就是根据接受值类型可以自行推导是左值引用还是右值引用。 如果声明变量或参数具有T&amp;&amp;某种推导类型的类型 T，则该变量或参数为通用引用，否则就是右值引用（无法传入左值）。 也就是传入的参数在编译时需要推导，如果不需要推导，则不是通用引用。如下： 123456789101112131415template&lt;typename T&gt;class B&#123;public: void print(T &amp;&amp;) &#123;&#125;&#125;; int main()&#123; B&lt;int&gt; b; b.print(3); // 为右值引用 system(&quot;pause&quot;); return 0;&#125; 因为在编译print之前print中的参数已经由B b确定了，所以在print编译时无需推导，故B中的T&amp;&amp;为右值引用。如果改为如下： 12345678910111213141516template&lt;typename T&gt;class B&#123;public: template&lt;typename Arg&gt; void print(Arg &amp;&amp;) &#123;&#125;&#125;; int main()&#123; B&lt;int&gt; b; b.print(3); // 为右值引用 system(&quot;pause&quot;); return 0;&#125; 因为print时函数模板形参和类模板形参类型时独立的，故在编译print时是需要推导的，故Arg&amp;&amp;为通用引用。 引用折叠引用虽然形式上是右值引用，但是却可以接受左值，这是怎么实现的呢？这就是引用折叠。 12345678910111213template&lt;typename T&gt;void print(T&amp;&amp; t) &#123;&#125; int main()&#123; int a = 9; print(a); print(9); system(&quot;pause&quot;); return 0;&#125; print(a)时，因为a为左值,会被推导成print(int&amp; &amp;&amp;t)形式，int&amp; &amp;&amp;t 会被折叠为int &amp;，所以最终形式为print(int &amp;)。（左值被推导为左值引用） print(9)时，为9为右值，所以被推导为print(int&amp;&amp; &amp;&amp;)形式，而int&amp;&amp; &amp;&amp;会被折叠为int&amp;&amp;，所以最终形式为print(int&amp;&amp;)。（右值被推导为右值引用） 引用类型只有两种，所以折叠形式就是4中，为：T&amp; &amp;,T&amp; &amp;&amp;,T&amp;&amp; &amp;,T&amp;&amp; &amp;&amp;。引用折叠规则概况为两种： T&amp;&amp; &amp;&amp;折叠为T&amp;&amp;; 其他折叠为T&amp;. 完美转发通用引用既可以接受左值也可以接受右值，但是通用引用本身是左值。如果在函数模板中继续传递该值给其他函数，势必会改变该值的属性，即都为左值引用。 使用std::forward(a)可以进行完美转发，使值属性和之前保持一致。某个功能对左值和右值处理情况不一致，如果将左值和右值引用当作同一种情况使用，可能会会有性能损失。例如左值进行深拷贝，右值进行移动。 原理是使用了引用折叠。具有推导类型的T&amp;&amp;转换会进行引用折叠。而int&amp;&amp;类型是确定的，不能进行折叠。 有两套，传入的为左或右，用右值进行强制类型转换，左右转化为左，右右转化为右","categories":[],"tags":[]},{"title":"hexo快速入门","slug":"hexo快速入门","date":"2023-03-20T03:34:10.000Z","updated":"2023-03-20T05:31:55.202Z","comments":true,"path":"2023/03/20/hexo快速入门/","link":"","permalink":"http://example.com/2023/03/20/hexo%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","excerpt":"安装安装node.js安装git安装hexo","text":"安装安装node.js安装git安装hexo 新开一个文件夹，右键，在这里打开git bash 12npm install -g hexo-clinpm install --save hexo-deployer-git 配置github SSHssh可以免密的将本地的源码和资源上传到github，无需要每次都输账号和密码。 12cd ~ssh-keygen -t rsa -C &quot;邮件地址&quot; 在用户文件夹下生成了一个.ssh文件夹，进入，复制.pub文件中全部内容 打开github主页，点击个人设置，点击左侧的SSH and GPG keys，点击New SSH key 将id_rsa.pub复制的内容粘贴到key中，title随便起一个就行。 配置好用户名和邮箱 12git config --global user.name &quot;xxx&quot; #你的github用户名git config --global user.email &quot;xxx@163.com&quot; #填写你的github注册邮箱 写个人博客初始化12hexo initnpm install 新建一个博客1hexo n &lt;title&gt; 存放地址：source/_posts 解决图片问题_config.yml文件做如下修改：yaml post_asset_folder: true 创建同名文件夹，可以放入图片 使用的是Typora编辑器，可以在编辑器的文件&#x2F;偏好设置&#x2F;图像中进行如下设置： 复制到指定路径./$(filename)/ 安装图片显示插件 1npm install hexo-asset-image 生成本地静态网站并预览123hexo cleanhexo ghexo s 截断在文章中加入&lt;!--more--&gt;或在开头加入description: xxx 部署到github新建一个库，名字叫 username.github.io 将本地库与远端github仓库绑定123456git initgit add .git commit -m &quot;commit&quot;git remote add origin 仓库的http地址git pull --rebase origin maingit push [-u] origin main 编辑_config.yml1234deploy: type: git repository: 仓库的ssh地址 branch: main 在bash部署123hexo cleanhexo ghexo d 更改主题安装依赖1npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive 下载对应的主题1git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly 更改配置文件编辑_config.yml 1theme: butterfly 主题文档1https://butterfly.js.org/posts/21cfbf15/ 开启live2d安装依赖1npm install --save hexo-helper-live2d 下载model文件模型浏览live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru_01live2d-widget-model-haru_02live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-ni-jlive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z16 1https://blog.csdn.net/wang_123_zy/article/details/87181892 模型下载1npm install live2d-widget-model-shizuku 配置配置Hexo的主_config.yml或者使用的主题的_config.yml 添加以下代码到配置文件中： 12345678910111213141516## Live2D看板娘live2d: enable: true pluginModelPath: assets/ model: #模板目录，在node_modules里 use: live2d-widget-model-shizuku display: position: right width: 300 height: 600 mobile: # 在手机端显示 show: false rect: opacity:0.7","categories":[],"tags":[]}],"categories":[],"tags":[]}