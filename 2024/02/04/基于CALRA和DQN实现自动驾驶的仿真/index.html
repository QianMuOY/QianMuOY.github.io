<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>基于CALRA和DQN实现自动驾驶的仿真 | qianmu's blog</title><meta name="author" content="qianmu"><meta name="copyright" content="qianmu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基于carla与DQN实现自动驾驶的仿真 1. 安装1.1 配置虚拟环境在anaconda prompt逐条运行下面命令，单独配置虚拟环境。car是名字，可以自己取，但是python必须是3.7。创建好后使用pip命令下载配置所有的库（方便换源，conda换源不太方便）。 123conda create -n car python&#x3D;3.7conda activate carpip install">
<meta property="og:type" content="article">
<meta property="og:title" content="基于CALRA和DQN实现自动驾驶的仿真">
<meta property="og:url" content="http://example.com/2024/02/04/%E5%9F%BA%E4%BA%8ECALRA%E5%92%8CDQN%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E7%9A%84%E4%BB%BF%E7%9C%9F/index.html">
<meta property="og:site_name" content="qianmu&#39;s blog">
<meta property="og:description" content="基于carla与DQN实现自动驾驶的仿真 1. 安装1.1 配置虚拟环境在anaconda prompt逐条运行下面命令，单独配置虚拟环境。car是名字，可以自己取，但是python必须是3.7。创建好后使用pip命令下载配置所有的库（方便换源，conda换源不太方便）。 123conda create -n car python&#x3D;3.7conda activate carpip install">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-02-04T12:43:53.000Z">
<meta property="article:modified_time" content="2024-02-04T12:44:04.632Z">
<meta property="article:author" content="qianmu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/02/04/%E5%9F%BA%E4%BA%8ECALRA%E5%92%8CDQN%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E7%9A%84%E4%BB%BF%E7%9C%9F/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '基于CALRA和DQN实现自动驾驶的仿真',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-04 20:44:04'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="qianmu's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">11</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="qianmu's blog"><span class="site-name">qianmu's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">基于CALRA和DQN实现自动驾驶的仿真</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-02-04T12:43:53.000Z" title="Created 2024-02-04 20:43:53">2024-02-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-02-04T12:44:04.632Z" title="Updated 2024-02-04 20:44:04">2024-02-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AI/">AI</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="基于CALRA和DQN实现自动驾驶的仿真"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="基于carla与DQN实现自动驾驶的仿真"><a href="#基于carla与DQN实现自动驾驶的仿真" class="headerlink" title="基于carla与DQN实现自动驾驶的仿真"></a>基于carla与DQN实现自动驾驶的仿真</h1><hr>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><h3 id="1-1-配置虚拟环境"><a href="#1-1-配置虚拟环境" class="headerlink" title="1.1 配置虚拟环境"></a>1.1 配置虚拟环境</h3><p>在anaconda prompt逐条运行下面命令，单独配置虚拟环境。car是名字，可以自己取，但是python必须是3.7。创建好后使用pip命令下载配置所有的库（方便换源，conda换源不太方便）。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda create -n car python=3.7</span><br><span class="line">conda activate car</span><br><span class="line">pip install carla,pygame,numpy</span><br></pre></td></tr></table></figure>

<h3 id="1-2-配置carla模拟器"><a href="#1-2-配置carla模拟器" class="headerlink" title="1.2 配置carla模拟器"></a>1.2 配置carla模拟器</h3><p><a target="_blank" rel="noopener" href="http://carla.org/">CARLA Simulator</a> 点击进入官网，可以查看版本信息与官方文档。官方文档是我们学习的基础。下载模拟器时，应该进入官网查看最新版本，再前往carla的github主页进行下载，确保下载的是最新版本。因为<strong>只有最新版本的carla能通过pip命令安装依赖库，其他版本的安装非常繁琐（在下面第三大点有详细描述）。版本错误程序会直接崩溃。</strong><a target="_blank" rel="noopener" href="https://github.com/carla-simulator/carla/releases">Releases · carla-simulator&#x2F;carla (github.com)</a> 根据版本下载对应的压缩包或使用git命令克隆下来。注意carla<strong>只支持Linux的乌班图系统和windows系统，不支持mac系统，</strong>mac用户使用虚拟机下载。</p>
<p><img src="/.com//image-20220713130421654.png" alt="image-20220713130421654"></p>
<p><img src="/.com//image-20220713130434214.png" alt="image-20220713130434214"></p>
<h3 id="1-3-仿真环境初体验"><a href="#1-3-仿真环境初体验" class="headerlink" title="1.3 仿真环境初体验"></a>1.3 仿真环境初体验</h3><p>解压下载好的压缩包，运行CarlaUE4.exe。windows可能会报“发布者未知”，这里点击信任，或直接关闭防火墙。carla的内核是虚幻4，需要较高的配置支持，首次启动请等待片刻。进去后是这样的画面：</p>
<p><img src="/.com//image-20220713131330156.png" alt="image-20220713131330156"></p>
<p>carla有好几个地图，还可以下载地图拓展，这里是默认的一号地图，后面可以在代码中修改。使用wasd键控制前后左右，按住鼠标中键可以转换视角，细看城市中的内容。后面可以在代码中修改地图。</p>
<p>使用conda命令窗口，激活car环境，使用cd命令转到WindowsNoEditor\PythonAPI\examples，使用python manual_control.py命令运行这个代码，可以得到一辆车，自由操控，使用Back键还能换别的来玩。</p>
<p>即使是这样，城市也非常空旷。接下来我们来看看如何使用carla进行自动驾驶的仿真。</p>
<h2 id="2-CARLA-Simulator的核心概念"><a href="#2-CARLA-Simulator的核心概念" class="headerlink" title="2. CARLA Simulator的核心概念"></a>2. CARLA Simulator的核心概念</h2><h3 id="2-1-客户端"><a href="#2-1-客户端" class="headerlink" title="2.1  客户端"></a>2.1  客户端</h3><h4 id="2-1-1客户端"><a href="#2-1-1客户端" class="headerlink" title="2.1.1客户端"></a>2.1.1客户端</h4><p>客户端是 CARLA 架构中的主要元素之一。 它们连接到服务器、检索信息和命令更改。 这是通过脚本完成的。 客户端识别自己，并连接到世界，然后使用模拟进行操作。</p>
<p>除此之外，客户还可以访问高级 CARLA 模块、功能和应用命令批处理。 本节仅介绍命令批处理。 这些对于生成大量actors之类的基本事物很有用。 其余功能更为复杂，将在各自页面的高级步骤中进行介绍。</p>
<p>查看 Python API 参考中的 carla.Client 以了解该类的特定方法和变量。</p>
<h4 id="2-1-2-客户端的创建"><a href="#2-1-2-客户端的创建" class="headerlink" title="2.1.2 客户端的创建"></a>2.1.2 客户端的创建</h4><p>使用carla.Client方法创建。需要三个参数，标识它的 IP 地址，以及用于与服务器通信的两个 TCP 端口。可选的第三个参数设置工作线程的数量。 默认情况下，这设置为全部 (0)。默认情况下，CARLA 使用本地主机 IP 和端口 2000 进行连接，但这些可以随意更改。 在这种情况下，第二个端口将始终为 n+1, 2001。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client = carla.Client(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-1-3-设置客户端超时时间"><a href="#2-1-3-设置客户端超时时间" class="headerlink" title="2.1.3 设置客户端超时时间"></a>2.1.3 设置客户端超时时间</h4><p>创建客户端后，使用set_timeout方法设置其超时时间。 这限制了所有网络操作，因此这些操作不会永远阻塞客户端。 如果连接失败，将返回错误。</p>
<p>可以连接多个客户端，因为一次运行多个脚本是很常见的。</p>
<p>超时时间以秒为单位。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.set_timeout(<span class="number">10.0</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-1-4-检查版本"><a href="#2-1-4-检查版本" class="headerlink" title="2.1.4 检查版本"></a>2.1.4 检查版本</h4><p>客户端和服务器具有不同的 libcarla 模块。 如果版本不同，可能会出现问题。 这可以使用 get_client_version() 和 get_server_version() 方法进行检查。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(client.get_client_version())</span><br><span class="line"><span class="built_in">print</span>(client.get_server_version())</span><br></pre></td></tr></table></figure>

<h4 id="2-1-5虚拟世界连接"><a href="#2-1-5虚拟世界连接" class="headerlink" title="2.1.5虚拟世界连接"></a>2.1.5虚拟世界连接</h4><p>客户端可以相当轻松地连接和检索当前世界。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">world = client.get_world()</span><br></pre></td></tr></table></figure>

<p>客户端还可以获取可用地图列表来更改当前地图。 这将摧毁当前的世界并创造一个新的世界。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(client.get_available_maps())</span><br><span class="line">...</span><br><span class="line">world = client.load_world(<span class="string">&#x27;Town01&#x27;</span>)</span><br><span class="line"><span class="comment"># client.reload_world() creates a new instance of the world with the same map. </span></span><br></pre></td></tr></table></figure>

<p>每个世界对象都有一个 ID 或形象地称作“情节”。 每次客户端调用 load_world() 或 reload_world() 时，前一个都会被销毁。 新的“情节”是从头开始创建的。 在此过程中不会重新启动虚幻引擎。</p>
<h4 id="2-1-6-运行命令"><a href="#2-1-6-运行命令" class="headerlink" title="2.1.6 运行命令"></a>2.1.6 运行命令</h4><p>命令是对一些最常见的 CARLA 方法的改编，可以批量应用。 例如，command.SetAutopilot 等价于 Vehicle.set_autopilot()，为车辆启用自动驾驶仪。 但是，使用 Client.apply_batch() 或 Client.apply_batch_sync() 方法，可以在一个模拟步骤中应用一系列命令。 这对于通常应用于甚至数百个元素的方法变得非常有用。</p>
<p>以下示例使用批处理一次性销毁车辆列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.apply_batch([carla.command.DestroyActor(x) <span class="keyword">for</span> x <span class="keyword">in</span> vehicles_list])</span><br></pre></td></tr></table></figure>

<p>因此我们后面创建actors时，会开一个列表来存放方便销毁。</p>
<h4 id="2-1-7-其他客户端实用程序"><a href="#2-1-7-其他客户端实用程序" class="headerlink" title="2.1.7 其他客户端实用程序"></a>2.1.7 其他客户端实用程序</h4><p>客户端对象的主要目的是获取或改变世界，并应用命令。 但是，它还提供对一些附加功能的访问。</p>
<ul>
<li>交通管理模块：该模块负责每辆设置为自动驾驶的车辆，以重建城市交通。</li>
<li>录像模块：允许重新制定以前的模拟。 通过录像快照来总结每帧的模拟状态。</li>
</ul>
<p>后面会重新提及。</p>
<h3 id="2-2-虚拟世界"><a href="#2-2-虚拟世界" class="headerlink" title="2.2 虚拟世界"></a>2.2 虚拟世界</h3><h4 id="2-2-1-虚拟世界"><a href="#2-2-1-虚拟世界" class="headerlink" title="2.2.1 虚拟世界"></a>2.2.1 虚拟世界</h4><p>模拟测试的主要部分。 它的实例应该由客户端检索。 它不包含世界本身的模型，它是 Map 类的一部分。 相反，可以从此类访问大部分信息和常规设置。</p>
<ul>
<li>模拟中的参与者和旁观者</li>
<li>蓝图库</li>
<li>地图</li>
<li>模拟设置</li>
<li>快照</li>
<li>天气和灯光管理器</li>
</ul>
<p>它的一些最重要的方法是 getter，精确地检索这些元素的信息或实例。 查看 carla.World 以了解更多信息。、</p>
<p>carla.World PythonAPI reference：</p>
<ul>
<li><p>Instance Variables</p>
</li>
<li><ul>
<li>id (int)：与这个世界关联的 episode 的 id<ul>
<li>debug (carla.DebugHelper)：负责创建不同的 shapes for debugging</li>
</ul>
</li>
</ul>
</li>
<li><p>Methods</p>
</li>
<li><ul>
<li>apply_settings：将 carla.WorldSettings 对象包含的设置应用于仿真，并返回实现他们的帧 id<ul>
<li>cast_ray：将射线从指定的 initial_location 投射到 final_location，检测与射线相交的所有几何体，并按顺序返回到 carla.LabelledPoint 列表</li>
<li>enable_environment_objects：启用或禁用由 id 标识的一组 EnvironmentObject。这些对象将在关卡中显示或消失</li>
<li>freeze_all_traffic_lights：冻结或解冻场景中所有的交通信号灯</li>
<li>ground_projection：将指定的点向下 (0,0,-1) 投射到场景中，并返回 carla.Labelled 对象，这个对象是与射线相交的第一个几何体（通常是地面）</li>
<li>load_map_layer：将选定的图层加载到关卡</li>
<li>on_tick：此方法用于异步模式，从客户端启用传入的回调 callback</li>
<li>project_point：将指定的点投影到场景中的所需方向</li>
<li>remove_on_tick：停止从 on_tick 开始的 callback_id 的回调</li>
<li>reset_all_traffic_lights：将地图中所有交通信号灯的周期重置为初始状态</li>
<li>spawn_actor：在世界中创建 Actor</li>
<li>tick：此方法用于同步模式，发从 tick 给 server，返回服务器计算好的新 id</li>
<li>try_spawn_actor：与 spawn_actor，但失败使返回 None 而不是异常</li>
<li>unload_map_layer：将选定的图层卸载</li>
<li>wait_for_tick：此方法用于异步模式，使客户端等服务器 tick</li>
</ul>
</li>
</ul>
</li>
<li><p>Getters</p>
</li>
<li><ul>
<li>get_actor：通过 id 查找 Actor，如果没找到返回 None<ul>
<li>get_actors：检索 carla.Actor 列表，使用提供的 id 列表返回所有的 Actor</li>
<li>get_blueprint_library：返回可以在世界中创建的 Actor 列表</li>
<li>get_environment_objects：返回带有请求的语义的 EnvironmentObject 列表</li>
<li>get_level_bbs：返回在世界空间中具有位置和渲染的边界框数组</li>
<li>get_lightmanager：返回 carla.LightManager 的实例，该实例可用于处理场景中的灯光</li>
<li>get_map：像服务器查询包含地图文件的 XDOR，将其解析为 carla.Map 并返回</li>
<li>get_random_location_form_navigation：只能和行人一起使用。检索被用作目的地的随机位置 go_to_location 的 carla.WalkerAIController</li>
<li>get_settings：返回一个包含仿真数据的对象，例如客户端和服务器之间同步或渲染模式</li>
<li>get_snapshot：返回某个时刻的世界快照，包括有关参与者的所有信息</li>
<li>get_spectator：返回观察者。观察者用来作为相机，并控制仿真窗口中的视图</li>
<li>get_traffic_light：提供一个 landmark，返回他描述的交通灯对象</li>
<li>get_traffic_sign：提供一个 landmark，返回他描述的交通标志对象</li>
<li>get_vehicles_light_states：返回一个字典，他的 key 是 carla.Actor id，value 是 carla.VehicleLightState</li>
<li>get_weather：检索一个对象，该对象包含当前仿真的天气参数，主要是 云、雨、风和太阳的位置</li>
</ul>
</li>
</ul>
</li>
<li><p>Setters</p>
</li>
<li><ul>
<li>set_weather：设定天气</li>
</ul>
</li>
<li><p>Dunder methods</p>
</li>
<li><ul>
<li><code>__str__</code>：解析并打印世界内容，作为其当前状态的简要报告</li>
</ul>
</li>
</ul>
<h4 id="2-2-2-元素"><a href="#2-2-2-元素" class="headerlink" title="2.2.2 元素"></a>2.2.2 元素</h4><p>世界有不同的方法，这与允许不同功能的“参与者”相关。</p>
<ul>
<li>生成actors（但不破坏它们）</li>
<li>让每个元素都在现场，或者特别找一个</li>
<li>访问蓝图库</li>
<li>访问旁观者视角</li>
<li>检索适合生成元素的随机位置。</li>
</ul>
<p>actors就是“演员”，代表着世界里可以移动的物体，包括汽车，传感器（因为传感器要安在车身上）以及行人。</p>
<h4 id="2-2-3-天气"><a href="#2-2-3-天气" class="headerlink" title="2.2.3 天气"></a>2.2.3 天气</h4><p>天气本身不是一个类，而是一组可从世界访问的参数。 参数化包括太阳方向、云量、风、雾等等。 辅助类 carla.WeatherParameters 用于定义自定义天气。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">weather = carla.WeatherParameters(</span><br><span class="line">    cloudiness=<span class="number">80.0</span>,</span><br><span class="line">    precipitation=<span class="number">30.0</span>,</span><br><span class="line">    sun_altitude_angle=<span class="number">70.0</span>)</span><br><span class="line"></span><br><span class="line">world.set_weather(weather)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(world.get_weather())</span><br></pre></td></tr></table></figure>

<p>有一些天气预设可以直接应用于世界。 这些在 carla.WeatherParameters 中列出，并可作为枚举访问。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">world.set_weather(carla.WeatherParameters.WetCloudySunset)</span><br></pre></td></tr></table></figure>

<p>天气也可以使用 CARLA 提供的两个脚本进行自定义。</p>
<ul>
<li><strong><code>environment.py</code></strong> <em>(in <code>PythonAPI/util</code>)</em> — 提供对天气和灯光参数的访问，以便实时更改这些参数。</li>
</ul>
<p>environment.py中的可选参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-h, --help            show this help message and exit</span><br><span class="line">--host H              IP of the host server (default: 127.0.0.1)</span><br><span class="line">-p P, --port P        TCP port to listen to (default: 2000)</span><br><span class="line">--sun SUN             Sun position presets [sunset | day | night]</span><br><span class="line">--weather WEATHER     Weather condition presets [clear | overcast | rain]</span><br><span class="line">--altitude A, -alt A  Sun altitude [-90.0, 90.0]</span><br><span class="line">--azimuth A, -azm A   Sun azimuth [0.0, 360.0]</span><br><span class="line">--clouds C, -c C      Clouds amount [0.0, 100.0]</span><br><span class="line">--rain R, -r R        Rain amount [0.0, 100.0]</span><br><span class="line">--puddles Pd, -pd Pd  Puddles amount [0.0, 100.0]</span><br><span class="line">--wind W, -w W        Wind intensity [0.0, 100.0]</span><br><span class="line">--fog F, -f F         Fog intensity [0.0, 100.0]</span><br><span class="line">--fogdist Fd, -fd Fd  Fog Distance [0.0, inf)</span><br><span class="line">--wetness Wet, -wet Wet</span><br><span class="line">                      Wetness intensity [0.0, 100.0]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>dynamic_weather.py</code></strong> <em>(in <code>PythonAPI/examples</code>)</em> — 启用开发人员为每个 CARLA 地图准备的特定天气周期。</li>
</ul>
<p>dynamic_weather.py的可选参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-h, --help            show this help message and exit</span><br><span class="line">--host H              IP of the host server (default: 127.0.0.1)</span><br><span class="line">-p P, --port P        TCP port to listen to (default: 2000)</span><br><span class="line">-s FACTOR, --speed FACTOR</span><br><span class="line">                      rate at which the weather changes (default: 1.0)</span><br></pre></td></tr></table></figure>

<p><strong>天气的变化不会影响世界中的车辆的物理性质。 它们只是相机传感器可以捕捉到的视觉效果。当 sun_altitude_angle &lt; 0 时，夜间模式开始，这被认为是日落。 这是灯光变得特别重要的时候。世界中路灯会自动打开。</strong></p>
<h4 id="2-2-4-光线"><a href="#2-2-4-光线" class="headerlink" title="2.2.4 光线"></a>2.2.4 光线</h4><p>路灯有这些相关类：</p>
<ul>
<li>carla.Light：地图开发者放置的 lights，通过 carla.Light 对象访问</li>
<li>carla.LightState：颜色和强度等属性，在 light_state 中设置</li>
<li>carla.LightGroup：使用 light_group 进行分类，例如 路灯、建筑物灯…</li>
<li>carla.LightManager：可以在一个调用中被检索来处理一组灯光</li>
</ul>
<p>当模拟进入夜间模式时，路灯会自动打开。 灯光由地图的开发人员放置，并可作为 carla.Light 对象访问。 颜色和强度等属性可以随意更改。 carla.LightState 类型的变量 light_state 允许在一次调用中设置所有这些。<br>路灯使用 carla.LightGroup 类型的属性 light_group 进行分类。 这允许将灯分类为路灯、建筑灯…… carla.LightManager 的一个实例可以被检索以在一次调用中处理灯组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get the light manager and lights</span></span><br><span class="line">lmanager = world.get_lightmanager()</span><br><span class="line">mylights = lmanager.get_all_lights()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Custom a specific light</span></span><br><span class="line">light01 = mylights[<span class="number">0</span>]</span><br><span class="line">light01.turn_on()</span><br><span class="line">light01.set_intensity(<span class="number">100.0</span>)</span><br><span class="line">state01 = carla.LightState(<span class="number">200.0</span>,red,carla.LightGroup.Building,<span class="literal">True</span>)</span><br><span class="line">light01.set_light_state(state01)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Custom a group of lights</span></span><br><span class="line">my_lights = lmanager.get_light_group(carla.LightGroup.Building)</span><br><span class="line">lmanager.turn_on(my_lights)</span><br><span class="line">lmanager.set_color(my_lights,carla.Color(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">lmanager.set_intensities(my_lights,list_of_intensities)</span><br></pre></td></tr></table></figure>

<ul>
<li>车灯必须由用户打开&#x2F;关闭。 每辆车都有一组在 carla.VehicleLightState 中列出的灯。 到目前为止，并非所有车辆都集成了灯光。 以下是撰写本文时可用的列表。<br>  自行车：它们都有一个前后位置灯。<br>  摩托车： 雅马哈和哈雷戴维森车型。<br>  汽车：奥迪TT、雪佛兰、道奇（警车）、Etron、林肯、野马、特斯拉3S、大众T2以及来到CARLA的新模组。</li>
</ul>
<p>可以使用 carla.Vehicle.get_light_state 和 carla.Vehicle.set_light_state 方法随时检索和更新车辆的灯光。 这些使用二进制操作来自定义灯光设置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Turn on position lights</span></span><br><span class="line">current_lights = carla.VehicleLightState.NONE</span><br><span class="line">current_lights |= carla.VehicleLightState.Position</span><br><span class="line">vehicle.set_light_state(current_lights)</span><br></pre></td></tr></table></figure>

<p>也可以使用天气部分中描述的 environment.py 实时设置灯光。</p>
<h4 id="2-2-5-调试"><a href="#2-2-5-调试" class="headerlink" title="2.2.5 调试"></a>2.2.5 调试</h4><p>世界对象有一个 carla.DebugHelper 对象作为公共属性。 它允许在模拟过程中绘制不同的形状。 这些用于跟踪正在发生的事件。 以下示例将在演员的位置和旋转处绘制一个红色框。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debug = world.debug</span><br><span class="line">debug.draw_box(carla.BoundingBox(actor_snapshot.get_transform().location,carla.Vector3D(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">2</span>)),actor_snapshot.get_transform().rotation, <span class="number">0.05</span>, carla.Color(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>此示例在 carla.DebugHelper 中的一个片段中进行了扩展，该片段显示了如何为世界快照中的每个角色绘制框。</p>
<h4 id="2-2-6-快照"><a href="#2-2-6-快照" class="headerlink" title="2.2.6 快照"></a>2.2.6 快照</h4><p>包含模拟中每个角色在单个帧中的状态。 一种带有时间参考的世界静止图像。 信息来自相同的模拟步骤，即使在异步模式下也是如此。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Retrieve a snapshot of the world at current frame.</span></span><br><span class="line">world_snapshot = world.get_snapshot()</span><br></pre></td></tr></table></figure>

<p>carla.WorldSnapshot 包含 carla.Timestamp 和 carla.ActorSnapshot 列表。 可以使用演员的 ID 搜索演员快照。 快照列出了其中出现的演员的 ID。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">timestamp = world_snapshot.timestamp <span class="comment"># Get the time reference </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> actor_snapshot <span class="keyword">in</span> world_snapshot: <span class="comment"># Get the actor and the snapshot information</span></span><br><span class="line">    actual_actor = world.get_actor(actor_snapshot.<span class="built_in">id</span>)</span><br><span class="line">    actor_snapshot.get_transform()</span><br><span class="line">    actor_snapshot.get_velocity()</span><br><span class="line">    actor_snapshot.get_angular_velocity()</span><br><span class="line">    actor_snapshot.get_acceleration()  </span><br><span class="line"></span><br><span class="line">actor_snapshot = world_snapshot.find(actual_actor.<span class="built_in">id</span>) <span class="comment"># Get an actor&#x27;s snapshot</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-7-世界设置"><a href="#2-2-7-世界设置" class="headerlink" title="2.2.7 世界设置"></a>2.2.7 世界设置</h4><p>世界可以访问一些用于模拟的高级配置。 这些决定了渲染条件、模拟时间步长以及客户端和服务器之间的同步。 它们可以从助手类 carla.WorldSettings 中访问。</p>
<p>目前，默认的 CARLA 以最佳图形质量、可变时间步长和异步运行。 要进一步了解此问题，请查看“高级步骤”部分。 有关同步和时间步长以及渲染选项的页面可能是一个很好的起点。</p>
<h3 id="2-3-蓝图"><a href="#2-3-蓝图" class="headerlink" title="2.3 蓝图"></a>2.3 蓝图</h3><p>CARLA 中的 Actor 是在模拟中执行动作的元素，它们可以影响其他 Actor。 CARLA 中的参与者包括车辆和步行者，还包括传感器、交通标志、交通灯和观众。 对如何操作它们有充分的了解是至关重要的。</p>
<p>本节将介绍生成、销毁、类型以及如何管理它们。 </p>
<h4 id="2-3-1-蓝图"><a href="#2-3-1-蓝图" class="headerlink" title="2.3.1 蓝图"></a>2.3.1 蓝图</h4><p>这些布局允许用户将新演员顺利融入模拟。 它们是带有动画和一系列属性的已制作模型。 其中一些是可修改的，而另一些则不是。 这些属性包括车辆颜色、激光雷达传感器中的通道数量、步行者的速度等等。</p>
<p>可用的蓝图及其属性列在蓝图库中。 车辆和步行者蓝图有一个世代属性，指示它们是新的（第 2 代）还是旧的（第 1 代）资产。</p>
<h4 id="2-3-2管理蓝图库"><a href="#2-3-2管理蓝图库" class="headerlink" title="2.3.2管理蓝图库"></a>2.3.2管理蓝图库</h4><p>carla.BlueprintLibrary 类包含一个 carla.ActorBlueprint 元素列表。 世界对象可以提供对它的访问。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blueprint_library = world.get_blueprint_library()</span><br></pre></td></tr></table></figure>

<p>蓝图有一个 ID 来识别它们以及由此产生的演员。 可以读取该库以查找特定 ID、随机选择蓝图或使用通配符模式过滤结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find a specific blueprint.</span></span><br><span class="line">collision_sensor_bp = blueprint_library.find(<span class="string">&#x27;sensor.other.collision&#x27;</span>)</span><br><span class="line"><span class="comment"># Choose a vehicle blueprint at random.</span></span><br><span class="line">vehicle_bp = random.choice(blueprint_library.<span class="built_in">filter</span>(<span class="string">&#x27;vehicle.*.*&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>除此之外，每个 carla.ActorBlueprint 都有一系列 carla.ActorAttribute 可以获取和设置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">is_bike = [vehicle.get_attribute(<span class="string">&#x27;number_of_wheels&#x27;</span>) == <span class="number">2</span>]</span><br><span class="line"><span class="keyword">if</span>(is_bike)</span><br><span class="line">    vehicle.set_attribute(<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;255,0,0&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意：有些属性无法修改，请在蓝图库中查看</strong></p>
<p>属性有一个 carla.ActorAttributeType 变量。 它从枚举列表中声明其类型。 此外，可修改属性带有推荐值列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> attr <span class="keyword">in</span> blueprint:</span><br><span class="line">    <span class="keyword">if</span> attr.is_modifiable:</span><br><span class="line">        blueprint.set_attribute(attr.<span class="built_in">id</span>, random.choice(attr.recommended_values))</span><br></pre></td></tr></table></figure>

<p>用户可以创建自己的交通工具。查看教程(资产)来学习。贡献者可以将他们的新内容添加到 CARLA。</p>
<h3 id="2-4-演员的生命周期"><a href="#2-4-演员的生命周期" class="headerlink" title="2.4 演员的生命周期"></a>2.4 演员的生命周期</h3><p>本节提到了关于参与者的不同方法。PythonAPI 提供了在一个框架中应用最常见的批处理命令的命令。</p>
<h4 id="2-4-1-生成"><a href="#2-4-1-生成" class="headerlink" title="2.4.1 生成"></a>2.4.1 生成</h4><p>世界对象负责生成actors并跟踪它们。 生成只需要一个蓝图和一个 carla.Transform 来说明 Actor 的位置和旋转。</p>
<p>这个世界有两种不同的方法来产生Actor。</p>
<ul>
<li>spawn_actor() 生成失败会报错</li>
<li>try_spawn_actor() 生成失败返回none</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transform = Transform(Location(x=<span class="number">230</span>, y=<span class="number">195</span>, z=<span class="number">40</span>), Rotation(yaw=<span class="number">180</span>))</span><br><span class="line">actor = world.spawn_actor(blueprint, transform)</span><br></pre></td></tr></table></figure>

<p><strong>注意：CARLA 使用虚拟引擎坐标系统。记住 carla.Rotation()构造函数定义为(俯仰，偏航，滚动) ，它不同于一般的虚拟引擎编辑器(滚动，俯仰，偏航)。xyz坐标的单位是m</strong></p>
<p>这里的俯仰，偏航，滚动事实上是pitch, yaw, roll，在笛卡尔坐标系中，pitch是围绕X轴旋转，也叫做俯仰角，yaw是围绕Y轴旋转，也叫偏航角，roll是围绕Z轴旋转，也叫翻滚角。如下图所示</p>
<p><img src="/.com//20140401183456562.jpg" alt="20140401183456562"></p>
<p>如果在指定位置发生碰撞，actor 将不会生成。 无论这发生在静态对象还是其他Actor身上。 可以尝试避免这些不希望的生成碰撞。</p>
<ul>
<li>map.get_spawn_points() 用于车辆。 返回推荐的生成点列表。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spawn_points = world.get_map().get_spawn_points()</span><br></pre></td></tr></table></figure>

<ul>
<li>world.get_random_location() 用于行人。 返回人行道上的随机点。 同样的方法用于为步行者设置目标位置。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spawn_point = carla.Transform()</span><br><span class="line">spawn_point.location = world.get_random_location_from_navigation()</span><br></pre></td></tr></table></figure>

<p>一个actor在生成时可以附加到另一个actor上。 演员跟随他们所依附的父类。 这对传感器特别有用。 附件可以是刚性的（适合检索精确数据），也可以根据其父项轻松移动。附加类型由carla.AttachmentType 定义。</p>
<p><strong>注意：当产生附加到另一个actor上的actor时，提供的transformer必须相对于父actor。</strong></p>
<p>下一个示例将摄像头固定在车辆上，因此它们的相对位置保持固定。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Attach Actor</span></span><br><span class="line">camera_bp = blueprint_library.find(<span class="string">&#x27;sensor.camera.rgb&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(camera_bp)</span><br><span class="line">relative_transform = carla.Transform(carla.Location(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>),carla.Rotation())</span><br><span class="line">camera = world.spawn_actor(camera_bp, relative_transform, actor, carla.AttachmentType.Rigid)</span><br></pre></td></tr></table></figure>

<p>生成后，世界对象会将演员添加到列表中。 这可以很容易地搜索或迭代。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">actor_list = world.get_actors()</span><br><span class="line"><span class="comment"># Find an actor by id.</span></span><br><span class="line">actor = actor_list.find(<span class="built_in">id</span>)</span><br><span class="line"><span class="comment"># Print the location of all the speed limit signs in the world.</span></span><br><span class="line"><span class="keyword">for</span> speed_sign <span class="keyword">in</span> actor_list.<span class="built_in">filter</span>(<span class="string">&#x27;traffic.speed_limit.*&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(speed_sign.get_location())</span><br></pre></td></tr></table></figure>

<p>上面的都是CARLA官方文档给我们写好的。实际上只有几个是常用的。如果我们想生成一个Actor, 必须要先定义它的蓝图（Blueprint），这就好比造房子前要先绘制设计图一样。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拿到这个世界所有物体的蓝图</span></span><br><span class="line">blueprint_library = world.get_blueprint_library()</span><br><span class="line"><span class="comment"># 从浩瀚如海的蓝图中找到奔驰的蓝图</span></span><br><span class="line">ego_vehicle_bp = blueprint_library.find(<span class="string">&#x27;vehicle.mercedes-benz.coupe&#x27;</span>)</span><br><span class="line"><span class="comment"># 给我们的车加上特定的颜色</span></span><br><span class="line">ego_vehicle_bp.set_attribute(<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;0, 0, 0&#x27;</span>)</span><br><span class="line"><span class="comment"># 找到所有可以作为初始点的位置并随机选择一个</span></span><br><span class="line">transform = random.choice(world.get_map().get_spawn_points())</span><br><span class="line"><span class="built_in">print</span>(transform)</span><br><span class="line"><span class="comment"># 在这个位置生成汽车</span></span><br><span class="line">ego_vehicle = world.spawn_actor(ego_vehicle_bp, transform)</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2管理"><a href="#2-4-2管理" class="headerlink" title="2.4.2管理"></a>2.4.2管理</h4><p>carla.Actor 主要由 get() 和 set() 方法组成，用于管理地图周围的演员。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Handle Actor</span></span><br><span class="line"><span class="built_in">print</span>(actor.get_acceleration())</span><br><span class="line"><span class="built_in">print</span>(actor.get_velocity())</span><br><span class="line"></span><br><span class="line">location = actor.get_location()</span><br><span class="line">location.z += <span class="number">10.0</span></span><br><span class="line">actor.set_location(location)</span><br></pre></td></tr></table></figure>

<p>可以禁用 actor 的物理，将其冻结在某位置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">actor.set_simulate_physics(<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(actor.get_location())</span><br></pre></td></tr></table></figure>

<p>除此之外，actor还有他们的蓝图提供的标签，这些标签主要用于语义分割传感器。</p>
<p><strong>注意：大多数方法异步地向模拟器发送请求。模拟器在每次更新时解析它们的时间是有限的。用 set ()方法充斥模拟器将会积累一个显著的延迟。</strong></p>
<h4 id="2-4-3销毁"><a href="#2-4-3销毁" class="headerlink" title="2.4.3销毁"></a>2.4.3销毁</h4><p>当 Python 脚本完成时，Actor 不会被销毁，需要明确地手动销毁他们。销毁会阻塞仿真，直到完成。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">destroyed_sucessfully = actor.destroy() <span class="comment"># Returns True if successful</span></span><br></pre></td></tr></table></figure>

<h3 id="2-5Actor类型"><a href="#2-5Actor类型" class="headerlink" title="2.5Actor类型"></a>2.5Actor类型</h3><h4 id="2-5-1-传感器"><a href="#2-5-1-传感器" class="headerlink" title="2.5.1 传感器"></a>2.5.1 传感器</h4><p>传感器是产生数据流的actor。在官方文档的第四部分和本文档接下来的部分会单独介绍。现在，让我们看看一个常见的传感器产生周期。此示例生成一个摄像机传感器，将其连接到车辆上，并告诉摄像机将生成的图像保存到磁盘。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">camera_bp = blueprint_library.find(<span class="string">&#x27;sensor.camera.rgb&#x27;</span>)</span><br><span class="line">camera = world.spawn_actor(camera_bp, relative_transform, attach_to=my_vehicle)</span><br><span class="line">camera.listen(<span class="keyword">lambda</span> image: image.save_to_disk(<span class="string">&#x27;output/%06d.png&#x27;</span> % image.frame))</span><br></pre></td></tr></table></figure>

<ul>
<li>传感器也有蓝图，可以设置属性</li>
<li>大多数传感器将连接到车辆，收集有关其周围环境的信息</li>
<li>传感器监听数据。接收到数据后，他们调用 Lambda表达式 描述的函数</li>
</ul>
<p>只设置了以上的回调，并不会保存传感器数据，需要调用 world.tick() 获取传感器数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Main loop</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># Tick the server</span></span><br><span class="line">    world.tick()</span><br><span class="line">    w_frame = world.get_snapshot().frame</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;World&#x27;s frame: %d&quot;</span> % w_frame)</span><br></pre></td></tr></table></figure>

<p>运行脚本的控制台打印世界的当前帧数，rgb 图像会保存在磁盘里。默认情况下 sensor.camera.rgb 产生的图像分辨率是 800 x 600，这个可以设定。</p>
<h4 id="2-5-2-旁观者"><a href="#2-5-2-旁观者" class="headerlink" title="2.5.2 旁观者"></a>2.5.2 旁观者</h4><p>由虚幻引擎放置以提供游戏内视角。 它可以用来移动模拟器窗口的视图。 以下示例将移动旁观者演员，以将视线指向所需的车辆。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spectator = world.get_spectator()</span><br><span class="line">transform = vehicle.get_transform()</span><br><span class="line">spectator.set_transform(carla.Transform(transform.location + carla.Location(z=<span class="number">50</span>),</span><br><span class="line">carla.Rotation(pitch=-<span class="number">90</span>)))</span><br></pre></td></tr></table></figure>

<h4 id="2-5-3-交通标志和交通灯"><a href="#2-5-3-交通标志和交通灯" class="headerlink" title="2.5.3 交通标志和交通灯"></a>2.5.3 交通标志和交通灯</h4><p>到目前为止，在 CARLA 中，只有停止点、生成和红绿灯被认为是演员。 其余的 OpenDRIVE 标志可从 API 作为 carla.Landmark 访问。 使用这些实例可以访问它们的信息，但它们在模拟中不作为参与者存在。 在下方的“地图和导航”有对地标更详细的解释。</p>
<p>当模拟开始时，使用 OpenDRIVE 文件中的信息自动生成停止、生成和交通灯。这些都不能在蓝图库中找到，因此不能产生。</p>
<p>CARLA 地图在 OpenDRIVE 文件中没有交通标志和灯光，这些都是由开发人员手动放置的。</p>
<p>道路图本身并没有界定交通标志。相反，他们有一个 carla.BoundingBox边界框影响其中的车辆。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Get the traffic light affecting a vehicle</span></span><br><span class="line"><span class="keyword">if</span> vehicle_actor.is_at_traffic_light():</span><br><span class="line">    traffic_light = vehicle_actor.get_traffic_light()</span><br></pre></td></tr></table></figure>

<p>交通信号灯出现在路口。 与任何actor一样，他们有自己的唯一 ID，但也有交汇点的组 ID。 为了识别同一组中的交通灯，使用了杆 ID。</p>
<p>同一组中的红绿灯遵循一个循环。 第一个设置为绿色，而其余的则保持为红色。 活跃的在绿色、黄色和红色上花费几秒钟，所以有一段时间所有的灯都是红色的。 然后，下一个红绿灯开始循环，前一个红绿灯与其他红绿灯一起冻结。</p>
<p>可以使用 API 设置交通灯的状态。 在每个状态上花费的秒数也是如此。 carla.TrafficLightState 将可能的状态描述为一系列枚举值。</p>
<p>交通信号灯的状态可以通过 API 设置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set traffic light state</span></span><br><span class="line">traffic_light = vehicle.get_traffic_light()</span><br><span class="line"><span class="built_in">print</span>(traffic_light)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Change a red traffic light to green （未验证，因为找不到 traffic_light）</span></span><br><span class="line"><span class="keyword">if</span> traffic_light.get_state() == carla.TrafficLightState.Red:</span><br><span class="line">    traffic_light.set_state(carla.TrafficLightState.Green)</span><br><span class="line">    traffic_light.set_set_green_time(<span class="number">4.0</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意：只有当红灯亮时，车辆才会注意到红灯。</strong></p>
<h4 id="2-5-4-车辆"><a href="#2-5-4-车辆" class="headerlink" title="2.5.4 车辆"></a>2.5.4 车辆</h4><p>carla.Vehicle 是一种特殊类型的演员。 它包含模拟轮式车辆物理特性的特殊内部组件。 这是通过应用四种不同的控件来实现的：</p>
<ul>
<li>carla.VehicleControl 为油门、转向、刹车等驾驶命令提供输入。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vehicle.apply_control(carla.VehicleControl(throttle=<span class="number">1.0</span>, steer=-<span class="number">1.0</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li>carla.VehiclePhysicsControl 定义了车辆的物理属性并包含另外两个控制器：</li>
<li>carla.GearPhysicsControl 控制齿轮。</li>
<li>carla.WheelPhysicsControl 提供对每个车轮的特定控制。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vehicle.apply_physics_control(carla.VehiclePhysicsControl(max_rpm = <span class="number">5000.0</span>, center_of_mass = carla.Vector3D(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), torque_curve=[[<span class="number">0</span>,<span class="number">400</span>],[<span class="number">5000</span>,<span class="number">400</span>]]))</span><br></pre></td></tr></table></figure>

<p>车辆有一个碰撞体积 carla.BoundingBox 。 此边界框允许将物理应用到车辆并检测碰撞。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">box = vehicle.bounding_box</span><br><span class="line"><span class="built_in">print</span>(box.location)         <span class="comment"># Location relative to the vehicle.</span></span><br><span class="line"><span class="built_in">print</span>(box.extent)           <span class="comment"># XYZ half-box extents in meters.</span></span><br></pre></td></tr></table></figure>

<p>通过启用扫描轮碰撞参数可以<strong>改善车轮的物理特性</strong>。 默认的车轮物理场对每个车轮使用从轴到地板的单射线投射，但是当启用扫描车轮碰撞时，会检查车轮的整个体积以防止碰撞。 它可以这样启用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">physics_control = vehicle.get_physics_control()</span><br><span class="line">physics_control.use_sweep_wheel_collision = <span class="literal">True</span></span><br><span class="line">vehicle.apply_physics_control(physics_control)</span><br></pre></td></tr></table></figure>

<p>车辆包括其他独有的功能：</p>
<ul>
<li>自动驾驶模式将为车辆订阅交通管理器以模拟真实的城市状况。 这个模块是硬编码的，不是基于机器学习的。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vehicle.set_autopilot(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>车灯必须由用户打开和关闭。 每辆车都有一组在 carla.VehicleLightState 中列出的灯。 并非所有车辆都集成了照明灯。 在撰写本文时，集成车灯的车辆如下：<br>  自行车：所有自行车都有前后位置灯。<br>  摩托车：雅马哈和哈雷戴维森车型。<br>  汽车：奥迪 TT、雪佛兰 Impala、道奇警车、道奇 Charger、奥迪 e-tron、林肯 2017 和 2020、野马、特斯拉 Model 3、特斯拉 Cybertruck、大众 T2 和梅赛德斯 C 级。</li>
</ul>
<p>可以使用方法 carla.Vehicle.get_light_state 和 carla.Vehicle.set_light_state 随时检索和更新车辆的灯光。 这些使用二进制操作来自定义灯光设置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Turn on position lights</span></span><br><span class="line">current_lights = carla.VehicleLightState.NONE</span><br><span class="line">current_lights |= carla.VehicleLightState.Position</span><br><span class="line">vehicle.set_light_state(current_lights)</span><br></pre></td></tr></table></figure>

<p>根据部分博主的内容实验以及本机实验，二进制操作灯光并不稳定（在很多情况下失败），因此建议把上方的第一第二行代码改为current_lights &#x3D; carla.VehicleLightState.Position直接设置。</p>
<h4 id="2-5-5行人"><a href="#2-5-5行人" class="headerlink" title="2.5.5行人"></a>2.5.5行人</h4><p>carla.Walker 的工作方式与车辆类似。 对它们的控制由controllers提供。</p>
<ul>
<li>carla.WalkerControl 以一定的方向和速度移动行人。 它还允许他们跳跃。</li>
<li>carla.WalkerBoneControl 提供对 3D 骨架的控制。</li>
</ul>
<p>步行者可以由 AI controller 控制。 他们没有自动驾驶模式。 carla.WalkerAIController Actor 围绕它所连接的 Actor 移动。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">walker_controller_bp = world.get_blueprint_library().find(<span class="string">&#x27;controller.ai.walker&#x27;</span>)</span><br><span class="line">world.SpawnActor(walker_controller_bp, carla.Transform(), parent_walker)</span><br></pre></td></tr></table></figure>

<p>每个 AI controller都需要初始化、目标和速度（可选）。 停止控制器的工作方式相同。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ai_controller.start()</span><br><span class="line">ai_controller.go_to_location(world.get_random_location_from_navigation())</span><br><span class="line">ai_controller.set_max_speed(<span class="number">1</span> + random.random())  <span class="comment"># Between 1 and 2 m/s (default is 1.4 m/s).</span></span><br><span class="line">...</span><br><span class="line">ai_controller.stop()</span><br></pre></td></tr></table></figure>

<p>注意：AI controller是没有身体的，没有物理。它不会出现在现场。而且，相对于其父节点的位置(0,0,0)不会引起冲突。</p>
<p>当行人到达目标位置时，他们会自动步行到另一个随机点。 如果无法到达目标点，步行者将前往离他们当前位置最近的点。</p>
<p><strong>注意：如果要删除AI行人，需要停止AI controller，并且清除所有的actor和controller。</strong></p>
<p>carla.Client 中的一个片段使用批量生成大量步行者并让他们四处游荡。</p>
<h3 id="2-6-地图"><a href="#2-6-地图" class="headerlink" title="2.6 地图"></a>2.6 地图</h3><p>地图包括城镇的 3D 模型及其道路定义。 地图的道路定义基于 OpenDRIVE 文件，这是一种标准化、带注释的道路定义格式。 OpenDRIVE 标准 1.4 定义道路、车道、交叉口等的方式决定了 Python API 的功能以及决策背后的推理。</p>
<p>Python API 充当高级查询系统来导航这些道路。 它不断发展以提供更广泛的工具集。后面会单独提到python API</p>
<h4 id="2-6-1-改变地图"><a href="#2-6-1-改变地图" class="headerlink" title="2.6.1 改变地图"></a>2.6.1 改变地图</h4><p>要改变地图，世界也必须改变。 模拟将从头开始重新创建。 您可以在新世界中使用同一张地图重新开始，也可以同时更改地图和世界：</p>
<ul>
<li>reload_world() 在同一张地图里创建一个新的实例</li>
<li>load_world() 改变当前地图，并创建一个新的世界</li>
</ul>
<p>每张地图都有一个与当前加载的城市名称相匹配的<code>name</code>属性，例如 <em>Town01</em>，可以用client.get_available_maps()来获取可用地图列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载地图</span></span><br><span class="line">world = client.load_world(<span class="string">&#x27;Town01&#x27;</span>)</span><br><span class="line"><span class="comment"># world = client.reload_world()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取可用地图列表</span></span><br><span class="line"><span class="built_in">print</span>(client.get_available_maps())</span><br></pre></td></tr></table></figure>

<h4 id="2-6-2-地标"><a href="#2-6-2-地标" class="headerlink" title="2.6.2 地标"></a>2.6.2 地标</h4><p>OpenDRIVE 种定义的交通标志将转换为 CARLA 的 landmark 对象，使用 API 查询：</p>
<ul>
<li>carla.Landmark 对象代表 OpenDRIVE 信号。 此类的属性和方法描述了地标及其影响范围。</li>
<li>carla.LandmarkOrientation 说明地标相对于道路几何定义的方向。</li>
<li>carla.LandmarkType 包含常见的地标类型，以便于转换为 OpenDRIVE 类型。</li>
<li>carla.Waypoint 可以获得位于其前方一定距离的地标。 可以指定要获取的地标类型。</li>
<li>carla.Map 检索地标集。 它可以返回地图中的所有地标，或者具有共同 ID、类型或组的地标。</li>
<li>carla.World 充当地标与在模拟中代表它们的 carla.TrafficSign 和 carla.TrafficLight 之间的中介。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取地标</span></span><br><span class="line"><span class="built_in">print</span>(world)</span><br><span class="line"><span class="built_in">map</span> = world.get_map()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">map</span>)</span><br><span class="line">waypoints = <span class="built_in">map</span>.generate_waypoints(<span class="number">100000</span>)</span><br><span class="line"><span class="built_in">print</span>(waypoints)</span><br><span class="line">waypoint = waypoints[<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(waypoint)</span><br><span class="line">landmarks = waypoint.get_landmarks(<span class="number">20000.0</span>, <span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(landmarks)</span><br></pre></td></tr></table></figure>

<h4 id="2-6-3航点"><a href="#2-6-3航点" class="headerlink" title="2.6.3航点"></a>2.6.3航点</h4><p>carla.Waypoint 是 CARLA 世界中的 3D 定向点，对应于 OpenDRIVE 车道。 与航点相关的一切都发生在客户端； 只需与服务器通信一次即可获取包含航点信息的地图对象。</p>
<p>每个航路点都包含一个 carla.Transform，它说明了它在地图上的位置以及包含它的车道的方向。 变量 road_id、section_id、lane_id 和 s 对应于 OpenDRIVE 道路。 路点的 id 由这四个值的哈希组合构成。</p>
<p>航路点保存有关包含它的车道的信息。 此信息包括车道的左右车道标记、确定车道是否在交叉路口内的布尔值、车道类型、宽度和车道变更权限。</p>
<p><strong>注意：同一条道路上距离小于2厘米的路标共用相同的id。</strong></p>
<p>航点还包含他所在的车道信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Access lane information from a waypoint</span></span><br><span class="line">inside_junction = waypoint.is_junction</span><br><span class="line"><span class="built_in">print</span>(inside_junction)</span><br><span class="line">width = waypoint.lane_width</span><br><span class="line"><span class="built_in">print</span>(width)</span><br><span class="line">right_lm_color = waypoint.right_lane_marking.color</span><br><span class="line"><span class="built_in">print</span>(right_lm_color)</span><br><span class="line"><span class="built_in">print</span>(waypoint.transform)</span><br></pre></td></tr></table></figure>

<h4 id="2-6-4-车道"><a href="#2-6-4-车道" class="headerlink" title="2.6.4 车道"></a>2.6.4 车道</h4><p>OpenDRIVE 标准 1.4 定义的车道类型作为一系列枚举值转换为 carla.LaneType 中的 API。</p>
<p>车道周围的车道标记可通过 carla.LaneMarking 访问。 车道标记由一系列变量定义：</p>
<ul>
<li>颜色：carla.LaneMarkingColor 是定义标记颜色的枚举值。</li>
<li>变道：carla.LaneChange 说明车道是否允许左转、右转、两者都允许或不允许。</li>
<li>类型：carla.LaneMarkingType 是根据 OpenDRIVE 标准定义标记类型的枚举值。</li>
<li>宽度：定义标记的厚度。</li>
</ul>
<p>下面的示例显示了获取有关特定航路点的车道类型、车道标记和车道变更权限的信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get the lane type where the waypoint is</span></span><br><span class="line">lane_type = waypoint.lane_type</span><br><span class="line"><span class="built_in">print</span>(lane_type)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the type of lane marking on the left</span></span><br><span class="line">left_lanemarking_type = waypoint.left_lane_marking.<span class="built_in">type</span></span><br><span class="line"><span class="built_in">print</span>(left_lanemarking_type)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get available lane changes for this waypoint</span></span><br><span class="line">lane_change = waypoint.lane_change</span><br><span class="line"><span class="built_in">print</span>(lane_change)</span><br></pre></td></tr></table></figure>

<h4 id="2-6-5-路口"><a href="#2-6-5-路口" class="headerlink" title="2.6.5 路口"></a>2.6.5 路口</h4><p>carla.Junction 表示 OpenDRIVE 连接点。 此类包含一个带有边界框的交叉路口，以识别其中的车道或车辆。</p>
<p>carla.Junction 类包含 get_waypoints 方法，该方法为路口内的每条车道返回一对航路点。 每对都位于交汇点边界的起点和终点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取路口</span></span><br><span class="line">junction = waypoint.get_junction()</span><br><span class="line"><span class="built_in">print</span>(junction)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取路口范围的航路点</span></span><br><span class="line">waypoints_junc = junction.get_waypoints(carla.LaneType.<span class="type">Any</span>)</span><br><span class="line"><span class="built_in">print</span>(waypoints_junc)</span><br></pre></td></tr></table></figure>

<h4 id="2-6-6-环境对象"><a href="#2-6-6-环境对象" class="headerlink" title="2.6.6 环境对象"></a>2.6.6 环境对象</h4><p>CARLA 地图上的每个对象都有一组相关变量，可在此处找到。 详见 carla.EnvironmentObject。这些变量中包含一个唯一 ID，可用于切换该对象在地图上的可见性。 您可以使用 Python API 根据语义标签获取每个环境对象的 ID：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get the building in the world</span></span><br><span class="line">env_objs = world.get_environment_objects(carla.CityObjectLabel.Buildings)</span><br><span class="line"><span class="built_in">print</span>(env_objs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Access individual building IDs and save in a set</span></span><br><span class="line">building_01 = env_objs[<span class="number">0</span>]</span><br><span class="line">building_02 = env_objs[<span class="number">1</span>]</span><br><span class="line">objects_to_toggle = &#123;building_01.<span class="built_in">id</span>, building_02.<span class="built_in">id</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(objects_to_toggle)</span><br><span class="line"></span><br><span class="line">spectator = world.get_spectator()</span><br><span class="line">spectator.set_transform(carla.Transform(building_01.transform.location + carla.Location(<span class="number">0</span>,<span class="number">0</span>,<span class="number">30</span>),</span><br><span class="line">    carla.Rotation(pitch=-<span class="number">90</span>)))</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Toggle buildings off</span></span><br><span class="line">world.enable_environment_objects(objects_to_toggle, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># Toggle buildings on</span></span><br><span class="line">world.enable_environment_objects(objects_to_toggle, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-7-CARLA中的导航"><a href="#2-7-CARLA中的导航" class="headerlink" title="2.7 CARLA中的导航"></a>2.7 CARLA中的导航</h3><p>CARLA 中的导航是通过 Waypoint API 管理的，它是 carla.Waypoint 和 carla.Map 方法的组合。</p>
<p>客户端必须首先与服务器通信以检索包含航点信息的地图对象。 这只需要一次，所有后续查询都在客户端执行。</p>
<h4 id="2-7-1-通过航点导航"><a href="#2-7-1-通过航点导航" class="headerlink" title="2.7.1 通过航点导航"></a>2.7.1 通过航点导航</h4><p>Waypoint API 公开了一些方法，这些方法允许路点相互连接并沿着道路构建路径供车辆导航：</p>
<ul>
<li>next(d) 在车道方向上创建近似距离 d 内的航路点列表。 该列表包含每个可能偏差的一个航路点。</li>
<li>previous(d) 创建一个航路点列表，航路点在车道相反方向的近似距离 d 内。 该列表包含每个可能偏差的一个航路点。</li>
<li>next_until_lane_end(d) 和 previous_until_lane_start(d) 返回相距 d 的航路点列表。 这些列表分别从当前航路点到其车道的终点和起点。</li>
<li>get_right_lane() 和 get_left_lane() 返回相邻车道中的等效航路点（如果存在）。 可以通过在其右&#x2F;左车道上找到下一个航路点并移动到该航路点来进行变道操作。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find next waypoint 2 meters ahead.</span></span><br><span class="line">waypoint = waypoint.<span class="built_in">next</span>(<span class="number">2.0</span>)</span><br></pre></td></tr></table></figure>

<p>以下代码，生成车辆，获取航路点。关闭车辆的物理模拟，在 loop 中获取下一个航路点，将车辆 transform 设置到航路点位置，同时将 spectator 设置到当前车辆位置上方俯视观察：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">set_spectator_transform</span>(<span class="params">in_transform</span>):</span><br><span class="line">    spectator = world.get_spectator()</span><br><span class="line">    spectator.set_transform(carla.Transform(in_transform.location + carla.Location(<span class="number">0</span>,<span class="number">0</span>,<span class="number">30</span>),</span><br><span class="line">        carla.Rotation(pitch=-<span class="number">90</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Spawn vehicle</span></span><br><span class="line">vehicle_bp = world.get_blueprint_library().find(<span class="string">&#x27;vehicle.audi.tt&#x27;</span>)</span><br><span class="line">spawn_point = random.choice(<span class="built_in">map</span>.get_spawn_points())</span><br><span class="line">vehicle = world.spawn_actor(vehicle_bp, spawn_point)</span><br><span class="line">set_spectator_transform(vehicle.get_transform())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get waypoint</span></span><br><span class="line">waypoint = <span class="built_in">map</span>.get_waypoint(vehicle.get_location())</span><br><span class="line"><span class="built_in">print</span>(waypoint)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Disable physics, in this example the vehicle is teleported</span></span><br><span class="line">vehicle.set_simulate_physics(<span class="literal">False</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># Find next waypoint 2 meters ahead</span></span><br><span class="line">    waypoint = random.choice(waypoint.<span class="built_in">next</span>(<span class="number">0.2</span>))</span><br><span class="line">    <span class="comment"># waypoint = waypoint.next(2.0)</span></span><br><span class="line">    <span class="built_in">print</span>(waypoint)</span><br><span class="line">    <span class="comment"># Teleport the vehicle</span></span><br><span class="line">    vehicle.set_transform(waypoint.transform)</span><br><span class="line">    set_spectator_transform(waypoint.transform)</span><br></pre></td></tr></table></figure>

<p>有一种纯数学方法的航点导航法，似乎已经无法使用，具体原因我水平太低经过无数测试也没找出来。</p>
<h4 id="2-7-2-生成地图导航"><a href="#2-7-2-生成地图导航" class="headerlink" title="2.7.2 生成地图导航"></a>2.7.2 生成地图导航</h4><p>客户端需要向服务器发出请求以获取 .xodr 映射文件并将其解析为 carla.Map 对象。 这只需要执行一次。</p>
<p>这里补充一点OpenDRIVE的知识：</p>
<p>OpenDRIVE格式是以可扩展标记语言(XML)为基础，文件后缀为xodr格式的描述道路及道路网的通用标准。存储在OpenDRIVE文件中的数据描述了道路的几何形状以及沿线的特征并且定义了可以影响交通逻辑的交通标志以及道路基础设施，例如车道和信号灯。</p>
<p>路网是OpenDRIVE文件中描述的道路信息，其既是基于经验建造的，也可以是依据真实道路数据生成的。OpenDRIVE的主要目的是提供一种可用于仿真模拟的道路网络描述，并且可以使得这些道路以及道路网的描述可以在仿真平台或仿真软件中被自定义或改变。</p>
<p>OpenDRIVE根据XML的格式以节点和元素描述道路中各类信息。这样的通用格式有助于虚拟仿真测试的高度专业化，并且可以保持不同国家之间数据交换所需的相互操作性。</p>
<p>获取地图对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span> = world.get_map()</span><br></pre></td></tr></table></figure>

<p>地图对象包含用于创建车辆的推荐生成点。 您可以使用以下方法获取这些生成点的列表，每个生成点都包含一个 carla.Transform。 请记住，生成点可能已经被占用，导致由于碰撞而无法创建车辆。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spawn_points = world.get_map().get_spawn_points()</span><br></pre></td></tr></table></figure>

<p>您可以通过获取最接近特定位置或地图 OpenDRIVE 定义中的特定 road_id、lane_id 和 s 值的航点来开始使用航点：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Nearest waypoint in the center of a Driving or Sidewalk lane.</span></span><br><span class="line">waypoint01 = <span class="built_in">map</span>.get_waypoint(vehicle.get_location(),project_to_road=<span class="literal">True</span>, lane_type=(carla.LaneType.Driving | carla.LaneType.Sidewalk))</span><br><span class="line"></span><br><span class="line"><span class="comment">#Nearest waypoint but specifying OpenDRIVE parameters. </span></span><br><span class="line">waypoint02 = <span class="built_in">map</span>.get_waypoint_xodr(road_id,lane_id,s)</span><br></pre></td></tr></table></figure>

<p>下面的示例显示了如何生成航点集合以可视化城市车道。 这将在地图上为每条道路和车道创建航点。 它们都将相距约 2 米：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">waypoint_list = <span class="built_in">map</span>.generate_waypoints(<span class="number">2.0</span>)</span><br></pre></td></tr></table></figure>

<p>要生成道路拓扑的最小图，请使用以下示例。 这将返回航点对（元组）的列表。 每对中的第一个元素与第二个元素连接，并且都定义了地图中每个车道的起点和终点。 有关此方法的更多信息，请参阅 PythonAPI。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">waypoint_tuple_list = <span class="built_in">map</span>.get_topology()</span><br></pre></td></tr></table></figure>

<p>下面的示例以 carla.GeoLocation 的形式将 carla.Transform 转换为地理纬度和经度坐标：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_geolocation = <span class="built_in">map</span>.transform_to_geolocation(vehicle.transform)</span><br></pre></td></tr></table></figure>

<p>使用以下示例将 OpenDRIVE 格式的道路信息保存到磁盘：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info_map = <span class="built_in">map</span>.to_opendrive()</span><br></pre></td></tr></table></figure>

<h3 id="2-8-CARLA中的地图"><a href="#2-8-CARLA中的地图" class="headerlink" title="2.8 CARLA中的地图"></a>2.8 CARLA中的地图</h3><p>CARLA 有8个城镇，每个城镇有2种地图，即非分层地图和分层地图（后缀_Opt）。图层包含这些分组：</p>
<ul>
<li>NONE 无</li>
<li>Buildings 建筑</li>
<li>Decals 贴花</li>
<li>Foliage 植被</li>
<li>Ground 地面</li>
<li>ParkedVehicles 停靠的车辆</li>
<li>Particles 粒子</li>
<li>Props 杂物</li>
<li>StreetLights 路灯</li>
<li>Walls 墙体</li>
<li>All 所有</li>
</ul>
<h4 id="2-8-1-非分层地图"><a href="#2-8-1-非分层地图" class="headerlink" title="2.8.1 非分层地图"></a>2.8.1 非分层地图</h4><p>非分层地图如下表所示（单击城镇名称可查看布局的俯视图）。 所有图层始终存在，并且无法在这些地图中打开或关闭。 在 CARLA 0.9.11 之前，这些是唯一可用的地图类型。</p>
<ul>
<li>Town01：基本城镇，T型路口</li>
<li>Town02：类似Town01，更小</li>
<li>Town03：复杂城镇，5车道路口，环路，坡道，隧道</li>
<li>Town04：高速路和小镇的循环道路</li>
<li>Town05：带有交叉路口和桥的格子小镇。每个方向有多条车道，适合验证变道</li>
<li>Town06：长高速路，出入匝道</li>
<li>Town07：乡村环境，道路狭窄，少信号灯</li>
<li>Town10：高清城市环境</li>
</ul>
<h4 id="2-8-2-分层地图"><a href="#2-8-2-分层地图" class="headerlink" title="2.8.2 分层地图"></a>2.8.2 分层地图</h4><p>分层地图的布局与非分层地图的布局相同，但可以关闭和打开地图的图层。 有一个不能关闭的最小布局，由道路、人行道、交通信号灯和交通标志组成。 分层地图可以通过后缀 _Opt 来标识，例如 Town01_Opt。 使用这些地图，可以通过 Python API 加载和卸载图层：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Load layerred map for Town01 with minimum layout plus buildings and parked vehicles</span></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">world = client.load_world(<span class="string">&#x27;Town01_Opt&#x27;</span>, carla.MapLayer.Buildings | carla.MapLayer.ParkedVehicles)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Toggle all buildings off</span></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">world.unload_map_layer(carla.MapLayer.Buildings)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Toggle all buildings on</span></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">world.load_map_layer(carla.MapLayer.Buildings)</span><br></pre></td></tr></table></figure>

<h4 id="2-8-3-自定义地图"><a href="#2-8-3-自定义地图" class="headerlink" title="2.8.3 自定义地图"></a>2.8.3 自定义地图</h4><p>CARLA 旨在为专业应用程序提供可扩展性和高度可定制性。 因此，除了 CARLA 中已经开箱即用的许多地图和资产外，还可以创建和导入新的地图、道路网络和资产，以在 CARLA 模拟中填充定制环境。官方文档中有详细的介绍。而大多数情况下暂时不需要用到，因此这里不多加赘述，可以到CARKA官网中查看详细教程。</p>
<h3 id="2-9-传感器与数据"><a href="#2-9-传感器与数据" class="headerlink" title="2.9  传感器与数据"></a>2.9  传感器与数据</h3><p>传感器是从周围环境中检索数据的actor，“参与者”。</p>
<p>carla.Sensor 类定义了一种特殊类型的actor，能够测量和流式传输数据。</p>
<ul>
<li>这是什么数据？ 根据传感器的类型，它变化很大。 所有类型的数据都继承自通用 carla.SensorData。</li>
<li>他们什么时候检索数据？ 在每个模拟步骤或注册某个事件时。 取决于传感器的类型。</li>
<li>他们如何检索数据？ 每个传感器都有一个listen() 方法来接收和管理数据。</li>
</ul>
<p>尽管存在差异，但所有传感器都以相似的方式使用。</p>
<h4 id="2-9-1-设置"><a href="#2-9-1-设置" class="headerlink" title="2.9.1 设置"></a>2.9.1 设置</h4><p>与其他所有参与者一样，找到蓝图并设置特定属性。 这在处理传感器时至关重要。 它们的属性将决定获得的结果。</p>
<p>以下示例设置仪表板高清摄像头。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the blueprint of the sensor.</span></span><br><span class="line">blueprint = world.get_blueprint_library().find(<span class="string">&#x27;sensor.camera.rgb&#x27;</span>)</span><br><span class="line"><span class="comment"># Modify the attributes of the blueprint to set image resolution and field of view.</span></span><br><span class="line">blueprint.set_attribute(<span class="string">&#x27;image_size_x&#x27;</span>, <span class="string">&#x27;1920&#x27;</span>)</span><br><span class="line">blueprint.set_attribute(<span class="string">&#x27;image_size_y&#x27;</span>, <span class="string">&#x27;1080&#x27;</span>)</span><br><span class="line">blueprint.set_attribute(<span class="string">&#x27;fov&#x27;</span>, <span class="string">&#x27;110&#x27;</span>)</span><br><span class="line"><span class="comment"># Set the time in seconds between sensor captures</span></span><br><span class="line">blueprint.set_attribute(<span class="string">&#x27;sensor_tick&#x27;</span>, <span class="string">&#x27;1.0&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-9-2-生成"><a href="#2-9-2-生成" class="headerlink" title="2.9.2 生成"></a>2.9.2 生成</h4><p>attach_to 和attachment_type 至关重要。 传感器应该连接到父参与者（通常是车辆）上，以跟随它并收集信息。 附件类型将确定其位置关于所述车辆的更新方式。</p>
<ul>
<li>刚性附加。 运动对其父位置非常严格。 这是从模拟中检索数据的正确附件。</li>
<li>弹性附加。 运动很平稳，加速和减速很少。 此附件仅推荐用于录制模拟视频。 移动是平滑的，并且在更新摄像机位置时避免了“跳跃”。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transform = carla.Transform(carla.Location(x=<span class="number">0.8</span>, z=<span class="number">1.7</span>))</span><br><span class="line">sensor = world.spawn_actor(blueprint, transform, attach_to=my_vehicle)</span><br></pre></td></tr></table></figure>

<h4 id="2-9-3-监听"><a href="#2-9-3-监听" class="headerlink" title="2.9.3 监听"></a>2.9.3 监听</h4><p>每个传感器都有一个listen() 方法。 每次传感器检索数据时都会调用它。</p>
<p>参数回调是一个 lambda 函数。 它描述了传感器在检索数据时应该做什么。 这必须将检索的数据作为参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># do_something() will be call each time a new image is generated by the camera</span></span><br><span class="line"><span class="comment"># sensor.listen(lambda data: do_something(date))</span></span><br><span class="line">sensor.listen(<span class="keyword">lambda</span> image: image.save_to_disk(<span class="string">&#x27;./output/%06d.png&#x27;</span> % image.frame))</span><br><span class="line"></span><br><span class="line"><span class="comment"># This collision sensor would print everytime a collision is detected</span></span><br><span class="line"><span class="comment"># def callback(event):</span></span><br><span class="line"><span class="comment">#     for actor_id in event:</span></span><br><span class="line"><span class="comment">#         vehicle = world_ref().get_actor(actor_id)</span></span><br><span class="line"><span class="comment">#         print(&#x27;Vehicle too close: %s&#x27; % vehicle.type_id)</span></span><br><span class="line"><span class="comment"># sensor02.listen(callback)</span></span><br></pre></td></tr></table></figure>

<h4 id="2-9-4-数据"><a href="#2-9-4-数据" class="headerlink" title="2.9.4 数据"></a>2.9.4 数据</h4><p>大多数传感器数据对象都具有将信息保存到磁盘的功能。 这将允许它在其他环境中使用。</p>
<p>传感器类型之间的传感器数据差异很大。 但是，它们总是带有一些基本信息的标记。</p>
<table>
<thead>
<tr>
<th>传感器数据属性</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>frame</code></td>
<td>int</td>
<td>进行测量时的帧数。</td>
</tr>
<tr>
<td><code>timestamp</code></td>
<td>double</td>
<td>自剧集开始以来以模拟秒为单位的测量时间戳。</td>
</tr>
<tr>
<td><code>transform</code></td>
<td>carla.Transform</td>
<td>测量时传感器的世界参考。</td>
</tr>
</tbody></table>
<p><strong>注意：is_listening 是传感器属性，用于启用和关闭数据侦听。sensor_tick 是蓝图属性，用于设置接收数据之间的仿真时间</strong></p>
<p>将以上的代码完成一下，就实现了 <strong>设置 rgb 相机参数 -&gt; 生成相机演员附加在车辆上 -&gt; 设置相机回调方法，将图像保存在磁盘上 -&gt; 调用 world.tick() 接收服务器数据</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the blueprint of the sensor</span></span><br><span class="line">camera_bp = world.get_blueprint_library().find(<span class="string">&#x27;sensor.camera.rgb&#x27;</span>)</span><br><span class="line"><span class="comment"># Modify the attributes of the blueprint to set image resolution and field of view</span></span><br><span class="line">camera_bp.set_attribute(<span class="string">&#x27;image_size_x&#x27;</span>, <span class="string">&#x27;1920&#x27;</span>)</span><br><span class="line">camera_bp.set_attribute(<span class="string">&#x27;image_size_y&#x27;</span>, <span class="string">&#x27;1080&#x27;</span>)</span><br><span class="line">camera_bp.set_attribute(<span class="string">&#x27;fov&#x27;</span>, <span class="string">&#x27;110&#x27;</span>)</span><br><span class="line"><span class="comment"># Set the time in seconds between sensor captures</span></span><br><span class="line">camera_bp.set_attribute(<span class="string">&#x27;sensor_tick&#x27;</span>, <span class="string">&#x27;1.0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">camera_transform = carla.Transform(carla.Location(x=<span class="number">0.8</span>, z=<span class="number">1.7</span>))</span><br><span class="line">sensor = world.spawn_actor(camera_bp, camera_transform, attach_to=vehicle)</span><br><span class="line"></span><br><span class="line"><span class="comment"># do_something() will be call each time a new image is generated by the camera</span></span><br><span class="line"><span class="comment"># sensor.listen(lambda data: do_something(date))</span></span><br><span class="line">sensor.listen(<span class="keyword">lambda</span> image: image.save_to_disk(<span class="string">&#x27;./output/%06d.png&#x27;</span> % image.frame))</span><br><span class="line"></span><br><span class="line"><span class="comment"># This collision sensor would print everytime a collision is detected</span></span><br><span class="line"><span class="comment"># def callback(event):</span></span><br><span class="line"><span class="comment">#     for actor_id in event:</span></span><br><span class="line"><span class="comment">#         vehicle = world_ref().get_actor(actor_id)</span></span><br><span class="line"><span class="comment">#         print(&#x27;Vehicle too close: %s&#x27; % vehicle.type_id)</span></span><br><span class="line"><span class="comment"># sensor02.listen(callback)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Main loop</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># Tick the server</span></span><br><span class="line">    world.tick()</span><br><span class="line">    w_frame = world.get_snapshot().frame</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;World&#x27;s frame: %d&quot;</span> % w_frame)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-10-传感器的类型"><a href="#2-10-传感器的类型" class="headerlink" title="2.10 传感器的类型"></a>2.10 传感器的类型</h3><h4 id="2-10-1-摄像头"><a href="#2-10-1-摄像头" class="headerlink" title="2.10.1 摄像头"></a>2.10.1 摄像头</h4><p>从相机的角度拍摄世界。 对于返回 carla.Image 的相机，您可以使用帮助类 carla.ColorConverter 来修改图像类型以表示不同的信息。</p>
<ul>
<li>检索每个模拟步骤的数据。</li>
</ul>
<table>
<thead>
<tr>
<th>传感器</th>
<th>输出</th>
<th>概述</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://carla.readthedocs.io/en/latest/ref_sensors/#depth-camera">Depth</a></td>
<td><a target="_blank" rel="noopener" href="https://carla.readthedocs.io/en/latest/python_api#carlaimage">carla.Image</a></td>
<td>在灰度图中渲染视场中元素的深度。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://carla.readthedocs.io/en/latest/ref_sensors/#rgb-camera">RGB</a></td>
<td><a target="_blank" rel="noopener" href="https://carla.readthedocs.io/en/latest/python_api#carlaimage">carla.Image</a></td>
<td>提供对周围环境的清晰视野。 看起来像一张普通的现场照片。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://carla.readthedocs.io/en/latest/ref_sensors/#optical-flow-camera">Optical Flow</a></td>
<td><a target="_blank" rel="noopener" href="https://carla.readthedocs.io/en/latest/python_api#carlaimage">carla.Image</a></td>
<td>渲染来自相机的每个像素的运动。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://carla.readthedocs.io/en/latest/ref_sensors/#semantic-segmentation-camera">Semantic segmentation</a></td>
<td><a target="_blank" rel="noopener" href="https://carla.readthedocs.io/en/latest/python_api#carlaimage">carla.Image</a></td>
<td>根据标签以特定颜色渲染视野中的元素。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://carla.readthedocs.io/en/latest/ref_sensors/#instance-segmentation-camera">Instance segmentation</a></td>
<td><a target="_blank" rel="noopener" href="https://carla.readthedocs.io/en/latest/python_api#carlaimage">carla.Image</a></td>
<td>根据标签和唯一的对象 ID 以特定颜色渲染视野中的元素。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://carla.readthedocs.io/en/latest/ref_sensors/#dvs-camera">DVS</a></td>
<td><a target="_blank" rel="noopener" href="https://carla.readthedocs.io/en/latest/python_api#carladvseventarray">carla.DVSEventArray</a></td>
<td>作为事件流异步测量亮度强度的变化。</td>
</tr>
</tbody></table>
<h4 id="2-10-2-探测器"><a href="#2-10-2-探测器" class="headerlink" title="2.10.2 探测器"></a>2.10.2 探测器</h4><p>探测器，当传感器附加的物体触发特定事件时，检索数据：</p>
<table>
<thead>
<tr>
<th>传感器</th>
<th>输出</th>
<th>概述</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://carla.readthedocs.io/en/latest/ref_sensors/#collision-detector">Collision</a></td>
<td><a target="_blank" rel="noopener" href="https://carla.readthedocs.io/en/latest/python_api#carlacollisionevent">carla.CollisionEvent</a></td>
<td>检索其父actor和其他actor之间的碰撞。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://carla.readthedocs.io/en/latest/ref_sensors/#lane-invasion-detector">Lane invasion</a></td>
<td><a target="_blank" rel="noopener" href="https://carla.readthedocs.io/en/latest/python_api#carlalaneinvasionevent">carla.LaneInvasionEvent</a></td>
<td>在其父项越过车道标记时注册。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://carla.readthedocs.io/en/latest/ref_sensors/#obstacle-detector">Obstacle</a></td>
<td><a target="_blank" rel="noopener" href="https://carla.readthedocs.io/en/latest/python_api#carlaobstacledetectionevent">carla.ObstacleDetectionEvent</a></td>
<td>检测到其父级之前可能存在的障碍。</td>
</tr>
</tbody></table>
<h4 id="2-10-3-其它"><a href="#2-10-3-其它" class="headerlink" title="2.10.3 其它"></a>2.10.3 其它</h4><p>不同的功能，例如导航、物理属性测量和场景的 2D&#x2F;3D 点图。</p>
<table>
<thead>
<tr>
<th>传感器</th>
<th>输出</th>
<th>概述</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://carla.readthedocs.io/en/latest/ref_sensors/#gnss-sensor">GNSS</a></td>
<td><a target="_blank" rel="noopener" href="https://carla.readthedocs.io/en/latest/python_api#carlagnssmeasurement">carla.GNSSMeasurement</a></td>
<td>检索传感器的地理位置。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://carla.readthedocs.io/en/latest/ref_sensors/#imu-sensor">IMU</a></td>
<td><a target="_blank" rel="noopener" href="https://carla.readthedocs.io/en/latest/python_api#carlaimumeasurement">carla.IMUMeasurement</a></td>
<td>包括加速度计、陀螺仪和指南针。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://carla.readthedocs.io/en/latest/ref_sensors/#lidar-sensor">LIDAR</a></td>
<td><a target="_blank" rel="noopener" href="https://carla.readthedocs.io/en/latest/python_api#carlalidarmeasurement">carla.LidarMeasurement</a></td>
<td>旋转激光雷达。 生成一个 4D 点云，每个点的坐标和强度对周围环境进行建模。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://carla.readthedocs.io/en/latest/ref_sensors/#radar-sensor">Radar</a></td>
<td><a target="_blank" rel="noopener" href="https://carla.readthedocs.io/en/latest/python_api#carlaradarmeasurement">carla.RadarMeasurement</a></td>
<td>2D 点图建模元素在视线内及其与传感器有关的运动。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://carla.readthedocs.io/en/latest/ref_sensors/#rss-sensor">RSS</a></td>
<td><a target="_blank" rel="noopener" href="https://carla.readthedocs.io/en/latest/python_api#carlarssresponse">carla.RssResponse</a></td>
<td>根据安全检查修改应用于车辆的控制器。 此传感器的工作方式与其他传感器不同，并且有专门的 RSS 文档。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://carla.readthedocs.io/en/latest/ref_sensors/#semantic-lidar-sensor">Semantic LIDAR</a></td>
<td><a target="_blank" rel="noopener" href="https://carla.readthedocs.io/en/latest/python_api#carlasemanticlidarmeasurement">carla.SemanticLidarMeasurement</a></td>
<td>旋转激光雷达。 生成具有有关实例和语义分割的额外信息的 3D 点云。</td>
</tr>
</tbody></table>
<ul>
<li><strong>Camera构建</strong></li>
</ul>
<p>与汽车类似，我们先创建蓝图，再定义位置，然后再选择我们想要的汽车安装上去。不过，这里的位置都是相对汽车中心点的位置（以米计量）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">camera_bp = blueprint_library.find(<span class="string">&#x27;sensor.camera.rgb&#x27;</span>)</span><br><span class="line">camera_transform = carla.Transform(carla.Location(x=<span class="number">1.5</span>, z=<span class="number">2.4</span>))</span><br><span class="line">camera = world.spawn_actor(camera_bp, camera_transform, attach_to=ego_vehicle)</span><br></pre></td></tr></table></figure>

<p>我们还要对相机定义它的callback function,定义每次仿真世界里传感器数据传回来后，我们要对它进行什么样的处理。在这个教程里我们只需要简单地将文件存在硬盘里。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">camera.listen(<span class="keyword">lambda</span> image: image.save_to_disk(os.path.join(output_path, <span class="string">&#x27;%06d.png&#x27;</span> % image.frame)))</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Lidar构建</strong></li>
</ul>
<p>Lidar可以设置的参数比较多，对Lidar模型不熟也没有关系，我在后面会另开文章详细介绍激光雷达模型，现在就知道我们设置了一些常用参数就好。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lidar_bp = blueprint_library.find(<span class="string">&#x27;sensor.lidar.ray_cast&#x27;</span>)</span><br><span class="line">lidar_bp.set_attribute(<span class="string">&#x27;channels&#x27;</span>, <span class="built_in">str</span>(<span class="number">32</span>))</span><br><span class="line">lidar_bp.set_attribute(<span class="string">&#x27;points_per_second&#x27;</span>, <span class="built_in">str</span>(<span class="number">90000</span>))</span><br><span class="line">lidar_bp.set_attribute(<span class="string">&#x27;rotation_frequency&#x27;</span>, <span class="built_in">str</span>(<span class="number">40</span>))</span><br><span class="line">lidar_bp.set_attribute(<span class="string">&#x27;range&#x27;</span>, <span class="built_in">str</span>(<span class="number">20</span>))</span><br></pre></td></tr></table></figure>

<p>接着把lidar放置在奔驰上, 定义它的callback function.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lidar_location = carla.Location(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">lidar_rotation = carla.Rotation(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">lidar_transform = carla.Transform(lidar_location, lidar_rotation)</span><br><span class="line">lidar = world.spawn_actor(lidar_bp, lidar_transform, attach_to=ego_vehicle)</span><br><span class="line">lidar.listen(<span class="keyword">lambda</span> point_cloud: \</span><br><span class="line">            point_cloud.save_to_disk(os.path.join(output_path, <span class="string">&#x27;%06d.ply&#x27;</span> % point_cloud.frame</span><br></pre></td></tr></table></figure>



<h2 id="3-PythonAPI的使用"><a href="#3-PythonAPI的使用" class="headerlink" title="3. PythonAPI的使用"></a>3. PythonAPI的使用</h2><h4 id="3-1-配置默认库"><a href="#3-1-配置默认库" class="headerlink" title="3.1 配置默认库"></a>3.1 配置默认库</h4><p>我们之前虽然已经make好了Carla的PythonAPI, 但是并没有将它的库安装到我们默认的python3里，如果你查看carla自带的example, 会发现都要先进行以下操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sys.path.append(glob.glob(<span class="string">&#x27;../carla/dist/carla-*%d.%d-%s.egg&#x27;</span> % (</span><br><span class="line">        sys.version_info.major,</span><br><span class="line">        sys.version_info.minor,</span><br><span class="line">        <span class="string">&#x27;win-amd64&#x27;</span> <span class="keyword">if</span> os.name == <span class="string">&#x27;nt&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;linux-x86_64&#x27;</span>))[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">except</span> IndexError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">import</span> carla</span><br></pre></td></tr></table></figure>

<p>在我们的代码中，也要这样做。当然有一劳永逸的方法。将Carla Library安装到你的python3.7里。这是我个人研究的方法，不一定都能成功。</p>
<p>最新版本的CARLA模拟器，可以直接pip install carla解决。</p>
<p>如果安装了旧版，需要按照以下步骤进行：</p>
<p>使用anaconda激活car环境，cd命令进入PythonAPI&#x2F;carla&#x2F;dist。运行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unzip carla-0.9.13-py3.7-win-amd64.egg -d carla-0.9.13-py3.7-win-amd64</span><br><span class="line">cd carla-0.9.13-py3.7-win-amd64</span><br></pre></td></tr></table></figure>

<p>在同目录下建立一个setup.py，复制进入：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup</span><br><span class="line">setup(name=<span class="string">&#x27;carla&#x27;</span>,</span><br><span class="line">      version=<span class="string">&#x27;0.9.10&#x27;</span>, </span><br><span class="line">      py_modules=[<span class="string">&#x27;carla&#x27;</span>],</span><br><span class="line">      )</span><br></pre></td></tr></table></figure>

<p>最后通过pip命令安装进去。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -e carla-0.9.13-py3.7-win-amd64</span><br></pre></td></tr></table></figure>

<h3 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h3><p>我原本准备详细写写他提供的pythonAPI，但是他提供的实在是非常多，后期只能用到什么查什么，写什么。这里放个官方文档地址。<a target="_blank" rel="noopener" href="https://zlhou-carla-doc-cn.readthedocs.io/zh/latest/python_api/">Python API 参考 - CARLA 模拟器 中文文档 (zlhou-carla-doc-cn.readthedocs.io)</a></p>
<h2 id="4-基于DQN的自动驾驶"><a href="#4-基于DQN的自动驾驶" class="headerlink" title="4. 基于DQN的自动驾驶"></a>4. 基于DQN的自动驾驶</h2><h3 id="4-1-DQN"><a href="#4-1-DQN" class="headerlink" title="4.1 DQN"></a>4.1 DQN</h3><p>DQN（Deep Q-Learning）可谓是深度强化学习（Deep Reinforcement Learning，DRL）的开山之作，是将深度学习与强化学习结合起来从而实现从感知（Perception）到动作（ Action ）的端对端（End-to-end）学习的一种全新的算法。由DeepMind在NIPS 2013上发表，后又在Nature 2015上提出改进版本。</p>
<p>DQN是DRL的其中一种算法，它要做的就是将卷积神经网络（CNN）和Q-Learning结合起来，CNN的输入是原始图像数据（作为状态State），输出则是每个动作Action对应的价值评估Value Function（Q值）。</p>
<p><img src="/.com//20170612220809641" alt="这里写图片描述"></p>
<p>创新点：</p>
<p>基于Q-Learning构造Loss Function（不算很新，过往使用线性和非线性函数拟合Q-Table时就是这样做）。<br>通过experience replay（经验池）解决相关性及非静态分布问题；<br>使用TargetNet解决稳定性问题。<br>优点：</p>
<p>算法通用性，可玩不同游戏；<br>End-to-End 训练方式；<br>可生产大量样本供监督学习。<br>缺点：</p>
<p>无法应用于连续动作控制；<br>只能处理只需短时记忆问题，无法处理需长时记忆问题（后续研究提出了使用LSTM等改进方法）；<br>CNN不一定收敛，需精良调参。</p>
<h3 id="4-2-DQN自动驾驶"><a href="#4-2-DQN自动驾驶" class="headerlink" title="4.2 DQN自动驾驶"></a>4.2 DQN自动驾驶</h3><p>这里我们用pytroch+gym实现一下来感受深度强化学习。pytorch的环境配置之前已经说过，这里不多加赘述。</p>
<h4 id="4-2-1-配置环境"><a href="#4-2-1-配置环境" class="headerlink" title="4.2.1 配置环境"></a>4.2.1 配置环境</h4><p>gym是用于开发和比较强化学习算法的工具包，在python中安装gym库和其中子场景都较为简便。</p>
<p>安装gym：pip install gym</p>
<p>安装自动驾驶模块，这里使用Edouard Leurent发布在github上的包highway-env（原链接）：pip install –user git+<a target="_blank" rel="noopener" href="https://github.com/eleurent/highway-env">https://github.com/eleurent/highway-env</a></p>
<p>其中包含6个场景：</p>
<ul>
<li><p>高速公路——“highway-v0”</p>
</li>
<li><p>汇入——“merge-v0”</p>
</li>
<li><p>环岛——“roundabout-v0”</p>
</li>
<li><p>泊车——“parking-v0”</p>
</li>
<li><p>十字路口——“intersection-v0”</p>
</li>
<li><p>赛车道——“racetrack-v0”</p>
</li>
</ul>
<h4 id="4-2-2-实验环境"><a href="#4-2-2-实验环境" class="headerlink" title="4.2.2 实验环境"></a>4.2.2 实验环境</h4><p>安装好后即可在代码中进行实验（以高速公路场景为例）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> highway_env</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">env = gym.make(<span class="string">&#x27;highway-v0&#x27;</span>)</span><br><span class="line">env.reset()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    action = env.action_type.actions_indexes[<span class="string">&quot;IDLE&quot;</span>]</span><br><span class="line">    obs, reward, done, info = env.step(action)</span><br><span class="line">    env.render()</span><br></pre></td></tr></table></figure>

<p>会出现这样的画面：</p>
<p><img src="/.com//image-20220719182153218.png" alt="image-20220719182153218"></p>
<p>可以看到这是上帝视角。绿色的就是我们可以用代码操控的车。这样的游戏相对简单，数据比较好处理，大家也比较容易理解。</p>
<p>env类有很多参数可以配置，具体可以参考在github上的原文档。</p>
<h4 id="4-2-3-数据处理"><a href="#4-2-3-数据处理" class="headerlink" title="4.2.3 数据处理"></a>4.2.3 数据处理</h4><p>(1)state<br>highway-env包中没有定义传感器，车辆所有的state (observations) 都从底层代码读取，节省了许多前期的工作量。根据文档介绍，state (ovservations) 有三种输出方式：Kinematics，Grayscale Image和Occupancy grid。</p>
<p>Kinematics</p>
<p>输出V*F的矩阵，V代表需要观测的车辆数量（包括ego vehicle本身），F代表需要统计的特征数量。<br>例：</p>
<p>Vehicle	x	y	v_x	v_y<br>ego-vehicle	5.0	4.0	15.0	0<br>vehicle1	-10.0	4.0	12.0	0<br>vehicle2	13.0	8.0	13.5	0<br>数据生成时会默认归一化，取值范围：[100, 100, 20, 20]，也可以设置ego vehicle以外的车辆属性是地图的绝对坐标还是对ego vehicle的相对坐标。</p>
<p>在定义环境时需要对特征的参数进行设定：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">config = \</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="string">&quot;observation&quot;</span>: </span><br><span class="line">         &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Kinematics&quot;</span>,</span><br><span class="line">        <span class="comment">#选取5辆车进行观察（包括ego vehicle）</span></span><br><span class="line">        <span class="string">&quot;vehicles_count&quot;</span>: <span class="number">5</span>,  </span><br><span class="line">        <span class="comment">#共7个特征</span></span><br><span class="line">        <span class="string">&quot;features&quot;</span>: [<span class="string">&quot;presence&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;vx&quot;</span>, <span class="string">&quot;vy&quot;</span>, <span class="string">&quot;cos_h&quot;</span>, <span class="string">&quot;sin_h&quot;</span>], </span><br><span class="line">        <span class="string">&quot;features_range&quot;</span>: </span><br><span class="line">            &#123;</span><br><span class="line">            <span class="string">&quot;x&quot;</span>: [-<span class="number">100</span>, <span class="number">100</span>],</span><br><span class="line">            <span class="string">&quot;y&quot;</span>: [-<span class="number">100</span>, <span class="number">100</span>],</span><br><span class="line">            <span class="string">&quot;vx&quot;</span>: [-<span class="number">20</span>, <span class="number">20</span>],</span><br><span class="line">            <span class="string">&quot;vy&quot;</span>: [-<span class="number">20</span>, <span class="number">20</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">        <span class="string">&quot;absolute&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">        <span class="string">&quot;order&quot;</span>: <span class="string">&quot;sorted&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    <span class="string">&quot;simulation_frequency&quot;</span>: <span class="number">8</span>,  <span class="comment"># [Hz]</span></span><br><span class="line">    <span class="string">&quot;policy_frequency&quot;</span>: <span class="number">2</span>,  <span class="comment"># [Hz]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Grayscale-Image"><a href="#Grayscale-Image" class="headerlink" title="Grayscale Image"></a>Grayscale Image</h4><p>生成一张W*H的灰度图像，W代表图像宽度，H代表图像高度</p>
<h4 id="Occupancy-grid"><a href="#Occupancy-grid" class="headerlink" title="Occupancy grid"></a>Occupancy grid</h4><p>生成一个W<em>H</em>F的三维矩阵，用W*H的表格表示ego vehicle周围的车辆情况，每个格子包含F个特征。</p>
<p>(2) action</p>
<p>highway-env包中的action分为连续和离散两种。连续型action可以直接定义throttle和steering angle的值，离散型包含5个meta actions：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ACTIONS_ALL = &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="string">&#x27;LANE_LEFT&#x27;</span>,</span><br><span class="line">        <span class="number">1</span>: <span class="string">&#x27;IDLE&#x27;</span>,</span><br><span class="line">        <span class="number">2</span>: <span class="string">&#x27;LANE_RIGHT&#x27;</span>,</span><br><span class="line">        <span class="number">3</span>: <span class="string">&#x27;FASTER&#x27;</span>,</span><br><span class="line">        <span class="number">4</span>: <span class="string">&#x27;SLOWER&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(3) reward</p>
<p>highway-env包中除了泊车场景外都采用同一个reward function：</p>
<p><img src="/.com//image-20220719182922431.png" alt="image-20220719182922431"></p>
<p>这个function只能在其源码中更改，在外层只能调整权重。</p>
<h4 id="4-2-4-搭建模型"><a href="#4-2-4-搭建模型" class="headerlink" title="4.2.4 搭建模型"></a>4.2.4 搭建模型</h4><p>这里采用第一种state表示方式——Kinematics进行示范。</p>
<p>由于state数据量较小（5辆车*7个特征），可以不考虑使用CNN，直接把二维数据的size[5,7]转成[1,35]即可，模型的输入就是35，输出是离散action数量，共5个。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> T</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> FloatTensor, LongTensor, ByteTensor</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Tensor = FloatTensor</span><br><span class="line"></span><br><span class="line">EPSILON = <span class="number">0</span>  <span class="comment"># epsilon used for epsilon greedy approach</span></span><br><span class="line">GAMMA = <span class="number">0.9</span></span><br><span class="line">TARGET_NETWORK_REPLACE_FREQ = <span class="number">40</span>  <span class="comment"># How frequently target netowrk updates</span></span><br><span class="line">MEMORY_CAPACITY = <span class="number">100</span></span><br><span class="line">BATCH_SIZE = <span class="number">80</span></span><br><span class="line">LR = <span class="number">0.01</span>  <span class="comment"># learning rate</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DQNNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(DQNNet, self).__init__()</span><br><span class="line">        self.linear1 = nn.Linear(<span class="number">35</span>, <span class="number">256</span>).to(device)</span><br><span class="line">        self.linear2 = nn.Linear(<span class="number">256</span>, <span class="number">256</span>).to(device)</span><br><span class="line">        self.linear3 = nn.Linear(<span class="number">256</span>, <span class="number">5</span>).to(device)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, s</span>):</span><br><span class="line">        s = torch.FloatTensor(s)</span><br><span class="line">        s = s.view(s.size(<span class="number">0</span>), <span class="number">1</span>, <span class="number">35</span>)</span><br><span class="line">        s = s.to(device)</span><br><span class="line">        s = self.linear1(s)</span><br><span class="line">        s = self.linear2(s)</span><br><span class="line">        s = self.linear3(s)</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DQN</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.net, self.target_net = DQNNet(), DQNNet()</span><br><span class="line">        self.learn_step_counter = <span class="number">0</span></span><br><span class="line">        self.memory = []</span><br><span class="line">        self.position = <span class="number">0</span></span><br><span class="line">        self.capacity = MEMORY_CAPACITY</span><br><span class="line">        self.optimizer = torch.optim.Adam(self.net.parameters(), lr=LR)</span><br><span class="line">        self.loss_func = nn.MSELoss().cuda()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">choose_action</span>(<span class="params">self, s, e</span>):</span><br><span class="line">        x = np.expand_dims(s, axis=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> np.random.uniform() &lt; <span class="number">1</span> - e:</span><br><span class="line">            actions_value = self.net.forward(x)</span><br><span class="line">            action = torch.<span class="built_in">max</span>(actions_value, -<span class="number">1</span>)[<span class="number">1</span>].data.cpu().numpy()</span><br><span class="line">            action = action.<span class="built_in">max</span>()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            action = np.random.randint(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push_memory</span>(<span class="params">self, s, a, r, s_</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.memory) &lt; self.capacity:</span><br><span class="line">            self.memory.append(<span class="literal">None</span>)</span><br><span class="line">        self.memory[self.position] = Transition(torch.unsqueeze(torch.FloatTensor(s), <span class="number">0</span>),</span><br><span class="line">                                                torch.unsqueeze(torch.FloatTensor(s_), <span class="number">0</span>),\</span><br><span class="line">                                                torch.from_numpy(np.array([a])),</span><br><span class="line">                                                torch.from_numpy(np.array([r], dtype=<span class="string">&#x27;float32&#x27;</span>)))  <span class="comment">#</span></span><br><span class="line">        self.position = (self.position + <span class="number">1</span>) % self.capacity</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_sample</span>(<span class="params">self, batch_size</span>):</span><br><span class="line">        sample = random.sample(self.memory, batch_size)</span><br><span class="line">        <span class="keyword">return</span> sample</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">learn</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.learn_step_counter % TARGET_NETWORK_REPLACE_FREQ == <span class="number">0</span>:</span><br><span class="line">            self.target_net.load_state_dict(self.net.state_dict())</span><br><span class="line">        self.learn_step_counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        transitions = self.get_sample(BATCH_SIZE)</span><br><span class="line">        batch = Transition(*<span class="built_in">zip</span>(*transitions))</span><br><span class="line"></span><br><span class="line">        b_s = Variable(torch.cat(batch.state))</span><br><span class="line">        b_s_ = Variable(torch.cat(batch.next_state))</span><br><span class="line">        b_a = Variable(torch.cat(batch.action)).to(device)</span><br><span class="line">        b_r = Variable(torch.cat(batch.reward)).to(device)</span><br><span class="line"></span><br><span class="line">        q_eval = self.net.forward(b_s).squeeze(<span class="number">1</span>).gather(<span class="number">1</span>, b_a.unsqueeze(<span class="number">1</span>).to(torch.int64))</span><br><span class="line">        q_next = self.target_net.forward(b_s_).detach().to(device)  <span class="comment">#</span></span><br><span class="line">        q_target = b_r + GAMMA * q_next.squeeze(<span class="number">1</span>).<span class="built_in">max</span>(<span class="number">1</span>)[<span class="number">0</span>].view(BATCH_SIZE, <span class="number">1</span>).t().to(device)</span><br><span class="line">        loss = self.loss_func(q_eval, q_target.t()).to(device)</span><br><span class="line">        self.optimizer.zero_grad()  <span class="comment"># reset the gradient to zero</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        self.optimizer.step()  <span class="comment"># execute back propagation for one step</span></span><br><span class="line">        <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Transition = namedtuple(<span class="string">&#x27;Transition&#x27;</span>, (<span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;next_state&#x27;</span>, <span class="string">&#x27;action&#x27;</span>, <span class="string">&#x27;reward&#x27;</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li>模型结构</li>
</ul>
<p>这里对原作者的网络结构进行了更改。在example里设置的模型只有一个隐藏层，neuron数量和输入层相同，即模型结构为[35,35,5]，把隐藏层的数量和neuron数都增大，这里设为了[35,256,256,5]，模型效果有所提升。</p>
<ul>
<li>reward定义</li>
</ul>
<p>highway-env环境内部对于reward的定义比较固定，不支持自由更改，如果想高度自定义reward，建议在环境外部自己写function，不要使用环境反馈的reward。</p>
<p>在highway-env的官方文档中又有说明，奖励必须是有界的，所以无论如何在config里设置奖励或惩罚的数值，都会被归一化，使其介于[0,1]。如果因为认为模型碰撞发生率过高，为了让它更注重避障，在config里把碰撞的惩罚设置成一个很小的负数，环境对碰撞的奖励输出还是0，但是加速奖励因为归一化的下界变化变得更接近1了，这样相当于没有减小碰撞奖励，反而增大了速度奖励，适得其反，模型变得更激进了。碰撞惩罚越大，发生碰撞的概率越高。</p>
<ul>
<li>网络价值分析</li>
</ul>
<p>假设当前DQN已经训练到最优，即对每个局面下的每个动作价值输出都是准确的，并且策略会在每个状态下做出最优选择。由于env定义的reward介于[0,1]，可以使用等比数列求和公式计算出最理想情况下每个动作值的上界。<br>$$<br>Qmax &#x3D; 1+γ∗1+γ∗(γ∗1)+γ∗(γ∗(γ∗1))+…&#x3D;1&#x2F;(1-γ)<br>$$<br>如果期望的收益是有限的，那么γ一定小于1，如果设为0.8，模型能输出的最大Q值是5，如果设为0.9，模型能输出的最大Q值是10，以此类推。如果模型输出的某个动作Q值超过了这个数，就可以认为模型没有正确学习到价值，学习过程有bug，需要检查代码。</p>
<h4 id="4-2-5-开始训练"><a href="#4-2-5-开始训练" class="headerlink" title="4.2.5 开始训练"></a>4.2.5 开始训练</h4><p>初始化环境，加入DQN的类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> highway_env</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> DQNnet <span class="keyword">import</span> DQN</span><br><span class="line">config = \</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="string">&quot;observation&quot;</span>: </span><br><span class="line">         &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Kinematics&quot;</span>,</span><br><span class="line">        <span class="string">&quot;vehicles_count&quot;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="string">&quot;features&quot;</span>: [<span class="string">&quot;presence&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;vx&quot;</span>, <span class="string">&quot;vy&quot;</span>, <span class="string">&quot;cos_h&quot;</span>, <span class="string">&quot;sin_h&quot;</span>],</span><br><span class="line">        <span class="string">&quot;features_range&quot;</span>: </span><br><span class="line">            &#123;</span><br><span class="line">            <span class="string">&quot;x&quot;</span>: [-<span class="number">100</span>, <span class="number">100</span>],</span><br><span class="line">            <span class="string">&quot;y&quot;</span>: [-<span class="number">100</span>, <span class="number">100</span>],</span><br><span class="line">            <span class="string">&quot;vx&quot;</span>: [-<span class="number">20</span>, <span class="number">20</span>],</span><br><span class="line">            <span class="string">&quot;vy&quot;</span>: [-<span class="number">20</span>, <span class="number">20</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">        <span class="string">&quot;absolute&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">        <span class="string">&quot;order&quot;</span>: <span class="string">&quot;sorted&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    <span class="string">&quot;simulation_frequency&quot;</span>: <span class="number">8</span>,  <span class="comment"># [Hz]</span></span><br><span class="line">    <span class="string">&quot;policy_frequency&quot;</span>: <span class="number">2</span>,  <span class="comment"># [Hz]</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">env = gym.make(<span class="string">&quot;highway-v0&quot;</span>)</span><br><span class="line">env.configure(config)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>训练：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> highway_env</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> DQNnet <span class="keyword">import</span> DQN</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&#x27;./log&#x27;</span>)</span><br><span class="line"></span><br><span class="line">config = \</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;observation&quot;</span>:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Kinematics&quot;</span>,</span><br><span class="line">                <span class="string">&quot;vehicles_count&quot;</span>: <span class="number">5</span>,</span><br><span class="line">                <span class="string">&quot;features&quot;</span>: [<span class="string">&quot;presence&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;vx&quot;</span>, <span class="string">&quot;vy&quot;</span>, <span class="string">&quot;cos_h&quot;</span>, <span class="string">&quot;sin_h&quot;</span>],</span><br><span class="line">                <span class="string">&quot;features_range&quot;</span>:</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;x&quot;</span>: [-<span class="number">100</span>, <span class="number">100</span>],</span><br><span class="line">                        <span class="string">&quot;y&quot;</span>: [-<span class="number">100</span>, <span class="number">100</span>],</span><br><span class="line">                        <span class="string">&quot;vx&quot;</span>: [-<span class="number">20</span>, <span class="number">20</span>],</span><br><span class="line">                        <span class="string">&quot;vy&quot;</span>: [-<span class="number">20</span>, <span class="number">20</span>]</span><br><span class="line">                    &#125;,</span><br><span class="line">                <span class="string">&quot;absolute&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">                <span class="string">&quot;order&quot;</span>: <span class="string">&quot;sorted&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        <span class="string">&quot;simulation_frequency&quot;</span>: <span class="number">8</span>,  <span class="comment"># [Hz]</span></span><br><span class="line">        <span class="string">&quot;policy_frequency&quot;</span>: <span class="number">2</span>,  <span class="comment"># [Hz]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">env = gym.make(<span class="string">&quot;highway-v0&quot;</span>)</span><br><span class="line">env.configure(config)</span><br><span class="line"></span><br><span class="line">dqn = DQN()</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">reward = []</span><br><span class="line">avg_reward = <span class="number">0</span></span><br><span class="line">all_reward = []</span><br><span class="line"></span><br><span class="line">time_ = []</span><br><span class="line">all_time = []</span><br><span class="line"></span><br><span class="line">collision_his = []</span><br><span class="line">all_collision = []</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    done = <span class="literal">False</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    s = env.reset()</span><br><span class="line">    s = s[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># while True:</span></span><br><span class="line">    <span class="comment">#     done = False</span></span><br><span class="line">    <span class="comment"># start_time = time.time()</span></span><br><span class="line">    <span class="comment"># s = env.reset()</span></span><br><span class="line">    <span class="comment"># s = s[0]</span></span><br><span class="line">    <span class="comment"># while not done:</span></span><br><span class="line">    <span class="comment">#     e = np.exp(-count / 300)  # 随机选择action的概率，随着训练次数增多逐渐降低</span></span><br><span class="line">    <span class="comment"># a = dqn.choose_action(s, e)</span></span><br><span class="line">    <span class="comment"># s_, r, done, truncated, info = env.step(a)</span></span><br><span class="line">    <span class="comment"># env.render()</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> done:</span><br><span class="line">        e = np.exp(-count / <span class="number">300</span>)  <span class="comment"># 随机选择action的概率，随着训练次数增多逐渐降低</span></span><br><span class="line">        a = dqn.choose_action(s, e)</span><br><span class="line">        s_, r, done,truncated, info = env.step(a)</span><br><span class="line">        env.render()</span><br><span class="line">        dqn.push_memory(s, a, r, s_)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((dqn.position != <span class="number">0</span>) &amp; (dqn.position % <span class="number">99</span> == <span class="number">0</span>)):</span><br><span class="line">            loss_ = dqn.learn()</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;epoch:&#x27;</span>, count)</span><br><span class="line">            avg_reward = np.mean(reward)</span><br><span class="line">            avg_time = np.mean(time_)</span><br><span class="line">            collision_rate = np.mean(collision_his)</span><br><span class="line"></span><br><span class="line">            all_reward.append(avg_reward)</span><br><span class="line">            all_time.append(avg_time)</span><br><span class="line">            all_collision.append(collision_rate)</span><br><span class="line"></span><br><span class="line">            writer.add_scalar(<span class="string">&#x27;result/reward&#x27;</span>, np.asarray(avg_reward), count)</span><br><span class="line">            writer.add_scalar(<span class="string">&#x27;result/time&#x27;</span>, np.asarray(avg_time), count)</span><br><span class="line">            writer.add_scalar(<span class="string">&#x27;result/collision&#x27;</span>, np.asarray(collision_rate), count)</span><br><span class="line"></span><br><span class="line">            reward = []</span><br><span class="line">            time_ = []</span><br><span class="line">            collision_his = []</span><br><span class="line"></span><br><span class="line">        s = s_</span><br><span class="line">        reward.append(r)</span><br><span class="line"></span><br><span class="line">    end_time = time.time()</span><br><span class="line">    episode_time = end_time - start_time</span><br><span class="line">    time_.append(episode_time)</span><br><span class="line"></span><br><span class="line">    is_collision = <span class="number">1</span> <span class="keyword">if</span> info[<span class="string">&#x27;crashed&#x27;</span>] == <span class="literal">True</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    collision_his.append(is_collision)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/.com//image-20220719184300915.png" alt="image-20220719184300915"></p>
<p>小车进行了规避的动作，以避免发生碰撞。</p>
<p>在终端运行tensorboard –logdir&#x3D;.&#x2F;log可以查看可视化界面。</p>
<p><img src="/.com//image-20220719214959967.png" alt="image-20220719214959967"></p>
<p><img src="/.com//image-20220719215011582.png" alt="image-20220719215011582"></p>
<p>可以看出平均碰撞发生率会随训练次数增多逐渐降低，每个epoch持续的时间会逐渐延长（如果发生碰撞epoch会立刻结束）</p>
<p>看到原作者的效果对比，可以看出模型更快达到高reward，高time，碰撞率也下降得更快。（原作者中是每40次记录一次，相当于八百次）。</p>
<p><img src="/.com//image-20220719215225768.png" alt="image-20220719215225768"></p>
<p>没有加上模型保存代码。这个模型也不是非常好，大家看着玩就行，调参的时间成本非常高，我没继续调下去了。</p>
<h3 id="4-3-使用CARLA模拟器实现DQN自动驾驶"><a href="#4-3-使用CARLA模拟器实现DQN自动驾驶" class="headerlink" title="4.3  使用CARLA模拟器实现DQN自动驾驶"></a>4.3  使用CARLA模拟器实现DQN自动驾驶</h3><p>由于图像数据的结构复杂，数据量大，考虑到用没有超强算力的电脑运行程序的时候，为了简化模型结构，对数据进行压缩，摄像头传来的图像先设置为80*60。</p>
<p>为了让模型能学到正确的参数，需要对智能体的action和reward进行定义，汽车控制的主要3个参数可以量化成油门力度([0,1])，刹车力度([0,1])，方向盘角度([-1,1])，是否倒档(True&#x2F;False)。但是根据一般的开车习惯，这些变量并不是相互独立的，比如油门和刹车一般不会同时踩下（除了漂移），定义DQN的输出时，为了计算对应action的Q值，先对action量化为几个类别：</p>
<p>1.直行加速：throttle&#x3D;1, brake&#x3D;0, steer&#x3D;0, reverse&#x3D;False<br>2.左转（满舵）：throttle&#x3D;0.5, brake&#x3D;0, steer&#x3D;-1, reverse&#x3D;False<br>3.右转（满舵）：throttle&#x3D;0.5, brake&#x3D;0, steer&#x3D;1, reverse&#x3D;False<br>4.直行减速：throttle&#x3D;0, brake&#x3D;0.5, steer&#x3D;0, reverse&#x3D;False<br>5.直行倒车：throttle&#x3D;1, brake&#x3D;0, steer&#x3D;0, reverse&#x3D;True</p>
<p>之后需要定义汽车行驶的reward，我们可以随机在地图上另选一点，将其坐标作为驾驶的终点，每一帧刷新时，如下定义reward：</p>
<p>1.若发生碰撞，reward&#x3D;-200<br>2.若下一帧和当前帧相比，汽车到终点的距离更近，reward&#x3D;1<br>3.若下一帧和当前帧相比，汽车到终点的距离更远，reward&#x3D;-1</p>
<p>定义好之后我们需要将上述功能封装进step()函数并加入环境class，修改后环境class代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> LambdaType</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sys.path.append(glob.glob(<span class="string">&#x27;../carla/dist/carla-*%d.%d-%s.egg&#x27;</span> % (</span><br><span class="line">        sys.version_info.major,</span><br><span class="line">        sys.version_info.minor,</span><br><span class="line">        <span class="string">&#x27;win-amd64&#x27;</span> <span class="keyword">if</span> os.name == <span class="string">&#x27;nt&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;linux-x86_64&#x27;</span>))[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">except</span> IndexError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> carla</span><br><span class="line"><span class="keyword">import</span> random </span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"> </span><br><span class="line">IM_WIDTH = <span class="number">80</span></span><br><span class="line">IM_HEIGHT = <span class="number">60</span></span><br><span class="line">SHOW_PREVIEW = <span class="literal">False</span></span><br><span class="line"> </span><br><span class="line">SECOND_PER_EPISODE = <span class="number">10</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car_Env</span>():</span><br><span class="line">    SHOW_CAM = SHOW_PREVIEW</span><br><span class="line">    STEER_AMT = <span class="number">1.0</span></span><br><span class="line">    im_width = IM_WIDTH</span><br><span class="line">    im_height = IM_HEIGHT</span><br><span class="line">    front_camera = <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.client = carla.Client(<span class="string">&#x27;localhost&#x27;</span>,<span class="number">2000</span>)</span><br><span class="line">        self.client.set_timeout(<span class="number">10.0</span>)</span><br><span class="line">        self.world = self.client.get_world()</span><br><span class="line">        self.blueprint_library = self.world.get_blueprint_library()</span><br><span class="line">        self.model_3 = self.blueprint_library.<span class="built_in">filter</span>(<span class="string">&#x27;model3&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reset</span>(<span class="params">self</span>):</span><br><span class="line">        self.collision_hist = []</span><br><span class="line">        self.radar_hist = []</span><br><span class="line">        self.actor_list = []</span><br><span class="line">        self.transform = self.world.get_map().get_spawn_points()[<span class="number">100</span>] <span class="comment">#spwan_points共265个点，选第一个点作为初始化小车的位置</span></span><br><span class="line">        self.vehicle = self.world.spawn_actor(self.model_3 , self.transform)</span><br><span class="line"> </span><br><span class="line">        self.actor_list.append(self.vehicle)</span><br><span class="line"> </span><br><span class="line">        self.rgb_cam = self.blueprint_library.find(<span class="string">&#x27;sensor.camera.rgb&#x27;</span>)</span><br><span class="line">        self.rgb_cam.set_attribute(<span class="string">&#x27;image_size_x&#x27;</span>,<span class="string">f&#x27;<span class="subst">&#123;self.im_width&#125;</span>&#x27;</span>)</span><br><span class="line">        self.rgb_cam.set_attribute(<span class="string">&#x27;image_size_y&#x27;</span>,<span class="string">f&#x27;<span class="subst">&#123;self.im_height&#125;</span>&#x27;</span>)</span><br><span class="line">        self.rgb_cam.set_attribute(<span class="string">&#x27;fov&#x27;</span>,<span class="string">f&#x27;110&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">        transform = carla.Transform(carla.Location(x=<span class="number">2.5</span> ,z=<span class="number">0.7</span> ))</span><br><span class="line">        self.sensor = self.world.spawn_actor(self.rgb_cam,transform, attach_to=self.vehicle)</span><br><span class="line">        self.actor_list.append(self.sensor)</span><br><span class="line">        self.sensor.listen(<span class="keyword">lambda</span> data: self.process_img(data))</span><br><span class="line"> </span><br><span class="line">        self.vehicle.apply_control(carla.VehicleControl(throttle=<span class="number">0.0</span>, brake=<span class="number">0.0</span>))</span><br><span class="line">        </span><br><span class="line">        time.sleep(<span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line">       </span><br><span class="line">        <span class="comment">#collision sensor</span></span><br><span class="line">        colsensor = self.blueprint_library.find(<span class="string">&#x27;sensor.other.collision&#x27;</span>)</span><br><span class="line">        self.colsensor = self.world.spawn_actor(colsensor, transform, attach_to = self.vehicle)</span><br><span class="line">        self.actor_list.append(self.colsensor)</span><br><span class="line">        self.colsensor.listen(<span class="keyword">lambda</span> event: self.collision_data(event))</span><br><span class="line">       </span><br><span class="line"> </span><br><span class="line">        <span class="comment">#target_transform 定义驾驶目的地坐标</span></span><br><span class="line">        self.target_transform = self.world.get_map().get_spawn_points()[<span class="number">101</span>]</span><br><span class="line">        self.target_dis = self.target_transform.location.distance(self.vehicle.get_location())</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> self.front_camera <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            time.sleep(<span class="number">0.01</span>)</span><br><span class="line"> </span><br><span class="line">        self.episode_start = time.time()</span><br><span class="line">        self.vehicle.apply_control(carla.VehicleControl(throttle=<span class="number">0.0</span>, brake=<span class="number">0.0</span>))</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> self.front_camera</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">collision_data</span>(<span class="params">self, event</span>):</span><br><span class="line">        self.collision_hist.append(event)</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">radar_data</span>(<span class="params">self, mesure</span>):</span><br><span class="line">        self.radar_hist.append(mesure)</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_img</span>(<span class="params">self, image</span>):</span><br><span class="line">        i = np.array(image.raw_data)</span><br><span class="line">        i2 = i.reshape((self.im_height, self.im_width , <span class="number">4</span>))</span><br><span class="line">        i3 = i2[: , : , : <span class="number">3</span>]</span><br><span class="line">        <span class="keyword">if</span> self.SHOW_CAM:</span><br><span class="line">            cv2.imshow(<span class="string">&quot;&quot;</span>,i3)</span><br><span class="line">            cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">        self.front_camera = i3</span><br><span class="line">        <span class="keyword">return</span> i3/<span class="number">255.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">step</span>(<span class="params">self, action</span>):</span><br><span class="line">        last_dis = self.target_dis  </span><br><span class="line">        <span class="keyword">if</span> action==<span class="number">0</span>:            </span><br><span class="line">            self.vehicle.apply_control(carla.VehicleControl(throttle=<span class="number">1.0</span>, steer=<span class="number">0.0</span>, brake=<span class="number">0.0</span>, hand_brake=<span class="literal">False</span>, reverse=<span class="literal">False</span>))</span><br><span class="line">        <span class="keyword">elif</span> action==<span class="number">1</span>:</span><br><span class="line">            self.vehicle.apply_control(carla.VehicleControl(throttle=<span class="number">0.5</span>, steer=-<span class="number">1</span>, brake=<span class="number">0.0</span>, hand_brake=<span class="literal">False</span>, reverse=<span class="literal">False</span>))</span><br><span class="line">        <span class="keyword">elif</span> action==<span class="number">2</span>:</span><br><span class="line">            self.vehicle.apply_control(carla.VehicleControl(throttle=<span class="number">0.5</span>, steer=<span class="number">1</span>, brake=<span class="number">0.0</span>, hand_brake=<span class="literal">False</span>, reverse=<span class="literal">False</span>))</span><br><span class="line">        <span class="keyword">elif</span> action==<span class="number">4</span>:</span><br><span class="line">            self.vehicle.apply_control(carla.VehicleControl(throttle=<span class="number">0.0</span>, steer=<span class="number">0.0</span>, brake=<span class="number">0.5</span>, hand_brake=<span class="literal">False</span>, reverse=<span class="literal">False</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.vehicle.apply_control(carla.VehicleControl(throttle=<span class="number">1.0</span>, steer=<span class="number">0.0</span>, brake=<span class="number">0.0</span>, hand_brake=<span class="literal">False</span>, reverse=<span class="literal">True</span>))</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        self.target_dis = self.target_transform.location.distance(self.vehicle.get_location())  </span><br><span class="line">                       </span><br><span class="line">        v = self.vehicle.get_velocity()</span><br><span class="line">        kmh = <span class="built_in">int</span>(<span class="number">3.6</span> * math.sqrt(v.x**<span class="number">2</span> + v.y**<span class="number">2</span> + v.z**<span class="number">2</span>))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.collision_hist)!=<span class="number">0</span>:</span><br><span class="line">            done = <span class="literal">True</span></span><br><span class="line">            reward = -<span class="number">200</span></span><br><span class="line">        <span class="keyword">elif</span> last_dis &lt; self.target_dis:  <span class="comment">#距离目标越来越远了</span></span><br><span class="line">            done = <span class="literal">False</span></span><br><span class="line">            reward = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            done = <span class="literal">False</span></span><br><span class="line">            reward = <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> self.episode_start + SECOND_PER_EPISODE &lt; time.time():</span><br><span class="line">            done = <span class="literal">True</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.front_camera, reward, done, <span class="literal">None</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>定义好环境后我们就可以开始定义DQN网络了，选择pytorch框架。在训练之前，还要开辟一个存储空间，用来保存小车每次和环境交互的数据(push_memory()函数)，每次训练都从buffer中随机抽取batch_size的样本(get_sample()函数)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> T</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> FloatTensor, LongTensor, ByteTensor</span><br><span class="line">Tensor = FloatTensor</span><br><span class="line"> </span><br><span class="line">EPSILON = <span class="number">0.9</span>       <span class="comment"># epsilon used for epsilon greedy approach</span></span><br><span class="line">GAMMA = <span class="number">0.9</span></span><br><span class="line">TARGET_NETWORK_REPLACE_FREQ = <span class="number">100</span>       <span class="comment"># How frequently target netowrk updates</span></span><br><span class="line">MEMORY_CAPACITY = <span class="number">200</span></span><br><span class="line">BATCH_SIZE = <span class="number">32</span></span><br><span class="line">LR = <span class="number">0.01</span>           <span class="comment"># learning rate</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">3</span>, <span class="number">16</span>, kernel_size=<span class="number">5</span>, stride=<span class="number">2</span>)</span><br><span class="line">        self.bn1 = nn.BatchNorm2d(<span class="number">16</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">16</span>, <span class="number">32</span>, kernel_size=<span class="number">5</span>, stride=<span class="number">2</span>)</span><br><span class="line">        self.bn2 = nn.BatchNorm2d(<span class="number">32</span>)</span><br><span class="line">        self.conv3 = nn.Conv2d(<span class="number">32</span>, <span class="number">32</span>, kernel_size=<span class="number">5</span>, stride=<span class="number">2</span>)</span><br><span class="line">        self.bn3 = nn.BatchNorm2d(<span class="number">32</span>)</span><br><span class="line">        self.head = nn.Linear(<span class="number">896</span>,<span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = F.relu(self.bn1(self.conv1(x)))  <span class="comment"># 一层卷积</span></span><br><span class="line">        x = F.relu(self.bn2(self.conv2(x)))  <span class="comment"># 两层卷积</span></span><br><span class="line">        x = F.relu(self.bn3(self.conv3(x)))  <span class="comment"># 三层卷积</span></span><br><span class="line">        <span class="keyword">return</span> self.head(x.view(x.size(<span class="number">0</span>),-<span class="number">1</span>)) <span class="comment"># 全连接层 </span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DQN</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.eval_net,self.target_net = Net(),Net()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Define counter, memory size and loss function</span></span><br><span class="line">        self.learn_step_counter = <span class="number">0</span> <span class="comment"># count the steps of learning process        </span></span><br><span class="line"> </span><br><span class="line">        self.memory = []</span><br><span class="line">        self.position = <span class="number">0</span> <span class="comment"># counter used for experience replay buff        </span></span><br><span class="line">        self.capacity = <span class="number">200</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#------- Define the optimizer------#</span></span><br><span class="line">        self.optimizer = torch.optim.Adam(self.eval_net.parameters(), lr=LR)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># ------Define the loss function-----#</span></span><br><span class="line">        self.loss_func = nn.MSELoss()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span>  <span class="title function_">choose_action</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># This function is used to make decision based upon epsilon greedy</span></span><br><span class="line">        </span><br><span class="line">        x = torch.unsqueeze(torch.FloatTensor(x), <span class="number">0</span>) <span class="comment"># add 1 dimension to input state x</span></span><br><span class="line">        x = x.permute(<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)  <span class="comment">#把图片维度从[batch, height, width, channel] 转为[batch, channel, height, width]</span></span><br><span class="line">        <span class="comment"># input only one sample</span></span><br><span class="line">        <span class="keyword">if</span> np.random.uniform() &lt; EPSILON:   <span class="comment"># greedy</span></span><br><span class="line">            <span class="comment"># use epsilon-greedy approach to take action</span></span><br><span class="line">            actions_value = self.eval_net.forward(x)</span><br><span class="line">            <span class="comment">#print(torch.max(actions_value, 1)) </span></span><br><span class="line">            <span class="comment"># torch.max() returns a tensor composed of max value along the axis=dim and corresponding index</span></span><br><span class="line">            <span class="comment"># what we need is the index in this function, representing the action of cart.</span></span><br><span class="line">            action = torch.<span class="built_in">max</span>(actions_value, <span class="number">1</span>)[<span class="number">1</span>].data.numpy()</span><br><span class="line">            action = action[<span class="number">0</span>]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            action = np.random.randint(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push_memory</span>(<span class="params">self, s, a, r, s_</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.memory) &lt; self.capacity:</span><br><span class="line">            self.memory.append(<span class="literal">None</span>)</span><br><span class="line">        self.memory[self.position] = Transition(torch.unsqueeze(torch.FloatTensor(s), <span class="number">0</span>),torch.unsqueeze(torch.FloatTensor(s_), <span class="number">0</span>),\</span><br><span class="line">                                                torch.from_numpy(np.array([a])),torch.from_numpy(np.array([r],dtype=<span class="string">&#x27;int64&#x27;</span>)))</span><br><span class="line">        self.position = (self.position + <span class="number">1</span>) % self.capacity</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_sample</span>(<span class="params">self,batch_size</span>):</span><br><span class="line">        <span class="keyword">return</span> random.sample(self.memory, batch_size)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">learn</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># Define how the whole DQN works including sampling batch of experiences,</span></span><br><span class="line">        <span class="comment"># when and how to update parameters of target network, and how to implement</span></span><br><span class="line">        <span class="comment"># backward propagation.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># update the target network every fixed steps</span></span><br><span class="line">        <span class="keyword">if</span> self.learn_step_counter % TARGET_NETWORK_REPLACE_FREQ == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># Assign the parameters of eval_net to target_net</span></span><br><span class="line">            self.target_net.load_state_dict(self.eval_net.state_dict())</span><br><span class="line">        self.learn_step_counter += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        transitions = self.get_sample(BATCH_SIZE)  <span class="comment"># 抽样</span></span><br><span class="line">        batch = Transition(*<span class="built_in">zip</span>(*transitions))</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># extract vectors or matrices s,a,r,s_ from batch memory and convert these to torch Variables</span></span><br><span class="line">        <span class="comment"># that are convenient to back propagation</span></span><br><span class="line">        b_s = Variable(torch.cat(batch.state))</span><br><span class="line">        <span class="comment"># convert long int type to tensor</span></span><br><span class="line">        b_a = Variable(torch.cat(batch.action))</span><br><span class="line">        b_r = Variable(torch.cat(batch.reward))</span><br><span class="line">        b_s_ = Variable(torch.cat(batch.next_state))</span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line">        <span class="comment">#b_s和b_s_分别对应当前帧和下一帧的图像数据，变量的维度是80*60*3(x*y*rgb_channel)，但进入神经网络需将其维度变为3*80*60</span></span><br><span class="line">        b_s = b_s.permute(<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)  </span><br><span class="line">        b_s_ = b_s_.permute(<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)        </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># calculate the Q value of state-action pair</span></span><br><span class="line">        q_eval = self.eval_net(b_s).gather(<span class="number">1</span>,b_a.unsqueeze(<span class="number">1</span>)) <span class="comment"># (batch_size, 1)</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># calculate the q value of next state</span></span><br><span class="line">        q_next = self.target_net(b_s_).detach() <span class="comment"># detach from computational graph, don&#x27;t back propagate</span></span><br><span class="line">        <span class="comment"># select the maximum q value</span></span><br><span class="line">        <span class="comment"># q_next.max(1) returns the max value along the axis=1 and its corresponding index</span></span><br><span class="line">        q_target = b_r + GAMMA * q_next.<span class="built_in">max</span>(<span class="number">1</span>)[<span class="number">0</span>].view(BATCH_SIZE, <span class="number">1</span>) <span class="comment"># (batch_size, 1)</span></span><br><span class="line">        loss = self.loss_func(q_eval, q_target)</span><br><span class="line">        </span><br><span class="line">        self.optimizer.zero_grad() <span class="comment"># reset the gradient to zero</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        self.optimizer.step() <span class="comment"># execute back propagation for one step</span></span><br><span class="line">        </span><br><span class="line">Transition = namedtuple(<span class="string">&#x27;Transition&#x27;</span>,(<span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;next_state&#x27;</span>,<span class="string">&#x27;action&#x27;</span>, <span class="string">&#x27;reward&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>之后添加主函数，模型便可以开始训练。每次和环境交互时选择action，一定概率是模型的输出结果，一定概率是随机选择，可以通过阈值设定(EPSILON)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    env=Car_Env()</span><br><span class="line">    s=env.reset()</span><br><span class="line">    dqn=DQN()</span><br><span class="line">    count=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2000</span>):</span><br><span class="line">        a=dqn.choose_action(s)</span><br><span class="line">        s_,r,done,info = env.step(a)</span><br><span class="line">        dqn.push_memory(s, a, r, s_)    </span><br><span class="line">        s=s_    </span><br><span class="line">        <span class="keyword">if</span> (dqn.position % (MEMORY_CAPACITY-<span class="number">1</span>) )== <span class="number">0</span>:</span><br><span class="line">            dqn.learn()</span><br><span class="line">            count+=<span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;learned times:&#x27;</span>,count)</span><br></pre></td></tr></table></figure>

<p>运行主函数后，我们就可以看到小车在道路中反复做出各种action以便探索环境。</p>
<p> 但是现在的模型还很基础，神经网络对驾驶的控制也远没达到智能，需要经过成千上万次的训练，或者增加传感器或摄像头数据的丰富度，才有可能训练出达到驾驶要求的DQN网络。愿意做下去的同学上github找好的模型或好的paper复现。千万不要硬跑这个模型，我们的电脑跑起来是没有止境的。</p>
<p>那么这个小教程就到这里了。还有很多不是很完善的地方，以后我会慢慢完善或出视频。感谢看到这里，希望对大家有所帮助。</p>
<p>参考文献：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44169614/article/details/118681651">使用CARLA模拟器实现DQN自动驾驶</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44169614/article/details/121444571">DQN自动驾驶——python+gym实现</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/108286901">【强化学习】Deep Q-Network (DQN) - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="http://carla.org/">carla.org</a></p>
<p><a target="_blank" rel="noopener" href="https://www.carla.org.cn/#/">Carla 中文站</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/365732535">CARLA完全实践-核心概念 - 知乎 (zhihu.com)</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">qianmu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2024/02/04/%E5%9F%BA%E4%BA%8ECALRA%E5%92%8CDQN%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E7%9A%84%E4%BB%BF%E7%9C%9F/">http://example.com/2024/02/04/%E5%9F%BA%E4%BA%8ECALRA%E5%92%8CDQN%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E7%9A%84%E4%BB%BF%E7%9C%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/02/04/%E7%9B%AE%E6%A0%87%E8%BF%9B%E7%A8%8B%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E5%8F%A5%E6%9F%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%86%85%E6%A0%B8%E5%8F%A5%E6%9F%84/" title="目标进程用户模式句柄转换为内核句柄"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">目标进程用户模式句柄转换为内核句柄</div></div></a></div><div class="next-post pull-right"><a href="/2024/02/04/%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%AB%AF%E5%88%B0%E7%AB%AF%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/" title="基于深度学习的端到端自动驾驶"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">基于深度学习的端到端自动驾驶</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">qianmu</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/QianMuOY"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Ecarla%E4%B8%8EDQN%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E7%9A%84%E4%BB%BF%E7%9C%9F"><span class="toc-number">1.</span> <span class="toc-text">基于carla与DQN实现自动驾驶的仿真</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%89%E8%A3%85"><span class="toc-number">1.1.</span> <span class="toc-text">1. 安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 配置虚拟环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E9%85%8D%E7%BD%AEcarla%E6%A8%A1%E6%8B%9F%E5%99%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 配置carla模拟器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83%E5%88%9D%E4%BD%93%E9%AA%8C"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 仿真环境初体验</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-CARLA-Simulator%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.</span> <span class="toc-text">2. CARLA Simulator的核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1  客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">2.1.1客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">2.1.2 客户端的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-%E8%AE%BE%E7%BD%AE%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">2.1.3 设置客户端超时时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4-%E6%A3%80%E6%9F%A5%E7%89%88%E6%9C%AC"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">2.1.4 检查版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-5%E8%99%9A%E6%8B%9F%E4%B8%96%E7%95%8C%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">2.1.5虚拟世界连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-6-%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.1.6.</span> <span class="toc-text">2.1.6 运行命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-7-%E5%85%B6%E4%BB%96%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.2.1.7.</span> <span class="toc-text">2.1.7 其他客户端实用程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%99%9A%E6%8B%9F%E4%B8%96%E7%95%8C"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 虚拟世界</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E8%99%9A%E6%8B%9F%E4%B8%96%E7%95%8C"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">2.2.1 虚拟世界</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E5%85%83%E7%B4%A0"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.2.2 元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E5%A4%A9%E6%B0%94"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">2.2.3 天气</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-%E5%85%89%E7%BA%BF"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">2.2.4 光线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-5-%E8%B0%83%E8%AF%95"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">2.2.5 调试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-6-%E5%BF%AB%E7%85%A7"><span class="toc-number">1.2.2.6.</span> <span class="toc-text">2.2.6 快照</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-7-%E4%B8%96%E7%95%8C%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.2.2.7.</span> <span class="toc-text">2.2.7 世界设置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%93%9D%E5%9B%BE"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 蓝图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E8%93%9D%E5%9B%BE"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">2.3.1 蓝图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2%E7%AE%A1%E7%90%86%E8%93%9D%E5%9B%BE%E5%BA%93"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2.3.2管理蓝图库</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%BC%94%E5%91%98%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 演员的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E7%94%9F%E6%88%90"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">2.4.1 生成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">2.4.2管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3%E9%94%80%E6%AF%81"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">2.4.3销毁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5Actor%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.5Actor类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1-%E4%BC%A0%E6%84%9F%E5%99%A8"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">2.5.1 传感器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2-%E6%97%81%E8%A7%82%E8%80%85"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">2.5.2 旁观者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-3-%E4%BA%A4%E9%80%9A%E6%A0%87%E5%BF%97%E5%92%8C%E4%BA%A4%E9%80%9A%E7%81%AF"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">2.5.3 交通标志和交通灯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-4-%E8%BD%A6%E8%BE%86"><span class="toc-number">1.2.5.4.</span> <span class="toc-text">2.5.4 车辆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-5%E8%A1%8C%E4%BA%BA"><span class="toc-number">1.2.5.5.</span> <span class="toc-text">2.5.5行人</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E5%9C%B0%E5%9B%BE"><span class="toc-number">1.2.6.</span> <span class="toc-text">2.6 地图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-%E6%94%B9%E5%8F%98%E5%9C%B0%E5%9B%BE"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">2.6.1 改变地图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2-%E5%9C%B0%E6%A0%87"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">2.6.2 地标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-3%E8%88%AA%E7%82%B9"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">2.6.3航点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-4-%E8%BD%A6%E9%81%93"><span class="toc-number">1.2.6.4.</span> <span class="toc-text">2.6.4 车道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-5-%E8%B7%AF%E5%8F%A3"><span class="toc-number">1.2.6.5.</span> <span class="toc-text">2.6.5 路口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-6-%E7%8E%AF%E5%A2%83%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.6.6.</span> <span class="toc-text">2.6.6 环境对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-CARLA%E4%B8%AD%E7%9A%84%E5%AF%BC%E8%88%AA"><span class="toc-number">1.2.7.</span> <span class="toc-text">2.7 CARLA中的导航</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-1-%E9%80%9A%E8%BF%87%E8%88%AA%E7%82%B9%E5%AF%BC%E8%88%AA"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">2.7.1 通过航点导航</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-2-%E7%94%9F%E6%88%90%E5%9C%B0%E5%9B%BE%E5%AF%BC%E8%88%AA"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">2.7.2 生成地图导航</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-CARLA%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9B%BE"><span class="toc-number">1.2.8.</span> <span class="toc-text">2.8 CARLA中的地图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-1-%E9%9D%9E%E5%88%86%E5%B1%82%E5%9C%B0%E5%9B%BE"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">2.8.1 非分层地图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-2-%E5%88%86%E5%B1%82%E5%9C%B0%E5%9B%BE"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">2.8.2 分层地图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9C%B0%E5%9B%BE"><span class="toc-number">1.2.8.3.</span> <span class="toc-text">2.8.3 自定义地图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-%E4%BC%A0%E6%84%9F%E5%99%A8%E4%B8%8E%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.9.</span> <span class="toc-text">2.9  传感器与数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-9-1-%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.2.9.1.</span> <span class="toc-text">2.9.1 设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-9-2-%E7%94%9F%E6%88%90"><span class="toc-number">1.2.9.2.</span> <span class="toc-text">2.9.2 生成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-9-3-%E7%9B%91%E5%90%AC"><span class="toc-number">1.2.9.3.</span> <span class="toc-text">2.9.3 监听</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-9-4-%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.9.4.</span> <span class="toc-text">2.9.4 数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.10.</span> <span class="toc-text">2.10 传感器的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-10-1-%E6%91%84%E5%83%8F%E5%A4%B4"><span class="toc-number">1.2.10.1.</span> <span class="toc-text">2.10.1 摄像头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-10-2-%E6%8E%A2%E6%B5%8B%E5%99%A8"><span class="toc-number">1.2.10.2.</span> <span class="toc-text">2.10.2 探测器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-10-3-%E5%85%B6%E5%AE%83"><span class="toc-number">1.2.10.3.</span> <span class="toc-text">2.10.3 其它</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-PythonAPI%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">3. PythonAPI的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E9%85%8D%E7%BD%AE%E9%BB%98%E8%AE%A4%E5%BA%93"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">3.1 配置默认库</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%9F%BA%E4%BA%8EDQN%E7%9A%84%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6"><span class="toc-number">1.4.</span> <span class="toc-text">4. 基于DQN的自动驾驶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-DQN"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 DQN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-DQN%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 DQN自动驾驶</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">4.2.1 配置环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">4.2.2 实验环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">4.2.3 数据处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Grayscale-Image"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">Grayscale Image</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Occupancy-grid"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">Occupancy grid</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-%E6%90%AD%E5%BB%BA%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.2.6.</span> <span class="toc-text">4.2.4 搭建模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-5-%E5%BC%80%E5%A7%8B%E8%AE%AD%E7%BB%83"><span class="toc-number">1.4.2.7.</span> <span class="toc-text">4.2.5 开始训练</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E4%BD%BF%E7%94%A8CARLA%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%AE%9E%E7%8E%B0DQN%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3  使用CARLA模拟器实现DQN自动驾驶</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/04/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8ASLR%E6%9C%BA%E5%88%B6%E4%B8%8BDLL%E6%96%87%E4%BB%B6%E5%9C%A8%E4%B8%8D%E5%90%8C%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%9F%BA%E5%9D%80%E7%9B%B8%E5%90%8C%EF%BC%9F/" title="为什么在ASLR机制下DLL文件在不同进程中的加载基址相同？">为什么在ASLR机制下DLL文件在不同进程中的加载基址相同？</a><time datetime="2024-02-04T13:17:35.000Z" title="Created 2024-02-04 21:17:35">2024-02-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/04/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="线程池">线程池</a><time datetime="2024-02-04T13:08:39.000Z" title="Created 2024-02-04 21:08:39">2024-02-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/04/VT-x/" title="VT-x">VT-x</a><time datetime="2024-02-04T13:02:40.000Z" title="Created 2024-02-04 21:02:40">2024-02-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/04/TLS/" title="TLS">TLS</a><time datetime="2024-02-04T13:01:16.000Z" title="Created 2024-02-04 21:01:16">2024-02-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/04/Hook%E8%AE%A1%E7%AE%97%E5%99%A8%E4%BB%A5%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97/" title="Hook计算器以显示中文数字">Hook计算器以显示中文数字</a><time datetime="2024-02-04T12:55:21.000Z" title="Created 2024-02-04 20:55:21">2024-02-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By qianmu</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async src="https://npm.elemecdn.com/tzy-blog/lib/js/other/sakura.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":225,"height":450},"mobile":{"show":true},"log":false});</script></body></html>