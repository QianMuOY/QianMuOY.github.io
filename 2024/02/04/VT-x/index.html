<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>VT-x | qianmu's blog</title><meta name="author" content="qianmu"><meta name="copyright" content="qianmu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="虚拟化目录（点击跳转）   [TOC]   检查硬件虚拟化12345678BOOLEAN HvmIsHVSupported()&amp;#123;    CPU_VENDOR vendor &#x3D; UtilCPUVendor();&#x2F;&#x2F; CPU供应商    if (vendor &#x3D;&#x3D; CPU_Intel)        return VmxHardSupported();    return TRUE;&amp;#12">
<meta property="og:type" content="article">
<meta property="og:title" content="VT-x">
<meta property="og:url" content="http://example.com/2024/02/04/VT-x/index.html">
<meta property="og:site_name" content="qianmu&#39;s blog">
<meta property="og:description" content="虚拟化目录（点击跳转）   [TOC]   检查硬件虚拟化12345678BOOLEAN HvmIsHVSupported()&amp;#123;    CPU_VENDOR vendor &#x3D; UtilCPUVendor();&#x2F;&#x2F; CPU供应商    if (vendor &#x3D;&#x3D; CPU_Intel)        return VmxHardSupported();    return TRUE;&amp;#12">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-02-04T13:02:40.000Z">
<meta property="article:modified_time" content="2024-02-04T13:02:57.606Z">
<meta property="article:author" content="qianmu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/02/04/VT-x/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'VT-x',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-04 21:02:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="qianmu's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">11</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="qianmu's blog"><span class="site-name">qianmu's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">VT-x</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-02-04T13:02:40.000Z" title="Created 2024-02-04 21:02:40">2024-02-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-02-04T13:02:57.606Z" title="Updated 2024-02-04 21:02:57">2024-02-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Windows-Kernel/">Windows Kernel</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="VT-x"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h1><center>目录（点击跳转）<center>


<p>[TOC]</p>
<div style="page-break-after:always;"></div>

<h1 id="检查硬件虚拟化"><a href="#检查硬件虚拟化" class="headerlink" title="检查硬件虚拟化"></a>检查硬件虚拟化</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOLEAN <span class="title">HvmIsHVSupported</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CPU_VENDOR vendor = <span class="built_in">UtilCPUVendor</span>();<span class="comment">// CPU供应商</span></span><br><span class="line">    <span class="keyword">if</span> (vendor == CPU_Intel)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">VmxHardSupported</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UtilCPUVendor获取CPU制造商信息"><a href="#UtilCPUVendor获取CPU制造商信息" class="headerlink" title="UtilCPUVendor获取CPU制造商信息"></a>UtilCPUVendor获取CPU制造商信息</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Get CPU vendor</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Intel or AMD. If failed - Other&lt;/returns&gt;</span></span><br><span class="line"><span class="function">CPU_VENDOR <span class="title">UtilCPUVendor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CPUID data = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">char</span> vendor[<span class="number">0x20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    __cpuid( (<span class="type">int</span>*)&amp;data, <span class="number">0</span> );<span class="comment">// #include &lt;intrin.h&gt;</span></span><br><span class="line">    *(<span class="type">int</span>*)(vendor) = data.ebx;</span><br><span class="line">    *(<span class="type">int</span>*)(vendor + <span class="number">4</span>) = data.edx;</span><br><span class="line">    *(<span class="type">int</span>*)(vendor + <span class="number">8</span>) = data.ecx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>( vendor, <span class="string">&quot;GenuineIntel&quot;</span>, <span class="number">12</span> ) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> CPU_Intel;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>( vendor, <span class="string">&quot;AuthenticAMD&quot;</span>, <span class="number">12</span> ) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> CPU_AMD;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CPU_Other;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="VmxHardSupported检查硬件虚拟化是否支持"><a href="#VmxHardSupported检查硬件虚拟化是否支持" class="headerlink" title="VmxHardSupported检查硬件虚拟化是否支持"></a>VmxHardSupported检查硬件虚拟化是否支持</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Check if VT-x is supported</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;TRUE if supported&lt;/returns&gt;</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">VmxHardSupported</span><span class="params">()</span><span class="comment">// 检查VT-x是否支持</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CPUID data = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// VMX bit</span></span><br><span class="line">    __cpuid( (<span class="type">int</span>*)&amp;data, <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">if</span> ((data.ecx &amp; (<span class="number">1</span> &lt;&lt; <span class="number">5</span>)) == <span class="number">0</span>)<span class="comment">// 检查ecx寄存器的第5位是否为1</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;<span class="comment">// 如果是0，说明不支持VT-x</span></span><br><span class="line"></span><br><span class="line">    IA32_FEATURE_CONTROL_MSR Control = &#123; <span class="number">0</span> &#125;;<span class="comment">// 读取IA32_FEATURE_CONTROL_MSR寄存器</span></span><br><span class="line">    Control.All = __readmsr( MSR_IA32_FEATURE_CONTROL );<span class="comment">// IA32_FEATURE_CONTROL_MSR寄存器的地址为0x3A</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// BIOS lock check</span></span><br><span class="line">    <span class="keyword">if</span> (Control.Fields.Lock == <span class="number">0</span>)<span class="comment">// 检查是否锁定</span></span><br><span class="line">    &#123;</span><br><span class="line">        Control.Fields.Lock = TRUE;<span class="comment">// 将锁定位置1</span></span><br><span class="line">        Control.Fields.EnableVmxon = TRUE;<span class="comment">// 将VMXON使能位置1</span></span><br><span class="line">        __writemsr( MSR_IA32_FEATURE_CONTROL, Control.All );<span class="comment">// 写入IA32_FEATURE_CONTROL_MSR寄存器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Control.Fields.EnableVmxon == FALSE)<span class="comment">// 检查VMXON是否使能</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: VMX locked off in BIOS\n&quot;</span>, CPU_IDX, __FUNCTION__ );<span class="comment">// 如果没有使能，打印错误信息</span></span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UtilSSDTEntry获取系统服务描述表特定索引处函数地址"><a href="#UtilSSDTEntry获取系统服务描述表特定索引处函数地址" class="headerlink" title="UtilSSDTEntry获取系统服务描述表特定索引处函数地址"></a>UtilSSDTEntry获取系统服务描述表特定索引处函数地址</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Gets the SSDT entry address by index.</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;index&quot;&gt;Service index&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Found service address, NULL if not found&lt;/returns&gt;</span></span><br><span class="line"><span class="function">PVOID <span class="title">UtilSSDTEntry</span><span class="params">( IN ULONG index )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG size = <span class="number">0</span>;</span><br><span class="line">    PSYSTEM_SERVICE_DESCRIPTOR_TABLE pSSDT = <span class="built_in">UtilSSDTBase</span>();<span class="comment">// 获取SSDT表的基址</span></span><br><span class="line">    PVOID pBase = <span class="built_in">UtilKernelBase</span>( &amp;size );<span class="comment">// 获取内核基址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pSSDT &amp;&amp; pBase)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 对索引进行范围检查</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; pSSDT-&gt;NumberOfServices)<span class="comment">// 如果索引大于服务数量</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (PUCHAR)pSSDT-&gt;ServiceTableBase + (((PLONG)pSSDT-&gt;ServiceTableBase)[index] &gt;&gt; <span class="number">4</span>);<span class="comment">// 返回服务地址，服务表基址+函数地址/16，因为函数地址按照16字节对齐</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="获取SSDT表函数地址"><a href="#获取SSDT表函数地址" class="headerlink" title="获取SSDT表函数地址"></a>获取SSDT表函数地址</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Gets the SSDT entry address by index.</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;index&quot;&gt;Service index&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Found service address, NULL if not found&lt;/returns&gt;</span></span><br><span class="line"><span class="function">PVOID <span class="title">UtilSSDTEntry</span><span class="params">( IN ULONG index )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG size = <span class="number">0</span>;</span><br><span class="line">    PSYSTEM_SERVICE_DESCRIPTOR_TABLE pSSDT = <span class="built_in">UtilSSDTBase</span>();<span class="comment">// 获取SSDT表的基址</span></span><br><span class="line">    PVOID pBase = <span class="built_in">UtilKernelBase</span>( &amp;size );<span class="comment">// 获取内核基址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pSSDT &amp;&amp; pBase)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 对索引进行范围检查</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; pSSDT-&gt;NumberOfServices)<span class="comment">// 如果索引大于服务数量</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (PUCHAR)pSSDT-&gt;ServiceTableBase + (((PLONG)pSSDT-&gt;ServiceTableBase)[index] &gt;&gt; <span class="number">4</span>);<span class="comment">// 返回服务地址，服务表基址+函数地址/16，因为函数地址按照16字节对齐</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="获取SSDT表基地址"><a href="#获取SSDT表基地址" class="headerlink" title="获取SSDT表基地址"></a>获取SSDT表基地址</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Gets SSDT base - KiServiceTable</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;SSDT base, NULL if not found&lt;/returns&gt;</span></span><br><span class="line"><span class="function">PSYSTEM_SERVICE_DESCRIPTOR_TABLE <span class="title">UtilSSDTBase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    NTOS内核是Windows操作系统的核心部分，</span></span><br><span class="line"><span class="comment">    负责管理操作系统的基本功能，</span></span><br><span class="line"><span class="comment">    如进程管理、内存管理、设备管理、文件系统等。</span></span><br><span class="line"><span class="comment">    在NT内核中，大部分的系统服务都是通过系统调用来实现的，</span></span><br><span class="line"><span class="comment">    而系统服务描述符表(SSDT)则是记录这些系统服务函数的重要数据结构之一。</span></span><br><span class="line"><span class="comment">    如果要在Windows操作系统内核中进行一些工作</span></span><br><span class="line"><span class="comment">    ，必须首先得到NTOS内核的基地址。</span></span><br><span class="line"><span class="comment">    因为所有的系统组件和模块都是基于内核加载的，</span></span><br><span class="line"><span class="comment">    只有获得NTOS内核的基地址，才能找到内核中具体的系统函数、数据结构，以便进行修改和操作。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    PUCHAR ntosBase = <span class="built_in">UtilKernelBase</span>( <span class="literal">NULL</span> );<span class="comment">// 获取NTOS内核的基址</span></span><br><span class="line">    <span class="comment">// Already found</span></span><br><span class="line">    <span class="keyword">if</span> (g_SSDT != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> g_SSDT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ntosBase)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    PIMAGE_NT_HEADERS pHdr = <span class="built_in">RtlImageNtHeader</span>( ntosBase );<span class="comment">// 获取NTOS内核的PE头</span></span><br><span class="line">    PIMAGE_SECTION_HEADER pFirstSec = (PIMAGE_SECTION_HEADER)(pHdr + <span class="number">1</span>);<span class="comment">// 获取NTOS内核的第一个节表</span></span><br><span class="line">    <span class="keyword">for</span> (PIMAGE_SECTION_HEADER pSec = pFirstSec; pSec &lt; pFirstSec + pHdr-&gt;FileHeader.NumberOfSections; pSec++)</span><br><span class="line">    &#123;   <span class="comment">// 遍历NTOS内核的所有节表</span></span><br><span class="line">        <span class="comment">// Non-paged, non-discardable, readable sections</span></span><br><span class="line">        <span class="comment">// Probably still not fool-proof enough...</span></span><br><span class="line">        <span class="keyword">if</span> (pSec-&gt;Characteristics &amp; IMAGE_SCN_MEM_NOT_PAGED &amp;&amp;</span><br><span class="line">            pSec-&gt;Characteristics &amp; IMAGE_SCN_MEM_EXECUTE &amp;&amp;</span><br><span class="line">            !(pSec-&gt;Characteristics &amp; IMAGE_SCN_MEM_DISCARDABLE) &amp;&amp;</span><br><span class="line">            (*(PULONG)pSec-&gt;Name != <span class="string">&#x27;TINI&#x27;</span>) &amp;&amp;</span><br><span class="line">            (*(PULONG)pSec-&gt;Name != <span class="string">&#x27;EGAP&#x27;</span>))</span><br><span class="line">        &#123;<span class="comment">// 判断是否为非分页、可执行和非可丢弃的、名称不为INIT和PAGE的代码节表</span></span><br><span class="line">            PVOID pFound = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// KiSystemServiceRepeat pattern 模式序列</span></span><br><span class="line">            UCHAR pattern[] = <span class="string">&quot;\x4c\x8d\x15\xcc\xcc\xcc\xcc\x4c\x8d\x1d\xcc\xcc\xcc\xcc\xf7&quot;</span>;</span><br><span class="line">            <span class="comment">// 模式匹配</span></span><br><span class="line">            NTSTATUS status = <span class="built_in">UtilSearchPattern</span>( pattern, <span class="number">0xCC</span>, <span class="built_in">sizeof</span>( pattern ) - <span class="number">1</span>, ntosBase + pSec-&gt;VirtualAddress, pSec-&gt;Misc.VirtualSize, &amp;pFound );</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>( status ))</span><br><span class="line">            &#123;   <span class="comment">// 找到SSDT表</span></span><br><span class="line">                g_SSDT = (PSYSTEM_SERVICE_DESCRIPTOR_TABLE)((PUCHAR)pFound + *(PULONG)((PUCHAR)pFound + <span class="number">3</span>) + <span class="number">7</span>);</span><br><span class="line">                <span class="comment">//DPRINT( &quot;BlackBone: %s: KeSystemServiceDescriptorTable = 0x%p\n&quot;, CPU_NUM, __FUNCTION__, g_SSDT );</span></span><br><span class="line">                <span class="keyword">return</span> g_SSDT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取NTOS内核基地址"><a href="#获取NTOS内核基地址" class="headerlink" title="获取NTOS内核基地址"></a>获取NTOS内核基地址</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Get ntoskrnl base address</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pSize&quot;&gt;Size of module&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Found address, NULL if not found&lt;/returns&gt;</span></span><br><span class="line"><span class="function">PVOID <span class="title">UtilKernelBase</span><span class="params">( OUT PULONG pSize )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    ULONG bytes = <span class="number">0</span>;</span><br><span class="line">    PRTL_PROCESS_MODULES pMods = <span class="literal">NULL</span>;</span><br><span class="line">    PVOID checkPtr = <span class="literal">NULL</span>;</span><br><span class="line">    UNICODE_STRING routineName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Already found</span></span><br><span class="line">    <span class="keyword">if</span> (g_KernelBase != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pSize)</span><br><span class="line">            *pSize = g_KernelSize;</span><br><span class="line">        <span class="keyword">return</span> g_KernelBase;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>( &amp;routineName, <span class="string">L&quot;NtOpenFile&quot;</span> );<span class="comment">// 初始化查找名称</span></span><br><span class="line"></span><br><span class="line">    checkPtr = <span class="built_in">MmGetSystemRoutineAddress</span>( &amp;routineName );<span class="comment">// 获取系统函数地址</span></span><br><span class="line">    <span class="keyword">if</span> (checkPtr == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Protect from UserMode AV</span></span><br><span class="line">    <span class="comment">// 保护来自用户模式的AV（防止访问冲突）</span></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 查询系统模块信息的缓冲区大小</span></span><br><span class="line">        status = <span class="built_in">ZwQuerySystemInformation</span>( SystemModuleInformation, <span class="number">0</span>, bytes, &amp;bytes );</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DPRINT</span>( <span class="string">&quot;BlackBone: %s: Invalid SystemModuleInformation size\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分配缓冲区</span></span><br><span class="line">        pMods = (PRTL_PROCESS_MODULES)<span class="built_in">ExAllocatePoolWithTag</span>( NonPagedPoolNx, bytes, HB_POOL_TAG );</span><br><span class="line">        <span class="comment">// 清空缓冲区</span></span><br><span class="line">        <span class="built_in">RtlZeroMemory</span>( pMods, bytes );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取系统模块信息</span></span><br><span class="line">        status = <span class="built_in">ZwQuerySystemInformation</span>( SystemModuleInformation, pMods, bytes, &amp;bytes );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>( status ))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 模块的信息 </span></span><br><span class="line">            PRTL_PROCESS_MODULE_INFORMATION pMod = pMods-&gt;Modules;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; pMods-&gt;NumberOfModules; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// System routine is inside module</span></span><br><span class="line">                <span class="keyword">if</span> (checkPtr &gt;= pMod[i].ImageBase &amp;&amp;</span><br><span class="line">                    checkPtr &lt; (PVOID)((PUCHAR)pMod[i].ImageBase + pMod[i].ImageSize))</span><br><span class="line">                &#123;</span><br><span class="line">                    g_KernelBase = pMod[i].ImageBase;<span class="comment">// 找到的内核基址</span></span><br><span class="line">                    g_KernelSize = pMod[i].ImageSize;<span class="comment">// 找到的内核大小</span></span><br><span class="line">                    <span class="keyword">if</span> (pSize)</span><br><span class="line">                        *pSize = g_KernelSize;<span class="comment">// 从参数返回内核大小</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;BlackBone: %s: Exception\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pMods)</span><br><span class="line">        <span class="built_in">ExFreePoolWithTag</span>( pMods, HB_POOL_TAG );<span class="comment">// 释放缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> g_KernelBase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对给定区域进行模式匹配"><a href="#对给定区域进行模式匹配" class="headerlink" title="对给定区域进行模式匹配"></a>对给定区域进行模式匹配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Search for pattern</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pattern&quot;&gt;Pattern to search for&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;wildcard&quot;&gt;Used wildcard&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;len&quot;&gt;Pattern length&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;base&quot;&gt;Base address for searching&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;size&quot;&gt;Address range to search in&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;ppFound&quot;&gt;Found location&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="comment">/// 遍历给定内存区域，与指定模式进行字节比较，进行模式匹配</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">UtilSearchPattern</span><span class="params">( IN PCUCHAR pattern, IN UCHAR wildcard, IN ULONG_PTR len, IN <span class="type">const</span> VOID* base, IN ULONG_PTR size, OUT PVOID* ppFound )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">NT_ASSERT</span>( ppFound != <span class="literal">NULL</span> &amp;&amp; pattern != <span class="literal">NULL</span> &amp;&amp; base != <span class="literal">NULL</span> );<span class="comment">// 断言</span></span><br><span class="line">    <span class="keyword">if</span> (ppFound == <span class="literal">NULL</span> || pattern == <span class="literal">NULL</span> || base == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (ULONG_PTR i = <span class="number">0</span>; i &lt; size - len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            BOOLEAN found = TRUE;</span><br><span class="line">            <span class="keyword">for</span> (ULONG_PTR j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (pattern[j] != wildcard &amp;&amp; pattern[j] != ((PCUCHAR)base)[i + j])</span><br><span class="line">                &#123;</span><br><span class="line">                    found = FALSE;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (found != FALSE)</span><br><span class="line">            &#123;</span><br><span class="line">                *ppFound = (PUCHAR)base + i;</span><br><span class="line">                <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNHANDLED_EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="初始化全局变量"><a href="#初始化全局变量" class="headerlink" title="初始化全局变量"></a>初始化全局变量</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Allocate global data</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Allocated data or NULL&lt;/returns&gt;</span></span><br><span class="line"><span class="function">PGLOBAL_DATA <span class="title">AllocGlobalData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    VCPU代表虚拟中央处理单元（Virtual Central Processing Unit），也称为逻辑处理器。</span></span><br><span class="line"><span class="comment">    它是在虚拟化环境中为虚拟机创建的一种模拟的CPU。</span></span><br><span class="line"><span class="comment">    每个虚拟机可以有一个或多个VCPU，它们负责执行虚拟机中的指令和处理计算任务。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    EPT代表扩展页面表（Extended Page Table）。</span></span><br><span class="line"><span class="comment">    EPT是Intel处理器中的一种硬件技术，</span></span><br><span class="line"><span class="comment">    用于虚拟地址到物理地址的转换。在虚拟化环境中，EPT用于管理虚拟机中的内存访问，</span></span><br><span class="line"><span class="comment">    实现虚拟机之间和虚拟机与宿主操作系统之间的地址隔离和保护。</span></span><br><span class="line"><span class="comment">    EPT表存储了虚拟地址与物理地址之间的映射关系。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Page表示内存页，是计算机系统中内存管理的最小单位。在常见的架构中，一个页面的大小通常为4KB。</span></span><br><span class="line"><span class="comment">    内存页被用于分配和管理内存，用于存储程序指令和数据。</span></span><br><span class="line"><span class="comment">    在这段代码中，Page指的是用于存储EPT表的一块连续的内存页。</span></span><br><span class="line"><span class="comment">    通过预分配这些页面并将页面地址存储在VCPU的EPT.Pages数组中，来管理EPT表的相关信息。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    PHYSICAL_ADDRESS low = &#123; <span class="number">0</span> &#125;, high = &#123; <span class="number">0</span> &#125;;<span class="comment">// 物理地址</span></span><br><span class="line">    high.QuadPart = MAXULONG64;<span class="comment">// 最大的64位ULONG</span></span><br><span class="line"></span><br><span class="line">    ULONG cpu_count = <span class="built_in">KeQueryActiveProcessorCountEx</span>( ALL_PROCESSOR_GROUPS );<span class="comment">// 当前CPU数量</span></span><br><span class="line">    ULONG_PTR size = <span class="built_in">FIELD_OFFSET</span>( GLOBAL_DATA, cpu_data ) + cpu_count * <span class="built_in">sizeof</span>( VCPU );<span class="comment">// 计算全局数据结构大小</span></span><br><span class="line">    <span class="comment">// 在非分页池中分配内存，大小为size</span></span><br><span class="line">    PGLOBAL_DATA pData = (PGLOBAL_DATA)<span class="built_in">ExAllocatePoolWithTag</span>( NonPagedPoolNx, size, HB_POOL_TAG );</span><br><span class="line">    <span class="keyword">if</span> (pData == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>( pData, size );<span class="comment">// 将分配的内存清零</span></span><br><span class="line">    <span class="comment">// 在非分页池中分配内存，大小为一页，存储MSR寄存器位图</span></span><br><span class="line">    pData-&gt;MSRBitmap = <span class="built_in">ExAllocatePoolWithTag</span>( NonPagedPoolNx, PAGE_SIZE, HB_POOL_TAG );</span><br><span class="line">    <span class="keyword">if</span> (pData-&gt;MSRBitmap == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 分配失败，释放空间</span></span><br><span class="line">        <span class="built_in">ExFreePoolWithTag</span>( pData, HB_POOL_TAG );</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>( pData-&gt;MSRBitmap, PAGE_SIZE );</span><br><span class="line">    <span class="comment">// 获取CPU制造商信息</span></span><br><span class="line">    pData-&gt;CPUVendor = <span class="built_in">UtilCPUVendor</span>();</span><br><span class="line">    <span class="comment">// 遍历cpu_data数组，对VCPU进行初始化</span></span><br><span class="line">    <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; cpu_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        PVCPU Vcpu = &amp;pData-&gt;cpu_data[i];</span><br><span class="line">        <span class="comment">// 初始化VCPU中的页链表</span></span><br><span class="line">        <span class="built_in">InitializeListHead</span>( &amp;Vcpu-&gt;EPT.PageList );</span><br><span class="line">        <span class="comment">// 循环预分配EPT页面</span></span><br><span class="line">        <span class="keyword">for</span> (ULONG j = <span class="number">0</span>; j &lt; EPT_PREALLOC_PAGES; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 分配一个连续页面</span></span><br><span class="line">            Vcpu-&gt;EPT.Pages[j] = <span class="built_in">MmAllocateContiguousMemorySpecifyCache</span>( PAGE_SIZE, low, high, low, MmNonCached );</span><br><span class="line">            <span class="keyword">if</span> (Vcpu-&gt;EPT.Pages[j] != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 设置页面为可读写</span></span><br><span class="line">                <span class="built_in">UtilProtectNonpagedMemory</span>( Vcpu-&gt;EPT.Pages[j], PAGE_SIZE, PAGE_READWRITE );</span><br><span class="line">                <span class="built_in">RtlZeroMemory</span>( Vcpu-&gt;EPT.Pages[j], PAGE_SIZE );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="获取物理内存信息"><a href="#获取物理内存信息" class="headerlink" title="获取物理内存信息"></a>获取物理内存信息</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Gather info about used physical pages</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">UtilQueryPhysicalMemory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_Data-&gt;Memory != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取物理内存范围信息</span></span><br><span class="line">    PPHYSICAL_MEMORY_RANGE pBaseRange = <span class="built_in">MmGetPhysicalMemoryRanges</span>();</span><br><span class="line">    <span class="keyword">if</span> (pBaseRange == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表，计算物理内存页面数目pageCount和区域数量runsCount</span></span><br><span class="line">    ULONG runsCount = <span class="number">0</span>, pageCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (PPHYSICAL_MEMORY_RANGE pRange = pBaseRange; pRange-&gt;NumberOfBytes.QuadPart != <span class="number">0</span>; pRange++)</span><br><span class="line">    &#123;</span><br><span class="line">        pageCount += (ULONG)<span class="built_in">PFN</span>( pRange-&gt;NumberOfBytes.QuadPart );</span><br><span class="line">        runsCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    APIC（Advanced Programmable Interrupt Controller）是一种高级可编程中断控制器，用于处理中断和异常。</span></span><br><span class="line"><span class="comment">    它是一种在计算机体系结构中实现中断控制的硬件设备。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    在多核处理器系统中，每个核心都有自己的本地 APIC。本地 APIC 负责接收和处理与该核心相关的中断，并将其分发给适当的处理器。</span></span><br><span class="line"><span class="comment">    此外，还有一个 I/O APIC，负责管理外部设备的中断信号以及将它们分发给适当的处理器。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    APIC 提供了一种灵活和可扩展的方式来管理和处理中断，使得系统能够高效地响应各种设备和事件引起的中断请求。</span></span><br><span class="line"><span class="comment">    它支持优先级、屏蔽、中断分发和处理、中断共享等功能，能够提高系统的可靠性和性能。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    APIC 物理页是指用于存储 APIC 相关数据结构的物理内存页。在x86 架构的计算机系统中，</span></span><br><span class="line"><span class="comment">    APIC 物理页通常位于物理内存的固定地址上，</span></span><br><span class="line"><span class="comment">    并用于存储本地 APIC、I/O APIC 和其他与 APIC 相关的寄存器和数据结构。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取APIC物理页信息</span></span><br><span class="line">    IA32_APIC_BASE apic = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    apic.All = __readmsr( MSR_APIC_BASE );<span class="comment">// IA32_APIC_BASE寄存器的值</span></span><br><span class="line">    runsCount += <span class="number">2</span>;<span class="comment">// 添加到 runsCount 中</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算Memory需要的大小，并为全局变量分配内存</span></span><br><span class="line">    ULONG size =  <span class="built_in">sizeof</span>( PPHYSICAL_MEMORY_DESCRIPTOR ) + runsCount * <span class="built_in">sizeof</span>( PHYSICAL_MEMORY_RUN );</span><br><span class="line">    g_Data-&gt;Memory = <span class="built_in">ExAllocatePoolWithTag</span>( NonPagedPoolNx, size, HB_POOL_TAG );</span><br><span class="line">    <span class="keyword">if</span> (g_Data-&gt;Memory != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">RtlZeroMemory</span>( g_Data-&gt;Memory, size );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将物理内存范围信息复制到全局变量中，设置每个范围的起始页和页面数目</span></span><br><span class="line">        g_Data-&gt;Memory-&gt;NumberOfPages = pageCount;</span><br><span class="line">        g_Data-&gt;Memory-&gt;NumberOfRuns  = runsCount;</span><br><span class="line"></span><br><span class="line">        runsCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (PPHYSICAL_MEMORY_RANGE pRange = pBaseRange; pRange-&gt;BaseAddress.QuadPart != <span class="number">0</span>; pRange++, runsCount++)</span><br><span class="line">        &#123;</span><br><span class="line">            g_Data-&gt;Memory-&gt;Run[runsCount].BasePage  = <span class="built_in">PFN</span>( pRange-&gt;BaseAddress.QuadPart );</span><br><span class="line">            g_Data-&gt;Memory-&gt;Run[runsCount].PageCount = <span class="built_in">PFN</span>( pRange-&gt;NumberOfBytes.QuadPart );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加用于存储APIC的单个页</span></span><br><span class="line">        g_Data-&gt;Memory-&gt;Run[runsCount].BasePage  = apic.Fields.Apic_base;</span><br><span class="line">        g_Data-&gt;Memory-&gt;Run[runsCount].PageCount = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 添加从0xF0000000共计0x10000页面的保留页</span></span><br><span class="line">        g_Data-&gt;Memory-&gt;Run[runsCount + <span class="number">1</span>].BasePage = <span class="built_in">PFN</span>( <span class="number">0xF0000000</span> );</span><br><span class="line">        g_Data-&gt;Memory-&gt;Run[runsCount + <span class="number">1</span>].PageCount = <span class="number">0x10000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ExFreePool</span>( pBaseRange );</span><br><span class="line">        <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">ExFreePool</span>( pBaseRange );</span><br><span class="line">    <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="释放全局变量"><a href="#释放全局变量" class="headerlink" title="释放全局变量"></a>释放全局变量</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Free global data</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pData&quot;&gt;Data pointer&lt;/param&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">FreeGlobalData</span><span class="params">( IN PGLOBAL_DATA pData )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pData == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前系统中活动处理器的数量</span></span><br><span class="line">    ULONG cpu_count = <span class="built_in">KeQueryActiveProcessorCountEx</span>( ALL_PROCESSOR_GROUPS );</span><br><span class="line">    <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; cpu_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//访问Vcpu数组成员，释放VMXON、VMCS、VMMStack和EPT.Pages数据结构内存</span></span><br><span class="line">        PVCPU Vcpu = &amp;pData-&gt;cpu_data[i];</span><br><span class="line">        <span class="keyword">if</span> (Vcpu-&gt;VMXON)</span><br><span class="line">            <span class="built_in">MmFreeContiguousMemory</span>( Vcpu-&gt;VMXON );</span><br><span class="line">        <span class="keyword">if</span> (Vcpu-&gt;VMCS)</span><br><span class="line">            <span class="built_in">MmFreeContiguousMemory</span>( Vcpu-&gt;VMCS );</span><br><span class="line">        <span class="keyword">if</span> (Vcpu-&gt;VMMStack)</span><br><span class="line">            <span class="built_in">MmFreeContiguousMemory</span>( Vcpu-&gt;VMMStack );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ULONG j = <span class="number">0</span>; j &lt; EPT_PREALLOC_PAGES; j++)</span><br><span class="line">            <span class="keyword">if</span> (Vcpu-&gt;EPT.Pages[j] != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">MmFreeContiguousMemory</span>( Vcpu-&gt;EPT.Pages[j] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放物理内存和MSR位图内存</span></span><br><span class="line">    <span class="keyword">if</span> (pData-&gt;Memory)</span><br><span class="line">        <span class="built_in">ExFreePoolWithTag</span>( pData-&gt;Memory, HB_POOL_TAG );</span><br><span class="line">    <span class="keyword">if</span> (pData-&gt;MSRBitmap)</span><br><span class="line">        <span class="built_in">ExFreePoolWithTag</span>( pData-&gt;MSRBitmap, HB_POOL_TAG );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存池内存</span></span><br><span class="line">    <span class="built_in">ExFreePoolWithTag</span>( pData, HB_POOL_TAG );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="检查CPU虚拟化特性"><a href="#检查CPU虚拟化特性" class="headerlink" title="检查CPU虚拟化特性"></a>检查CPU虚拟化特性</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// CPU virtualization features</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">HvmCheckFeatures</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CPU_VENDOR vendor = <span class="built_in">UtilCPUVendor</span>();</span><br><span class="line">    <span class="keyword">if</span> (vendor == CPU_Intel)</span><br><span class="line">        <span class="built_in">VmxCheckFeatures</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="检查并记录相应的CPU虚拟化特性"><a href="#检查并记录相应的CPU虚拟化特性" class="headerlink" title="检查并记录相应的CPU虚拟化特性"></a>检查并记录相应的CPU虚拟化特性</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Check various VMX features: EPT, VPID, VMFUNC, etc.</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">VmxCheckFeatures</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IA32_VMX_BASIC_MSR basic = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    IA32_VMX_PROCBASED_CTLS_MSR ctl = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    IA32_VMX_PROCBASED_CTLS2_MSR ctl2 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    IA32_VMX_EPT_VPID_CAP_MSR vpidcap = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// True MSRs</span></span><br><span class="line">    basic.All = __readmsr( MSR_IA32_VMX_BASIC );<span class="comment">// 读取MSR_IA32_VMX_BASIC寄存器</span></span><br><span class="line">    g_Data-&gt;Features.TrueMSRs = basic.Fields.VmxCapabilityHint;<span class="comment">// 检查硬件直接提供的真实MSR</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Secondary control</span></span><br><span class="line">    ctl.All = __readmsr( MSR_IA32_VMX_PROCBASED_CTLS );</span><br><span class="line">    g_Data-&gt;Features.SecondaryControls = ctl.Fields.ActivateSecondaryControl;<span class="comment">// 检查是否支持次级控制</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Secondary control（次级控制）是指在虚拟化环境中，</span></span><br><span class="line"><span class="comment">    用于控制虚拟机对处理器部分功能的访问和使用的一组寄存器或设置。</span></span><br><span class="line"><span class="comment">    在虚拟化技术中，虚拟机监视器（VMM）负责管理和控制虚拟机，包括对处理器的访问和配置。</span></span><br><span class="line"><span class="comment">    为了实现安全的虚拟化环境，处理器提供了一些特殊的次级控制寄存器或标志位，</span></span><br><span class="line"><span class="comment">    用于限制虚拟机的某些操作或行为，以防止虚拟机绕过VMM直接访问处理器的敏感功能或破坏虚拟化隔离。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctl.Fields.ActivateSecondaryControl)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//检查 EPT, VPID, VMFUNC</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        EPT（Extended Page Tables）：EPT是Intel VT-x虚拟化技术中的一项功能，</span></span><br><span class="line"><span class="comment">        它允许在虚拟机监控程序（VMM）和虚拟机（VM）之间进行内存管理。</span></span><br><span class="line"><span class="comment">        EPT使用了额外的页表层级，将虚拟地址转换为物理地址，并提供了更高效的内存虚拟化支持。</span></span><br><span class="line"><span class="comment">        EPT可以提高虚拟机的性能和隔离性。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        VPID（Virtual Processor Identifier）：VPID是Intel VT-x虚拟化技术中的一个特性，</span></span><br><span class="line"><span class="comment">        用于改进虚拟机切换时的TLB（Translation Lookaside Buffer）缓存效率。</span></span><br><span class="line"><span class="comment">        每个虚拟机都被分配一个唯一的VPID，当虚拟机切换时，可以保留TLB中与新虚拟机关联的页表条目，</span></span><br><span class="line"><span class="comment">        加速虚拟机的上下文切换。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        VMFUNC（VM Functions）：VMFUNC是Intel VT-x虚拟化技术中的一项功能，</span></span><br><span class="line"><span class="comment">        它允许虚拟机中的代码调用一些特殊的处理器功能。</span></span><br><span class="line"><span class="comment">        通过VMFUNC，虚拟机可以执行一些特权指令，包括对虚拟化扩展的访问控制、访问虚拟机控制结构等。</span></span><br><span class="line"><span class="comment">        VMFUNC使得虚拟化软件可以更加灵活地扩展和控制虚拟机的功能。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        ctl2.All = __readmsr( MSR_IA32_VMX_PROCBASED_CTLS2 );</span><br><span class="line">        g_Data-&gt;Features.EPT  = ctl2.Fields.EnableEPT;</span><br><span class="line">        g_Data-&gt;Features.VPID = ctl2.Fields.EnableVPID;</span><br><span class="line">        g_Data-&gt;Features.VMFUNC = ctl2.Fields.EnableVMFunctions;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ctl2.Fields.EnableEPT != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Execute only</span></span><br><span class="line">            vpidcap.All = __readmsr( MSR_IA32_VMX_EPT_VPID_CAP );</span><br><span class="line">            g_Data-&gt;Features.ExecOnlyEPT = vpidcap.Fields.ExecuteOnly;</span><br><span class="line">            g_Data-&gt;Features.InvSingleAddress = vpidcap.Fields.IndividualAddressInvVpid;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (vpidcap.Fields.ExecuteOnly == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: No execute-only EPT translation support\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: No EPT/VPID support\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: No secondary contol support\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="HVM与VMX"><a href="#HVM与VMX" class="headerlink" title="HVM与VMX"></a>HVM与VMX</h1><p>VMX代表虚拟机扩展（Virtual Machine Extensions），是Intel处理器提供的硬件虚拟化技术。通过VMX，处理器可以在同一个物理主机上同时运行多个虚拟机，每个虚拟机都能拥有自己的操作系统和应用程序，并且相互之间是隔离的。</p>
<p>HVM代表硬件辅助虚拟化（Hardware-assisted Virtualization），是一种虚拟化技术。它利用处理器中的硬件特性来提高虚拟化的性能和效率。HVM通常与VMX结合使用，以实现更快速、更可靠的虚拟化环境。</p>
<p>简而言之，VMX指的是Intel处理器提供的硬件虚拟化技术，而HVM则是一种利用硬件辅助虚拟化的技术。这两者都是为了实现高效、安全的虚拟化环境而存在的。</p>
<h1 id="开启虚拟化"><a href="#开启虚拟化" class="headerlink" title="开启虚拟化"></a>开启虚拟化</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Virtualize each CPU</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">StartHV</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Unknown CPU</span></span><br><span class="line">    <span class="keyword">if</span> (g_Data-&gt;CPUVendor == CPU_Other)</span><br><span class="line">        <span class="keyword">return</span> STATUS_NOT_SUPPORTED;<span class="comment">// 不支持</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">KeGenericCallDpc</span>( HvmpHVCallbackDPC, (PVOID)__readcr3() );<span class="comment">// 读取CR3寄存器的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Some CPU failed</span></span><br><span class="line">    ULONG count = <span class="built_in">KeQueryActiveProcessorCountEx</span>( ALL_PROCESSOR_GROUPS );<span class="comment">// 查询活动处理器的数量</span></span><br><span class="line">    <span class="keyword">if</span> (count != (ULONG)g_Data-&gt;vcpus)<span class="comment">// 活动处理器的数量不等于虚拟处理器的数量</span></span><br><span class="line">    &#123;<span class="comment">// 有处理器失败，停止虚拟化并返回失败</span></span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: Some CPU failed to subvert\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        <span class="built_in">StopHV</span>();</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DPC回调进行虚拟化处理"><a href="#DPC回调进行虚拟化处理" class="headerlink" title="DPC回调进行虚拟化处理"></a>DPC回调进行虚拟化处理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">HvmpHVCallbackDPC</span><span class="params">( PRKDPC Dpc, PVOID Context, PVOID SystemArgument1, PVOID SystemArgument2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    DPC（Deferred Procedure Call）是一种延迟执行的过程调用机制，</span></span><br><span class="line"><span class="comment">    用于在计算机系统的中断或系统事件处理过程完成后，延迟执行一些需要高优先级处理的任务或回调函数。</span></span><br><span class="line"><span class="comment">    DPC的执行是在系统抢占模式下进行的，因此可以保证其执行的稳定性和一致性。</span></span><br><span class="line"><span class="comment">    使用DPC可以实现一些延迟处理的任务，例如缓冲区刷新、资源回收、数据处理等。</span></span><br><span class="line"><span class="comment">    通过将这些任务置于DPC中执行，可以避免阻塞正常的中断处理程序或系统服务例程，提高系统的效率和响应性能。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>( Dpc );<span class="comment">// Dpc是一个未使用的参数</span></span><br><span class="line">    PVCPU pVCPU = &amp;g_Data-&gt;cpu_data[CPU_IDX];<span class="comment">// 获取当前处理器的虚拟处理器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if we are loading, or unloading</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ARGUMENT_PRESENT</span>( Context ))<span class="comment">// 检测Context是否被传递，通过Context参数判断是加载还是卸载</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 执行对应的初始化操作</span></span><br><span class="line">        g_Data-&gt;CPUVendor == CPU_Intel ? <span class="built_in">IntelSubvertCPU</span>( pVCPU, Context ) : <span class="built_in">AMDSubvertCPU</span>( pVCPU, Context );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 恢复虚拟处理器</span></span><br><span class="line">        g_Data-&gt;CPUVendor == CPU_Intel ? <span class="built_in">IntelRestoreCPU</span>( pVCPU ) : <span class="built_in">AMDRestoreCPU</span>( pVCPU );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有DPC同步，传入同步信号量</span></span><br><span class="line">    <span class="built_in">KeSignalCallDpcSynchronize</span>( SystemArgument2 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记DPC执行完成，传入完成信号量</span></span><br><span class="line">    <span class="built_in">KeSignalCallDpcDone</span>( SystemArgument1 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化IntelCPU"><a href="#初始化IntelCPU" class="headerlink" title="初始化IntelCPU"></a>初始化IntelCPU</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HVM.c</span></span><br><span class="line"><span class="comment">// Vendor-specific calls</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> VOID <span class="title">IntelSubvertCPU</span><span class="params">( IN PVCPU Vcpu, IN PVOID SystemDirectoryTableBase )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">VmxInitializeCPU</span>( Vcpu, (ULONG64)SystemDirectoryTableBase );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VMX.c</span></span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Virtualize LP 初始化逻辑处理器</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Vcpu&quot;&gt;Virtual CPU data&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;SystemDirectoryTableBase&quot;&gt;Kernel CR3&lt;/param&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">VmxInitializeCPU</span><span class="params">( IN PVCPU Vcpu, IN ULONG64 SystemDirectoryTableBase )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    存储处理器的休眠状态，其中包含所有特殊寄存器和MSR（模型特定寄存器），</span></span><br><span class="line"><span class="comment">    VMCS（虚拟机控制结构）将需要这些作为其设置的一部分。这样可以避免使用汇编序列</span></span><br><span class="line"><span class="comment">    并手动读取这些数据。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    KeSaveStateForHibernate是Windows内核函数，用于保存处理器的状态以进行休眠操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    在Windows系统中，当计算机进入休眠状态时，操作系统需要保存处理器的当前状态，</span></span><br><span class="line"><span class="comment">    包括寄存器、程序计数器（指令指针）以及其他关键的执行上下文信息。</span></span><br><span class="line"><span class="comment">    这样，在计算机重新唤醒时，系统可以从先前保存的状态中恢复，并继续执行之前的操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    KeSaveStateForHibernate函数的作用就是将当前处理器的状态保存到内存中，</span></span><br><span class="line"><span class="comment">    以便后续的休眠操作使用。它会将所有的特殊寄存器、模型特定寄存器、以及一般寄存器的值保存起来，</span></span><br><span class="line"><span class="comment">    确保在休眠期间数据不会丢失。具体而言，该函数会将处理器状态保存到与休眠操作相关的数据结构中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    这个函数通常由操作系统内核在准备进入休眠状态之前调用，以便将当前的处理器状态保存下来。</span></span><br><span class="line"><span class="comment">    然后，在计算机唤醒时，操作系统可以使用相应的函数来还原保存的状态，以实现无缝的恢复。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">KeSaveStateForHibernate</span>( &amp;Vcpu-&gt;HostState );<span class="comment">// 启动之前确保可以保存现有处理器状态，确保在虚拟化期间数据不会丢失</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    捕获整个寄存器状态。因为一旦启动虚拟机，它将从定义的客户机指令指针处开始执行，</span></span><br><span class="line"><span class="comment">    该指针会在此调用中被捕获。换句话说，我们将返回到我们的原始位置，但由于VMCS/VMX初始化代码的影响，</span></span><br><span class="line"><span class="comment">    我们的寄存器都被破坏了（因为客户机状态不包括寄存器状态）。通过在这里保存上下文，</span></span><br><span class="line"><span class="comment">    包括所有通用寄存器，我们保证返回时我们也能恢复我们的起始寄存器值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">RtlCaptureContext</span>( &amp;Vcpu-&gt;HostState.ContextFrame );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    根据上述情况，在这里可以判断虚拟机实际上是否已启动。</span></span><br><span class="line"><span class="comment">    我们可以通过验证VmxEnabled字段的值来检查这一点，该字段在执行VMXLAUNCH之前设置为1。</span></span><br><span class="line"><span class="comment">    在此函数中，我们不使用Data参数或任何其他局部寄存器，并且事实上VmxEnabled是不确定的，</span></span><br><span class="line"><span class="comment">    因为根据上述情况，由于VMCALL本身，我们的寄存器状态当前是脏的。</span></span><br><span class="line"><span class="comment">    通过结合全局变量和API调用使用它，我们还确保编译器不会以任何方式优化此访问，</span></span><br><span class="line"><span class="comment">    即使在LTGC/Ox构建上也是如此。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (g_Data-&gt;cpu_data[CPU_IDX].VmxState == VMX_STATE_TRANSITION)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        表示虚拟机已启动，因此即将将GPR（通用寄存器）还原为其原始值。</span></span><br><span class="line"><span class="comment">        这将使我们再次回到上一行代码，但是这次VmxEnabled的值将为2，绕过if和else if检查。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        g_Data-&gt;cpu_data[CPU_IDX].VmxState = VMX_STATE_ON;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        最后，恢复上下文，以便最终恢复所有寄存器和堆栈状态。通过继续以这种方式引用每个VP数据，</span></span><br><span class="line"><span class="comment">        编译器将继续生成非优化的访问，确保不会破坏先前的寄存器状态。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">VmRestoreContext</span>( &amp;g_Data-&gt;cpu_data[CPU_IDX].HostState.ContextFrame );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    尚未尝试启动虚拟机，也没有启动它。换句话说，</span></span><br><span class="line"><span class="comment">    这是第一次调用VmxInitializeCPU。因此，我们可以自由地使用所有寄存器状态。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (g_Data-&gt;cpu_data[CPU_IDX].VmxState == VMX_STATE_OFF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        首先，捕获SYSTEM进程的PML4（页目录表）的值，以便无论当前LP中断哪个进程，</span></span><br><span class="line"><span class="comment">        所有虚拟处理器都可以共享正确的内核地址空间。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在x86-64架构下，操作系统内核和用户进程共享同一个物理地址空间。为了实现这个地址空间共享，</span></span><br><span class="line"><span class="comment">        x86-64架构定义了一个层次化的虚拟内存地址转换机制，这个机制包括页表、页目录表和页全局目录等数据结构。</span></span><br><span class="line"><span class="comment">        其中，页全局目录是整个地址空间的根节点，每个进程都有一个自己的页全局目录。</span></span><br><span class="line"><span class="comment">        页目录表用来描述一个进程的用户地址空间，</span></span><br><span class="line"><span class="comment">        而具有特殊权限的内核空间也需要一个页目录表来映射内核地址空间。</span></span><br><span class="line"><span class="comment">        &quot;捕获SYSTEM进程的PML4（页目录表）的值&quot;，</span></span><br><span class="line"><span class="comment">        实际上就是获取当前系统的内核页目录表的物理地址，以便后续的操作可以正确地访问内核的地址空间。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        由于LP调度器会将不同进程调度到不同的逻辑处理器上执行，</span></span><br><span class="line"><span class="comment">        为了保证多个逻辑处理器之间能够正确地共享内核地址空间，</span></span><br><span class="line"><span class="comment">        必须要使所有的虚拟处理器共享同一个内核页目录表。</span></span><br><span class="line"><span class="comment">        因此，在运行任意一个进程之前，需要将其对应的页目录表设置为内核页目录表的地址，即代码中所描述的部分。</span></span><br><span class="line"><span class="comment">        以保证该进程可以正确地访问内核地址空间。这可以通过在LP上下文切换时，</span></span><br><span class="line"><span class="comment">        将当前进程的页目录表设置为系统内核页目录表的物理地址来实现。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Vcpu-&gt;SystemDirectoryTableBase = SystemDirectoryTableBase;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试在该处理器上初始化VMX</span></span><br><span class="line">        <span class="built_in">VmxSubvertCPU</span>( Vcpu );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="从-CONTEXT-结构体中恢复寄存器上下文"><a href="#从-CONTEXT-结构体中恢复寄存器上下文" class="headerlink" title="从 CONTEXT 结构体中恢复寄存器上下文"></a>从 CONTEXT 结构体中恢复寄存器上下文</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">VmRestoreContext PROC</span><br><span class="line">	; 与RtlCaptureContext()兼容。使用此函数代替RtlRestoreContext()函数，以便在Win10 15063+版本上不会由于RSP检查而导致蓝屏。</span><br><span class="line">	push rbp</span><br><span class="line">	push rsi</span><br><span class="line">	push rdi</span><br><span class="line">	sub rsp, 30h</span><br><span class="line">	mov rbp, rsp</span><br><span class="line">	movaps  xmm0, xmmword ptr [rcx+1A0h]</span><br><span class="line">	movaps  xmm1, xmmword ptr [rcx+1B0h]</span><br><span class="line">	movaps  xmm2, xmmword ptr [rcx+1C0h]</span><br><span class="line">	movaps  xmm3, xmmword ptr [rcx+1D0h]</span><br><span class="line">	movaps  xmm4, xmmword ptr [rcx+1E0h]</span><br><span class="line">	movaps  xmm5, xmmword ptr [rcx+1F0h]</span><br><span class="line">	movaps  xmm6, xmmword ptr [rcx+200h]</span><br><span class="line">	movaps  xmm7, xmmword ptr [rcx+210h]</span><br><span class="line">	movaps  xmm8, xmmword ptr [rcx+220h]</span><br><span class="line">	movaps  xmm9, xmmword ptr [rcx+230h]</span><br><span class="line">	movaps  xmm10, xmmword ptr [rcx+240h]</span><br><span class="line">	movaps  xmm11, xmmword ptr [rcx+250h]</span><br><span class="line">	movaps  xmm12, xmmword ptr [rcx+260h]</span><br><span class="line">	movaps  xmm13, xmmword ptr [rcx+270h]</span><br><span class="line">	movaps  xmm14, xmmword ptr [rcx+280h]</span><br><span class="line">	movaps  xmm15, xmmword ptr [rcx+290h]</span><br><span class="line">	ldmxcsr dword ptr [rcx+34h]</span><br><span class="line"></span><br><span class="line">	mov     ax, [rcx+42h]</span><br><span class="line">	mov     [rsp+20h], ax</span><br><span class="line">	mov     rax, [rcx+98h] ; RSP</span><br><span class="line">	mov     [rsp+18h], rax</span><br><span class="line">	mov     eax, [rcx+44h]</span><br><span class="line">	mov     [rsp+10h], eax</span><br><span class="line">	mov     ax, [rcx+38h]</span><br><span class="line">	mov     [rsp+08h], ax</span><br><span class="line">	mov     rax, [rcx+0F8h] ; RIP</span><br><span class="line">	mov     [rsp+00h], rax ; set RIP as return address (for iretq instruction).</span><br><span class="line"></span><br><span class="line">	mov     rax, [rcx+78h]</span><br><span class="line">	mov     rdx, [rcx+88h]</span><br><span class="line">	mov     r8, [rcx+0B8h]</span><br><span class="line">	mov     r9, [rcx+0C0h]</span><br><span class="line">	mov     r10, [rcx+0C8h]</span><br><span class="line">	mov     r11, [rcx+0D0h]</span><br><span class="line">	cli</span><br><span class="line">	mov     rbx, [rcx+90h]</span><br><span class="line">	mov     rsi, [rcx+0A8h]</span><br><span class="line">	mov     rdi, [rcx+0B0h]</span><br><span class="line">	mov     rbp, [rcx+0A0h]</span><br><span class="line">	mov     r12, [rcx+0D8h]</span><br><span class="line">	mov     r13, [rcx+0E0h]</span><br><span class="line">	mov     r14, [rcx+0E8h]</span><br><span class="line">	mov     r15, [rcx+0F0h]</span><br><span class="line">	mov     rcx, [rcx+80h]</span><br><span class="line">	iretq</span><br><span class="line"></span><br><span class="line">VmRestoreContext ENDP</span><br></pre></td></tr></table></figure>

<h4 id="使用Intel虚拟化技术启动虚拟机，创建虚拟CPU"><a href="#使用Intel虚拟化技术启动虚拟机，创建虚拟CPU" class="headerlink" title="使用Intel虚拟化技术启动虚拟机，创建虚拟CPU"></a>使用Intel虚拟化技术启动虚拟机，创建虚拟CPU</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Execute VMLAUNCH</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Vcpu&quot;&gt;Virtyal CPU data&lt;/param&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">VmxSubvertCPU</span><span class="params">( IN PVCPU Vcpu )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PHYSICAL_ADDRESS phys = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    phys.QuadPart = MAXULONG64;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化所有与VMX相关的MSR，通过读取它们的值来初始化</span></span><br><span class="line">    <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt;= <span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_VMCS_ENUM ); i++)</span><br><span class="line">        Vcpu-&gt;MsrData[i].QuadPart = __readmsr( MSR_IA32_VMX_BASIC + i );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据系统支持的功能，初始化次级控制（secondary controls）、真实模型专用寄存器（true MSRs）和VMFUNC</span></span><br><span class="line">    <span class="comment">// 见VmxCheckFeatures()</span></span><br><span class="line">    <span class="keyword">if</span> (g_Data-&gt;Features.SecondaryControls)</span><br><span class="line">        Vcpu-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_PROCBASED_CTLS2 )].QuadPart = __readmsr( MSR_IA32_VMX_PROCBASED_CTLS2 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// True MSRs, if present</span></span><br><span class="line">    <span class="keyword">if</span> (g_Data-&gt;Features.TrueMSRs)</span><br><span class="line">        <span class="keyword">for</span> (ULONG i = <span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_TRUE_PINBASED_CTLS ); i &lt;= <span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_TRUE_ENTRY_CTLS ); i++)</span><br><span class="line">            Vcpu-&gt;MsrData[i].QuadPart = __readmsr( MSR_IA32_VMX_BASIC + i );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// VMFUNC, if present</span></span><br><span class="line">    <span class="keyword">if</span>(g_Data-&gt;Features.VMFUNC)</span><br><span class="line">        Vcpu-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_VMFUNC )].QuadPart = __readmsr( MSR_IA32_VMX_VMFUNC );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配VMXON、VMCS和VMM堆栈内存</span></span><br><span class="line">    Vcpu-&gt;VMXON    = <span class="built_in">MmAllocateContiguousMemory</span>( <span class="built_in">sizeof</span>( VMX_VMCS ), phys );</span><br><span class="line">    Vcpu-&gt;VMCS     = <span class="built_in">MmAllocateContiguousMemory</span>( <span class="built_in">sizeof</span>( VMX_VMCS ), phys );</span><br><span class="line">    Vcpu-&gt;VMMStack = <span class="built_in">MmAllocateContiguousMemory</span>( KERNEL_STACK_SIZE,  phys );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!Vcpu-&gt;VMXON || !Vcpu-&gt;VMCS || !Vcpu-&gt;VMMStack)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: Failed to allocate memory\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行保护设置</span></span><br><span class="line">    <span class="built_in">UtilProtectNonpagedMemory</span>( Vcpu-&gt;VMXON,    <span class="built_in">sizeof</span>( VMX_VMCS ), PAGE_READWRITE );</span><br><span class="line">    <span class="built_in">UtilProtectNonpagedMemory</span>( Vcpu-&gt;VMCS,     <span class="built_in">sizeof</span>( VMX_VMCS ), PAGE_READWRITE );</span><br><span class="line">    <span class="built_in">UtilProtectNonpagedMemory</span>( Vcpu-&gt;VMMStack, KERNEL_STACK_SIZE,  PAGE_READWRITE );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化内存空间</span></span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>( Vcpu-&gt;VMXON,    <span class="built_in">sizeof</span>( VMX_VMCS ) );</span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>( Vcpu-&gt;VMCS,     <span class="built_in">sizeof</span>( VMX_VMCS ) );</span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>( Vcpu-&gt;VMMStack, KERNEL_STACK_SIZE );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试进入VMX Root模式</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">VmxEnterRoot</span>( Vcpu ))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// I继续配置VMCS虚拟机控制结构（包括guest和host状态）</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        VMCS是是一种数据结构，用于存储虚拟机的状态信息，如处理器寄存器、段描述符、中断描述符等等。</span></span><br><span class="line"><span class="comment">        VMCS包含了虚拟机执行环境的所有状态信息，是虚拟机管理软件和硬件虚拟化扩展之间的接口。</span></span><br><span class="line"><span class="comment">        VMCS中有两种状态：guest状态和host状态。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        guest状态是指在虚拟机内执行的代码所使用的状态。</span></span><br><span class="line"><span class="comment">        当虚拟化软件将控制权转移到虚拟机内部时，处理器会使用VMCS中的guest状态信息来切换到虚拟机的执行环境。</span></span><br><span class="line"><span class="comment">        guest状态包含了虚拟机内部的所有状态信息，如处理器寄存器、页表、分段描述符等等。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        host状态是指在虚拟机外执行的代码所使用的状态。当虚拟机执行完成后，</span></span><br><span class="line"><span class="comment">        处理器需要恢复到虚拟化软件的执行环境中。</span></span><br><span class="line"><span class="comment">        VMCS中的host状态信息就提供了这个执行环境所需要的状态信息，如处理器寄存器、页表、分段描述符等等。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        在VMCS中，不同类型的状态信息被分为不同的区域，</span></span><br><span class="line"><span class="comment">        如控制区、guest状态区、host状态区等等。通过对VMCS的设置，虚拟化软件可以控制虚拟机的行为，</span></span><br><span class="line"><span class="comment">        如内存地址翻译、中断处理等等。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">VmxSetupVMCS</span>( Vcpu );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置EPT</span></span><br><span class="line">        <span class="keyword">if</span>(g_Data-&gt;Features.EPT)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>( <span class="built_in">EptBuildIdentityMap</span>( &amp;Vcpu-&gt;EPT ) ))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: Failed to build EPT identity map\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">                <span class="keyword">goto</span> failedvmxoff;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">EptEnable</span>( Vcpu-&gt;EPT.PML4Ptr );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录VMX已开启</span></span><br><span class="line">        Vcpu-&gt;VmxState = VMX_STATE_TRANSITION;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在VmxSetupVmcs函数中设置了各种VMCS字段（VMCS fields）,</span></span><br><span class="line">        <span class="comment">// 让处理器跳转到VmxInitializeCPU中调用VmxSetupVmcs的RtlCaptureContext函数的返回地址。</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        RtlCaptureContext是一个Windows操作系统提供的函数，用于获取当前线程的上下文信息，</span></span><br><span class="line"><span class="comment">        包括寄存器的值和程序计数器的值。</span></span><br><span class="line"><span class="comment">        通过将处理器的控制流转移到RtlCaptureContext的返回地址，</span></span><br><span class="line"><span class="comment">        可以在VmxInitializeCPU函数中恢复处理器的状态，继续执行后续的代码逻辑。</span></span><br><span class="line"><span class="comment">        这样做的目的可能是为了在VmxInitializeCPU函数中进行额外的处理或记录虚拟机的初始化状态。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 原子自增操作，意味着有一个虚拟CPU被创建或启动。该函数确保在多线程环境下，对变量进行原子操作，避免了竞争条件。</span></span><br><span class="line">        <span class="built_in">InterlockedIncrement</span>( &amp;g_Data-&gt;vcpus );</span><br><span class="line">        <span class="type">int</span> res = __vmx_vmlaunch();<span class="comment">// 启动虚拟机</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原子自减操作，表示一个虚拟CPU的执行已经结束或销毁。</span></span><br><span class="line">        <span class="built_in">InterlockedDecrement</span>( &amp;g_Data-&gt;vcpus );</span><br><span class="line">        <span class="comment">/* 这两个函数有c++11新特性atomic，详见文档 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        如果程序执行到了这里，那么可能存在两种情况：VMCS设置失败，或者启动操作没有按照计划进行。</span></span><br><span class="line"><span class="comment">        无论是哪种情况，由于VmxEnabled没有被设置为1，都代表失败的情况。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Vcpu-&gt;VmxState = VMX_STATE_OFF;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: __vmx_vmlaunch failed with result %d\n&quot;</span>, CPU_IDX, __FUNCTION__, res );</span><br><span class="line"></span><br><span class="line">failedvmxoff:</span><br><span class="line">        __vmx_off();<span class="comment">// 关闭VMX</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">failed:;<span class="comment">// 失败处理 释放内存</span></span><br><span class="line">    <span class="keyword">if</span> (Vcpu-&gt;VMXON)</span><br><span class="line">        <span class="built_in">MmFreeContiguousMemory</span>( Vcpu-&gt;VMXON );</span><br><span class="line">    <span class="keyword">if</span> (Vcpu-&gt;VMCS)</span><br><span class="line">        <span class="built_in">MmFreeContiguousMemory</span>( Vcpu-&gt;VMCS );</span><br><span class="line">    <span class="keyword">if</span> (Vcpu-&gt;VMMStack)</span><br><span class="line">        <span class="built_in">MmFreeContiguousMemory</span>( Vcpu-&gt;VMMStack );</span><br><span class="line"></span><br><span class="line">    Vcpu-&gt;VMXON    = <span class="literal">NULL</span>;</span><br><span class="line">    Vcpu-&gt;VMCS     = <span class="literal">NULL</span>;</span><br><span class="line">    Vcpu-&gt;VMMStack = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="设置保护"><a href="#设置保护" class="headerlink" title="设置保护"></a>设置保护</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Change protection of nonpaged system address</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;ptr&quot;&gt;Address&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;size&quot;&gt;Size of region&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;protection&quot;&gt;New protection flags&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line">NTSTATUS <span class="title function_">UtilProtectNonpagedMemory</span><span class="params">( IN PVOID ptr, IN ULONG64 size, IN ULONG protection )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    MDL是Windows内核中的数据结构，Memory Descriptor List（内存描述列表）。</span></span><br><span class="line"><span class="comment">    它用于描述一个或多个连续物理内存页的详细信息。</span></span><br><span class="line"><span class="comment">    在Windows操作系统中，内存管理模块使用MDL来跟踪和管理内存分配、映射和保护。</span></span><br><span class="line"><span class="comment">    MDL通常与虚拟内存映射、物理内存页面和驱动程序之间的交互密切相关。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    MDL的主要字段包括：</span></span><br><span class="line"><span class="comment">        StartVa：指向MDL所描述的内存区域的起始虚拟地址。</span></span><br><span class="line"><span class="comment">        ByteCount：描述MDL涵盖的内存区域的总字节数。</span></span><br><span class="line"><span class="comment">        MappedSystemVa：如果MDL中的内存区域被映射到了系统地址空间，则该字段表示映射后的虚拟地址；否则为NULL。</span></span><br><span class="line"><span class="comment">        Process：指向拥有该MDL的进程对象的指针。</span></span><br><span class="line"><span class="comment">        Flags：用于标识MDL的一些特性，如是否映射到系统地址空间、是否是锁定的等。</span></span><br><span class="line"><span class="comment">    驱动程序可以通过创建和操作MDL来管理内存。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    PMDL pMdl = IoAllocateMdl( ptr, (ULONG)size, FALSE, FALSE, <span class="literal">NULL</span> );<span class="comment">// 创建一个包含给定地址的MDL</span></span><br><span class="line">    <span class="keyword">if</span> (pMdl)</span><br><span class="line">    &#123;</span><br><span class="line">        MmBuildMdlForNonPagedPool( pMdl );<span class="comment">// 将这个MDL描述的物理内存区域与非分页池相关联</span></span><br><span class="line">        pMdl-&gt;MdlFlags |= MDL_MAPPED_TO_SYSTEM_VA;<span class="comment">// 该MDL描述的虚拟地址映射到了内核的虚拟地址空间中</span></span><br><span class="line">        status = MmProtectMdlSystemAddress( pMdl, protection );<span class="comment">// 在MDL中描述的物理内存区域的保护属性设置为给定的属性</span></span><br><span class="line">        IoFreeMdl( pMdl );<span class="comment">// 释放MDL</span></span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="启动Vmx-Root模式"><a href="#启动Vmx-Root模式" class="headerlink" title="启动Vmx Root模式"></a>启动Vmx Root模式</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Switch CPU to root mode</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Vcpu&quot;&gt;Virtual CPU data&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;TRUE on success&lt;/returns&gt;</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">VmxEnterRoot</span><span class="params">( IN PVCPU Vcpu )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将CPU切换到root模式，虚拟机监视器VMM运行的特权级别最高的模式，用于管理和控制虚拟机的执行</span></span><br><span class="line">    PKSPECIAL_REGISTERS Registers = &amp;Vcpu-&gt;HostState.SpecialRegisters;<span class="comment">// 主机特殊寄存器</span></span><br><span class="line">    PIA32_VMX_BASIC_MSR pBasic = (PIA32_VMX_BASIC_MSR)&amp;Vcpu-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_BASIC )];<span class="comment">// VMX基本MSR</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查虚拟机控制结构VMCS是否能够适应单个页面</span></span><br><span class="line">    <span class="keyword">if</span> (pBasic-&gt;Fields.RegionSize &gt; PAGE_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: VMCS region doesn&#x27;t fit into one page\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查VMCS所需的内存类型是否为写回缓存类型</span></span><br><span class="line">    <span class="keyword">if</span> (pBasic-&gt;Fields.MemoryType != VMX_MEM_TYPE_WRITEBACK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: Unsupported memory type\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否支持使用真实MSR获取虚拟化功能信息</span></span><br><span class="line">    <span class="keyword">if</span> (pBasic-&gt;Fields.VmxCapabilityHint == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: No true MSR support\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存VMXON、VMCS的修订号</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在硬件层面，VMXON指令用于激活处理器的虚拟机扩展（Intel VT-x或AMD-V），这是一种硬件虚拟化技术，</span></span><br><span class="line"><span class="comment">    允许多个虚拟机同时运行，并将它们隔离开来。VMXON指令的执行会初始化虚拟机相关的数据结构，</span></span><br><span class="line"><span class="comment">    并将处理器的运行模式从非虚拟化模式切换到虚拟化模式。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    在虚拟化环境中，VMXON指令通常由虚拟机监视器（VMM）或Hypervisor在启动虚拟机时调用。</span></span><br><span class="line"><span class="comment">    它必须在特权级别最高的模式下执行，通常是在操作系统内核中。</span></span><br><span class="line"><span class="comment">    执行VMXON指令后，处理器将转入根模式，VMM可以通过VMCS（虚拟机控制结构）对虚拟机进行管理和控制。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Vcpu-&gt;VMXON-&gt;RevisionId = pBasic-&gt;Fields.RevisionIdentifier;</span><br><span class="line">    Vcpu-&gt;VMCS-&gt;RevisionId  = pBasic-&gt;Fields.RevisionIdentifier;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据MSR_IA32_VMX_CR0_FIXED0和MSR_IA32_VMX_CR0_FIXED1的要求修正CR0寄存器</span></span><br><span class="line">    Registers-&gt;Cr0 &amp;= Vcpu-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_CR0_FIXED1 )].LowPart;</span><br><span class="line">    Registers-&gt;Cr0 |= Vcpu-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_CR0_FIXED0 )].LowPart;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据MSR_IA32_VMX_CR4_FIXED0和MSR_IA32_VMX_CR4_FIXED1的要求修正CR4寄存器</span></span><br><span class="line">    Registers-&gt;Cr4 &amp;= Vcpu-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_CR4_FIXED1 )].LowPart;</span><br><span class="line">    Registers-&gt;Cr4 |= Vcpu-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_CR4_FIXED0 )].LowPart;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交r0、r4寄存器的更新</span></span><br><span class="line">    __writecr0( Registers-&gt;Cr0 );</span><br><span class="line">    __writecr4( Registers-&gt;Cr4 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启VMX root模式</span></span><br><span class="line">    PHYSICAL_ADDRESS phys = <span class="built_in">MmGetPhysicalAddress</span>( Vcpu-&gt;VMXON );</span><br><span class="line">    <span class="type">int</span> res = __vmx_on( (PULONG64)&amp;phys );</span><br><span class="line">    <span class="keyword">if</span> (res)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: __vmx_on failed with status %d\n&quot;</span>, CPU_IDX, __FUNCTION__, res );</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除VMCS, 修改状态为Inactive</span></span><br><span class="line">    phys = <span class="built_in">MmGetPhysicalAddress</span>( Vcpu-&gt;VMCS );</span><br><span class="line">    <span class="keyword">if</span> (__vmx_vmclear( (PULONG64)&amp;phys ))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: __vmx_vmclear failed\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载VMCS, 设置状态为Active</span></span><br><span class="line">    <span class="keyword">if</span> (__vmx_vmptrld( (PULONG64)&amp;phys ))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: __vmx_vmptrld failed\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// VMX Root模式启动, 以及一个激活的VMCS.</span></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="设置VMCS字段"><a href="#设置VMCS字段" class="headerlink" title="设置VMCS字段"></a>设置VMCS字段</h5><p><img src="/.com//e29d346719df43fd8b7c9363083f23e6.png" alt="在这里插入图片描述"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Setup VMCS fields</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;VpData&quot;&gt;Virtual CPU data&lt;/param&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">VmxSetupVMCS</span><span class="params">( IN PVCPU VpData )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PKPROCESSOR_STATE state = &amp;VpData-&gt;HostState;</span><br><span class="line">    VMX_GDTENTRY64 vmxGdtEntry = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    VMX_VM_ENTER_CONTROLS vmEnterCtlRequested = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    VMX_VM_EXIT_CONTROLS vmExitCtlRequested = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    VMX_PIN_BASED_CONTROLS vmPinCtlRequested = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    VMX_CPU_BASED_CONTROLS vmCpuCtlRequested = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    VMX_SECONDARY_CPU_BASED_CONTROLS vmCpuCtl2Requested = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Hypervisor（超级监控程序）是一种虚拟化技术的关键组成部分。</span></span><br><span class="line"><span class="comment">    它是在物理计算机上创建和管理虚拟机（Virtual Machine，VM）的软件或固件。</span></span><br><span class="line"><span class="comment">    Hypervisor 在物理硬件和虚拟机之间充当中间层，允许多个虚拟机同时在同一台物理机上运行，</span></span><br><span class="line"><span class="comment">    并提供虚拟机对硬件资源的访问。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Hypervisor 有两种主要类型：</span></span><br><span class="line"><span class="comment">        直接运行在物理硬件上，它可以直接管理物理资源和虚拟机实例，将物理资源划分给各个虚拟机，</span></span><br><span class="line"><span class="comment">    并在它们之间进行调度和隔离。常见的类型 1 Hypervisor 包括 VMware ESXi、Microsoft Hyper-V 和 Xen。</span></span><br><span class="line"><span class="comment">        作为一个应用程序在操作系统之上运行。它需要一个宿主操作系统提供硬件访问和资源管理功能，</span></span><br><span class="line"><span class="comment">    然后在其上创建和管理虚拟机。常见的类型 2 Hypervisor 包括 Oracle VirtualBox 和 VMware Workstation。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入控制字段，虚拟机在进入hypervisor时确保以x64模式进入</span></span><br><span class="line">    vmEnterCtlRequested.Fields.IA32eModeGuest = TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出控制字段，虚拟机退出hypervisor时，确保以x64模式退出</span></span><br><span class="line">    vmExitCtlRequested.Fields.AcknowledgeInterruptOnExit = TRUE;</span><br><span class="line">    vmExitCtlRequested.Fields.HostAddressSpaceSize = TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚拟机CPU控制字段，启用MSR位图，激活次级控制和CR3退出，在CR3改变时无效VPID缓存</span></span><br><span class="line">    vmCpuCtlRequested.Fields.UseMSRBitmaps = TRUE;</span><br><span class="line">    vmCpuCtlRequested.Fields.ActivateSecondaryControl = TRUE;</span><br><span class="line">    <span class="comment">//vmCpuCtlRequested.Fields.UseTSCOffseting = TRUE;</span></span><br><span class="line">    <span class="comment">//vmCpuCtlRequested.Fields.RDTSCExiting = TRUE;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// VPID caches must be invalidated on CR3 change</span></span><br><span class="line">    <span class="keyword">if</span>(g_Data-&gt;Features.VPID)</span><br><span class="line">        vmCpuCtlRequested.Fields.CR3LoadExiting = TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在虚拟机中启用对于 RDTSCP 和 XSAVES/XRESTORES 指令的支持。</span></span><br><span class="line"><span class="comment">    在 Windows 10 系统中，如果 CPU 支持这些指令，操作系统会使用它们来提高性能。</span></span><br><span class="line"><span class="comment">    通过使用 VmxpAdjustMsr 函数，如果处理器不支持这些指令，将会忽略对这些选项的设置。</span></span><br><span class="line"><span class="comment">    这样可以确保在不支持这些指令的处理器上仍然可以正常运行虚拟机监控程序，</span></span><br><span class="line"><span class="comment">    而不会因为这些指令的不支持而导致错误。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    vmCpuCtl2Requested.Fields.EnableRDTSCP = TRUE;</span><br><span class="line">    vmCpuCtl2Requested.Fields.EnableXSAVESXSTORS = TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Begin by setting the link pointer to the required value for 4KB VMCS.</span></span><br><span class="line">    <span class="comment">// 从设置VMCS的链接指针字段开始，设置为4KB VMCS所需的值</span></span><br><span class="line">    __vmx_vmwrite( VMCS_LINK_POINTER, MAXULONG64 );</span><br><span class="line">    <span class="comment">// 将VMCS需要的各个控制字段写入VMCS</span></span><br><span class="line">    __vmx_vmwrite(</span><br><span class="line">        PIN_BASED_VM_EXEC_CONTROL, </span><br><span class="line">        <span class="built_in">VmxpAdjustMsr</span>( VpData-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_TRUE_PINBASED_CTLS )], vmPinCtlRequested.All ) </span><br><span class="line">        );</span><br><span class="line">    __vmx_vmwrite( </span><br><span class="line">        CPU_BASED_VM_EXEC_CONTROL, </span><br><span class="line">        <span class="built_in">VmxpAdjustMsr</span>( VpData-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_TRUE_PROCBASED_CTLS )], vmCpuCtlRequested.All ) </span><br><span class="line">        );</span><br><span class="line">    __vmx_vmwrite( </span><br><span class="line">        SECONDARY_VM_EXEC_CONTROL, </span><br><span class="line">        <span class="built_in">VmxpAdjustMsr</span>( VpData-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_PROCBASED_CTLS2 )], vmCpuCtl2Requested.All ) </span><br><span class="line">        );</span><br><span class="line">    __vmx_vmwrite(</span><br><span class="line">        VM_EXIT_CONTROLS, </span><br><span class="line">        <span class="built_in">VmxpAdjustMsr</span>( VpData-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_TRUE_EXIT_CTLS )], vmExitCtlRequested.All ) </span><br><span class="line">        );</span><br><span class="line">    __vmx_vmwrite( </span><br><span class="line">        VM_ENTRY_CONTROLS, </span><br><span class="line">        <span class="built_in">VmxpAdjustMsr</span>( VpData-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_TRUE_ENTRY_CTLS )], vmEnterCtlRequested.All ) </span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载MSR位图</span></span><br><span class="line">    PUCHAR bitMapReadLow = g_Data-&gt;MSRBitmap;       <span class="comment">// 0x00000000 - 0x00001FFF</span></span><br><span class="line">    PUCHAR bitMapReadHigh = bitMapReadLow + <span class="number">1024</span>;   <span class="comment">// 0xC0000000 - 0xC0001FFF</span></span><br><span class="line"></span><br><span class="line">    RTL_BITMAP bitMapReadLowHeader = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    RTL_BITMAP bitMapReadHighHeader = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">RtlInitializeBitMap</span>( &amp;bitMapReadLowHeader, (PULONG)bitMapReadLow, <span class="number">1024</span> * <span class="number">8</span> );</span><br><span class="line">    <span class="built_in">RtlInitializeBitMap</span>( &amp;bitMapReadHighHeader, (PULONG)bitMapReadHigh, <span class="number">1024</span> * <span class="number">8</span> );</span><br><span class="line">    <span class="comment">// 设置需要捕获的MSR</span></span><br><span class="line">    <span class="built_in">RtlSetBit</span>( &amp;bitMapReadLowHeader, MSR_IA32_FEATURE_CONTROL );    <span class="comment">// MSR_IA32_FEATURE_CONTROL</span></span><br><span class="line">    <span class="built_in">RtlSetBit</span>( &amp;bitMapReadLowHeader,  MSR_IA32_DEBUGCTL );          <span class="comment">// MSR_DEBUGCTL</span></span><br><span class="line">    <span class="built_in">RtlSetBit</span>( &amp;bitMapReadHighHeader, MSR_LSTAR - <span class="number">0xC0000000</span> );     <span class="comment">// MSR_LSTAR</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// VMX MSRs</span></span><br><span class="line">    <span class="keyword">for</span> (ULONG i = MSR_IA32_VMX_BASIC; i &lt;= MSR_IA32_VMX_VMFUNC; i++)</span><br><span class="line">        <span class="built_in">RtlSetBit</span>( &amp;bitMapReadLowHeader, i );</span><br><span class="line"></span><br><span class="line">    __vmx_vmwrite( MSR_BITMAP, <span class="built_in">MmGetPhysicalAddress</span>( g_Data-&gt;MSRBitmap ).QuadPart );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置异常位图 Exception bitmap，捕获断点异常</span></span><br><span class="line">    ULONG ExceptionBitmap = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//ExceptionBitmap |= 1 &lt;&lt; VECTOR_DEBUG_EXCEPTION;</span></span><br><span class="line">    ExceptionBitmap |= <span class="number">1</span> &lt;&lt; VECTOR_BREAKPOINT_EXCEPTION;</span><br><span class="line"></span><br><span class="line">    __vmx_vmwrite( EXCEPTION_BITMAP, ExceptionBitmap );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CS (Ring 0 Code)</span></span><br><span class="line">    <span class="comment">// 代码段描述符中包含了代码段的基地址和大小，并且还包含了一些权限信息。CS 寄存器存放的是代码段描述符在 GDT 表中的索引（Selector）。</span></span><br><span class="line">    <span class="built_in">VmxpConvertGdtEntry</span>( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;ContextFrame.SegCs, &amp;vmxGdtEntry );</span><br><span class="line">    __vmx_vmwrite( GUEST_CS_SELECTOR, vmxGdtEntry.Selector );</span><br><span class="line">    __vmx_vmwrite( GUEST_CS_LIMIT, vmxGdtEntry.Limit );</span><br><span class="line">    __vmx_vmwrite( GUEST_CS_AR_BYTES, vmxGdtEntry.AccessRights );</span><br><span class="line">    __vmx_vmwrite( GUEST_CS_BASE, vmxGdtEntry.Base );</span><br><span class="line">    __vmx_vmwrite( HOST_CS_SELECTOR, state-&gt;ContextFrame.SegCs &amp; ~RPL_MASK );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SS (Ring 0 Data)</span></span><br><span class="line">    <span class="comment">// 栈段描述符中包含了栈段的基地址和大小，并且还包含了一些权限信息。SS 寄存器存放的是栈段描述符在 GDT 表中的索引（Selector）。</span></span><br><span class="line">    <span class="built_in">VmxpConvertGdtEntry</span>( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;ContextFrame.SegSs, &amp;vmxGdtEntry );</span><br><span class="line">    __vmx_vmwrite( GUEST_SS_SELECTOR, vmxGdtEntry.Selector );</span><br><span class="line">    __vmx_vmwrite( GUEST_SS_LIMIT, vmxGdtEntry.Limit );</span><br><span class="line">    __vmx_vmwrite( GUEST_SS_AR_BYTES, vmxGdtEntry.AccessRights );</span><br><span class="line">    __vmx_vmwrite( GUEST_SS_BASE, vmxGdtEntry.Base );</span><br><span class="line">    __vmx_vmwrite( HOST_SS_SELECTOR, state-&gt;ContextFrame.SegSs &amp; ~RPL_MASK );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DS (Ring 3 Data)</span></span><br><span class="line">    <span class="comment">// 数据段描述符中包含了数据段的基地址和大小，并且还包含了一些权限信息。DS、ES、FS、GS 寄存器分别存放数据段描述符在 GDT 表中的索引（Selector）。</span></span><br><span class="line">    <span class="built_in">VmxpConvertGdtEntry</span>( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;ContextFrame.SegDs, &amp;vmxGdtEntry );</span><br><span class="line">    __vmx_vmwrite( GUEST_DS_SELECTOR, vmxGdtEntry.Selector );</span><br><span class="line">    __vmx_vmwrite( GUEST_DS_LIMIT, vmxGdtEntry.Limit );</span><br><span class="line">    __vmx_vmwrite( GUEST_DS_AR_BYTES, vmxGdtEntry.AccessRights );</span><br><span class="line">    __vmx_vmwrite( GUEST_DS_BASE, vmxGdtEntry.Base );</span><br><span class="line">    __vmx_vmwrite( HOST_DS_SELECTOR, state-&gt;ContextFrame.SegDs &amp; ~RPL_MASK );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ES (Ring 3 Data)</span></span><br><span class="line">    <span class="built_in">VmxpConvertGdtEntry</span>( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;ContextFrame.SegEs, &amp;vmxGdtEntry );</span><br><span class="line">    __vmx_vmwrite( GUEST_ES_SELECTOR, vmxGdtEntry.Selector );</span><br><span class="line">    __vmx_vmwrite( GUEST_ES_LIMIT, vmxGdtEntry.Limit );</span><br><span class="line">    __vmx_vmwrite( GUEST_ES_AR_BYTES, vmxGdtEntry.AccessRights );</span><br><span class="line">    __vmx_vmwrite( GUEST_ES_BASE, vmxGdtEntry.Base );</span><br><span class="line">    __vmx_vmwrite( HOST_ES_SELECTOR, state-&gt;ContextFrame.SegEs &amp; ~RPL_MASK );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FS (Ring 3 Compatibility-Mode TEB)</span></span><br><span class="line">    <span class="built_in">VmxpConvertGdtEntry</span>( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;ContextFrame.SegFs, &amp;vmxGdtEntry );</span><br><span class="line">    __vmx_vmwrite( GUEST_FS_SELECTOR, vmxGdtEntry.Selector );</span><br><span class="line">    __vmx_vmwrite( GUEST_FS_LIMIT, vmxGdtEntry.Limit );</span><br><span class="line">    __vmx_vmwrite( GUEST_FS_AR_BYTES, vmxGdtEntry.AccessRights );</span><br><span class="line">    __vmx_vmwrite( GUEST_FS_BASE, vmxGdtEntry.Base );</span><br><span class="line">    __vmx_vmwrite( HOST_FS_BASE, vmxGdtEntry.Base );</span><br><span class="line">    __vmx_vmwrite( HOST_FS_SELECTOR, state-&gt;ContextFrame.SegFs &amp; ~RPL_MASK );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GS (Ring 3 Data if in Compatibility-Mode, MSR-based in Long Mode)</span></span><br><span class="line">    <span class="built_in">VmxpConvertGdtEntry</span>( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;ContextFrame.SegGs, &amp;vmxGdtEntry );</span><br><span class="line">    __vmx_vmwrite( GUEST_GS_SELECTOR, vmxGdtEntry.Selector );</span><br><span class="line">    __vmx_vmwrite( GUEST_GS_LIMIT, vmxGdtEntry.Limit );</span><br><span class="line">    __vmx_vmwrite( GUEST_GS_AR_BYTES, vmxGdtEntry.AccessRights );</span><br><span class="line">    __vmx_vmwrite( GUEST_GS_BASE, state-&gt;SpecialRegisters.MsrGsBase );</span><br><span class="line">    __vmx_vmwrite( HOST_GS_BASE, state-&gt;SpecialRegisters.MsrGsBase );</span><br><span class="line">    __vmx_vmwrite( HOST_GS_SELECTOR, state-&gt;ContextFrame.SegGs &amp; ~RPL_MASK );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Task Register (Ring 0 TSS)</span></span><br><span class="line">    <span class="comment">// 存放任务状态段 (TSS) 的选择符，在进行任务切换时使用。</span></span><br><span class="line">    <span class="built_in">VmxpConvertGdtEntry</span>( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;SpecialRegisters.Tr, &amp;vmxGdtEntry );</span><br><span class="line">    __vmx_vmwrite( GUEST_TR_SELECTOR, vmxGdtEntry.Selector );</span><br><span class="line">    __vmx_vmwrite( GUEST_TR_LIMIT, vmxGdtEntry.Limit );</span><br><span class="line">    __vmx_vmwrite( GUEST_TR_AR_BYTES, vmxGdtEntry.AccessRights );</span><br><span class="line">    __vmx_vmwrite( GUEST_TR_BASE, vmxGdtEntry.Base );</span><br><span class="line">    __vmx_vmwrite( HOST_TR_BASE, vmxGdtEntry.Base );</span><br><span class="line">    __vmx_vmwrite( HOST_TR_SELECTOR, state-&gt;SpecialRegisters.Tr &amp; ~RPL_MASK );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LDT</span></span><br><span class="line">    <span class="comment">// 进程的局部任务表描述符（LDT），存放 LDT 描述符在 GDT 表中的索引（Selector）。</span></span><br><span class="line">    <span class="built_in">VmxpConvertGdtEntry</span>( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;SpecialRegisters.Ldtr, &amp;vmxGdtEntry );</span><br><span class="line">    __vmx_vmwrite( GUEST_LDTR_SELECTOR, vmxGdtEntry.Selector );</span><br><span class="line">    __vmx_vmwrite( GUEST_LDTR_LIMIT, vmxGdtEntry.Limit );</span><br><span class="line">    __vmx_vmwrite( GUEST_LDTR_AR_BYTES, vmxGdtEntry.AccessRights );</span><br><span class="line">    __vmx_vmwrite( GUEST_LDTR_BASE, vmxGdtEntry.Base );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GDT</span></span><br><span class="line">    <span class="comment">// 全局描述符表 (GDT)，存放系统运行过程中所有描述符的表。GDT 表包含了各种类型的描述符，如代码段描述符、数据段描述符、TSS 描述符等。</span></span><br><span class="line">    __vmx_vmwrite( GUEST_GDTR_BASE, (ULONG_PTR)state-&gt;SpecialRegisters.Gdtr.Base );</span><br><span class="line">    __vmx_vmwrite( GUEST_GDTR_LIMIT, state-&gt;SpecialRegisters.Gdtr.Limit );</span><br><span class="line">    __vmx_vmwrite( HOST_GDTR_BASE, (ULONG_PTR)state-&gt;SpecialRegisters.Gdtr.Base );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IDT</span></span><br><span class="line">    <span class="comment">// 中断描述符表(IDT)，存放中断处理程序的入口地址，当中断发生时 CPU 会根据中断号查找该表并跳转到对应的处理程序。</span></span><br><span class="line">    __vmx_vmwrite( GUEST_IDTR_BASE, (ULONG_PTR)state-&gt;SpecialRegisters.Idtr.Base );</span><br><span class="line">    __vmx_vmwrite( GUEST_IDTR_LIMIT, state-&gt;SpecialRegisters.Idtr.Limit );</span><br><span class="line">    __vmx_vmwrite( HOST_IDTR_BASE, (ULONG_PTR)state-&gt;SpecialRegisters.Idtr.Base );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CR0</span></span><br><span class="line">    <span class="comment">// 包含了控制处理器运行方式和操作系统的特定行为的控制位，比如保护模式、分页机制等。</span></span><br><span class="line">    __vmx_vmwrite( CR0_READ_SHADOW, state-&gt;SpecialRegisters.Cr0 );</span><br><span class="line">    __vmx_vmwrite( HOST_CR0, state-&gt;SpecialRegisters.Cr0 );</span><br><span class="line">    __vmx_vmwrite( GUEST_CR0, state-&gt;SpecialRegisters.Cr0 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CR3</span></span><br><span class="line">    <span class="comment">// 存放页面目录表 (Page Directory Table) 的地址，页面目录表描述了虚拟地址空间和物理地址空间的映射关系。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    “不要使用当前进程的地址空间作为 host”，因为此时可能正在任意的用户模式进程中执行，</span></span><br><span class="line"><span class="comment">    这里的 host 指的是 hypervisor。也就是说，当 hypervisor 在处理 DPC 中断时，</span></span><br><span class="line"><span class="comment">    DPC 可能正在运行某个用户进程的上下文中，没有特权访问 CR3 寄存器来获取当前进程的页目录表或页表。</span></span><br><span class="line"><span class="comment">    因此，需要手动映射一份特殊的地址空间（例如 kernel 物理地址空间）作为 hypervisor 的地址空间，</span></span><br><span class="line"><span class="comment">    并将其指定为 CR3 的值。这里做了这样的优化，避免使用错误的地址空间导致虚拟地址到物理地址的解析错误。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    __vmx_vmwrite( HOST_CR3, VpData-&gt;SystemDirectoryTableBase );</span><br><span class="line">    __vmx_vmwrite( GUEST_CR3, state-&gt;SpecialRegisters.Cr3 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CR4</span></span><br><span class="line">    <span class="comment">// 包含了一些高级控制和特征寄存器（Advanced Controls and Features Register），比如支持硬件虚拟化技术、支持大页面等。</span></span><br><span class="line">    __vmx_vmwrite( HOST_CR4, state-&gt;SpecialRegisters.Cr4 );</span><br><span class="line">    __vmx_vmwrite( GUEST_CR4, state-&gt;SpecialRegisters.Cr4 );</span><br><span class="line">    __vmx_vmwrite( CR4_GUEST_HOST_MASK, <span class="number">0x2000</span> );</span><br><span class="line">    __vmx_vmwrite( CR4_READ_SHADOW, state-&gt;SpecialRegisters.Cr4 &amp; ~<span class="number">0x2000</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Debug MSR and DR7</span></span><br><span class="line">    <span class="comment">// 包含有关调试状态和断点设置的信息。通过这些寄存器，可以在 CPU 上设置断点和调试相关信息。</span></span><br><span class="line">    __vmx_vmwrite( GUEST_IA32_DEBUGCTL, state-&gt;SpecialRegisters.DebugControl );</span><br><span class="line">    __vmx_vmwrite( GUEST_DR7, state-&gt;SpecialRegisters.KernelDr7 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    最后，加载客户机的堆栈、指令指针和标志寄存器，</span></span><br><span class="line"><span class="comment">    这与 RtlCaptureContext 在 VmxInitializeCPU 中返回的位置完全对应。</span></span><br><span class="line"><span class="comment">    这段代码的作用是将保存在特定位置的客户机上下文数据加载到相应的寄存器中，</span></span><br><span class="line"><span class="comment">    以便恢复客户机的执行状态。具体来说，它加载了客户机的堆栈指针、指令指针和标志寄存器值，</span></span><br><span class="line"><span class="comment">    使得当控制权返回到 VmxInitializeCPU 时，客户机可以继续执行。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    __vmx_vmwrite( GUEST_RSP, state-&gt;ContextFrame.Rsp );</span><br><span class="line">    __vmx_vmwrite( GUEST_RIP, state-&gt;ContextFrame.Rip );</span><br><span class="line">    __vmx_vmwrite( GUEST_RFLAGS, state-&gt;ContextFrame.EFlags );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    加载 hypervisor 的入口地址和 hypervisor 栈。我们为自己分配了一个标准大小的内核栈（24KB），</span></span><br><span class="line"><span class="comment">    并偏移指向上下文结构的指针，从而避免在 entrypoint 中需要修改叠加寄存器 RSP 的指令。</span></span><br><span class="line"><span class="comment">    注意 CONTEXT 指针和栈本身必须按照 16 字节对齐，以保证与 AMD64 架构的 ABI 兼容性。</span></span><br><span class="line"><span class="comment">    否则，诸如 RtlCaptureContext 将执行的 XMM 操作等操作将会失败。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">NT_ASSERT</span>( (KERNEL_STACK_SIZE - <span class="built_in">sizeof</span>( CONTEXT )) % <span class="number">16</span> == <span class="number">0</span> );</span><br><span class="line">    __vmx_vmwrite( HOST_RSP, (ULONG_PTR)VpData-&gt;VMMStack + KERNEL_STACK_SIZE - <span class="built_in">sizeof</span>( CONTEXT ) );</span><br><span class="line">    <span class="comment">// 将当前状态存储在栈中，并跳转到一个 C 函数 VmxpExitHandler 中去处理 VM 的 exit 事件</span></span><br><span class="line">    __vmx_vmwrite( HOST_RIP, (ULONG_PTR)VmxVMEntry );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="将GDT（全局描述符表）中的段信息转换为VMX（虚拟机扩展）所需的格式"><a href="#将GDT（全局描述符表）中的段信息转换为VMX（虚拟机扩展）所需的格式" class="headerlink" title="将GDT（全局描述符表）中的段信息转换为VMX（虚拟机扩展）所需的格式"></a>将GDT（全局描述符表）中的段信息转换为VMX（虚拟机扩展）所需的格式</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Fill segment data</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;GdtBase&quot;&gt;GDTR base&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Selector&quot;&gt;Segment selector value&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;VmxGdtEntry&quot;&gt;Resulting entry&lt;/param&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">VmxpConvertGdtEntry</span><span class="params">( IN PVOID GdtBase, IN USHORT Selector, OUT PVMX_GDTENTRY64 VmxGdtEntry )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    段选择子（segment selector）是用来唯一地标识一个内存段的16位或64位数字。</span></span><br><span class="line"><span class="comment">    在x86体系结构中，每个段选择子由两个部分组成：</span></span><br><span class="line"><span class="comment">    索引（index）和请求特权级别（requested privilege level，RPL）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    索引用于查找全局描述符表（GDT）或局部描述符表（LDT）中的段描述符，</span></span><br><span class="line"><span class="comment">    而RPL则指定了访问该段所需的最低权限级别（0到3）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RPL可以通过对段选择子进行屏蔽（掩码）来获取。具体来说，将段选择子与0b11（即二进制的3）进行按位与运算，可以得到RPL的值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    例如，如果段选择子为0x08，那么其二进制表示为0000 1000，其中低两位（00）即为RPL的值。如果需要将RPL屏蔽掉，</span></span><br><span class="line"><span class="comment">    可以使用按位与运算符&amp;和~操作数取反运算符来进行屏蔽：0x08 &amp; ~0b11 = 0x08 &amp; 0xFC = 0x08。</span></span><br><span class="line"><span class="comment">    需要注意的是，在64位模式下，只有GDT被使用，因此只需要考虑索引部分，而RPL位会被忽略。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在x64 Windows操作系统内核中，每个进程都有自己的全局描述符表（GDT），</span></span><br><span class="line"><span class="comment">    用于保存其自身内存分段的信息。在对内存进行分段时，可以使用一个16位的段选择子来唯一地标识一个内存段。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    读取给定选择子（segment selector）的GDT条目，并屏蔽掉请求特权级别（requested privilege level，RPL）位。</span></span><br><span class="line"><span class="comment">    因为x64Windows在内核态下已经不使用局部描述符表（LDT），所以不需要考虑TI位（Table Indicator），它用于区分是引用GDT还是LDT。</span></span><br><span class="line"><span class="comment">    TI位（Table Indicator）是段选择子的一个位，用于指示该选择子所引用的描述符表是GDT还是LDT。TI位的取值为0或1，其中0表示引用GDT，1表示引用LDT。</span></span><br><span class="line"><span class="comment">    TI位则占据了选择子的第2位，因此选择子的最高有效位为TI位。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    在x64模式下，每个选择子由两个部分组成：索引部分和RPL部分。索引部分用于查找GDT中的相应段描述符，</span></span><br><span class="line"><span class="comment">    而RPL则指定了访问该段的权限级别。RPL通常会和当前运行代码的特权级别进行比较，以确定访问是否被允许。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    在Windows内核中，0和3级特权级别都可以引用内核GDT中的所有段描述符，因此不需要进行RPL屏蔽。</span></span><br><span class="line"><span class="comment">    但是，在某些情况下，为了安全起见，可能会使用引用GDT的低特权级别来访问只有高特权级别才能访问的内存段。</span></span><br><span class="line"><span class="comment">    在这种情况下，需要进行RPL屏蔽来确保代码可以访问相应的内存段。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 屏蔽RPL位</span></span><br><span class="line">    PKGDTENTRY64 gdtEntry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">NT_ASSERT</span>( (Selector &amp; SELECTOR_TABLE_INDEX) == <span class="number">0</span> );</span><br><span class="line">    gdtEntry = (PKGDTENTRY64)((ULONG_PTR)GdtBase + (Selector &amp; ~RPL_MASK));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将传入的段选择子赋值给VMX_GDTENTRY64结构体的Selector字段</span></span><br><span class="line">    VmxGdtEntry-&gt;Selector = Selector;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用LSL指令（Load Segment Limit）读取段限制（segment limit）。</span></span><br><span class="line">    VmxGdtEntry-&gt;Limit = __segmentlimit( Selector );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在x86体系结构中，段描述符中的“System”位（也称为“S”位）用于区分系统段和代码/数据段。</span></span><br><span class="line"><span class="comment">    当“System”位被清除时（即为0），表示这是一个代码段或数据段，需要对相对虚拟地址（RVA）进行地址计算。</span></span><br><span class="line"><span class="comment">    将段基址与RVA相加，构建完整的64位有效地址。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    对于非系统段，需要进行以下步骤来构建完整的64位线性地址：</span></span><br><span class="line"><span class="comment">        将段基址与RVA相加，得到32位的线性地址。</span></span><br><span class="line"><span class="comment">        将线性地址的高32位与段选择子中的基地址合并，构建出64位的线性地址。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    需要注意的是，在Windows操作系统中，KGDTENTRY64结构中的“System”字段位置被定义错误了，</span></span><br><span class="line"><span class="comment">    实际上，“System”位应该编码在“Type”字段的最高位。这意味着在Windows内核中计算64位地址时需要特别小心，</span></span><br><span class="line"><span class="comment">    以确保不会使用错误的字段。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    根据GDT中的字段信息，构建完整的64位有效地址。需要注意的是，只有当Type字段中的System位为0时才进行构建。</span></span><br><span class="line"><span class="comment">    构建过程分为三部分：将BaseHigh字段左移24位，将BaseMiddle字段左移16位，将BaseLow字段保持不变，</span></span><br><span class="line"><span class="comment">    并使用逻辑或运算符组合它们。如果Type字段中的最高位为0，</span></span><br><span class="line"><span class="comment">    则还需要将BaseUpper字段左移32位并与之前的结果进行逻辑或运算。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    VmxGdtEntry-&gt;Base = ((gdtEntry-&gt;Bytes.BaseHigh &lt;&lt; <span class="number">24</span>) | (gdtEntry-&gt;Bytes.BaseMiddle &lt;&lt; <span class="number">16</span>) | (gdtEntry-&gt;BaseLow)) &amp; MAXULONG;</span><br><span class="line">    VmxGdtEntry-&gt;Base |= ((gdtEntry-&gt;Bits.Type &amp; <span class="number">0x10</span>) == <span class="number">0</span>) ? ((ULONG_PTR)gdtEntry-&gt;BaseUpper &lt;&lt; <span class="number">32</span>) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载访问权限信息</span></span><br><span class="line">    VmxGdtEntry-&gt;AccessRights = <span class="number">0</span>;</span><br><span class="line">    VmxGdtEntry-&gt;Bytes.Flags1 = gdtEntry-&gt;Bytes.Flags1;</span><br><span class="line">    VmxGdtEntry-&gt;Bytes.Flags2 = gdtEntry-&gt;Bytes.Flags2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理VMX相关的位</span></span><br><span class="line">    VmxGdtEntry-&gt;Bits.Reserved = <span class="number">0</span>;</span><br><span class="line">    VmxGdtEntry-&gt;Bits.Unusable = !gdtEntry-&gt;Bits.Present;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="将当前状态存储在栈中，并跳转到一个-C-函数-VmxpExitHandler-中去处理-VM-的-exit-事件"><a href="#将当前状态存储在栈中，并跳转到一个-C-函数-VmxpExitHandler-中去处理-VM-的-exit-事件" class="headerlink" title="将当前状态存储在栈中，并跳转到一个 C 函数 VmxpExitHandler 中去处理 VM 的 exit 事件"></a>将当前状态存储在栈中，并跳转到一个 C 函数 VmxpExitHandler 中去处理 VM 的 exit 事件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">VmxVMEntry PROC</span><br><span class="line">    push    rcx                 ; save RCX, as we will need to orverride it</span><br><span class="line">    lea     rcx, [rsp+8h]       ; store the context in the stack, bias for</span><br><span class="line">                                ; the return address and the push we just did.</span><br><span class="line">    call    RtlCaptureContext   ; save the current register state.</span><br><span class="line">                                ; note that this is a specially written function</span><br><span class="line">                                ; which has the following key characteristics:</span><br><span class="line">                                ;   1) it does not taint the value of RCX</span><br><span class="line">                                ;   2) it does not spill any registers, nor</span><br><span class="line">                                ;      expect home space to be allocated for it</span><br><span class="line"></span><br><span class="line">    jmp     VmxpExitHandler     ; jump to the C code handler. we assume that it</span><br><span class="line">                                ; compiled with optimizations and does not use</span><br><span class="line">                                ; home space, which is true of release builds.</span><br><span class="line">VmxVMEntry ENDP</span><br></pre></td></tr></table></figure>

<h5 id="初始化EPT，创建Guest到Host的页映射（Page-Mappings）"><a href="#初始化EPT，创建Guest到Host的页映射（Page-Mappings）" class="headerlink" title="初始化EPT，创建Guest到Host的页映射（Page Mappings）"></a>初始化EPT，创建Guest到Host的页映射（Page Mappings）</h5><p><img src="/.com//20200404211829769.jpeg" alt="在这里插入图片描述"></p>
<p>为了解决GVA-GPA-HPA的转换关系，在没有硬件辅助的时代，Hypervisor通过影子页表，很巧妙的将GVA-GPA映射到GVA-HPA, 功能虽然达成，但是在很多实际场景下，如进程频繁切换，内存频繁分配释放等，性能损耗会非常大；</p>
<p>EPT在硬件的帮助下，实现内存虚拟化简单直接，传统页表继续负责GVA-GPA, 而EPT负责GPA-HPA; 虽然内存访问延时可能会增加一些，但是大幅减少了因为页表更新带来的vmexit, 综合性价比提升巨大, 所以现代内存虚拟化，基本都被EPT统一了。</p>
<p><img src="https://pic1.zhimg.com/80/v2-121b31dd73963473ebb0ea19ea59bef4_720w.webp" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Create Guest to Host page mappings</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pEPT&quot;&gt;CPU EPT data&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">EptBuildIdentityMap</span><span class="params">( IN PEPT_DATA pEPT )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pEPT-&gt;PML4Ptr != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_SUCCESS;<span class="comment">// 已经创建过</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    PML4（Page Map Level 4）是 x86 架构中分页机制的一级页表。</span></span><br><span class="line"><span class="comment">    在 x86 架构的分页机制中，物理内存被划分为固定大小的页面（通常为4KB）。</span></span><br><span class="line"><span class="comment">    为了管理这些页面，操作系统使用页表来建立虚拟地址与物理地址之间的映射关系。</span></span><br><span class="line"><span class="comment">    页表被组织为一个多级结构，其中 PML4 是最高级的页表。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    PML4 是一个包含512个表项的数组，每个表项（PML4 Entry）的大小为8字节。</span></span><br><span class="line"><span class="comment">    每个表项对应着一个 PDP（Page Directory Pointer）表，PDP 表进一步将虚拟地址映射到下一级的页表，</span></span><br><span class="line"><span class="comment">    直到最后一级页表（称为页表 PDT）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    通过多级的页表结构，操作系统可以灵活地管理大量的内存页面，并实现虚拟地址到物理地址的映射。</span></span><br><span class="line"><span class="comment">    PML4 负责管理最高级的页表，它的物理地址必须在处理器的控制寄存器（CR3）中设置，</span></span><br><span class="line"><span class="comment">    以使处理器能够正确进行地址转换。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    pEPT-&gt;PML4Ptr = (PEPT_PML4_ENTRY)<span class="built_in">EptpAllocatePage</span>( pEPT );<span class="comment">// 分配一个页面作为PML4表表项</span></span><br><span class="line">    <span class="keyword">if</span> (pEPT-&gt;PML4Ptr == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;<span class="comment">// 错误则表示内存资源不足</span></span><br><span class="line"></span><br><span class="line">    NTSTATUS status = <span class="built_in">EptpFillTable</span>( pEPT, pEPT-&gt;PML4Ptr );<span class="comment">// 填充PML4表，创建其他级别的页表和映射关系</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>( status ))</span><br><span class="line">        <span class="built_in">EptFreeIdentityMap</span>( pEPT );<span class="comment">// 创建失败则释放资源</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//DPRINT( &quot;HyperBone: CPU %d: %s: Used pages %d\n&quot;, CPU_IDX, __FUNCTION__, pEPT-&gt;TotalPages );</span></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="分配EPT页面"><a href="#分配EPT页面" class="headerlink" title="分配EPT页面"></a>分配EPT页面</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Allocate page for PTE table</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pEPT&quot;&gt;CPU EPT data&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Allocated page or NULL&lt;/returns&gt;</span></span><br><span class="line"><span class="function">PEPT_MMPTE <span class="title">EptpAllocatePage</span><span class="params">( IN PEPT_DATA pEPT )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    IRQL（Interrupt Request Level）是Windows操作系统中用于表示中断请求的优先级的概念。</span></span><br><span class="line"><span class="comment">    它用于控制不同中断的处理顺序，以确保系统正常运行并防止冲突。</span></span><br><span class="line"><span class="comment">    在Windows内核中，存在多个不同的IRQL级别，从最低的PASSIVE_LEVEL到最高的HIGH_LEVEL。</span></span><br><span class="line"><span class="comment">    较低的IRQL级别表示较低的中断优先级，而较高的IRQL级别表示较高的中断优先级。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    例程（Routine）是指一段代码或函数，通常用于执行特定的任务或功能。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    检查当前IRQL是否大于DISPATCH_LEVEL，如果大于意味着在此级别以上的中断处理程序中，</span></span><br><span class="line"><span class="comment">    使用内存分配例程会发生错误，因此直接调用高IRQL情况下的页面分配函数。 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">KeGetCurrentIrql</span>() &gt; DISPATCH_LEVEL)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">EptpAllocatePageHighIRQL</span>( pEPT );</span><br><span class="line"></span><br><span class="line">    PHYSICAL_ADDRESS Highest = &#123; <span class="number">0</span> &#125;, Lowest = &#123; <span class="number">0</span> &#125;;<span class="comment">// 物理地址</span></span><br><span class="line">    Highest.QuadPart = ~<span class="number">0</span>;<span class="comment">// 全部置为1，设为最大物理地址</span></span><br><span class="line">    <span class="comment">// 分配连续的、指定缓存类型的内存页面，页面大小为PAGE_SIZE(4kb)</span></span><br><span class="line">    PEPT_MMPTE ptr = (PEPT_MMPTE)<span class="built_in">MmAllocateContiguousMemorySpecifyCache</span>( PAGE_SIZE, Lowest, Highest, Lowest, MmNonCached );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功分配 Save page ptr in array</span></span><br><span class="line">    <span class="keyword">if</span> (ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        pEPT-&gt;TotalPages++;<span class="comment">// 增加已分配页面数量</span></span><br><span class="line">        <span class="built_in">RtlZeroMemory</span>( ptr, PAGE_SIZE );</span><br><span class="line"></span><br><span class="line">        BOOLEAN allocEntry = FALSE;</span><br><span class="line">        PEPT_PAGES_ENTRY pEntry = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">IsListEmpty</span>( &amp;pEPT-&gt;PageList ))<span class="comment">// 检查EPT页链表是否为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            allocEntry = TRUE;<span class="comment">// 需要分配一个新的列表入口</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pEntry = <span class="built_in">CONTAINING_RECORD</span>( pEPT-&gt;PageList.Flink, EPT_PAGES_ENTRY, link );</span><br><span class="line">            <span class="keyword">if</span> (pEntry-&gt;count &gt;= PAGES_PER_ENTRY)<span class="comment">// 检查当前列表入口是否已满</span></span><br><span class="line">                allocEntry = TRUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (allocEntry)<span class="comment">// 需要分配一个新的列表入口</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从指定NonPagedPoolNx内存池中分配内存，大小为EPT_PAGES_ENTRY结构体大小</span></span><br><span class="line">            pEntry = <span class="built_in">ExAllocatePoolWithTag</span>( NonPagedPoolNx, <span class="built_in">sizeof</span>( EPT_PAGES_ENTRY ), HB_POOL_TAG );</span><br><span class="line">            <span class="keyword">if</span> (pEntry == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: Failed to allocate EPT_PAGES_ENTRY struct\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">RtlZeroMemory</span>( pEntry, <span class="built_in">sizeof</span>( EPT_PAGES_ENTRY ) );</span><br><span class="line">            pEntry-&gt;pages[pEntry-&gt;count] = ptr;</span><br><span class="line">            pEntry-&gt;count++;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">InsertHeadList</span>( &amp;pEPT-&gt;PageList, &amp;pEntry-&gt;link );<span class="comment">// 将新的列表入口插到EPT页链表头部</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 不需要分配，直接记录</span></span><br><span class="line">            pEntry-&gt;pages[pEntry-&gt;count] = ptr;</span><br><span class="line">            pEntry-&gt;count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: Failed to allocate EPT page\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        <span class="built_in">ASSERT</span>( FALSE );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="在更高级的IRQL申请页面"><a href="#在更高级的IRQL申请页面" class="headerlink" title="-在更高级的IRQL申请页面"></a>-在更高级的IRQL申请页面</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Allocate page at IRQL &gt; DISPATCH_LEVEL</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pEPT&quot;&gt;CPU EPT data&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Allocated page or NULL&lt;/returns&gt;</span></span><br><span class="line"><span class="function">PEPT_MMPTE <span class="title">EptpAllocatePageHighIRQL</span><span class="params">( IN PEPT_DATA pEPT )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查预分配页面数量是否小于预分配页面数量上限</span></span><br><span class="line">    <span class="keyword">if</span> (pEPT-&gt;Preallocations &lt; EPT_PREALLOC_PAGES)</span><br><span class="line">    &#123;</span><br><span class="line">        PEPT_MMPTE ptr = pEPT-&gt;Pages[pEPT-&gt;Preallocations];<span class="comment">// 将预分配页面数组中的下一个页面指针赋给ptr</span></span><br><span class="line">        pEPT-&gt;Preallocations++;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有页面可以分配，触发蓝屏</span></span><br><span class="line">    <span class="built_in">KeBugCheckEx</span>( HYPERVISOR_ERROR, BUG_CHECK_EPT_NO_PAGES, pEPT-&gt;Preallocations, EPT_PREALLOC_PAGES, <span class="number">0</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="根据已使用的物理区域填充-PML4-表"><a href="#根据已使用的物理区域填充-PML4-表" class="headerlink" title="根据已使用的物理区域填充 PML4 表"></a>根据已使用的物理区域填充 PML4 表</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Fill PML4 table accordingly to used physical regions</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pEPT&quot;&gt;CPU EPT data&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;PML4Ptr&quot;&gt;EPT PML4 pointer&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">EptpFillTable</span><span class="params">( IN PEPT_DATA pEPT, IN PEPT_PML4_ENTRY PML4Ptr )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">NT_ASSERT</span>( PML4Ptr != <span class="literal">NULL</span> );<span class="comment">// 断言PML4Ptr不为空</span></span><br><span class="line">    <span class="keyword">if</span> (PML4Ptr == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line">    <span class="comment">// 遍历已使用的物理内存区域填充PML4表</span></span><br><span class="line">    <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; g_Data-&gt;Memory-&gt;NumberOfRuns; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 计算该物理区域可用于填充表的页数，取总页数和EPT表项数的最小值</span></span><br><span class="line">        ULONG64 first = g_Data-&gt;Memory-&gt;Run[i].BasePage;</span><br><span class="line">        ULONG64 total = g_Data-&gt;Memory-&gt;Run[i].PageCount;</span><br><span class="line">        ULONG64 count = <span class="built_in">min</span>( total, EPT_TABLE_ENTRIES - (first &amp; (EPT_TABLE_ENTRIES - <span class="number">1</span>)) );</span><br><span class="line">       <span class="comment">// 初始化物理页帧号为first</span></span><br><span class="line">        ULONG64 hostPFN = first;</span><br><span class="line">        <span class="keyword">for</span> (ULONG64 pfn = first; total &gt; <span class="number">0</span>;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 嵌套调用EptUpdateTableRecursive函数，填充PML4表</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>( <span class="built_in">EptUpdateTableRecursive</span>( pEPT, PML4Ptr, EPT_TOP_LEVEL, pfn, EPT_ACCESS_ALL, hostPFN, (ULONG)count ) ))</span><br><span class="line">                <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">            <span class="comment">// 更新pfn、hostPFN和total</span></span><br><span class="line">            pfn += count; </span><br><span class="line">            hostPFN += count;</span><br><span class="line">            total -= count;</span><br><span class="line">            count = <span class="built_in">min</span>( total, EPT_TABLE_ENTRIES - (pfn &amp; (EPT_TABLE_ENTRIES - <span class="number">1</span>)) );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*for (ULONG64 pfn = 0; pfn &lt;= 0xFEE00; pfn += EPT_TABLE_ENTRIES, hostPFN += EPT_TABLE_ENTRIES)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if (!NT_SUCCESS( EptUpdateTableRecursive( PML4Ptr, 3, pfn, EPT_ACCESS_ALL, hostPFN, EPT_TABLE_ENTRIES ) ))</span></span><br><span class="line"><span class="comment">            return STATUS_UNSUCCESSFUL;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="递归更新EPT表项"><a href="#递归更新EPT表项" class="headerlink" title="-递归更新EPT表项"></a>-递归更新EPT表项</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Update EPT entry</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pEPTData&quot;&gt;CPU EPT data&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pTable&quot;&gt;EPT table&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;level&quot;&gt;EPT table level&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pfn&quot;&gt;Page frame number to update&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;access&quot;&gt;New PFN access&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;hostPFN&quot;&gt;New hot PFN&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;count&quot;&gt;Number of entries to update&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">EptUpdateTableRecursive</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">    IN PEPT_DATA pEPTData,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN PEPT_MMPTE pTable,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN EPT_TABLE_LEVEL level,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN ULONG64 pfn,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN UCHAR access,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN ULONG64 hostPFN,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN ULONG count</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (level == EPT_LEVEL_PTE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// PTE表示已递归到最底层</span></span><br><span class="line">        <span class="comment">// 避免越界</span></span><br><span class="line">        ULONG64 first = <span class="built_in">EptpTableOffset</span>( pfn, level );</span><br><span class="line">        <span class="built_in">ASSERT</span>( first + count &lt;= EPT_TABLE_ENTRIES );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据访问权限设置对应字段</span></span><br><span class="line">        PEPT_PTE_ENTRY pPTE = (PEPT_PTE_ENTRY)pTable;</span><br><span class="line">        <span class="keyword">for</span> (ULONG64 i = first; i &lt; first + count; i++, hostPFN++)        </span><br><span class="line">        &#123;</span><br><span class="line">            pPTE[i].Fields.Read       = (access &amp; EPT_ACCESS_READ)  != <span class="number">0</span>;</span><br><span class="line">            pPTE[i].Fields.Write      = (access &amp; EPT_ACCESS_WRITE) != <span class="number">0</span>;</span><br><span class="line">            pPTE[i].Fields.Execute    = (access &amp; EPT_ACCESS_EXEC)  != <span class="number">0</span>;</span><br><span class="line">            pPTE[i].Fields.MemoryType = VMX_MEM_TYPE_WRITEBACK;</span><br><span class="line">            pPTE[i].Fields.PhysAddr   = hostPFN;<span class="comment">// 物理地址字段为hostPFN</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ULONG64 offset = <span class="built_in">EptpTableOffset</span>( pfn, level );<span class="comment">// 计算要更新的 EPT 表项在指定表中的偏移量</span></span><br><span class="line">    PEPT_MMPTE pEPT = &amp;pTable[offset];<span class="comment">// 要更新的 EPT 表中的具体表项</span></span><br><span class="line">    PEPT_MMPTE pNewEPT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pEPT-&gt;Fields.PhysAddr == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 表示该表项未分配页面，需要分配一个页面</span></span><br><span class="line">        pNewEPT = (PEPT_MMPTE)<span class="built_in">EptpAllocatePage</span>( pEPTData );</span><br><span class="line">        <span class="keyword">if</span> (pNewEPT == <span class="literal">NULL</span>)          </span><br><span class="line">            <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">        <span class="comment">// 设置表示存在，可写，可执行和物理地址</span></span><br><span class="line">        pEPT-&gt;Fields.Present  = <span class="number">1</span>;</span><br><span class="line">        pEPT-&gt;Fields.Write    = <span class="number">1</span>;</span><br><span class="line">        pEPT-&gt;Fields.Execute  = <span class="number">1</span>;</span><br><span class="line">        pEPT-&gt;Fields.PhysAddr = <span class="built_in">PFN</span>( <span class="built_in">MmGetPhysicalAddress</span>( pNewEPT ).QuadPart );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 表示该表项已分配页面，通过物理地址获取其虚拟地址</span></span><br><span class="line">        PHYSICAL_ADDRESS phys = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        phys.QuadPart = pEPT-&gt;Fields.PhysAddr &lt;&lt; <span class="number">12</span>;</span><br><span class="line">        pNewEPT = <span class="built_in">MmGetVirtualForPhysical</span>( phys );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">EptUpdateTableRecursive</span>( pEPTData, pNewEPT, level - <span class="number">1</span>, pfn, access, hostPFN, count );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="–计算-EPT-表项索引（Table-Index）"><a href="#–计算-EPT-表项索引（Table-Index）" class="headerlink" title="–计算 EPT 表项索引（Table Index）"></a>–计算 EPT 表项索引（Table Index）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// EPT entry index in table</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pfn&quot;&gt;EPT PFN&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;level&quot;&gt;EPT level&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Table index&lt;/returns&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ULONG64 <span class="title">EptpTableOffset</span><span class="params">( IN ULONG64 pfn, IN CHAR level )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    首先定义一个掩码（mask），用于提取指定层级的表项索引。</span></span><br><span class="line"><span class="comment">    这里使用位运算来生成掩码，具体生成方式为 1 左移 ((level + 1) * EPT_TABLE_ORDER) 位，然后减去 1，</span></span><br><span class="line"><span class="comment">    得到了一个所有位都置为 1 的掩码。</span></span><br><span class="line"><span class="comment">    将掩码与 PFN 进行按位与操作，目的是提取出指定层级的表项索引。</span></span><br><span class="line"><span class="comment">    按位与操作会将掩码中相应位为 0 的位置上的 PFN 位也设置为 0，从而提取出表项索引。</span></span><br><span class="line"><span class="comment">    最后，将提取出的表项索引右移 (level * EPT_TABLE_ORDER) 位，将其放置在正确的位置上，并作为函数返回值。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ULONG64 mask = (<span class="number">1ULL</span> &lt;&lt; ((level + <span class="number">1</span>) * EPT_TABLE_ORDER)) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (pfn &amp; mask) &gt;&gt; (level * EPT_TABLE_ORDER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="在CPU上开启EPT"><a href="#在CPU上开启EPT" class="headerlink" title="在CPU上开启EPT"></a>在CPU上开启EPT</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Enable EPT for CPU</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;PML4&quot;&gt;PML4 pointer to use&lt;/param&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">EptEnable</span><span class="params">( IN PEPT_PML4_ENTRY PML4 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    基本CPU执行控制是一组CPU执行控制位，用于控制处理器在VMX操作期间的行为。</span></span><br><span class="line"><span class="comment">    这些控制位包括启用VMX操作、允许或阻止对VMCS的加载或存储、中断虚拟化、启用或禁用NMI虚拟化、</span></span><br><span class="line"><span class="comment">    读取或屏蔽虚拟-NMI信息等。这些控制位可通过VMXON指令设置，</span></span><br><span class="line"><span class="comment">    也可以通过VMClear和VMLaunch指令清除并重新加载来更新。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    二级CPU执行控制是一组掩码，用于启用或禁用一组次要的、特殊的、可选的处理器功能。</span></span><br><span class="line"><span class="comment">    这些控制位包括启用或禁用EPT、启用或禁用VPID、启用或禁用虚拟处理器退出控制、启用或禁用VMFUNC指令、</span></span><br><span class="line"><span class="comment">    CR3传递、IO位图中断虚拟化、APIC虚拟化等。</span></span><br><span class="line"><span class="comment">    这些控制位可以通过设置MSR IA32_VMX_PROCBASED_CTLS2寄存器来更新。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    VMX_CPU_BASED_CONTROLS primary = &#123; <span class="number">0</span> &#125;;<span class="comment">// 基本CPU执行控制</span></span><br><span class="line">    VMX_SECONDARY_CPU_BASED_CONTROLS secondary = &#123; <span class="number">0</span> &#125;;<span class="comment">// 二级CPU执行控制</span></span><br><span class="line">    EPT_TABLE_POINTER EPTP = &#123; <span class="number">0</span> &#125;;<span class="comment">// EPT指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取相应寄存器的值</span></span><br><span class="line">    __vmx_vmread( SECONDARY_VM_EXEC_CONTROL, (<span class="type">size_t</span>*)&amp;secondary.All );</span><br><span class="line">    __vmx_vmread( CPU_BASED_VM_EXEC_CONTROL, (<span class="type">size_t</span>*)&amp;primary.All );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置EPTP（EPT表指针）的字段值。</span></span><br><span class="line">    <span class="comment">// 将EPTP的物理地址字段设置为PML4的物理地址（MmGetPhysicalAddress(PML4)），并将其右移12位（相当于除以4096），</span></span><br><span class="line">    <span class="comment">// 以获取正确的页帧号。将页表的长度设置为3，表示EPT有4级表（PML4、PDPT、PD和PT）。</span></span><br><span class="line">    EPTP.Fields.PhysAddr = <span class="built_in">MmGetPhysicalAddress</span>( PML4 ).QuadPart &gt;&gt; <span class="number">12</span>;</span><br><span class="line">    EPTP.Fields.PageWalkLength = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将EPTP的值写入EPT_POINTER VMCS字段中，以启用EPT。</span></span><br><span class="line">    __vmx_vmwrite( EPT_POINTER, EPTP.All );</span><br><span class="line">    <span class="comment">// 将虚拟处理器标识符（VPID）写入VMCS中，以启用VPID。</span></span><br><span class="line">    __vmx_vmwrite( VIRTUAL_PROCESSOR_ID, VM_VPID );</span><br><span class="line"></span><br><span class="line">    primary.Fields.ActivateSecondaryControl = TRUE;<span class="comment">// 激活二级CPU执行控制</span></span><br><span class="line">    secondary.Fields.EnableEPT = TRUE;<span class="comment">// 启用EPT</span></span><br><span class="line">    <span class="keyword">if</span>(g_Data-&gt;Features.VPID)</span><br><span class="line">        secondary.Fields.EnableVPID = TRUE;<span class="comment">// 启用VPID</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将更新后的值写入VMCS中</span></span><br><span class="line">    __vmx_vmwrite( SECONDARY_VM_EXEC_CONTROL, secondary.All );</span><br><span class="line">    __vmx_vmwrite( CPU_BASED_VM_EXEC_CONTROL, primary.All );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新EPT上下文，并从ctx拿到上下文信息</span></span><br><span class="line">    EPT_CTX ctx = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    __invept( INV_ALL_CONTEXTS, &amp;ctx );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DPRINT( &quot;HyperBone: CPU %d: %s: EPT enabled\n&quot;, CPU_NUM, __FUNCTION__ );</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="刷新EPT上下文"><a href="#刷新EPT上下文" class="headerlink" title="刷新EPT上下文"></a>刷新EPT上下文</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__invept PROC</span><br><span class="line">    invept rcx, OWORD PTR [rdx]</span><br><span class="line">    ret</span><br><span class="line">__invept ENDP</span><br></pre></td></tr></table></figure>

<h3 id="AMD-CPU-不支持"><a href="#AMD-CPU-不支持" class="headerlink" title="AMD CPU 不支持"></a>AMD CPU 不支持</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> VOID <span class="title">AMDSubvertCPU</span><span class="params">( IN PVCPU Vcpu, IN PVOID arg )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>( Vcpu );</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>( arg );</span><br><span class="line">    <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: AMD-V not yet supported\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="释放IntelCPU"><a href="#释放IntelCPU" class="headerlink" title="释放IntelCPU"></a>释放IntelCPU</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> VOID <span class="title">IntelRestoreCPU</span><span class="params">( IN PVCPU Vcpu )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Prevent execution of VMCALL on non-vmx CPU</span></span><br><span class="line">    <span class="keyword">if</span> (Vcpu-&gt;VmxState &gt; VMX_STATE_OFF)</span><br><span class="line">        <span class="built_in">VmxShutdown</span>( Vcpu );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="从根模式切换回非根模式"><a href="#从根模式切换回非根模式" class="headerlink" title="从根模式切换回非根模式"></a>从根模式切换回非根模式</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Revert CPU to non-root mode</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Vcpu&quot;&gt;Virtual CPU data&lt;/param&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">VmxShutdown</span><span class="params">( IN PVCPU Vcpu )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//DPRINT( &quot;HyperBone: CPU %d: %s: CR3 load count %d\n&quot;, CPU_IDX, __FUNCTION__, Vcpu-&gt;Cr3Loads );</span></span><br><span class="line"></span><br><span class="line">    __vmx_vmcall( HYPERCALL_UNLOAD, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> );<span class="comment">// 通知VMM卸载所加载的虚拟机</span></span><br><span class="line">    <span class="built_in">VmxVMCleanup</span>( KGDT64_R3_DATA | RPL_MASK, KGDT64_R3_CMTEB | RPL_MASK );<span class="comment">// 清除VMX相关设置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放EPT的身份映射</span></span><br><span class="line">    <span class="built_in">EptFreeIdentityMap</span>( &amp;Vcpu-&gt;EPT );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放数据结构VMXON、VMCS和VMM堆栈内存</span></span><br><span class="line">    <span class="keyword">if</span> (Vcpu-&gt;VMXON)</span><br><span class="line">        <span class="built_in">MmFreeContiguousMemory</span>( Vcpu-&gt;VMXON );</span><br><span class="line">    <span class="keyword">if</span> (Vcpu-&gt;VMCS)</span><br><span class="line">        <span class="built_in">MmFreeContiguousMemory</span>( Vcpu-&gt;VMCS );</span><br><span class="line">    <span class="keyword">if</span> (Vcpu-&gt;VMMStack)</span><br><span class="line">        <span class="built_in">MmFreeContiguousMemory</span>( Vcpu-&gt;VMMStack );</span><br><span class="line"></span><br><span class="line">    Vcpu-&gt;VMXON = <span class="literal">NULL</span>;</span><br><span class="line">    Vcpu-&gt;VMCS = <span class="literal">NULL</span>;</span><br><span class="line">    Vcpu-&gt;VMMStack = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="通知VMM"><a href="#通知VMM" class="headerlink" title="通知VMM"></a>通知VMM</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__vmx_vmcall PROC</span><br><span class="line">    vmcall</span><br><span class="line">    ret</span><br><span class="line">__vmx_vmcall ENDP</span><br></pre></td></tr></table></figure>

<h5 id="清除VMX相关设置"><a href="#清除VMX相关设置" class="headerlink" title="清除VMX相关设置"></a>清除VMX相关设置</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VmxVMCleanup PROC</span><br><span class="line">    mov     ds, cx              ; set DS to parameter 1</span><br><span class="line">    mov     es, cx              ; set ES to parameter 1</span><br><span class="line">    mov     fs, dx              ; set FS to parameter 2</span><br><span class="line">    ret                         ; return</span><br><span class="line">VmxVMCleanup ENDP</span><br></pre></td></tr></table></figure>

<h5 id="释放EPT的身份映射"><a href="#释放EPT的身份映射" class="headerlink" title="释放EPT的身份映射"></a>释放EPT的身份映射</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Release Guest to Host page mappings</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pEPT&quot;&gt;CPU EPT data&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">EptFreeIdentityMap</span><span class="params">( IN PEPT_DATA pEPT )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查PML4表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (pEPT-&gt;PML4Ptr == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放PML4表</span></span><br><span class="line">    pEPT-&gt;PML4Ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 循环释放EPT页链表中每个表项的所有页面</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">IsListEmpty</span>( &amp;pEPT-&gt;PageList ))</span><br><span class="line">    &#123;</span><br><span class="line">        PLIST_ENTRY pListEntry = pEPT-&gt;PageList.Flink;</span><br><span class="line">        <span class="comment">// 获取列表入口的地址 从结构的成员指针得到结构的起始地址</span></span><br><span class="line">        PEPT_PAGES_ENTRY pEntry = <span class="built_in">CONTAINING_RECORD</span>( pListEntry, EPT_PAGES_ENTRY, link );</span><br><span class="line">        <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; pEntry-&gt;count; i++)</span><br><span class="line">            <span class="comment">// 释放表项的每个页面</span></span><br><span class="line">            <span class="keyword">if</span> (pEntry-&gt;pages[i] != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">MmFreeContiguousMemory</span>( pEntry-&gt;pages[i] );</span><br><span class="line">        <span class="comment">// 移除当前表项，并释放内存空间</span></span><br><span class="line">        <span class="built_in">RemoveEntryList</span>( pListEntry );</span><br><span class="line">        <span class="built_in">ExFreePoolWithTag</span>( pListEntry, HB_POOL_TAG );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示释放了预分配的内存空间</span></span><br><span class="line">    pEPT-&gt;Preallocations = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AMD不支持"><a href="#AMD不支持" class="headerlink" title="AMD不支持"></a>AMD不支持</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> VOID <span class="title">AMDRestoreCPU</span><span class="params">( IN PVCPU Vcpu )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>( Vcpu );</span><br><span class="line">    <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: AMD-V not yet supported\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="停止虚拟化"><a href="#停止虚拟化" class="headerlink" title="停止虚拟化"></a>停止虚拟化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Devirtualize each CPU</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">StopHV</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Unknown CPU</span></span><br><span class="line">	<span class="keyword">if</span> (g_Data-&gt;CPUVendor == CPU_Other)</span><br><span class="line">		<span class="keyword">return</span> STATUS_NOT_SUPPORTED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果在当前的上下文中调用 KeGenericCallDpc 并将当前线程切换到另一个处理器上执行回调函数，可能会导致死锁。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    死锁是指两个或多个线程互相等待对方所持有的资源。在这种情况下，如果回调函数依赖于当前线程的某些资源，</span></span><br><span class="line"><span class="comment">    并且该资源在其他处理器上被另一个线程持有，那么当前线程会一直等待资源释放，从而导致死锁。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    为了避免潜在的死锁风险，作者决定屏蔽调用 KeGenericCallDpc 函数的代码，</span></span><br><span class="line"><span class="comment">    并采用其他方式来停止虚拟化的每个CPU。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="comment">// KeGenericCallDpc( HvmpHVCallbackDPC, NULL ); there will be Dead Lock</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取系统中活动处理器的数量，并循环依次处理每个处理器</span></span><br><span class="line">	ULONG number_of_processors = <span class="built_in">KeQueryActiveProcessorCountEx</span>(ALL_PROCESSOR_GROUPS);</span><br><span class="line">	<span class="keyword">for</span> (ULONG processor_index = <span class="number">0</span>; processor_index &lt; number_of_processors; processor_index++) &#123;</span><br><span class="line">		PROCESSOR_NUMBER processor_number;</span><br><span class="line">		<span class="built_in">RtlZeroMemory</span>(&amp;processor_number, <span class="built_in">sizeof</span>(PROCESSOR_NUMBER));</span><br><span class="line">        <span class="comment">// 获取当前处理器的PROCESSOR_NUMBER处理器编号结构体</span></span><br><span class="line">		NTSTATUS status = <span class="built_in">KeGetProcessorNumberFromIndex</span>(processor_index, &amp;processor_number);</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">DbgBreakPoint</span>();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Switch the current processor</span></span><br><span class="line">		GROUP_AFFINITY affinity;</span><br><span class="line">		<span class="built_in">RtlZeroMemory</span>(&amp;affinity, <span class="built_in">sizeof</span>(GROUP_AFFINITY));</span><br><span class="line">        <span class="comment">// 表示将当前处理器作为目标处理器</span></span><br><span class="line">		affinity.Group = processor_number.Group;</span><br><span class="line">		affinity.Mask = <span class="number">1ull</span> &lt;&lt; processor_number.Number;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        系统组亲和性（System Group Affinity）是一种将线程限制在特定处理器组上运行的机制。</span></span><br><span class="line"><span class="comment">        在支持 NUMA（非统一内存访问）的系统中，处理器分为多个组，每个组具有自己的本地内存和其他资源。</span></span><br><span class="line"><span class="comment">        通过设置线程的系统组亲和性，可以使线程优先在特定的处理器组上运行，以提高性能和资源的局部性。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        KeSetSystemGroupAffinityThread 函数用于设置线程的系统组亲和性。它接受一个参数affinity，</span></span><br><span class="line"><span class="comment">        表示要设置的系统组亲和性信息。affinity 结构体中的字段包括 Mask 和 Group，</span></span><br><span class="line"><span class="comment">        分别表示处理器组掩码和组索引。通过调用该函数，可以将线程限制在指定的处理器组上运行。</span></span><br><span class="line"><span class="comment">        将原本的信息返回到previous_affinity</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        KeRevertToUserGroupAffinityThread 函数用于恢复线程的用户组亲和性。当线程的系统组亲和性被设置后，</span></span><br><span class="line"><span class="comment">        如果希望将其恢复为默认的用户组亲和性，则可以调用该函数。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        GROUP_AFFINITY previous_affinity;</span><br><span class="line">        <span class="built_in">RtlZeroMemory</span>(&amp;affinity, <span class="built_in">sizeof</span>(GROUP_AFFINITY));</span><br><span class="line">        <span class="comment">// 将当前线程切换到目标处理器</span></span><br><span class="line">		<span class="built_in">KeSetSystemGroupAffinityThread</span>(&amp;affinity, &amp;previous_affinity);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指向当前处理器的指针，停止该处理器的虚拟化</span></span><br><span class="line">		PVCPU pVCPU = &amp;g_Data-&gt;cpu_data[processor_index];</span><br><span class="line">		<span class="built_in">IntelRestoreCPU</span>(pVCPU);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前线程切换回原来的处理器</span></span><br><span class="line">		<span class="built_in">KeRevertToUserGroupAffinityThread</span>(&amp;previous_affinity);</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">DbgBreakPoint</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="开始测试"><a href="#开始测试" class="headerlink" title="开始测试"></a>开始测试</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">TestStart</span><span class="params">( IN BOOLEAN SyscallHook, IN BOOLEAN PageHook1, IN IN BOOLEAN PageHook2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PageHook1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">TestPageHook</span>();<span class="comment">// 测试页面钩子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试获取 NtClose 系统调用函数的地址，并将其保存到全局变量 g_NtClose 中。</span></span><br><span class="line">    g_NtClose = (PVOID)<span class="built_in">UtilSSDTEntry</span>( <span class="built_in">SSDTIndex</span>( &amp;ZwClose ) );</span><br><span class="line">    <span class="keyword">if</span> (g_NtClose)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果获取到</span></span><br><span class="line">        <span class="keyword">if</span> (SyscallHook)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>( <span class="built_in">SHInitHook</span>() ))<span class="comment">// 系统调用入口钩子</span></span><br><span class="line">                <span class="built_in">SHHookSyscall</span>( <span class="built_in">SSDTIndex</span>( &amp;ZwClose ), (PVOID)hkNtClose, <span class="number">1</span> );<span class="comment">// 将系统调用函数的地址与自定义hkNtClose进行钩子绑定</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: SHInitHook() failed\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PageHook2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (g_NtClose)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>( <span class="built_in">PHHook</span>( g_NtClose, (PVOID)hkNtClose2 ) ))<span class="comment">// 将全局系统调用函数的地址与自定义hkNtClose2进行钩子绑定</span></span><br><span class="line">                    <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: PHHook() failed\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: NtClose not found\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: NtClose not found\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试页面钩子"><a href="#测试页面钩子" class="headerlink" title="测试页面钩子"></a>测试页面钩子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">TestPageHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 缓冲区</span></span><br><span class="line">    UCHAR buf[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// TestFn函数地址</span></span><br><span class="line">    PVOID pFn = (PVOID)TestFn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制函数地址前16字节到缓冲区，调用TestFn函数</span></span><br><span class="line">    <span class="built_in">RtlCopyMemory</span>( buf, pFn, <span class="number">16</span> );</span><br><span class="line">    <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: Buffer contents: 0x%p, Call result 0x%X\n&quot;</span>, CPU_IDX, __FUNCTION__, *(PULONG64)buf, <span class="built_in">TestFn</span>( <span class="number">100</span>, <span class="number">5</span> ) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将pFn地址与hkTestFn函数进行钩子绑定</span></span><br><span class="line">    <span class="built_in">PHHook</span>( pFn, (PVOID)hkTestFn );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次复制函数地址前16字节到缓冲区</span></span><br><span class="line">    <span class="comment">// 此时钩子生效，调用TestFn函数时，实际上调用的是hkTestFn函数</span></span><br><span class="line">    <span class="built_in">RtlCopyMemory</span>( buf, pFn, <span class="number">16</span> );</span><br><span class="line">    <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: Buffer contents: 0x%p, Call result 0x%X\n&quot;</span>, CPU_IDX, __FUNCTION__, *(PULONG64)buf, <span class="built_in">TestFn</span>( <span class="number">100</span>, <span class="number">5</span> ) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复钩子</span></span><br><span class="line">    <span class="built_in">PHRestore</span>( pFn );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次复制函数地址前16字节到缓冲区，查看结果</span></span><br><span class="line">    <span class="built_in">RtlCopyMemory</span>( buf, pFn, <span class="number">16</span> );</span><br><span class="line">    <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: Buffer contents: 0x%p, Call result 0x%X\n&quot;</span>, CPU_IDX, __FUNCTION__, *(PULONG64)buf, <span class="built_in">TestFn</span>( <span class="number">100</span>, <span class="number">5</span> ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TestFn"><a href="#TestFn" class="headerlink" title="TestFn"></a>TestFn</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指示放在.text0段中</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> alloc_text(<span class="string">&quot;.text0&quot;</span>, TestFn)</span></span><br><span class="line"><span class="function">ULONG64 <span class="title">TestFn</span><span class="params">( ULONG64 in1, ULONG64 in2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对传入的参数进行一些数学运算</span></span><br><span class="line">    ULONG64 data1 = <span class="number">0x500</span>;</span><br><span class="line">    data1 += in1;</span><br><span class="line">    in2 -= <span class="number">0x10</span>;</span><br><span class="line">    <span class="keyword">return</span> in1 + in2 * <span class="number">3</span> - in1 / in2 + data1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hkTestFn"><a href="#hkTestFn" class="headerlink" title="hkTestFn"></a>hkTestFn</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> alloc_text(<span class="string">&quot;.text1&quot;</span>, hkTestFn)</span></span><br><span class="line"><span class="function">ULONG64 <span class="title">hkTestFn</span><span class="params">( ULONG64 in1, ULONG64 in2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取 TestFn 函数的 hook entry</span></span><br><span class="line">    PPAGE_HOOK_ENTRY pEntry = <span class="built_in">PHGetHookEntry</span>( (PVOID)(ULONG_PTR)TestFn );</span><br><span class="line">    <span class="keyword">if</span> (pEntry)</span><br><span class="line">        <span class="comment">// 将其 OriginalData 字段转换为函数指针，并调用原始函数，传入参数 in1 和 in2。</span></span><br><span class="line">        ((<span class="built_in">ULONG64</span>( *)(ULONG64, ULONG64))(ULONG_PTR)pEntry-&gt;OriginalData)(in1, in2);</span><br><span class="line">    <span class="comment">// 返回固定值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xDEADBEEF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取对应函数的HookEntry"><a href="#获取对应函数的HookEntry" class="headerlink" title="获取对应函数的HookEntry"></a>获取对应函数的HookEntry</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Get hook data by function pointer</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;ptr&quot;&gt;Function address&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Found entry or NULL&lt;/returns&gt;</span></span><br><span class="line"><span class="function">PPAGE_HOOK_ENTRY <span class="title">PHGetHookEntry</span><span class="params">( IN PVOID ptr )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_PageList.Flink == <span class="literal">NULL</span> || <span class="built_in">IsListEmpty</span>( &amp;g_PageList ))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历g_PageList查找匹配的HookEntry钩子入口数据结构</span></span><br><span class="line">    <span class="keyword">for</span> (PLIST_ENTRY pListEntry = g_PageList.Flink; pListEntry != &amp;g_PageList; pListEntry = pListEntry-&gt;Flink)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 计算PAGE_HOOK_ENTRY结构体的地址</span></span><br><span class="line">        PPAGE_HOOK_ENTRY pEntry = <span class="built_in">CONTAINING_RECORD</span>( pListEntry, PAGE_HOOK_ENTRY, Link );</span><br><span class="line">        <span class="comment">// 判断是否找到了匹配的PAGE_HOOK_ENTRY</span></span><br><span class="line">        <span class="keyword">if</span> (pEntry-&gt;OriginalPtr == ptr)</span><br><span class="line">            <span class="keyword">return</span> pEntry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="页面钩子"><a href="#页面钩子" class="headerlink" title="页面钩子"></a>页面钩子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Hook function</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pFunc&quot;&gt;Function address&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pHook&quot;&gt;Hook address&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// /// &lt;param name=&quot;Type&quot;&gt;Hook type&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">PHHook</span><span class="params">( IN PVOID pFunc, IN PVOID pHook )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PUCHAR CodePage = <span class="literal">NULL</span>;</span><br><span class="line">    BOOLEAN Newpage = FALSE;</span><br><span class="line">    PHYSICAL_ADDRESS phys = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    phys.QuadPart = MAXULONG64;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查EPT是否开启，权限是否为仅执行</span></span><br><span class="line">    <span class="keyword">if</span> (!g_Data-&gt;Features.EPT || !g_Data-&gt;Features.ExecOnlyEPT)</span><br><span class="line">        <span class="keyword">return</span> STATUS_NOT_SUPPORTED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查页面是否已经被钩子</span></span><br><span class="line">    PPAGE_HOOK_ENTRY pEntry = <span class="built_in">PHGetHookEntryByPage</span>( pFunc, DATA_PAGE );</span><br><span class="line">    <span class="keyword">if</span> (pEntry != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 已经有钩子，获取HookEntry中的CodePageVA</span></span><br><span class="line">        CodePage = pEntry-&gt;CodePageVA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 没有钩子，分配一个连续页面</span></span><br><span class="line">        CodePage = <span class="built_in">MmAllocateContiguousMemory</span>( PAGE_SIZE, phys );</span><br><span class="line">        Newpage = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CodePage == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配PAGE_HOOK_ENTRY结构体内存</span></span><br><span class="line">    PPAGE_HOOK_ENTRY pHookEntry = <span class="built_in">ExAllocatePoolWithTag</span>( NonPagedPool, <span class="built_in">sizeof</span>( PAGE_HOOK_ENTRY ), HB_POOL_TAG );</span><br><span class="line">    <span class="keyword">if</span> (pHookEntry == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>( pHookEntry, <span class="built_in">sizeof</span>( PAGE_HOOK_ENTRY ) );</span><br><span class="line">    <span class="comment">// 将原始函数代码拷贝到CodePage所指向的内存页</span></span><br><span class="line">    <span class="built_in">RtlCopyMemory</span>( CodePage, <span class="built_in">PAGE_ALIGN</span>( pFunc ), PAGE_SIZE );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将原始函数代码拷贝到PAGE_HOOK_ENTRY的OriginalData缓冲区，并记录复制的代码长度</span></span><br><span class="line">    NTSTATUS status = <span class="built_in">PHpCopyCode</span>( pFunc, pHookEntry-&gt;OriginalData, &amp;pHookEntry-&gt;OriginalSize );</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>( status ))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ExFreePoolWithTag</span>( pHookEntry, HB_POOL_TAG );</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算函数地址相对于页面的偏移</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    掩码运算通过将一个页面大小减一的二进制数作为掩码，与待对齐地址进行位运算，</span></span><br><span class="line"><span class="comment">    将指定位数之外的位都设置为0，从而达到向4kb对齐的目的。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ULONG_PTR page_offset = (ULONG_PTR)pFunc - (ULONG_PTR)<span class="built_in">PAGE_ALIGN</span>( pFunc );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化JUMP_THUNK结构体，用于跳转到Hook函数</span></span><br><span class="line">    JUMP_THUNK thunk = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">PHpInitJumpThunk</span>( &amp;thunk, (ULONG64)pHook );</span><br><span class="line">    <span class="built_in">memcpy</span>( CodePage + page_offset, &amp;thunk, <span class="built_in">sizeof</span>( thunk ) );<span class="comment">// 将JUMP_THUNK结构体拷贝到CodePage的偏移处</span></span><br><span class="line"></span><br><span class="line">    pHookEntry-&gt;OriginalPtr = pFunc;<span class="comment">// 原始函数地址</span></span><br><span class="line">    pHookEntry-&gt;DataPageVA = <span class="built_in">PAGE_ALIGN</span>( pFunc );<span class="comment">// 数据页面虚拟地址</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    物理帧号是指在操作系统中用来管理物理内存的一种编号方式。</span></span><br><span class="line"><span class="comment">    物理内存由一系列连续的物理页面（或称为物理帧）组成，每个物理页面的大小通常是固定的，</span></span><br><span class="line"><span class="comment">    比如4KB或者更大的幂次方。</span></span><br><span class="line"><span class="comment">    物理帧号是用来标识这些物理页面的唯一数字编号。它与物理内存地址相对应，可以用于将逻辑地址映射到物理地址。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    操作系统通过维护一个数据结构（如页表、段表等）来管理和跟踪物理内存的使用情况。</span></span><br><span class="line"><span class="comment">    这些数据结构中的条目使用物理帧号来标识每个物理页面的状态，如被使用、空闲、保留等。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    通过使用物理帧号，操作系统可以实现内存分页机制、内存保护、虚拟内存管理等功能。</span></span><br><span class="line"><span class="comment">    它使得操作系统能够有效地管理和控制物理内存资源，同时提供了对进程的内存访问控制和地址映射的支持。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    pHookEntry-&gt;DataPagePFN = <span class="built_in">PFN</span>( <span class="built_in">MmGetPhysicalAddress</span>( pFunc ).QuadPart );<span class="comment">// 数据页面物理帧号</span></span><br><span class="line">    pHookEntry-&gt;CodePageVA = CodePage;<span class="comment">// 代码页面虚拟地址</span></span><br><span class="line">    pHookEntry-&gt;CodePagePFN = <span class="built_in">PFN</span>( <span class="built_in">MmGetPhysicalAddress</span>( CodePage ).QuadPart );<span class="comment">// 代码页面物理帧号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查全局链表是否为空，如果为空则初始化链表</span></span><br><span class="line">    <span class="keyword">if</span> (g_PageList.Flink == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">InitializeListHead</span>( &amp;g_PageList );</span><br><span class="line">    <span class="built_in">InsertTailList</span>( &amp;g_PageList, &amp;pHookEntry-&gt;Link );<span class="comment">// 将PAGE_HOOK_ENTRY结构体插入全局链表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新分配的页面</span></span><br><span class="line">    <span class="keyword">if</span> (Newpage)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建HOOK_CONTEXT结构体，设置对应的值</span></span><br><span class="line">        HOOK_CONTEXT ctx = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        ctx.Hook = TRUE;</span><br><span class="line">        ctx.DataPagePFN = pHookEntry-&gt;DataPagePFN;</span><br><span class="line">        ctx.CodePagePFN = pHookEntry-&gt;CodePagePFN;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行PHpHookCallbackDPC回调创建EPT页面映射</span></span><br><span class="line">        <span class="built_in">KeGenericCallDpc</span>( PHpHookCallbackDPC, &amp;ctx );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="计算物理帧"><a href="#计算物理帧" class="headerlink" title="计算物理帧"></a>计算物理帧</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里的PFN是一个宏函数，接受一个地址作为参数，使用位移操作符&gt;&gt;将地址右移PAGE_SHIFT位，并将结果强制转换为ULONG64类型，作为物理帧号返回。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">PAGE_SHIFT是一个常量或宏，表示页面大小与页内偏移之间的位移量。通常，页面大小是2的幂次方，例如4KB页面大小对应的PAGE_SHIFT值为12，即右移12位。位移操作实际上是对地址进行除法运算，将高位的部分消除，得到一个较小的数值，该数值就是物理帧号。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN(addr)                   (ULONG64)((addr) &gt;&gt; PAGE_SHIFT)</span></span><br></pre></td></tr></table></figure>

<h4 id="获取页面函数钩子信息"><a href="#获取页面函数钩子信息" class="headerlink" title="获取页面函数钩子信息"></a>获取页面函数钩子信息</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Get hook data by page address</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;ptr&quot;&gt;Function pointer&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Type&quot;&gt;Page type&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Found hook entry or NULL&lt;/returns&gt;</span></span><br><span class="line"><span class="function">PPAGE_HOOK_ENTRY <span class="title">PHGetHookEntryByPage</span><span class="params">( IN PVOID ptr, IN PAGE_TYPE Type )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_PageList.Flink == <span class="literal">NULL</span> || <span class="built_in">IsListEmpty</span>( &amp;g_PageList ))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    PVOID page = <span class="built_in">PAGE_ALIGN</span>( ptr );<span class="comment">// 确保页面对齐</span></span><br><span class="line">    <span class="comment">// 遍历g_PageList查找匹配的PAGE_HOOK_ENTRY结构体</span></span><br><span class="line">    <span class="keyword">for</span> (PLIST_ENTRY pListEntry = g_PageList.Flink; pListEntry != &amp;g_PageList; pListEntry = pListEntry-&gt;Flink)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将节点转换为PAGE_HOOK_ENTRY结构体初始位置</span></span><br><span class="line">        PPAGE_HOOK_ENTRY pEntry = <span class="built_in">CONTAINING_RECORD</span>( pListEntry, PAGE_HOOK_ENTRY, Link );</span><br><span class="line">        <span class="comment">// 判断钩子的页面类型、数据是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> ((Type == DATA_PAGE &amp;&amp; pEntry-&gt;DataPageVA == page) || (Type == CODE_PAGE &amp;&amp; pEntry-&gt;CodePageVA == page))</span><br><span class="line">            <span class="keyword">return</span> pEntry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="计算给定成员的结构体初始位置"><a href="#计算给定成员的结构体初始位置" class="headerlink" title="计算给定成员的结构体初始位置"></a>计算给定成员的结构体初始位置</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">接受三个参数：address是指向某个成员的指针，type是结构体类型，field是结构体中的成员名。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">宏定义使用了一些指针运算和转换来计算结构体的起始地址。首先，将address强制转换为PCHAR类型（字符指针），然后通过减去(&amp;((type *)0)-&gt;field)的结果，得到结构体中成员field相对于结构体起始地址的偏移量（以字节计）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">接下来，将该偏移量加到address的地址上，得到结构体的起始地址，并将其强制转换为目标的type类型指针，最终返回该指针作为结果。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这个宏定义可以用于在已知结构体的某个成员地址的情况下，快速地获取整个结构体的起始地址。这种技巧在处理数据结构时非常有用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONTAINING_RECORD(address, type, field) ((type *)( \</span></span><br><span class="line"><span class="meta">                                                  (PCHAR)(address) - \</span></span><br><span class="line"><span class="meta">                                                  (ULONG_PTR)(&amp;((type *)0)-&gt;field)))</span></span><br></pre></td></tr></table></figure>

<h4 id="通过LDASM工具将原始字节复制到指定的缓冲区中"><a href="#通过LDASM工具将原始字节复制到指定的缓冲区中" class="headerlink" title="通过LDASM工具将原始字节复制到指定的缓冲区中"></a>通过LDASM工具将原始字节复制到指定的缓冲区中</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Copy original bytes using LDASM</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pFunc&quot;&gt;Original function ptr&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;OriginalStore&quot;&gt;Buffer to store bytes&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pSize&quot;&gt;Lenght of copied data&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">PHpCopyCode</span><span class="params">( IN PVOID pFunc, OUT PUCHAR OriginalStore, OUT PULONG pSize )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    LDASM是一个函数解析工具，用于解析x86和x64指令的长度和操作码。它可以读取给定地址上的指令，</span></span><br><span class="line"><span class="comment">    并提供有关指令的详细信息，例如指令长度、操作码、操作数等。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    通过使用LDASM，开发人员可以分析和处理二进制代码，包括动态修改和重写函数的字节码。</span></span><br><span class="line"><span class="comment">    它是基于汇编和机器码规范的解析库，它能够准确地分析各种指令，并提供相关信息以供后续处理。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 追踪已复制的总字节数</span></span><br><span class="line">    PUCHAR src = pFunc;<span class="comment">// 指向原始函数地址</span></span><br><span class="line">    PUCHAR old = OriginalStore;<span class="comment">// 指向目标地址OriginalStore缓冲区</span></span><br><span class="line">    ULONG all_len = <span class="number">0</span>;<span class="comment">// 已复制的总字节数</span></span><br><span class="line">    ldasm_data ld = &#123; <span class="number">0</span> &#125;;<span class="comment">// ldasm_data结构体，用于存储指令信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        ULONG len = <span class="built_in">ldasm</span>( src, &amp;ld, TRUE );<span class="comment">// 解析指令，返回指令长度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Determine code end</span></span><br><span class="line">        <span class="keyword">if</span> (ld.flags &amp; F_INVALID</span><br><span class="line">            || (len == <span class="number">1</span> &amp;&amp; (src[ld.opcd_offset] == <span class="number">0xCC</span> || src[ld.opcd_offset] == <span class="number">0xC3</span>))</span><br><span class="line">            || (len == <span class="number">3</span> &amp;&amp; src[ld.opcd_offset] == <span class="number">0xC2</span>)</span><br><span class="line">            || len + all_len &gt; <span class="number">128</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 解析失败或者指令长度超过128字节或者指令为单字节返回(0xcc\0xc3)、3字节返回(0xc2),RET、RETN、RETF</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将原始函数代码拷贝到OriginalStore缓冲区</span></span><br><span class="line">        <span class="built_in">memcpy</span>( old, src, len );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果指令中有相对偏移，需要修复</span></span><br><span class="line">        <span class="keyword">if</span> (ld.flags &amp; F_RELATIVE)</span><br><span class="line">        &#123;</span><br><span class="line">            LONG diff = <span class="number">0</span>;</span><br><span class="line">            <span class="type">const</span> <span class="type">uintptr_t</span> ofst = (ld.disp_offset != <span class="number">0</span> ? ld.disp_offset : ld.imm_offset);</span><br><span class="line">            <span class="type">const</span> <span class="type">uintptr_t</span> sz = ld.disp_size != <span class="number">0</span> ? ld.disp_size : ld.imm_size;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">memcpy</span>( &amp;diff, src + ofst, sz );</span><br><span class="line">            <span class="comment">// 检查跳转目标地址是否超过了2GB的范围。如果跳转目标地址大于2GB，则跳转会导致整数溢出和错误的行为。</span></span><br><span class="line">            <span class="keyword">if</span> (_abs64( src + len + diff - old ) &gt; INT_MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                diff += (LONG)(src - old);</span><br><span class="line">                <span class="built_in">memcpy</span>( old + ofst, &amp;diff, sz );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        src += len;</span><br><span class="line">        old += len;</span><br><span class="line">        all_len += len;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (all_len &lt; <span class="built_in">sizeof</span>( JUMP_THUNK ));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否成功复制了JUMP_THUNK结构体</span></span><br><span class="line">    <span class="keyword">if</span> (all_len &lt; <span class="built_in">sizeof</span>( JUMP_THUNK ))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化JUMP_THUNK结构体，用于跳转到Hook函数</span></span><br><span class="line">        <span class="built_in">PHpInitJumpThunk</span>( (PJUMP_THUNK)old, (ULONG64)src );</span><br><span class="line">        *pSize = all_len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="LDASM-返回指令长度"><a href="#LDASM-返回指令长度" class="headerlink" title="LDASM 返回指令长度"></a>LDASM 返回指令长度</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> __fastcall <span class="title">ldasm</span><span class="params">( <span class="type">void</span> *code, ldasm_data *ld, ULONG is64 )</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function"> Description:</span></span></span><br><span class="line"><span class="comment"><span class="function"> Disassemble one instruction</span></span></span><br><span class="line"><span class="comment"><span class="function"></span></span></span><br><span class="line"><span class="comment"><span class="function"> Arguments:</span></span></span><br><span class="line"><span class="comment"><span class="function"> code    - pointer to the code for disassemble</span></span></span><br><span class="line"><span class="comment"><span class="function"> ld        - pointer to structure ldasm_data</span></span></span><br><span class="line"><span class="comment"><span class="function"> is64    - set this flag for 64-bit code, and clear for 32-bit</span></span></span><br><span class="line"><span class="comment"><span class="function"></span></span></span><br><span class="line"><span class="comment"><span class="function"> Return:</span></span></span><br><span class="line"><span class="comment"><span class="function"> length of instruction</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UCHAR *p = (UCHAR*)code;</span><br><span class="line">    UCHAR s, op, f;</span><br><span class="line">    UCHAR rexw, pr_66, pr_67;</span><br><span class="line"></span><br><span class="line">    s = rexw = pr_66 = pr_67 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* dummy check */</span></span><br><span class="line">    <span class="keyword">if</span> (!code || !ld)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init output data */</span></span><br><span class="line">    <span class="built_in">memset</span>( ld, <span class="number">0</span>, <span class="built_in">sizeof</span>( ldasm_data ) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* phase 1: parse prefixies */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cflags</span>( *p ) &amp; OP_PREFIX) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*p == <span class="number">0x66</span>)</span><br><span class="line">            pr_66 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (*p == <span class="number">0x67</span>)</span><br><span class="line">            pr_67 = <span class="number">1</span>;</span><br><span class="line">        p++; s++;</span><br><span class="line">        ld-&gt;flags |= F_PREFIX;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="number">15</span>) &#123;</span><br><span class="line">            ld-&gt;flags |= F_INVALID;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parse REX prefix */</span></span><br><span class="line">    <span class="keyword">if</span> (is64 &amp;&amp; *p &gt;&gt; <span class="number">4</span> == <span class="number">4</span>) &#123;</span><br><span class="line">        ld-&gt;rex = *p;</span><br><span class="line">        rexw = (ld-&gt;rex &gt;&gt; <span class="number">3</span>) &amp; <span class="number">1</span>;</span><br><span class="line">        ld-&gt;flags |= F_REX;</span><br><span class="line">        p++; s++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* can be only one REX prefix */</span></span><br><span class="line">    <span class="keyword">if</span> (is64 &amp;&amp; *p &gt;&gt; <span class="number">4</span> == <span class="number">4</span>) &#123;</span><br><span class="line">        ld-&gt;flags |= F_INVALID;</span><br><span class="line">        s++;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* phase 2: parse opcode */</span></span><br><span class="line">    ld-&gt;opcd_offset = (UCHAR)(p - (UCHAR*)code);</span><br><span class="line">    ld-&gt;opcd_size = <span class="number">1</span>;</span><br><span class="line">    op = *p++; s++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* is 2 byte opcode? */</span></span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">0x0F</span>) &#123;</span><br><span class="line">        op = *p++; s++;</span><br><span class="line">        ld-&gt;opcd_size++;</span><br><span class="line">        f = <span class="built_in">cflags_ex</span>( op );</span><br><span class="line">        <span class="keyword">if</span> (f &amp; OP_INVALID) &#123;</span><br><span class="line">            ld-&gt;flags |= F_INVALID;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* for SSE instructions */</span></span><br><span class="line">        <span class="keyword">if</span> (f &amp; OP_EXTENDED) &#123;</span><br><span class="line">            op = *p++; s++;</span><br><span class="line">            ld-&gt;opcd_size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        f = <span class="built_in">cflags</span>( op );</span><br><span class="line">        <span class="comment">/* pr_66 = pr_67 for opcodes A0-A3 */</span></span><br><span class="line">        <span class="keyword">if</span> (op &gt;= <span class="number">0xA0</span> &amp;&amp; op &lt;= <span class="number">0xA3</span>)</span><br><span class="line">            pr_66 = pr_67;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* phase 3: parse ModR/M, SIB and DISP */</span></span><br><span class="line">    <span class="keyword">if</span> (f &amp; OP_MODRM) &#123;</span><br><span class="line">        UCHAR    mod = (*p &gt;&gt; <span class="number">6</span>);</span><br><span class="line">        UCHAR    ro = (*p &amp; <span class="number">0x38</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">        UCHAR    rm = (*p &amp; <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        ld-&gt;modrm = *p++; s++;</span><br><span class="line">        ld-&gt;flags |= F_MODRM;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* in F6,F7 opcodes immediate data present if R/O == 0 */</span></span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">0xF6</span> &amp;&amp; (ro == <span class="number">0</span> || ro == <span class="number">1</span>))</span><br><span class="line">            f |= OP_DATA_I8;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">0xF7</span> &amp;&amp; (ro == <span class="number">0</span> || ro == <span class="number">1</span>))</span><br><span class="line">            f |= OP_DATA_I16_I32_I64;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* is SIB byte exist? */</span></span><br><span class="line">        <span class="keyword">if</span> (mod != <span class="number">3</span> &amp;&amp; rm == <span class="number">4</span> &amp;&amp; !(!is64 &amp;&amp; pr_67)) &#123;</span><br><span class="line">            ld-&gt;sib = *p++; s++;</span><br><span class="line">            ld-&gt;flags |= F_SIB;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* if base == 5 and mod == 0 */</span></span><br><span class="line">            <span class="keyword">if</span> ((ld-&gt;sib &amp; <span class="number">7</span>) == <span class="number">5</span> &amp;&amp; mod == <span class="number">0</span>) &#123;</span><br><span class="line">                ld-&gt;disp_size = <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (mod) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> (is64) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rm == <span class="number">5</span>) &#123;</span><br><span class="line">                    ld-&gt;disp_size = <span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">if</span> (is64)</span><br><span class="line">                        ld-&gt;flags |= F_RELATIVE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pr_67) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rm == <span class="number">6</span>)</span><br><span class="line">                    ld-&gt;disp_size = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rm == <span class="number">5</span>)</span><br><span class="line">                    ld-&gt;disp_size = <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            ld-&gt;disp_size = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> (is64)</span><br><span class="line">                ld-&gt;disp_size = <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pr_67)</span><br><span class="line">                ld-&gt;disp_size = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ld-&gt;disp_size = <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ld-&gt;disp_size) &#123;</span><br><span class="line">            ld-&gt;disp_offset = (UCHAR)(p - (UCHAR *)code);</span><br><span class="line">            p += ld-&gt;disp_size;</span><br><span class="line">            s += ld-&gt;disp_size;</span><br><span class="line">            ld-&gt;flags |= F_DISP;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* phase 4: parse immediate data */</span></span><br><span class="line">    <span class="keyword">if</span> (rexw &amp;&amp; f &amp; OP_DATA_I16_I32_I64)</span><br><span class="line">        ld-&gt;imm_size = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (f &amp; OP_DATA_I16_I32 || f &amp; OP_DATA_I16_I32_I64)</span><br><span class="line">        ld-&gt;imm_size = <span class="number">4</span> - (pr_66 &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if exist, add OP_DATA_I16 and OP_DATA_I8 size */</span></span><br><span class="line">    ld-&gt;imm_size += f &amp; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ld-&gt;imm_size) &#123;</span><br><span class="line">        s += ld-&gt;imm_size;</span><br><span class="line">        ld-&gt;imm_offset = (UCHAR)(p - (UCHAR *)code);</span><br><span class="line">        ld-&gt;flags |= F_IMM;</span><br><span class="line">        <span class="keyword">if</span> (f &amp; OP_RELATIVE)</span><br><span class="line">            ld-&gt;flags |= F_RELATIVE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* instruction is too long */</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">15</span>)</span><br><span class="line">        ld-&gt;flags |= F_INVALID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="构造跳转指令字节码"><a href="#构造跳转指令字节码" class="headerlink" title="构造跳转指令字节码"></a>构造跳转指令字节码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Construct jump </span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pThunk&quot;&gt;Data to initialize&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;To&quot;&gt;Address of jump&lt;/param&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">PHpInitJumpThunk</span><span class="params">( IN OUT PJUMP_THUNK pThunk, IN ULONG64 To )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PULARGE_INTEGER liTo = (PULARGE_INTEGER)&amp;To;<span class="comment">// 无符号64位整数</span></span><br><span class="line"></span><br><span class="line">    pThunk-&gt;PushOp = <span class="number">0x68</span>;<span class="comment">// 推入32位立即数</span></span><br><span class="line">    pThunk-&gt;AddressLow = liTo-&gt;LowPart;<span class="comment">// 低32位地址</span></span><br><span class="line">    pThunk-&gt;MovOp = <span class="number">0x042444C7</span>;<span class="comment">// 将32位常数移动到指定内存</span></span><br><span class="line">    pThunk-&gt;AddressHigh = liTo-&gt;HighPart;<span class="comment">// 高32位地址</span></span><br><span class="line">    pThunk-&gt;RetOp = <span class="number">0xC3</span>;<span class="comment">// 返回指令</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="每个CPU页面钩子和解钩的回调函数"><a href="#每个CPU页面钩子和解钩的回调函数" class="headerlink" title="每个CPU页面钩子和解钩的回调函数"></a>每个CPU页面钩子和解钩的回调函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Per-CPU page hook/unhook routine</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Dpc&quot;&gt;Unused&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Context&quot;&gt;Valid PHOOK_CONTEXT&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;SystemArgument1&quot;&gt;Unused&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;SystemArgument2&quot;&gt;Unused&lt;/param&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">PHpHookCallbackDPC</span><span class="params">( IN PRKDPC Dpc, IN PVOID Context, IN PVOID SystemArgument1, IN PVOID SystemArgument2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>( Dpc );</span><br><span class="line">    PHOOK_CONTEXT pCTX = (PHOOK_CONTEXT)Context;<span class="comment">// hook上下文</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pCTX != <span class="literal">NULL</span>)<span class="comment">// 进行hook或unhook</span></span><br><span class="line">        __vmx_vmcall( pCTX-&gt;Hook ? HYPERCALL_HOOK_PAGE : HYPERCALL_UNHOOK_PAGE, pCTX-&gt;DataPagePFN, pCTX-&gt;CodePagePFN, <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">KeSignalCallDpcSynchronize</span>( SystemArgument2 );<span class="comment">// 发出同步信号</span></span><br><span class="line">    <span class="built_in">KeSignalCallDpcDone</span>( SystemArgument1 );<span class="comment">// 通知DPC执行完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解除页面钩子"><a href="#解除页面钩子" class="headerlink" title="解除页面钩子"></a>解除页面钩子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Restore hooked function</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pFunc&quot;&gt;Function address&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">PHRestore</span><span class="params">( IN PVOID pFunc )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 不支持执行保护，无法恢复</span></span><br><span class="line">    <span class="keyword">if</span> (!g_Data-&gt;Features.ExecOnlyEPT)</span><br><span class="line">        <span class="keyword">return</span> STATUS_NOT_SUPPORTED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取要恢复函数的PAGE_HOOK_ENTRY结构体</span></span><br><span class="line">    PPAGE_HOOK_ENTRY pHookEntry = <span class="built_in">PHGetHookEntry</span>( pFunc );</span><br><span class="line">    <span class="keyword">if</span> (pHookEntry == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_NOT_FOUND;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复原始字节，根据页面钩子数量</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">PHPageHookCount</span>( pFunc, DATA_PAGE ) &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 存在其他CPU正在使用页面钩子，需要进行原子性的内存补丁操作</span></span><br><span class="line">        <span class="comment">// 将原始的字节数据从钩子页中复制回原始函数所在的页面。这样可以确保其他CPU在执行期间的一致性。</span></span><br><span class="line">        ULONG_PTR page_offset = (ULONG_PTR)pFunc - (ULONG_PTR)<span class="built_in">PAGE_ALIGN</span>( pFunc );</span><br><span class="line">        <span class="built_in">memcpy</span>( (PUCHAR)pHookEntry-&gt;CodePageVA + page_offset, pHookEntry-&gt;OriginalData, pHookEntry-&gt;OriginalSize );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只被一个CPU钩子的函数，将钩子所在页面与原始函数所在的页面进行交换，以还原函数的内容</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        HOOK_CONTEXT ctx = &#123; <span class="number">0</span> &#125;;<span class="comment">// 临时HOOK_CONTEXT结构体</span></span><br><span class="line">        ctx.Hook = FALSE;</span><br><span class="line">        ctx.DataPagePFN = pHookEntry-&gt;DataPagePFN;</span><br><span class="line">        ctx.CodePagePFN = pHookEntry-&gt;CodePagePFN;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Dpc回调Unhook模式</span></span><br><span class="line">        <span class="built_in">KeGenericCallDpc</span>( PHpHookCallbackDPC, &amp;ctx );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放钩子信息缓存</span></span><br><span class="line">    <span class="built_in">MmFreeContiguousMemory</span>( pHookEntry-&gt;CodePageVA );</span><br><span class="line">    <span class="built_in">RemoveEntryList</span>( &amp;pHookEntry-&gt;Link );</span><br><span class="line">    <span class="built_in">ExFreePoolWithTag</span>( pHookEntry, HB_POOL_TAG );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="计算当前函数有多少个hook"><a href="#计算当前函数有多少个hook" class="headerlink" title="计算当前函数有多少个hook"></a>计算当前函数有多少个hook</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Get number of hooks in one page</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;ptr&quot;&gt;Function address&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Type&quot;&gt;Page type&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Number of hooks&lt;/returns&gt;</span></span><br><span class="line"><span class="function">ULONG <span class="title">PHPageHookCount</span><span class="params">( IN PVOID ptr, IN PAGE_TYPE Type )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 检查是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (g_PageList.Flink == <span class="literal">NULL</span> || <span class="built_in">IsListEmpty</span>( &amp;g_PageList ))</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取页面地址</span></span><br><span class="line">    PVOID page = <span class="built_in">PAGE_ALIGN</span>( ptr );</span><br><span class="line">    <span class="comment">// 遍历g_PageList查找匹配的PAGE_HOOK_ENTRY结构体</span></span><br><span class="line">    <span class="keyword">for</span> (PLIST_ENTRY pListEntry = g_PageList.Flink; pListEntry != &amp;g_PageList; pListEntry = pListEntry-&gt;Flink)</span><br><span class="line">    &#123;</span><br><span class="line">        PPAGE_HOOK_ENTRY pEntry = <span class="built_in">CONTAINING_RECORD</span>( pListEntry, PAGE_HOOK_ENTRY, Link );</span><br><span class="line">        <span class="comment">// 判断钩子的页面类型、数据是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> ((Type == DATA_PAGE &amp;&amp; pEntry-&gt;DataPageVA == page) || (Type == CODE_PAGE &amp;&amp; pEntry-&gt;CodePageVA == page))</span><br><span class="line">            count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="系统调用入口钩子"><a href="#系统调用入口钩子" class="headerlink" title="系统调用入口钩子"></a>系统调用入口钩子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Perform LSTAR hooking</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">SHInitHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    LSTAR是一个MSR（Machine Specific Register），它保存了系统调用（system call）的入口地址，</span></span><br><span class="line"><span class="comment">    hooking LSTAR就可以实现对所有系统调用的监控和拦截。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有SSDT</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">UtilSSDTBase</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: SSDT base not found\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        <span class="keyword">return</span> STATUS_NOT_FOUND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KiSystemServiceCopyEnd</span></span><br><span class="line">    <span class="comment">// 这个函数用于将系统调用的参数从用户空间复制到内核空间并调用具体的系统调用处理函数</span></span><br><span class="line">    <span class="comment">// F7 05 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0F 85 ? ? ? ? ? ? ? ? 41 FF D2</span></span><br><span class="line">    <span class="keyword">if</span> (KiServiceCopyEndPtr == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 搜索KiSystemServiceCopyEnd函数特征码找到地址</span></span><br><span class="line">        CHAR pattern[] = <span class="string">&quot;\xF7\x05\xcc\xcc\xcc\xcc\xcc\xcc\xcc\xcc\x0F\x85\xcc\xcc\xcc\xcc\x41\xFF\xD2&quot;</span>;</span><br><span class="line">        status = <span class="built_in">UtilScanSection</span>( <span class="string">&quot;.text&quot;</span>, (PCUCHAR)pattern, <span class="number">0xCC</span>, <span class="built_in">sizeof</span>( pattern ) - <span class="number">1</span>, (PVOID)&amp;KiServiceCopyEndPtr );</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>( status ))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: KiSystemServiceCopyEnd not found\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hook LSTAR</span></span><br><span class="line">    <span class="keyword">if</span> (KiSystemCall64Ptr == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        KiSystemCall64Ptr = __readmsr( MSR_LSTAR );<span class="comment">// 原始LSTAR地址</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Something isn&#x27;t right</span></span><br><span class="line">        <span class="keyword">if</span> (KiSystemCall64Ptr == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在DPC回调中hook，修改LSTAR寄存器的值为SyscallEntryPoint定义的函数</span></span><br><span class="line">        <span class="built_in">KeGenericCallDpc</span>( SHpHookCallbackDPC, (PVOID)(ULONG_PTR)SyscallEntryPoint );</span><br><span class="line">        <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在内核PE文件的指定section中查找指定的pattern"><a href="#在内核PE文件的指定section中查找指定的pattern" class="headerlink" title="在内核PE文件的指定section中查找指定的pattern"></a>在内核PE文件的指定section中查找指定的pattern</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Find pattern in kernel PE section</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;section&quot;&gt;Section name&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pattern&quot;&gt;Pattern data&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;wildcard&quot;&gt;Pattern wildcard symbol&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;len&quot;&gt;Pattern length&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;ppFound&quot;&gt;Found address&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">UtilScanSection</span><span class="params">( IN PCCHAR section, IN PCUCHAR pattern, IN UCHAR wildcard, IN ULONG_PTR len, OUT PVOID* ppFound )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">NT_ASSERT</span>( ppFound != <span class="literal">NULL</span> );</span><br><span class="line">    <span class="keyword">if</span> (ppFound == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line">    PVOID base = <span class="built_in">UtilKernelBase</span>( <span class="literal">NULL</span> );<span class="comment">// 获取NTOS内核的基址</span></span><br><span class="line">    <span class="keyword">if</span> (!base)</span><br><span class="line">        <span class="keyword">return</span> STATUS_NOT_FOUND;</span><br><span class="line"></span><br><span class="line">    PIMAGE_NT_HEADERS64 pHdr = <span class="built_in">RtlImageNtHeader</span>( base );<span class="comment">// 获取NTOS内核的PE头</span></span><br><span class="line">    <span class="keyword">if</span> (!pHdr)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_IMAGE_FORMAT;</span><br><span class="line"></span><br><span class="line">    PIMAGE_SECTION_HEADER pFirstSection = (PIMAGE_SECTION_HEADER)(pHdr + <span class="number">1</span>);<span class="comment">// 获取NTOS内核的第一个节表</span></span><br><span class="line">    <span class="comment">// 遍历所有节表，进行模式匹配</span></span><br><span class="line">    <span class="keyword">for</span> (PIMAGE_SECTION_HEADER pSection = pFirstSection; pSection &lt; pFirstSection + pHdr-&gt;FileHeader.NumberOfSections; pSection++)</span><br><span class="line">    &#123;</span><br><span class="line">        ANSI_STRING s1, s2;</span><br><span class="line">        <span class="built_in">RtlInitAnsiString</span>( &amp;s1, section );</span><br><span class="line">        <span class="built_in">RtlInitAnsiString</span>( &amp;s2, (PCCHAR)pSection-&gt;Name );</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">RtlCompareString</span>( &amp;s1, &amp;s2, TRUE ) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">UtilSearchPattern</span>( pattern, wildcard, len, (PUCHAR)base + pSection-&gt;VirtualAddress, pSection-&gt;Misc.VirtualSize, ppFound );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LSTAR-Hook-回调函数"><a href="#LSTAR-Hook-回调函数" class="headerlink" title="LSTAR Hook 回调函数"></a>LSTAR Hook 回调函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Per-CPU LSTAR hook/unhook routine</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Dpc&quot;&gt;Unused&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Context&quot;&gt;New LASTAR value if hooking, 0 if unhooking&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;SystemArgument1&quot;&gt;Unused&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;SystemArgument2&quot;&gt;Unused&lt;/param&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">SHpHookCallbackDPC</span><span class="params">( PRKDPC Dpc, PVOID Context, PVOID SystemArgument1, PVOID SystemArgument2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>( Dpc );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断Context确定hook或unhook操作，进行VMCALL调用</span></span><br><span class="line">    __vmx_vmcall( Context != <span class="literal">NULL</span> ? HYPERCALL_HOOK_LSTAR : HYPERCALL_UNHOOK_LSTAR, (ULONG64)Context, <span class="number">0</span>, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">KeSignalCallDpcSynchronize</span>( SystemArgument2 );<span class="comment">// 通知等待同步</span></span><br><span class="line">    <span class="built_in">KeSignalCallDpcDone</span>( SystemArgument1 );<span class="comment">// 通知DPC执行完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SyscallEntryPoint"><a href="#SyscallEntryPoint" class="headerlink" title="SyscallEntryPoint"></a>SyscallEntryPoint</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">EXTERN HookEnabled:DB</span><br><span class="line">EXTERN ArgTble:DB</span><br><span class="line">EXTERN HookTable:DQ</span><br><span class="line"></span><br><span class="line">EXTERN KiSystemCall64Ptr:DQ</span><br><span class="line">EXTERN KiServiceCopyEndPtr:DQ</span><br><span class="line"></span><br><span class="line">USERMD_STACK_GS = 10h</span><br><span class="line">KERNEL_STACK_GS = 1A8h</span><br><span class="line"></span><br><span class="line">MAX_SYSCALL_INDEX = 1000h</span><br><span class="line"></span><br><span class="line">.CODE</span><br><span class="line"></span><br><span class="line">; *********************************************************</span><br><span class="line">;</span><br><span class="line">; Determine if the specific syscall should be hooked</span><br><span class="line">;</span><br><span class="line">; if (SyscallHookEnabled[EAX &amp; 0xFFF] == TRUE)</span><br><span class="line">;     jmp KiSystemCall64_Emulate</span><br><span class="line">; else (fall-through)</span><br><span class="line">;     jmp KiSystemCall64</span><br><span class="line">;</span><br><span class="line">; *********************************************************</span><br><span class="line">SyscallEntryPoint PROC</span><br><span class="line">    ;cli                                    ; Disable interrupts</span><br><span class="line">    swapgs                                  ; 将GS寄存器切换为内核PCR</span><br><span class="line">    mov         gs:[USERMD_STACK_GS], rsp   ; 将当前用户栈保存，以便调用返回时恢复</span><br><span class="line"></span><br><span class="line">    cmp         rax, MAX_SYSCALL_INDEX      ; 检查rax寄存器的值是否大于系统调用数组的大小</span><br><span class="line">    jge         KiSystemCall64              ; 大于，表示该调用不存在，跳转到KiSystemCall64</span><br><span class="line"></span><br><span class="line">    lea         rsp, offset HookEnabled     ; 检查Hook是否被启用</span><br><span class="line">    cmp         byte ptr [rsp + rax], 0     ; 检查Hook是否被启用</span><br><span class="line">    jne         KiSystemCall64_Emulate      ; 跳转进行KiSystemCall64_Emulate，否则进行KiSystemCall64</span><br><span class="line">SyscallEntryPoint ENDP</span><br><span class="line"></span><br><span class="line">; *********************************************************</span><br><span class="line">;</span><br><span class="line">; 返回到原始NTOSKRNL系统调用处理程序</span><br><span class="line">; (Restore all old registers first)</span><br><span class="line">;</span><br><span class="line">; *********************************************************</span><br><span class="line">KiSystemCall64 PROC</span><br><span class="line">	mov         rsp, gs:[USERMD_STACK_GS]   ; 取出用户模式RSP加载到RSP，切换到用户模式栈</span><br><span class="line">	swapgs                                  ; 切换到用户模式GS寄存器，恢复原先寄存器</span><br><span class="line">	jmp         [KiSystemCall64Ptr]         ; 跳转到KiSystemCall64Ptr所指向的地址，64位指针</span><br><span class="line">KiSystemCall64 ENDP</span><br><span class="line"></span><br><span class="line">; *********************************************************</span><br><span class="line">;</span><br><span class="line">; 在SYSCALL之后直接执行的例程</span><br><span class="line">; (See: MSR_LSTAR)</span><br><span class="line">;</span><br><span class="line">; *********************************************************</span><br><span class="line">KiSystemCall64_Emulate PROC</span><br><span class="line">    ; NOTE:</span><br><span class="line">    ; First 2 lines are included in SyscallEntryPoint</span><br><span class="line"></span><br><span class="line">    mov         rsp, gs:[KERNEL_STACK_GS]   ; 加载内核模式RSP</span><br><span class="line">    push        2Bh                         ; push 虚拟的SS选择子</span><br><span class="line">    push        qword ptr gs:[10h]          ; push 用户模式栈指针</span><br><span class="line">    push        r11                         ; push 先前的 EFLAGS</span><br><span class="line">    push        33h                         ; push 虚拟 64位 CS 选择子</span><br><span class="line">    push        rcx                         ; push 返回地址</span><br><span class="line">    mov         rcx, r10                    ; 在rcx中保存第一个参数</span><br><span class="line"></span><br><span class="line">    sub         rsp, 8h                     ; 分配8字节作为虚拟错误码</span><br><span class="line">    push        rbp                         ; 保存标准寄存器的值</span><br><span class="line">    sub         rsp, 158h                   ; 分配一个固定大小的框架</span><br><span class="line">    lea         rbp, [rsp+80h]              ; 设置RBP为当前帧的基地址</span><br><span class="line">    mov         [rbp+0C0h], rbx             ; 保存一些非易失性的寄存器的值</span><br><span class="line">    mov         [rbp+0C8h], rdi             ;</span><br><span class="line">    mov         [rbp+0D0h], rsi             ;</span><br><span class="line">    mov         byte ptr [rbp-55h], 2h      ; 标志位，表示服务活动</span><br><span class="line">    mov         rbx, gs:[188h]              ; 获取当前线程地址</span><br><span class="line">    prefetchw   byte ptr [rbx+90h]          ; 对线程地址进行预取操作</span><br><span class="line">    stmxcsr     dword ptr [rbp-54h]         ; 保存当前MXCSR</span><br><span class="line">    ldmxcsr     dword ptr gs:[180h]         ; 设置默认MXCSR</span><br><span class="line">    cmp         byte ptr [rbx+3], 0         ; 检查调试是否启用</span><br><span class="line">    mov         word ptr [rbp+80h], 0       ; 如果调试未启用</span><br><span class="line">    jz          KiSS05                      ; 跳转到KiSS05标签处</span><br><span class="line">    mov         [rbp-50h], rax              ; 保存服务参数寄存器</span><br><span class="line">    mov         [rbp-48h], rcx              ;</span><br><span class="line">    mov         [rbp-40h], rdx              ;</span><br><span class="line">    mov         [rbp-38h], r8               ;</span><br><span class="line">    mov         [rbp-30h], r9               ;</span><br><span class="line"></span><br><span class="line">    int         3                           ; 触发一个中断</span><br><span class="line">    align       10h</span><br><span class="line"></span><br><span class="line">    KiSS05:</span><br><span class="line">    ;sti                                    ; 启动中断</span><br><span class="line">    mov         [rbx+88h], rcx</span><br><span class="line">    mov         [rbx+80h], eax</span><br><span class="line"></span><br><span class="line">KiSystemCall64_Emulate ENDP</span><br></pre></td></tr></table></figure>

<h4 id="EFLAGS"><a href="#EFLAGS" class="headerlink" title="EFLAGS"></a>EFLAGS</h4><p>EFLAGS是x86架构中特有的寄存器，用于存储和控制处理器的状态标志位（flags）。它记录了CPU执行指令过程中产生的各种状态信息。</p>
<p>EFLAGS寄存器的位布局如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">31      23           15          7    0</span><br><span class="line">┌───────┬───────────┬───────────┬────┐</span><br><span class="line">|       |           |           |    |</span><br><span class="line">|  RFU  |  VM, VIP  |  ID, VIP  |  AC  |</span><br><span class="line">|       |           |           |    |</span><br><span class="line">└───────┴───────────┴───────────┴────┘</span><br></pre></td></tr></table></figure>

<p>各个标志位的含义如下：</p>
<ul>
<li>AC (Alignment Check)：对齐检查标志位，用于检测内存操作的对齐情况。</li>
<li>ID (ID Flag)：识别标志位，用于表示CPU是否支持CPUID指令。</li>
<li>VIP (Virtual Interrupt Pending)：虚拟中断挂起标志位，在虚拟8086模式下使用。</li>
<li>VIF (Virtual Interrupt Flag)：虚拟中断标志位，在虚拟8086模式下使用。</li>
<li>OF (Overflow Flag)：溢出标志位，用于检测有符号整数运算结果是否溢出。</li>
<li>DF (Direction Flag)：方向标志位，用于控制字符串操作指令的方向。</li>
<li>IF (Interrupt Flag)：中断标志位，用于控制CPU是否响应外部中断。</li>
<li>TF (Trap Flag)：陷阱标志位，用于控制CPU是否进入单步执行模式。</li>
<li>SF (Sign Flag)：符号标志位，用于表示有符号整数运算结果的符号。</li>
<li>ZF (Zero Flag)：零标志位，用于表示算术或逻辑运算结果是否为零。</li>
<li>AF (Auxiliary Carry Flag)：辅助进位标志位，用于检测无符号整数运算时的进位情况。</li>
<li>PF (Parity Flag)：奇偶标志位，用于表示运算结果的低8位中1的个数的奇偶性。</li>
<li>CF (Carry Flag)：进位标志位，用于检测无符号整数运算结果是否产生进位。</li>
</ul>
<p>这些标志位的状态可以通过指令读取或修改，用于判断和控制程序的执行流程。例如，通过检查ZF标志位可以判断某个运算结果是否为零，从而进行条件分支或循环的控制。</p>
<h4 id="MXCSR"><a href="#MXCSR" class="headerlink" title="MXCSR"></a>MXCSR</h4><p>MXCSR是x86架构中的一种控制寄存器，全称为”Floating-Point Control and Status Register”，它用于管理和控制浮点运算的行为和状态。</p>
<p>MXCSR寄存器是一个32位的寄存器，其位布局如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copy Code31        15       7      0</span><br><span class="line">┌─────────┬───────┬───────┬─────┐</span><br><span class="line">│   RFU   │  RC   │  PC   │  PM │</span><br><span class="line">└─────────┴───────┴───────┴─────┘</span><br></pre></td></tr></table></figure>

<p>各个标志位的含义如下：</p>
<ul>
<li>PM (Precision Mask)：精度掩码位，用于控制浮点运算结果的舍入精度。</li>
<li>PC (Precision Control)：精度控制位，用于设置浮点运算结果的默认舍入精度模式。</li>
<li>RC (Rounding Control)：舍入控制位，用于设置浮点运算结果的舍入方式。</li>
<li>RFU (Reserved for Future Use)：保留字段，暂未使用。</li>
</ul>
<p>通过对MXCSR寄存器的设置，可以控制浮点运算的舍入方式、精度和异常处理等行为。例如，可以设置精度掩码位PM来屏蔽或允许特定类型的浮点异常，或者通过设置精度控制位PC来指定浮点运算结果的默认舍入精度模式。</p>
<p>MXCSR寄存器可以通过指令进行读取和修改，例如LDMXCSR和STMXCSR指令。它对于进行精确的浮点计算和处理浮点异常非常重要，能够提供更好的浮点运算控制和性能优化。</p>
<h4 id="CS选择子"><a href="#CS选择子" class="headerlink" title="CS选择子"></a>CS选择子</h4><p>在x86架构中，CS（Code Segment）是一种代码段寄存器，主要用于存储当前程序正在执行的代码所在的段的信息。CS选择子则是对CS寄存器进行访问的一种方式。</p>
<p>CS选择子是一个16位的数据结构，包含了以下信息：</p>
<ul>
<li>段选择子：用于指向代码段的段描述符，其中包含了代码段的起始地址、大小、特权级等信息。</li>
<li>请求特权级（RPL）：用于指定代码段的访问权限，取值为0~3。</li>
</ul>
<p>CS选择子可以通过一些指令读取或修改，例如LAR指令、LDS指令、LSS指令等。在进行指令跳转时，CPU会使用CS选择子来确定下一条指令的地址。因此，CS选择子的正确设置非常重要，对程序的执行具有至关重要的影响。</p>
<p>需要注意的是，CS选择子只是用于访问CS寄存器的一种方式，它并不是CS寄存器本身。CS寄存器还可以通过其他方式进行访问，例如POP CS指令、IRET指令等。</p>
<h2 id="系统调用钩子"><a href="#系统调用钩子" class="headerlink" title="系统调用钩子"></a>系统调用钩子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Hook specific SSDT entry</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;index&quot;&gt;SSDT index&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;hookPtr&quot;&gt;Hook address&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;argCount&quot;&gt;Number of function arguments&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">SHHookSyscall</span><span class="params">( IN ULONG index, IN PVOID hookPtr, IN CHAR argCount )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; MAX_SYSCALL_INDEX || hookPtr == <span class="literal">NULL</span>)<span class="comment">// 超过最大系统调用索引或者hook地址为空</span></span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line">    KIRQL irql = <span class="built_in">KeGetCurrentIrql</span>();<span class="comment">// 获取当前IRQL（中断请求级别）</span></span><br><span class="line">    <span class="keyword">if</span> (irql &lt; DISPATCH_LEVEL)</span><br><span class="line">        <span class="comment">// 如果小于调度级别，提升到调度级别</span></span><br><span class="line">        irql = <span class="built_in">KeRaiseIrqlToDpcLevel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存原始hook地址和参数个数</span></span><br><span class="line">    <span class="comment">// 保证多线程环境下对HookTable、ArgTble、HookEnabled的操作的原子性</span></span><br><span class="line">    <span class="built_in">InterlockedExchange64</span>( (PLONG64)&amp;HookTable[index], (LONG64)hookPtr );</span><br><span class="line">    <span class="built_in">InterlockedExchange8</span>( &amp;ArgTble[index], argCount );</span><br><span class="line">    <span class="built_in">InterlockedExchange8</span>( &amp;HookEnabled[index], TRUE );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复权限</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">KeGetCurrentIrql</span>() &gt; irql)</span><br><span class="line">        <span class="built_in">KeLowerIrql</span>( irql );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hkNtClose"><a href="#hkNtClose" class="headerlink" title="hkNtClose"></a>hkNtClose</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">hkNtClose</span><span class="params">( HANDLE handle )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    calls1++;<span class="comment">// 记录hkNtClose函数被调用的次数</span></span><br><span class="line">    <span class="keyword">return</span> ((pfnNtClose)g_NtClose)(handle);<span class="comment">// 使用函数指针类型pfnNtClose调用了全局变量g_NtClose所指向的原始NtClose系统调用函数，并将handle作为参数传递给原始函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hkNtClose2"><a href="#hkNtClose2" class="headerlink" title="hkNtClose2"></a>hkNtClose2</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">hkNtClose2</span><span class="params">( HANDLE handle )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PPAGE_HOOK_ENTRY pEntry = <span class="built_in">PHGetHookEntry</span>( g_NtClose );<span class="comment">// 获取全局系统调用函数的hook entry</span></span><br><span class="line">    <span class="keyword">if</span> (pEntry)</span><br><span class="line">    &#123;</span><br><span class="line">        calls2++;<span class="comment">// 记录hkNtClose2函数被调用的次数</span></span><br><span class="line">        <span class="comment">// 使用函数指针类型pfnNtClose调用了hook entry的OriginalData字段所指向的原始NtClose系统调用函数，并将handle作为参数传递给原始函数</span></span><br><span class="line">        <span class="keyword">return</span> ((pfnNtClose)pEntry-&gt;OriginalData)(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="驱动卸载"><a href="#驱动卸载" class="headerlink" title="驱动卸载"></a>驱动卸载</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">HBUnload</span><span class="params">( IN PDRIVER_OBJECT DriverObject )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>( DriverObject );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TestPrintResults</span>();<span class="comment">// 打印测试结果</span></span><br><span class="line">    <span class="built_in">TestStop</span>();<span class="comment">// 停止测试</span></span><br><span class="line"></span><br><span class="line">    NTSTATUS status = <span class="built_in">StopHV</span>();<span class="comment">// 停止虚拟化</span></span><br><span class="line">    <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: Unload %s\n&quot;</span>, CPU_IDX, __FUNCTION__, <span class="built_in">NT_SUCCESS</span>( status ) ? <span class="string">&quot;SUCCEDED&quot;</span> : <span class="string">&quot;FAILED&quot;</span> );</span><br><span class="line">    <span class="built_in">FreeGlobalData</span>( g_Data );<span class="comment">// 释放全局变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打印测试结果"><a href="#打印测试结果" class="headerlink" title="打印测试结果"></a>打印测试结果</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">TestPrintResults</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: SyscallHook Calls made %d\n&quot;</span>, CPU_IDX, __FUNCTION__, calls1 );</span><br><span class="line">    <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: PageHook Calls made %d\n&quot;</span>, CPU_IDX, __FUNCTION__, calls2 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="停止测试"><a href="#停止测试" class="headerlink" title="停止测试"></a>停止测试</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">TestStop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">PHRestore</span>( g_NtClose );<span class="comment">// 恢复系统调用钩子</span></span><br><span class="line">    <span class="built_in">SHRestoreSyscall</span>( <span class="built_in">SSDTIndex</span>( &amp;ZwClose ) );<span class="comment">// 恢复原始SSDT表入口</span></span><br><span class="line">    <span class="built_in">SHDestroyHook</span>();<span class="comment">// 释放LSTAR钩子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="恢复SSDT表"><a href="#恢复SSDT表" class="headerlink" title="恢复SSDT表"></a>恢复SSDT表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Restore original SSDT entry</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;index&quot;&gt;SSDT index&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">SHRestoreSyscall</span><span class="params">( IN ULONG index )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查最大系统调用索引</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt; MAX_SYSCALL_INDEX)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查权限</span></span><br><span class="line">    KIRQL irql = <span class="built_in">KeGetCurrentIrql</span>();</span><br><span class="line">    <span class="keyword">if</span> (irql &lt; DISPATCH_LEVEL)</span><br><span class="line">        irql = <span class="built_in">KeRaiseIrqlToDpcLevel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复原始系统调用表</span></span><br><span class="line">    <span class="built_in">InterlockedExchange8</span>( &amp;HookEnabled[index], <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">InterlockedExchange8</span>( &amp;ArgTble[index], <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">InterlockedExchange64</span>( (PLONG64)&amp;HookTable[index], <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还原权限</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">KeGetCurrentIrql</span>() &gt; irql )</span><br><span class="line">        <span class="built_in">KeLowerIrql</span>( irql );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="释放LSTAR钩子"><a href="#释放LSTAR钩子" class="headerlink" title="释放LSTAR钩子"></a>释放LSTAR钩子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Unhook LSTAR</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">SHDestroyHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    <span class="keyword">if</span> (KiSystemCall64Ptr != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 有hook，DPC回调恢复原始LSTAR地址</span></span><br><span class="line">        <span class="built_in">KeGenericCallDpc</span>( SHpHookCallbackDPC, <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>( status ))</span><br><span class="line">        <span class="comment">// 取消钩子</span></span><br><span class="line">        KiSystemCall64Ptr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</center></center></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">qianmu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2024/02/04/VT-x/">http://example.com/2024/02/04/VT-x/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/02/04/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="线程池"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">线程池</div></div></a></div><div class="next-post pull-right"><a href="/2024/02/04/TLS/" title="TLS"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">TLS</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">qianmu</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">24</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/QianMuOY"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="toc-number">1.</span> <span class="toc-text">虚拟化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E7%A1%AC%E4%BB%B6%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="toc-number">2.</span> <span class="toc-text">检查硬件虚拟化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#UtilCPUVendor%E8%8E%B7%E5%8F%96CPU%E5%88%B6%E9%80%A0%E5%95%86%E4%BF%A1%E6%81%AF"><span class="toc-number">2.1.</span> <span class="toc-text">UtilCPUVendor获取CPU制造商信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VmxHardSupported%E6%A3%80%E6%9F%A5%E7%A1%AC%E4%BB%B6%E8%99%9A%E6%8B%9F%E5%8C%96%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81"><span class="toc-number">2.2.</span> <span class="toc-text">VmxHardSupported检查硬件虚拟化是否支持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UtilSSDTEntry%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E6%8F%8F%E8%BF%B0%E8%A1%A8%E7%89%B9%E5%AE%9A%E7%B4%A2%E5%BC%95%E5%A4%84%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80"><span class="toc-number">2.3.</span> <span class="toc-text">UtilSSDTEntry获取系统服务描述表特定索引处函数地址</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96SSDT%E8%A1%A8%E5%87%BD%E6%95%B0%E5%9C%B0%E5%9D%80"><span class="toc-number">3.</span> <span class="toc-text">获取SSDT表函数地址</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96SSDT%E8%A1%A8%E5%9F%BA%E5%9C%B0%E5%9D%80"><span class="toc-number">3.1.</span> <span class="toc-text">获取SSDT表基地址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96NTOS%E5%86%85%E6%A0%B8%E5%9F%BA%E5%9C%B0%E5%9D%80"><span class="toc-number">3.1.1.</span> <span class="toc-text">获取NTOS内核基地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%BB%99%E5%AE%9A%E5%8C%BA%E5%9F%9F%E8%BF%9B%E8%A1%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">3.1.2.</span> <span class="toc-text">对给定区域进行模式匹配</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">4.</span> <span class="toc-text">初始化全局变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF"><span class="toc-number">5.</span> <span class="toc-text">获取物理内存信息</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">6.</span> <span class="toc-text">释放全局变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5CPU%E8%99%9A%E6%8B%9F%E5%8C%96%E7%89%B9%E6%80%A7"><span class="toc-number">7.</span> <span class="toc-text">检查CPU虚拟化特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E5%B9%B6%E8%AE%B0%E5%BD%95%E7%9B%B8%E5%BA%94%E7%9A%84CPU%E8%99%9A%E6%8B%9F%E5%8C%96%E7%89%B9%E6%80%A7"><span class="toc-number">7.1.</span> <span class="toc-text">检查并记录相应的CPU虚拟化特性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HVM%E4%B8%8EVMX"><span class="toc-number">8.</span> <span class="toc-text">HVM与VMX</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="toc-number">9.</span> <span class="toc-text">开启虚拟化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DPC%E5%9B%9E%E8%B0%83%E8%BF%9B%E8%A1%8C%E8%99%9A%E6%8B%9F%E5%8C%96%E5%A4%84%E7%90%86"><span class="toc-number">9.1.</span> <span class="toc-text">DPC回调进行虚拟化处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96IntelCPU"><span class="toc-number">9.1.1.</span> <span class="toc-text">初始化IntelCPU</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E-CONTEXT-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E6%81%A2%E5%A4%8D%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">9.1.1.1.</span> <span class="toc-text">从 CONTEXT 结构体中恢复寄存器上下文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Intel%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E5%90%AF%E5%8A%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8C%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9FCPU"><span class="toc-number">9.1.1.2.</span> <span class="toc-text">使用Intel虚拟化技术启动虚拟机，创建虚拟CPU</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E4%BF%9D%E6%8A%A4"><span class="toc-number">9.1.1.2.1.</span> <span class="toc-text">设置保护</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8Vmx-Root%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.1.1.2.2.</span> <span class="toc-text">启动Vmx Root模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEVMCS%E5%AD%97%E6%AE%B5"><span class="toc-number">9.1.1.2.3.</span> <span class="toc-text">设置VMCS字段</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B0%86GDT%EF%BC%88%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%EF%BC%89%E4%B8%AD%E7%9A%84%E6%AE%B5%E4%BF%A1%E6%81%AF%E8%BD%AC%E6%8D%A2%E4%B8%BAVMX%EF%BC%88%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A9%E5%B1%95%EF%BC%89%E6%89%80%E9%9C%80%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">9.1.1.2.3.1.</span> <span class="toc-text">将GDT（全局描述符表）中的段信息转换为VMX（虚拟机扩展）所需的格式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B0%86%E5%BD%93%E5%89%8D%E7%8A%B6%E6%80%81%E5%AD%98%E5%82%A8%E5%9C%A8%E6%A0%88%E4%B8%AD%EF%BC%8C%E5%B9%B6%E8%B7%B3%E8%BD%AC%E5%88%B0%E4%B8%80%E4%B8%AA-C-%E5%87%BD%E6%95%B0-VmxpExitHandler-%E4%B8%AD%E5%8E%BB%E5%A4%84%E7%90%86-VM-%E7%9A%84-exit-%E4%BA%8B%E4%BB%B6"><span class="toc-number">9.1.1.2.3.2.</span> <span class="toc-text">将当前状态存储在栈中，并跳转到一个 C 函数 VmxpExitHandler 中去处理 VM 的 exit 事件</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96EPT%EF%BC%8C%E5%88%9B%E5%BB%BAGuest%E5%88%B0Host%E7%9A%84%E9%A1%B5%E6%98%A0%E5%B0%84%EF%BC%88Page-Mappings%EF%BC%89"><span class="toc-number">9.1.1.2.4.</span> <span class="toc-text">初始化EPT，创建Guest到Host的页映射（Page Mappings）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%86%E9%85%8DEPT%E9%A1%B5%E9%9D%A2"><span class="toc-number">9.1.1.2.4.1.</span> <span class="toc-text">分配EPT页面</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%A8%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84IRQL%E7%94%B3%E8%AF%B7%E9%A1%B5%E9%9D%A2"><span class="toc-number">9.1.1.2.4.2.</span> <span class="toc-text">-在更高级的IRQL申请页面</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E5%B7%B2%E4%BD%BF%E7%94%A8%E7%9A%84%E7%89%A9%E7%90%86%E5%8C%BA%E5%9F%9F%E5%A1%AB%E5%85%85-PML4-%E8%A1%A8"><span class="toc-number">9.1.1.2.4.3.</span> <span class="toc-text">根据已使用的物理区域填充 PML4 表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%9B%B4%E6%96%B0EPT%E8%A1%A8%E9%A1%B9"><span class="toc-number">9.1.1.2.4.4.</span> <span class="toc-text">-递归更新EPT表项</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%80%93%E8%AE%A1%E7%AE%97-EPT-%E8%A1%A8%E9%A1%B9%E7%B4%A2%E5%BC%95%EF%BC%88Table-Index%EF%BC%89"><span class="toc-number">9.1.1.2.4.5.</span> <span class="toc-text">–计算 EPT 表项索引（Table Index）</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8CPU%E4%B8%8A%E5%BC%80%E5%90%AFEPT"><span class="toc-number">9.1.1.2.5.</span> <span class="toc-text">在CPU上开启EPT</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%B7%E6%96%B0EPT%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">9.1.1.2.5.1.</span> <span class="toc-text">刷新EPT上下文</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AMD-CPU-%E4%B8%8D%E6%94%AF%E6%8C%81"><span class="toc-number">9.1.2.</span> <span class="toc-text">AMD CPU 不支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8A%E6%94%BEIntelCPU"><span class="toc-number">9.1.3.</span> <span class="toc-text">释放IntelCPU</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E6%A0%B9%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2%E5%9B%9E%E9%9D%9E%E6%A0%B9%E6%A8%A1%E5%BC%8F"><span class="toc-number">9.1.3.1.</span> <span class="toc-text">从根模式切换回非根模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E7%9F%A5VMM"><span class="toc-number">9.1.3.1.1.</span> <span class="toc-text">通知VMM</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B8%85%E9%99%A4VMX%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE"><span class="toc-number">9.1.3.1.2.</span> <span class="toc-text">清除VMX相关设置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8A%E6%94%BEEPT%E7%9A%84%E8%BA%AB%E4%BB%BD%E6%98%A0%E5%B0%84"><span class="toc-number">9.1.3.1.3.</span> <span class="toc-text">释放EPT的身份映射</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AMD%E4%B8%8D%E6%94%AF%E6%8C%81"><span class="toc-number">9.1.4.</span> <span class="toc-text">AMD不支持</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E8%99%9A%E6%8B%9F%E5%8C%96"><span class="toc-number">9.2.</span> <span class="toc-text">停止虚拟化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B%E6%B5%8B%E8%AF%95"><span class="toc-number">10.</span> <span class="toc-text">开始测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E9%A1%B5%E9%9D%A2%E9%92%A9%E5%AD%90"><span class="toc-number">10.1.</span> <span class="toc-text">测试页面钩子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TestFn"><span class="toc-number">10.1.1.</span> <span class="toc-text">TestFn</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hkTestFn"><span class="toc-number">10.1.2.</span> <span class="toc-text">hkTestFn</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94%E5%87%BD%E6%95%B0%E7%9A%84HookEntry"><span class="toc-number">10.1.2.1.</span> <span class="toc-text">获取对应函数的HookEntry</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E9%92%A9%E5%AD%90"><span class="toc-number">10.1.3.</span> <span class="toc-text">页面钩子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E7%89%A9%E7%90%86%E5%B8%A7"><span class="toc-number">10.1.3.1.</span> <span class="toc-text">计算物理帧</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%A1%B5%E9%9D%A2%E5%87%BD%E6%95%B0%E9%92%A9%E5%AD%90%E4%BF%A1%E6%81%AF"><span class="toc-number">10.1.3.2.</span> <span class="toc-text">获取页面函数钩子信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E7%BB%99%E5%AE%9A%E6%88%90%E5%91%98%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%9D%E5%A7%8B%E4%BD%8D%E7%BD%AE"><span class="toc-number">10.1.3.3.</span> <span class="toc-text">计算给定成员的结构体初始位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87LDASM%E5%B7%A5%E5%85%B7%E5%B0%86%E5%8E%9F%E5%A7%8B%E5%AD%97%E8%8A%82%E5%A4%8D%E5%88%B6%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%AD"><span class="toc-number">10.1.3.4.</span> <span class="toc-text">通过LDASM工具将原始字节复制到指定的缓冲区中</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#LDASM-%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4%E9%95%BF%E5%BA%A6"><span class="toc-number">10.1.3.4.1.</span> <span class="toc-text">LDASM 返回指令长度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">10.1.3.4.2.</span> <span class="toc-text">构造跳转指令字节码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%8F%E4%B8%AACPU%E9%A1%B5%E9%9D%A2%E9%92%A9%E5%AD%90%E5%92%8C%E8%A7%A3%E9%92%A9%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">10.1.3.5.</span> <span class="toc-text">每个CPU页面钩子和解钩的回调函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%99%A4%E9%A1%B5%E9%9D%A2%E9%92%A9%E5%AD%90"><span class="toc-number">10.1.4.</span> <span class="toc-text">解除页面钩子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%BD%93%E5%89%8D%E5%87%BD%E6%95%B0%E6%9C%89%E5%A4%9A%E5%B0%91%E4%B8%AAhook"><span class="toc-number">10.1.4.1.</span> <span class="toc-text">计算当前函数有多少个hook</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%85%A5%E5%8F%A3%E9%92%A9%E5%AD%90"><span class="toc-number">10.2.</span> <span class="toc-text">系统调用入口钩子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%86%85%E6%A0%B8PE%E6%96%87%E4%BB%B6%E7%9A%84%E6%8C%87%E5%AE%9Asection%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E7%9A%84pattern"><span class="toc-number">10.2.1.</span> <span class="toc-text">在内核PE文件的指定section中查找指定的pattern</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LSTAR-Hook-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">10.2.2.</span> <span class="toc-text">LSTAR Hook 回调函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SyscallEntryPoint"><span class="toc-number">10.2.3.</span> <span class="toc-text">SyscallEntryPoint</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EFLAGS"><span class="toc-number">10.2.3.1.</span> <span class="toc-text">EFLAGS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MXCSR"><span class="toc-number">10.2.3.2.</span> <span class="toc-text">MXCSR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CS%E9%80%89%E6%8B%A9%E5%AD%90"><span class="toc-number">10.2.3.3.</span> <span class="toc-text">CS选择子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E9%92%A9%E5%AD%90"><span class="toc-number">10.3.</span> <span class="toc-text">系统调用钩子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hkNtClose"><span class="toc-number">10.4.</span> <span class="toc-text">hkNtClose</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hkNtClose2"><span class="toc-number">10.5.</span> <span class="toc-text">hkNtClose2</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E5%8D%B8%E8%BD%BD"><span class="toc-number">11.</span> <span class="toc-text">驱动卸载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C"><span class="toc-number">11.1.</span> <span class="toc-text">打印测试结果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E6%B5%8B%E8%AF%95"><span class="toc-number">11.2.</span> <span class="toc-text">停止测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%81%A2%E5%A4%8DSSDT%E8%A1%A8"><span class="toc-number">11.2.1.</span> <span class="toc-text">恢复SSDT表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8A%E6%94%BELSTAR%E9%92%A9%E5%AD%90"><span class="toc-number">11.2.2.</span> <span class="toc-text">释放LSTAR钩子</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/04/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="线程池">线程池</a><time datetime="2024-02-04T13:08:39.000Z" title="Created 2024-02-04 21:08:39">2024-02-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/04/VT-x/" title="VT-x">VT-x</a><time datetime="2024-02-04T13:02:40.000Z" title="Created 2024-02-04 21:02:40">2024-02-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/04/TLS/" title="TLS">TLS</a><time datetime="2024-02-04T13:01:16.000Z" title="Created 2024-02-04 21:01:16">2024-02-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/04/Hook%E8%AE%A1%E7%AE%97%E5%99%A8%E4%BB%A5%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97/" title="Hook计算器以显示中文数字">Hook计算器以显示中文数字</a><time datetime="2024-02-04T12:55:21.000Z" title="Created 2024-02-04 20:55:21">2024-02-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/" title="PE文件格式">PE文件格式</a><time datetime="2024-02-04T12:51:11.000Z" title="Created 2024-02-04 20:51:11">2024-02-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By qianmu</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async src="https://npm.elemecdn.com/tzy-blog/lib/js/other/sakura.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":225,"height":450},"mobile":{"show":true},"log":false});</script></body></html>