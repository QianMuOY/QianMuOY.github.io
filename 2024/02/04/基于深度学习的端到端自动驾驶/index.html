<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>基于深度学习的端到端自动驾驶 | qianmu's blog</title><meta name="author" content="qianmu"><meta name="copyright" content="qianmu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基于深度学习的端到端自动驾驶主体来源:钱斌的博客  1.模拟平台安装和基本使用1.1模拟器的安装下载地址：右键或点击此处或按住ctrl+&#x2F;进入代码模式，复制链接到浏览器打开。 该地址中提供的模拟器是基于Unity开发的，是经过删减过后的可执行程序，不再需要额外安装unity，下载下来后就可以直接运行。目前覆盖windows、Linux、Mac共3个版本。以下只讲解如何在windows平台">
<meta property="og:type" content="article">
<meta property="og:title" content="基于深度学习的端到端自动驾驶">
<meta property="og:url" content="https://qianmuoy.github.io/2024/02/04/%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%AB%AF%E5%88%B0%E7%AB%AF%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/index.html">
<meta property="og:site_name" content="qianmu&#39;s blog">
<meta property="og:description" content="基于深度学习的端到端自动驾驶主体来源:钱斌的博客  1.模拟平台安装和基本使用1.1模拟器的安装下载地址：右键或点击此处或按住ctrl+&#x2F;进入代码模式，复制链接到浏览器打开。 该地址中提供的模拟器是基于Unity开发的，是经过删减过后的可执行程序，不再需要额外安装unity，下载下来后就可以直接运行。目前覆盖windows、Linux、Mac共3个版本。以下只讲解如何在windows平台">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-02-04T12:42:03.000Z">
<meta property="article:modified_time" content="2024-02-04T12:42:31.394Z">
<meta property="article:author" content="qianmu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://qianmuoy.github.io/2024/02/04/%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%AB%AF%E5%88%B0%E7%AB%AF%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '基于深度学习的端到端自动驾驶',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-04 20:42:31'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="qianmu's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">11</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="qianmu's blog"><span class="site-name">qianmu's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">基于深度学习的端到端自动驾驶</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-02-04T12:42:03.000Z" title="Created 2024-02-04 20:42:03">2024-02-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-02-04T12:42:31.394Z" title="Updated 2024-02-04 20:42:31">2024-02-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AI/">AI</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="基于深度学习的端到端自动驾驶"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="基于深度学习的端到端自动驾驶"><a href="#基于深度学习的端到端自动驾驶" class="headerlink" title="基于深度学习的端到端自动驾驶"></a>基于深度学习的端到端自动驾驶</h1><p>主体来源:<a target="_blank" rel="noopener" href="https://blog.csdn.net/qianbin3200896/article/details/119832583">钱斌的博客</a> </p>
<h2 id="1-模拟平台安装和基本使用"><a href="#1-模拟平台安装和基本使用" class="headerlink" title="1.模拟平台安装和基本使用"></a>1.模拟平台安装和基本使用</h2><h3 id="1-1模拟器的安装"><a href="#1-1模拟器的安装" class="headerlink" title="1.1模拟器的安装"></a>1.1模拟器的安装</h3><p>下载地址：<a target="_blank" rel="noopener" href="https://github.com/tawnkramer/gym-donkeycar/releases">右键或点击此处</a>或按住ctrl+&#x2F;进入代码模式，复制链接到浏览器打开。</p>
<p>该地址中提供的模拟器是基于Unity开发的，是经过删减过后的可执行程序，不再需要额外安装unity，下载下来后就可以直接运行。目前覆盖windows、Linux、Mac共3个版本。以下只讲解如何在windows平台上运行和使用该模拟器。</p>
<p>下载完成后运行donkey_sim.exe文件即可进入模拟器。左边是设置，根据自己的需要进行设置即可。</p>
<p>在场景中，如果我们前面主界面使用了手工模式（paceCar处勾选manualDriving），那么我们就可以通过键盘来操控小车进行体验了。与一般的赛车游戏类似，W键表示前进，A表示左转，D表示右转，S表示后退。</p>
<p>在该模拟器中，控制小车的主要是两个参数：油门（W和S键）和转向角度（A和D键），这个与我们真实驾驶的汽车基本一致：挂挡+踩油门来控制前进动力，打方向盘控制车辆转向。为了能够实现自动驾驶，我们首先要能够根据这两个参数去控制模拟器里面小车的运行。我们怎么样通过Python代码来控制这个模拟器呢？</p>
<h3 id="1-2git工具的安装与配置"><a href="#1-2git工具的安装与配置" class="headerlink" title="1.2git工具的安装与配置"></a>1.2git工具的安装与配置</h3><p>详细的git工具安装与教程请参照<a target="_blank" rel="noopener" href="https://blog.csdn.net/mukes/article/details/115693833">这篇文章</a>，这里仅描述如何在pycharm中使用git</p>
<h4 id="1-2-1注册github账号"><a href="#1-2-1注册github账号" class="headerlink" title="1.2.1注册github账号"></a>1.2.1注册github账号</h4><p> <a target="_blank" rel="noopener" href="https://github.com/">GitHub官网</a> 按照提示进行注册。请注意记下用户名和邮箱地址，下面步骤需要使用。</p>
<h4 id="1-2-2安装git"><a href="#1-2-2安装git" class="headerlink" title="1.2.2安装git"></a>1.2.2安装git</h4><p> <a target="_blank" rel="noopener" href="https://git-scm.com/">到git官网下载git安装包</a>，点击downloads，选择操作平台(windows)，下载完成后运行，第一次选择全勾，后面一直下一步即可。</p>
<p>下载完成后，运行cmd，输入命令检查下载版本。能正确显示版本即为安装成功</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git version</span><br></pre></td></tr></table></figure>

<h4 id="1-2-3配置git"><a href="#1-2-3配置git" class="headerlink" title="1.2.3配置git"></a>1.2.3配置git</h4><p>安装成功后，配置git</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br><span class="line"></span><br><span class="line">git config --global user.email  &quot;用户邮箱&quot;</span><br></pre></td></tr></table></figure>

<p><strong>请注意此处空格必须严格遵循，否则将无法配置成功。建议直接复制过去改。</strong></p>
<p>检查配置是否成功。在最下面会出现属性user.name与user.email，如果没有请重新到回到上一步。</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure>

<h4 id="1-2-4在pycharm中配置git"><a href="#1-2-4在pycharm中配置git" class="headerlink" title="1.2.4在pycharm中配置git"></a>1.2.4在pycharm中配置git</h4><p>file-&gt;settings-&gt;version control-&gt;git，一般此处默认检测系统中安装的第一个git，如果没有检测到请手动选择。</p>
<p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/zeroooorez/article/details/94715752">具体git操作请参照这篇文章</a> 这里不进行描述。</p>
<p>###1.3自动驾驶初体验</p>
<p>这个模拟器的好处就在于预留了Python控制接口，我们只需要安装一个驱动库就可以直接驱动模拟器里面的小车运行（提前安装好Git工具）：</p>
<p>在pycharm下方终端输入以下pip命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install git+https://github.com/tawnkramer/gym-donkeycar</span><br></pre></td></tr></table></figure>

<p> 安装好以后我们可以运行下面的python代码来实现小车的控制（注意：运行下面的代码前先启动模拟器，并停留在模拟器对应地图里） ：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入库</span></span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> gym_donkeycar</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置模拟器环境</span></span><br><span class="line">env = gym.make(<span class="string">&quot;donkey-generated-roads-v0&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 重置当前场景</span></span><br><span class="line">obv = env.reset()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 运行100帧</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="comment"># 定义控制动作</span></span><br><span class="line">    action = np.array([<span class="number">0.3</span>,<span class="number">0.5</span>]) <span class="comment"># 动作控制，0.3表示转向，0.5表示油门</span></span><br><span class="line">    <span class="comment"># 执行动作</span></span><br><span class="line">    obv, reward, done, info = env.step(action)</span><br><span class="line">    <span class="comment"># 取一张图像保存</span></span><br><span class="line">    <span class="keyword">if</span> t == <span class="number">20</span>:</span><br><span class="line">        img = cv2.cvtColor(obv,cv2.COLOR_RGB2BGR)</span><br><span class="line">        cv2.imwrite(<span class="string">&#x27;test.jpg&#x27;</span>,img)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 运行完以后重置当前场景</span></span><br><span class="line">obv = env.reset()</span><br></pre></td></tr></table></figure>

<p> 我们先分析下这段代码。下面这行代码用于设置模拟器环境，简单来说就是启用哪张地图： </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env = gym.make(<span class="string">&quot;donkey-generated-roads-v0&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在这个模拟器里面我们可以用到的地图如下所示：</p>
<ul>
<li><p>“donkey-warehouse-v0”</p>
</li>
<li><p>“donkey-generated-roads-v0”</p>
</li>
<li><p>“donkey-avc-sparkfun-v0”</p>
</li>
<li><p>“donkey-generated-track-v0”</p>
</li>
<li><p>“donkey-roboracingleague-track-v0”</p>
</li>
<li><p>“donkey-waveshare-v0”</p>
</li>
<li><p>“donkey-minimonaco-track-v0”</p>
</li>
<li><p>“donkey-warren-track-v0”</p>
</li>
<li><p>“donkey-thunderhill-track-v0”</p>
</li>
<li><p>“donkey-circuit-launch-track-v0”<br>  接下来的代码里面，我们运行了100帧，每帧都用固定的控制参数来执行：右转0.3、前进0.5。这两个字段就是我们前面提到的转向和油门值。下面给出这两个值的具体定义：</p>
</li>
</ul>
<p>油门值取值范围是[-1，1]，负值代表倒退，正值代表前进。转向值取值范围也是[-1，1]，负值代表向左，正值代表向右。</p>
<p>接下来使用np.array封装这两个参数，然后通过env.step来执行单步动作。执行完动作以后会返回一些信息，其中我们需要重点关注obs这个返回参数，这个参数表示当前位于小车正中间行车记录仪摄像头返回的一帧图像 ，图像宽160像素，高120像素，3通道RGB图像。可以在代码根目录下找到test.jpg文件查看。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Wy4y1h7ii?share_source=copy_web">numpy教程十分钟入门</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Fo4y1d7JL?share_source=copy_web">openCV教程 黑马程序员</a></p>
<p>建议观看以上视频，学习一定的基础知识。当然没有这样的知识硬记语法也是可以的。</p>
<h2 id="2-基于OpenCV的自动驾驶控制"><a href="#2-基于OpenCV的自动驾驶控制" class="headerlink" title="2.基于OpenCV的自动驾驶控制"></a>2.基于OpenCV的自动驾驶控制</h2><p>在学习自动驾驶前，我们先看看传统算法是怎么解决自动驾驶任务的。本节为后续自动驾驶作铺垫，如果不感兴趣可以直接跳转到深度学习部分。</p>
<p>我们希望通过算法来控制小车，最终让这个小车稳定运行在行车道内。这里面涉及到两方面：感知和动作规划。感知部分我们主要通过行道线检测来实现，动作规划通过操控转向角度来实现。行道线检测的目的就是希望能够根据检测到的行道线位置来计算最终应该转向的角度，从而控制小车始终运行在当前车道线内。</p>
<p>由于道路环境比较简单，针对我们这个任务，我们进一步简化我们的控制变量，我们只控制转向角度，对于油门值我们在运行时保持低匀速，这样我们的重点就可以放在一个变量上面—转向角度。</p>
<h3 id="2-1基于HSV空间的特定颜色区域提取"><a href="#2-1基于HSV空间的特定颜色区域提取" class="headerlink" title="2.1基于HSV空间的特定颜色区域提取"></a>2.1基于HSV空间的特定颜色区域提取</h3><p> 颜色过滤是目前经常被使用到的图像处理技巧之一，例如天气预报抠像等，经常会使用绿幕作为背景进行抠图。本小节使用颜色过滤来初步提取出行道线。 </p>
<p>从模拟平台的图像数据上进行分析，小车左侧是黄实线，右侧是白实线。我们希望小车一直运行在这两根线之间。因此，我们首先要定位出这两根线。我们可以通过颜色空间变换来定位这两根线。</p>
<p>为了方便将黄色线和白色线从图像中过滤出来，我们需要将图像从RGB空间转换到HSV空间再处理。</p>
<p>这里首先我们解释下RGB和HSV颜色空间的区别。</p>
<p>RGB 是我们接触最多的颜色空间，由三个通道表示一幅图像，分别为红色(R)，绿色(G)和蓝色(B)。这三种颜色的不同组合可以形成几乎所有的其他颜色。RGB 颜色空间是图像处理中最基本、最常用、面向硬件的颜色空间，比较容易理解。RGB 颜色空间利用三个颜色分量的线性组合来表示颜色，任何颜色都与这三个分量有关，而且这三个分量是高度相关的，所以连续变换颜色时并不直观，想对图像的颜色进行调整需要更改这三个分量才行。自然环境下获取的图像容易受自然光照、遮挡和阴影等情况的影响，即对亮度比较敏感。而 RGB 颜色空间的三个分量都与亮度密切相关，即只要亮度改变，三个分量都会随之相应地改变，而没有一种更直观的方式来表达。但是人眼对于这三种颜色分量的敏感程度是不一样的，在单色中，人眼对红色最不敏感，蓝色最敏感，所以 RGB 颜色空间是一种均匀性较差的颜色空间。如果颜色的相似性直接用欧氏距离来度量，其结果与人眼视觉会有较大的偏差。对于某一种颜色，我们很难推测出较为精确的三个分量数值来表示。所以，RGB 颜色空间适合于显示系统，却并不适合于图像处理。</p>
<p>基于上述理由，在图像处理中使用较多的是 HSV 颜色空间，它比 RGB 更接近人们对彩色的感知经验。非常直观地表达颜色的色调、鲜艳程度和明暗程度，方便进行颜色的对比。在 HSV 颜色空间下，比 BGR 更容易跟踪某种颜色的物体，常用于分割指定颜色的物体。HSV 表达彩色图像的方式由三个部分组成：</p>
<ul>
<li><p>Hue（色调、色相）</p>
</li>
<li><p>Saturation（饱和度、色彩纯净度）</p>
</li>
<li><p>Value（明度）</p>
</li>
</ul>
<p>其中Hue用角度度量，取值范围为0～360°，表示色彩信息，即所处的光谱颜色的位置，如下图所示。</p>
<p> <img src="/.io//b544148acdca474388fc0347f155d4f1.png" alt="img"> </p>
<p>如果我们想要过滤出黄色线，那么我们就可以将色调范围控制在[30~ 90]之间即可。注意：在OpenCV中色调范围是[0~ 180]，因此上述黄色范围需要缩小1倍，即[15~ 45]。检测白色行道线也是采用类似的原理。 </p>
<p>RGB转化到HSV的算法(c++):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">retmax</span><span class="params">(<span class="type">float</span> a,<span class="type">float</span> b,<span class="type">float</span> c)</span><span class="comment">//求最大值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> max = <span class="number">0</span>;</span><br><span class="line">    max = a;</span><br><span class="line">    <span class="keyword">if</span>(max&lt;b)</span><br><span class="line">        max = b;</span><br><span class="line">    <span class="keyword">if</span>(max&lt;c)</span><br><span class="line">        max = c;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">retmin</span><span class="params">(<span class="type">float</span> a,<span class="type">float</span> b,<span class="type">float</span> c)</span><span class="comment">//求最小值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> min = <span class="number">0</span>;</span><br><span class="line">    min = a;</span><br><span class="line">    <span class="keyword">if</span>(min&gt;b)</span><br><span class="line">        min = b;</span><br><span class="line">    <span class="keyword">if</span>(min&gt;c)</span><br><span class="line">        min = c;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//R,G,B参数传入范围（0~100）</span></span><br><span class="line"><span class="comment">//转换结果h(0~360),s(0~100),v(0~100)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rgb_to_hsv</span><span class="params">(<span class="type">float</span> *h,<span class="type">float</span> *s,<span class="type">float</span> *v,<span class="type">float</span> R,<span class="type">float</span> G,<span class="type">float</span> B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> max = <span class="number">0</span>,min = <span class="number">0</span>;</span><br><span class="line">    R = R/<span class="number">100</span>;</span><br><span class="line">    G = G/<span class="number">100</span>;</span><br><span class="line">    B = B/<span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">    max = <span class="built_in">retmax</span>(R,G,B);</span><br><span class="line">    min = <span class="built_in">retmin</span>(R,G,B);</span><br><span class="line">    *v = max;</span><br><span class="line">    <span class="keyword">if</span>(max == <span class="number">0</span>)</span><br><span class="line">        *s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        *s = <span class="number">1</span> - (min/max);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(max == min)</span><br><span class="line">        *h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(max == R &amp;&amp; G&gt;=B)</span><br><span class="line">        *h = <span class="number">60</span>*((G-B)/(max-min));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(max == R &amp;&amp; G&lt;B)</span><br><span class="line">        *h = <span class="number">60</span>*((G-B)/(max-min)) + <span class="number">360</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(max == G)</span><br><span class="line">        *h = <span class="number">60</span>*((B-R)/(max-min)) + <span class="number">120</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(max == B)</span><br><span class="line">        *h = <span class="number">60</span>*((R-G)/(max-min)) + <span class="number">240</span>;</span><br><span class="line"> </span><br><span class="line">    *v = *v * <span class="number">100</span>;</span><br><span class="line">    *s = *s * <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HSV转RGB算法：(c++)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数入参范围h(0~360),s(0~100),v(0~100),这里要注意，要把s,v缩放到0~1之间</span></span><br><span class="line"><span class="comment">//转换结果R(0~100),G(0~100),B(0~100)，如需转换到0~255，只需把后面的乘100改成乘255</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hsv_to_rgb</span><span class="params">(<span class="type">int</span> h,<span class="type">int</span> s,<span class="type">int</span> v,<span class="type">float</span> *R,<span class="type">float</span> *G,<span class="type">float</span> *B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> C = <span class="number">0</span>,X = <span class="number">0</span>,Y = <span class="number">0</span>,Z = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> H=(<span class="type">float</span>)(h);</span><br><span class="line">    <span class="type">float</span> S=(<span class="type">float</span>)(s)/<span class="number">100.0</span>;</span><br><span class="line">    <span class="type">float</span> V=(<span class="type">float</span>)(v)/<span class="number">100.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(S == <span class="number">0</span>)</span><br><span class="line">        *R = *G = *B = V;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        H = H/<span class="number">60</span>;</span><br><span class="line">        i = (<span class="type">int</span>)H;</span><br><span class="line">        C = H - i;</span><br><span class="line"> </span><br><span class="line">        X = V * (<span class="number">1</span> - S);</span><br><span class="line">        Y = V * (<span class="number">1</span> - S*C);</span><br><span class="line">        Z = V * (<span class="number">1</span> - S*(<span class="number">1</span>-C));</span><br><span class="line">        <span class="keyword">switch</span>(i)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> : *R = V; *G = Z; *B = X; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> : *R = Y; *G = V; *B = X; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span> : *R = X; *G = V; *B = Z; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span> : *R = X; *G = Y; *B = V; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span> : *R = Z; *G = X; *B = V; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span> : *R = V; *G = X; *B = Y; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *R = *R *<span class="number">100</span>;</span><br><span class="line">    *G = *G *<span class="number">100</span>;</span><br><span class="line">    *B = *B *<span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而以上方法在opencv中都有封装，仅需要一句代码即可实现。现在我们来检测黄色线与白色线。</p>
<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"><span class="comment">#读取图像并转换到HSV空间</span></span><br><span class="line">frame = cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line">hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 黄色线检测</span></span><br><span class="line">lower_blue = np.array([<span class="number">15</span>, <span class="number">40</span>, <span class="number">40</span>])</span><br><span class="line">upper_blue = np.array([<span class="number">45</span>, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line">yellow_mask = cv2.inRange(hsv, lower_blue, upper_blue)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;yellow_mask.jpg&#x27;</span>,yellow_mask)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 白色线检测</span></span><br><span class="line">lower_blue = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>])</span><br><span class="line">upper_blue = np.array([<span class="number">180</span>, <span class="number">30</span>, <span class="number">255</span>])</span><br><span class="line">white_mask = cv2.inRange(hsv, lower_blue, upper_blue)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;white_mask.jpg&#x27;</span>,white_mask)</span><br></pre></td></tr></table></figure>

<p>运行效果如下图：</p>
<p><img src="/.io//white_mask.jpg"></p>
<p><img src="/.io//yellow_mask.jpg"></p>
<p>可以看到还有很大的干扰存在。主要来自于相似的颜色，因此我们还需要进行进一步的处理。</p>
<h3 id="2-2基于canny算子的边缘轮廓提取"><a href="#2-2基于canny算子的边缘轮廓提取" class="headerlink" title="2.2基于canny算子的边缘轮廓提取"></a>2.2基于canny算子的边缘轮廓提取</h3><p> 目前我们仅获得了行道线区域，为了后续能够方便的计算行道线角度，我们需要得到行道线具体的轮廓&#x2F;线段信息，即从区域中提取出线段。这里我们使用Canny算法实现。</p>
<p>Canny边缘检测是从不同视觉对象中提取有用的结构信息并大大减少要处理的数据量的一种技术，于1986年被提出，目前已广泛应用于各种计算机视觉系统。</p>
<p>Canny算法具体包括5个步骤：</p>
<ol>
<li><pre><code>   使用高斯滤波器，以平滑图像，滤除噪声。
</code></pre>
</li>
<li><pre><code>   计算图像中每个像素点的梯度强度和方向。
</code></pre>
</li>
<li><pre><code>   应用非极大值（Non-Maximum Suppression）抑制，以消除边缘检测带来的杂散响应。
</code></pre>
</li>
<li><pre><code>   应用双阈值（Double-Threshold）检测来确定真实的和潜在的边缘。
</code></pre>
</li>
<li><pre><code>   通过抑制孤立的弱边缘最终完成边缘检测。
</code></pre>
</li>
</ol>
<p>具体实现细节我们不再详细剖析，在OpenCV中集成了canny算法，只需要一行代码即可实现canny边缘检测。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 黄色线边缘提取</span></span><br><span class="line">yellow_edge = cv2.Canny(yellow_mask, <span class="number">200</span>, <span class="number">400</span>)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;yellow_edge.jpg&#x27;</span>, yellow_edge)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 白色线边缘提取white</span></span><br><span class="line">white_edge = cv2.Canny(white_mask, <span class="number">200</span>, <span class="number">400</span>)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;white_edge.jpg&#x27;</span>, white_edge)</span><br></pre></td></tr></table></figure>

<p>有兴趣了解canny的同学可以查看<a target="_blank" rel="noopener" href="https://blog.csdn.net/sodaANDcola/article/details/119821939">这篇博客</a> ,其中运用到的正态分布、偏导、梯度与极限的知识我们都学过，可以理解。高斯核滤波也用于卷积，而实际上的卷积还会复杂一点，可以自行了解。在后面的pytorch版本我会详细解释运行原理。</p>
<p> 代码中200和400这两个参数表示canny算子的低、高阈值，按照opencv教程一般可以不用修改。 </p>
<p> 最终效果： </p>
<p><img src="/.io//white_edge.jpg"></p>
<p><img src="/.io//yellow_edge.jpg"></p>
<h3 id="2-3感兴趣区域-ROI-定位"><a href="#2-3感兴趣区域-ROI-定位" class="headerlink" title="2.3感兴趣区域(ROI)定位"></a>2.3感兴趣区域(ROI)定位</h3><p>在利用OpenCV对图像进行处理时，通常会遇到一个情况，就是只需要对部分感兴趣区域（Region Of Interest, ROI）进行处理。例如针对我们这个模拟平台上的智能小车任务来说，对于黄色行道线，我们只关注图像右下部分，而对于白色行道线，我们只关注图像左下部分即可。至于图像其他部分因为我们通过人工分析知道，这些区域我们并不需要处理。因此，我们只用提取图像的对应区域。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">region_of_interest</span>(<span class="params">edges, color=<span class="string">&#x27;yellow&#x27;</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    感兴趣区域提取</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    height, width, _ = edges.shape</span><br><span class="line">    mask = np.zeros_like(edges)</span><br><span class="line">    <span class="comment"># 定义感兴趣区域掩码轮廓</span></span><br><span class="line">    <span class="keyword">if</span> color == <span class="string">&#x27;yellow&#x27;</span>:</span><br><span class="line">        polygon = np.array([[(width * <span class="number">1</span> / <span class="number">2</span>, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                                (width, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                                (width, height),</span><br><span class="line">                                (width * <span class="number">1</span> / <span class="number">2</span>, height)]], np.int32)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        polygon = np.array([[(<span class="number">0</span>, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                             (width * <span class="number">1</span> / <span class="number">2</span>, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                             (width * <span class="number">1</span> / <span class="number">2</span>, height),</span><br><span class="line">                             (<span class="number">0</span>, height)]], np.int32)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 填充感兴趣区域掩码</span></span><br><span class="line">    cv2.fillPoly(mask, polygon, (<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>))</span><br><span class="line">    <span class="comment"># 提取感兴趣区域</span></span><br><span class="line">    croped_edge = cv2.bitwise_and(edges, mask)</span><br><span class="line">    <span class="keyword">return</span> croped_edge</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    yimg = cv2.imread(<span class="string">&#x27;yellow_edge.jpg&#x27;</span>)</span><br><span class="line">    wimg = cv2.imread(<span class="string">&#x27;white_edge.jpg&#x27;</span>)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;white_edge_new.jpg&#x27;</span>, region_of_interest(wimg, <span class="string">&#x27;white&#x27;</span>))</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;yellow_edge_new.jpg&#x27;</span>, region_of_interest(yimg))</span><br></pre></td></tr></table></figure>

<p>这里定义感兴趣区域、填充感兴趣区域是使用了暴力的直接定位法，按住ctrl+函数名可以进入cv2.fillPoly查看函数的参数与具体作用。在实际应用中我们还有一些更加高级的方法来锁定感兴趣区域，但对于模拟器而言这种方法已经够用。注意这一段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    感兴趣区域提取</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    height, width, _ = edges.shape</span><br><span class="line">    mask = np.zeros_like(edges)</span><br></pre></td></tr></table></figure>

<p>edges.shape返回有三个参数，分别为高度、宽度、通道数，如rgb图像就是三通道的。但是下面我们用不到通道数的值，但解包赋值需要把返回值全部接受，因此此处用_ 暂时存放通道数。</p>
<p>对于如何填充矩形有兴趣的同学，可以查看<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43525427/article/details/105317567">这篇博客</a> 。这里进行部分的转载。</p>
<p>一、fillConvexPoly( )函数<br>以填充矩形为例<br>我图中想填充以1、2、3、4为顶点的矩形，我就要按1、2、3、4的顺序给出坐标序列array，或者是连贯的相邻顶点顺序（比如1432，4321…）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rectangular = np.array([ [<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">740</span>], [<span class="number">4032</span>,<span class="number">740</span>], [<span class="number">4032</span>,<span class="number">0</span>] ])</span><br><span class="line">cv2.fillConvexPoly(img_gray, rectangular, (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br></pre></td></tr></table></figure>

<p> 效果如下图所示<img src="/.io//20200404212500502.png" alt="在这里插入图片描述"> </p>
<p>那如果不按邻边顺序，如果我写成1423会如何呢？来看。</p>
<p> <img src="/.io//20200404213614360.png" alt="在这里插入图片描述"> </p>
<p>emmm， 我觉得想画五角星的画可以这样。</p>
<p>二、fillPoly( )函数<br>好了，上面都是基本操作，看看官方教程都可以。<br>我们玩点别的。<br>我如果想把一个矩形区域留住（拿车牌举例），剩下的填充为白色应该怎么办呢？<br>举一反三一下，两种办法：<br>（1）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.fillPoly(img_gray, [rec1, rec2, rec3, rec4], (<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>))</span><br></pre></td></tr></table></figure>

<p>四个矩形，改用fillPoly（）方法。</p>
<p> <img src="/.io//20200404221502411.png" alt="在这里插入图片描述"> </p>
<p>结果如上图。</p>
<p>（2）非要死脑筋其实用fillConvexPoly( )也不是不可以。</p>
<p> <img src="/.io//2020040422244385.png" alt="在这里插入图片描述"> </p>
<p>画个示意图，你们懂我意思吧。</p>
<p>定位后，我们的图片如下所示，可以看到更加“整洁”了。</p>
<p><img src="/.io//white_edge_new.jpg"></p>
<p><img src="/.io//yellow_edge_new.jpg"></p>
<p>###2.4基于霍夫变换的线段检测</p>
<p>到目前，我们抽取出了比较精确的行道线轮廓，但是对于实际的自动驾驶任务来说还没有完成目标任务要求，我们要对行道线轮廓再进一步处理，得到行道线的具体线段信息（每条线段的起始点坐标）。本小节我们使用霍夫变换来完成这个任务。霍夫变换，英文名称Hough Transform，作用是用来检测图像中的直线或者圆等几何图形的。</p>
<p>具体的，一条直线的表示方法有好多种，最常见的是y&#x3D;mx+b的形式。结合我们这个任务，对于最终检测出的感兴趣区域，怎么把图片中的直线提取出来。基本的思考流程是：如果直线 y&#x3D;mx+b 在图片中，那么图片中，必需有N多点在直线上（像素点代入表达式成立），只要有这条直线上的两个点，就能确定这条直线。该问题可以转换为：求解所有的(m,b)组合。<strong>【以下是部分原理，不感兴趣的同学可以直接跳到代码】</strong></p>
<p>设置两个坐标系，左边的坐标系表示的是(x,y)值，右边的坐标系表达的是(m,b)的值，即直线的参数值。那么一个(x,y)点在右边对应的就是一条线，左边坐标系的一条直线就是右边坐标系中的一个点。这样，右边左边系中的交点就表示有多个点经过(k,b)确定的直线。但是，该方法存在一个问题，(m,b)的取值范围太大。</p>
<p> <img src="/.io//a3c0d9612c82496cbd1bdaa987971f1c.png" alt="img"> </p>
<p>为了解决(m,b)取值范围过大的问题，在直线的表示方面用 <em>xcosθ+ysinθ&#x3D;r</em> 的规范式代替一般表达式，参数空间变成(θ,r)，0&#x3D;&lt;θ&lt;&#x3D;2PI。这样图像空间中的一个像素点在参数空间中就是一条曲线（三角函数曲线）。</p>
<p> <img src="/.io//2238243e98dd8ea95315fa27848f801f.png" alt="image-20220321140942980"> </p>
<p> 此时，图像空间和参数空间的对应关系如下： </p>
<p> <img src="/.io//20200211011825716.jpg" alt="img"> </p>
<p>从图中可以看出，霍夫直线检测即为在参数空间中对r和theta投票的过程，得票最高者为最终的直线参数。  theta表示与直线垂直的线与x轴的夹角，那么他的取值范围就是-pi到pi ，但显然取0-pi就可以表示所有直线。</p>
<p>更详细的数学原理请查看<a target="_blank" rel="noopener" href="https://blog.csdn.net/u013066730/article/details/123086027">这篇博客</a> ，其中涉及到笛卡尔坐标向极坐标变换(事实上是一个特殊的参数空间)的讨论，对数学感兴趣的同学可以深入了解，这里不再展示。走到这一步，流程图如下所示。</p>
<p>霍夫线段检测算法原理步骤如下：</p>
<ul>
<li>初始化(θ,r)空间，N(θ,r)&#x3D;0 。（N(θ,r)表示在该参数表示的直线上的像素点的个数）</li>
<li>对于每一个像素点(x,y)，在参数空间中找出令 xcosθ+ysinθ&#x3D;r 的(θ,r)坐标，N(θ,r)+&#x3D;1</li>
<li>统计所有N(θ,r)的大小，取出N(θ,r)&gt;threasold的参数 。（threadsold是预设的阈值）</li>
</ul>
<p> OpenCV中封装好了基于霍夫变换的直线检测方法HoughLinesP，下面我们就来使用它进行线段检测。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">detect_line</span>(<span class="params">edges</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    基于霍夫变换的直线检测</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    rho = <span class="number">1</span>  <span class="comment"># 距离精度：1像素</span></span><br><span class="line">    angle = np.pi / <span class="number">180</span>  <span class="comment">#角度精度：1度</span></span><br><span class="line">    min_thr = <span class="number">10</span>  <span class="comment">#最少投票数</span></span><br><span class="line">    lines = cv2.HoughLinesP(edges,</span><br><span class="line">                            rho,</span><br><span class="line">                            angle,</span><br><span class="line">                            min_thr,</span><br><span class="line">                            np.array([]),</span><br><span class="line">                            minLineLength=<span class="number">8</span>,</span><br><span class="line">                            maxLineGap=<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">return</span> lines</span><br></pre></td></tr></table></figure>

<p>我们可以print一下lines，结果如下(此处仅作展示，后面有这一步的完整代码)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[[[  1  94  47  62]]</span><br><span class="line"> [[143  94 156 103]]</span><br><span class="line"> [[103  67 119  77]]</span><br><span class="line"> [[  1  86  41  60]]</span><br><span class="line"> [[101  52 158  56]]</span><br><span class="line"> [[104  69 159 100]]</span><br><span class="line"> [[  5  52  22  53]]</span><br><span class="line"> [[129  63 140  63]]</span><br><span class="line"> [[ 87  50 110  52]]</span><br><span class="line"> [[  0  88  17  77]]</span><br><span class="line"> [[ 88  55 134  89]]</span><br><span class="line"> [[  2  94  36  70]]</span><br><span class="line"> [[ 17  50  29  50]]</span><br><span class="line"> [[ 23  73  42  60]]</span><br><span class="line"> [[ 90  56 110  70]]</span><br><span class="line"> [[  1  56  16  51]]</span><br><span class="line"> [[128  55 148  56]]</span><br><span class="line"> [[  0  89   8  84]]</span><br><span class="line"> [[ 88  56 112  75]]</span><br><span class="line"> [[151 101 159 104]]</span><br><span class="line"> [[ 30  73  43  61]]]</span><br></pre></td></tr></table></figure>

<p>返回的每组值都是一条线段表示线段起始位置(x_start,y_start,x_end,y_end)。可以看到小线段很多，我们对这些小线段做一下聚类和平均： </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">average_lines</span>(<span class="params">frame, lines, direction=<span class="string">&#x27;left&#x27;</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    小线段聚类</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    lane_lines = []</span><br><span class="line">    <span class="keyword">if</span> lines <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(direction + <span class="string">&#x27;没有检测到线段&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> lane_lines</span><br><span class="line">    height, width, _ = frame.shape</span><br><span class="line">    fits = []</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line:</span><br><span class="line">            <span class="keyword">if</span> x1 == x2:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 计算拟合直线</span></span><br><span class="line">            fit = np.polyfit((x1, x2), (y1, y2), <span class="number">1</span>)</span><br><span class="line">            slope = fit[<span class="number">0</span>]</span><br><span class="line">            intercept = fit[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> direction == <span class="string">&#x27;left&#x27;</span> <span class="keyword">and</span> slope &lt; <span class="number">0</span>:</span><br><span class="line">                fits.append((slope, intercept))</span><br><span class="line">            <span class="keyword">elif</span> direction == <span class="string">&#x27;right&#x27;</span> <span class="keyword">and</span> slope &gt; <span class="number">0</span>:</span><br><span class="line">                fits.append((slope, intercept))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(fits) &gt; <span class="number">0</span>:</span><br><span class="line">        fit_average = np.average(fits, axis=<span class="number">0</span>)</span><br><span class="line">        lane_lines.append(make_points(frame, fit_average))</span><br><span class="line">    <span class="keyword">return</span> lane_lines</span><br></pre></td></tr></table></figure>

<p>这里需要注意，由于图像的y坐标跟我们数学上经常遇到的y坐标方向是相反的（图像的y坐标轴正向是朝下的），因此，左侧黄色实线斜率是负值，右侧白色实线斜率是正值。上述代码我们将所有小线段的斜率和截距进行了平均，并且使用make_points函数重新计算了该平均线对应到图像上的起始坐标位置，make_points函数如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_points</span>(<span class="params">frame, line</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    根据直线斜率和截距计算线段起始坐标</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    height, width, _ = frame.shape</span><br><span class="line">    slope, intercept = line</span><br><span class="line">    y1 = height</span><br><span class="line">    y2 = <span class="built_in">int</span>(y1 * <span class="number">1</span> / <span class="number">2</span>)</span><br><span class="line">    x1 = <span class="built_in">max</span>(-width, <span class="built_in">min</span>(<span class="number">2</span> * width, <span class="built_in">int</span>((y1 - intercept) / slope)))</span><br><span class="line">    x2 = <span class="built_in">max</span>(-width, <span class="built_in">min</span>(<span class="number">2</span> * width, <span class="built_in">int</span>((y2 - intercept) / slope)))</span><br><span class="line">    <span class="keyword">return</span> [[x1, y1, x2, y2]]</span><br></pre></td></tr></table></figure>

<p>上述函数最后返回的是坐标数值，这样看线段的坐标值不是很直观，我们可以写个脚本显式的观察这些线段： </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">display_line</span>(<span class="params">frame, lines, line_color=(<span class="params"><span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span></span>), line_width=<span class="number">2</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    在原图上展示线段</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    line_img = np.zeros_like(frame)</span><br><span class="line">    <span class="keyword">if</span> lines <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line:</span><br><span class="line">                cv2.line(line_img, (x1, y1), (x2, y2), line_color, line_width)</span><br><span class="line">    line_img = cv2.addWeighted(frame, <span class="number">0.8</span>, line_img, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> line_img</span><br></pre></td></tr></table></figure>

<p>上述代码我们将行道线按照一定权重与原图进行合成，方便我们查看最终效果。 </p>
<p>完整代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">detect_line</span>(<span class="params">edges</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    基于霍夫变换的直线检测</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    rho = <span class="number">1</span>  <span class="comment"># 距离精度：1像素</span></span><br><span class="line">    angle = np.pi / <span class="number">180</span>  <span class="comment"># 角度精度：1度</span></span><br><span class="line">    min_thr = <span class="number">10</span>  <span class="comment"># 最少投票数</span></span><br><span class="line">    lines = cv2.HoughLinesP(edges,rho, angle,min_thr,np.array([]),minLineLength=<span class="number">8</span>,maxLineGap=<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">return</span> lines</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">average_lines</span>(<span class="params">frame, lines, direction=<span class="string">&#x27;left&#x27;</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    小线段聚类</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    lane_lines = []</span><br><span class="line">    <span class="keyword">if</span> lines <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(direction + <span class="string">&#x27;没有检测到线段&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> lane_lines</span><br><span class="line">    <span class="comment">#height, width , _= frame.shape</span></span><br><span class="line">    fits = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line:</span><br><span class="line">            <span class="keyword">if</span> x1 == x2:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 计算拟合直线</span></span><br><span class="line">            fit = np.polyfit((x1, x2), (y1, y2), <span class="number">1</span>)</span><br><span class="line">            slope = fit[<span class="number">0</span>]</span><br><span class="line">            intercept = fit[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> direction == <span class="string">&#x27;left&#x27;</span> <span class="keyword">and</span> slope &lt; <span class="number">0</span>:</span><br><span class="line">                fits.append((slope, intercept))</span><br><span class="line">            <span class="keyword">elif</span> direction == <span class="string">&#x27;right&#x27;</span> <span class="keyword">and</span> slope &gt; <span class="number">0</span>:</span><br><span class="line">                fits.append((slope, intercept))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(fits) &gt; <span class="number">0</span>:</span><br><span class="line">        fit_average = np.average(fits, axis=<span class="number">0</span>)</span><br><span class="line">        lane_lines.append(make_points(frame, fit_average))</span><br><span class="line">    <span class="keyword">return</span> lane_lines</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_points</span>(<span class="params">frame, line</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    根据直线斜率和截距计算线段起始坐标</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    height, width= frame.shape</span><br><span class="line">    slope, intercept = line</span><br><span class="line">    y1 = height</span><br><span class="line">    y2 = <span class="built_in">int</span>(y1 * <span class="number">1</span> / <span class="number">2</span>)</span><br><span class="line">    x1 = <span class="built_in">max</span>(-width, <span class="built_in">min</span>(<span class="number">2</span> * width, <span class="built_in">int</span>((y1 - intercept) / slope)))</span><br><span class="line">    x2 = <span class="built_in">max</span>(-width, <span class="built_in">min</span>(<span class="number">2</span> * width, <span class="built_in">int</span>((y2 - intercept) / slope)))</span><br><span class="line">    <span class="keyword">return</span> [[x1, y1, x2, y2]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">display_line</span>(<span class="params">frame, lines, line_color=(<span class="params"><span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span></span>), line_width=<span class="number">2</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    在原图上展示线段</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    line_img = np.zeros_like(frame)</span><br><span class="line">    <span class="keyword">if</span> lines <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line:</span><br><span class="line">                cv2.line(line_img, (x1, y1), (x2, y2), line_color, line_width)</span><br><span class="line">    line_img = cv2.addWeighted(frame, <span class="number">0.8</span>, line_img, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> line_img</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    yimg = cv2.imread(<span class="string">&#x27;yellow_edge_new.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">    wimg = cv2.imread(<span class="string">&#x27;white_edge_new.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#霍夫变换</span></span><br><span class="line">    yimg_detect_line = detect_line(yimg)</span><br><span class="line">    wimg_detect_line = detect_line(wimg)</span><br><span class="line">    <span class="comment">#小线段聚类</span></span><br><span class="line">    yimg_average_lines = average_lines(yimg,yimg_detect_line,direction=<span class="string">&#x27;right&#x27;</span>)</span><br><span class="line">    wimg_average_lines = average_lines(wimg,wimg_detect_line)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#在原图上展示线段</span></span><br><span class="line">    y=cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line">    w=cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line">    yellow_display_line = display_line(y, yimg_average_lines)</span><br><span class="line">    white_display_line = display_line(w, wimg_average_lines)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;yellow_display_line.jpg&#x27;</span>, yellow_display_line)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;white_display_line.jpg&#x27;</span>, white_display_line)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment">#函数入口</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>我们来分析一下几段容易出错的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(fits) &gt; <span class="number">0</span>:</span><br><span class="line">        fit_average = np.average(fits, axis=<span class="number">0</span>)</span><br><span class="line">        lane_lines.append(make_points(frame, fit_average))</span><br></pre></td></tr></table></figure>

<p>注意此处已经嵌套调用了make_points函数，返回了图片的x，y坐标。后续不需要再进行make_points，否则将会出现传入参数错误。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    yimg = cv2.imread(<span class="string">&#x27;yellow_edge_new.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">    wimg = cv2.imread(<span class="string">&#x27;white_edge_new.jpg&#x27;</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>这里imread后面多带一个参数0，表示以单通道读入。即使图像显示为黑白，它仍然可能是三通道的，而yimg_detect_line中HoughLinesP霍夫变换只接受单通道的图片。这里不加0这个参数将会出现错误。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">display_line</span>(<span class="params">frame, lines, line_color=(<span class="params"><span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span></span>), line_width=<span class="number">2</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    在原图上展示线段</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>注意line_color传入的rgb三色值是倒过来的，实际上红色对应的是(255，0，0)，而(0， 0， 255)是紫蓝色(?)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">height, width= frame.shape</span><br></pre></td></tr></table></figure>

<p>某些.shape返回的是三个参数，第三个表示的是通道数。一般用_ 来接收这个不需要用到的通道数，而此处不会返回这个值，所以加入_ 会出错。实际应该根据编译器的提示进行修改(因为我也没摸透为什么，可能图片经过其他函数的一些转换后，不会返回这个参数。实际上修改起来也比较简单。)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在原图上展示线段</span></span><br><span class="line">    y=cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line">    w=cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line">    yellow_display_line = display_line(y, yimg_average_lines)</span><br><span class="line">    white_display_line = display_line(w, wimg_average_lines)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;yellow_display_line.jpg&#x27;</span>, yellow_display_line)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;white_display_line.jpg&#x27;</span>, white_display_line)</span><br></pre></td></tr></table></figure>

<p>这里读入我们拍摄的彩色图片，将红色的线段合成上去。整体代码运行结果如下：</p>
<p><img src="/.io//white_display_line.jpg"></p>
<p><img src="/.io//yellow_display_line.jpg"></p>
<p> 从效果上看我们准确的将两条行道线检测了出来。接下来就是根据这两条行道线进行自动驾驶方向控制。 </p>
<h3 id="2-5动作控制：转向角"><a href="#2-5动作控制：转向角" class="headerlink" title="2.5动作控制：转向角"></a>2.5动作控制：转向角</h3><p>针对前面的测试图片，我们可以有效的检测出两条行道线（左侧黄色线和右侧白色线），但是在真实的运行过程中，可能会出现3种情况：</p>
<p>(1)正常检测到2条行道线：这种情况一般是直线车道且车辆稳定运行在行道线内，这时候我们只需要根据检测出的两条行道线微调整角度即可。</p>
<p>(2)检测出1条行道线：这种情况在转弯处容易出现，或者在车辆开始大范围偏离时出现，这时候我们的策略应该是向能够检测到的这条行道线方向前进。</p>
<p>(3)检测不到行道线：这种情况应该停下小车。</p>
<p>因此，针对三种情况我们需要不同的处理方式。代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算转向角</span></span><br><span class="line">x_offset = <span class="number">0</span></span><br><span class="line">y_offset = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(yellow_lane)&gt;<span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(white_lane)&gt;<span class="number">0</span>:  <span class="comment"># 检测到2条线</span></span><br><span class="line">    _, _, left_x2, _ = yellow_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    _, _, right_x2, _ = white_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    mid = <span class="built_in">int</span>(width / <span class="number">2</span>)</span><br><span class="line">    x_offset = (left_x2 + right_x2) / <span class="number">2</span> - mid</span><br><span class="line">    y_offset = <span class="built_in">int</span>(height / <span class="number">2</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">len</span>(yellow_lane)&gt;<span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(yellow_lane[<span class="number">0</span>])==<span class="number">1</span>:  <span class="comment"># 只检测到黄色行道线</span></span><br><span class="line">    x1, _, x2, _ = yellow_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    x_offset = x2 - x1</span><br><span class="line">    y_offset = <span class="built_in">int</span>(height / <span class="number">2</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">len</span>(white_lane)&gt;<span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(white_lane[<span class="number">0</span>])==<span class="number">1</span>:  <span class="comment"># 只检测到白色行道线</span></span><br><span class="line">    x1, _, x2, _ = white_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    x_offset = x2 - x1</span><br><span class="line">    y_offset = <span class="built_in">int</span>(height / <span class="number">2</span>)</span><br><span class="line"><span class="keyword">else</span>: <span class="comment"># 一条线都没检测到</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;检测不到行道线，退出程序&#x27;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line">angle_to_mid_radian = math.atan(x_offset / y_offset)  </span><br><span class="line">angle_to_mid_deg = <span class="built_in">int</span>(angle_to_mid_radian * <span class="number">180.0</span> / math.pi) </span><br><span class="line">steering_angle = angle_to_mid_deg/<span class="number">45.0</span></span><br><span class="line">action = np.array([steering_angle, <span class="number">0.3</span>])  <span class="comment"># 油门值恒定</span></span><br></pre></td></tr></table></figure>

<p> 到这里我们就可以开始启动程序了。完整代码如下所示： </p>
<p>先编写自定义库tools：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">detect_line</span>(<span class="params">edges</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    基于霍夫变换的直线检测</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    rho = <span class="number">1</span>  <span class="comment"># 距离精度：1像素</span></span><br><span class="line">    angle = np.pi / <span class="number">180</span>  <span class="comment"># 角度精度：1度</span></span><br><span class="line">    min_thr = <span class="number">10</span>  <span class="comment"># 最少投票数</span></span><br><span class="line">    lines = cv2.HoughLinesP(edges,rho, angle,min_thr,np.array([]),minLineLength=<span class="number">8</span>,maxLineGap=<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">return</span> lines</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">average_lines</span>(<span class="params">frame, lines, direction=<span class="string">&#x27;left&#x27;</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    小线段聚类</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    lane_lines = []</span><br><span class="line">    <span class="keyword">if</span> lines <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(direction + <span class="string">&#x27;没有检测到线段&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> lane_lines</span><br><span class="line">    <span class="comment">#height, width , _= frame.shape</span></span><br><span class="line">    fits = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line:</span><br><span class="line">            <span class="keyword">if</span> x1 == x2:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 计算拟合直线</span></span><br><span class="line">            fit = np.polyfit((x1, x2), (y1, y2), <span class="number">1</span>)</span><br><span class="line">            slope = fit[<span class="number">0</span>]</span><br><span class="line">            intercept = fit[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> direction == <span class="string">&#x27;left&#x27;</span> <span class="keyword">and</span> slope &lt; <span class="number">0</span>:</span><br><span class="line">                fits.append((slope, intercept))</span><br><span class="line">            <span class="keyword">elif</span> direction == <span class="string">&#x27;right&#x27;</span> <span class="keyword">and</span> slope &gt; <span class="number">0</span>:</span><br><span class="line">                fits.append((slope, intercept))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(fits) &gt; <span class="number">0</span>:</span><br><span class="line">        fit_average = np.average(fits, axis=<span class="number">0</span>)</span><br><span class="line">        lane_lines.append(make_points(frame, fit_average))</span><br><span class="line">    <span class="keyword">return</span> lane_lines</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_points</span>(<span class="params">frame, line</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    根据直线斜率和截距计算线段起始坐标</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    height, width, _ = frame.shape</span><br><span class="line">    slope, intercept = line</span><br><span class="line">    y1 = height</span><br><span class="line">    y2 = <span class="built_in">int</span>(y1 * <span class="number">1</span> / <span class="number">2</span>)</span><br><span class="line">    x1 = <span class="built_in">max</span>(-width, <span class="built_in">min</span>(<span class="number">2</span> * width, <span class="built_in">int</span>((y1 - intercept) / slope)))</span><br><span class="line">    x2 = <span class="built_in">max</span>(-width, <span class="built_in">min</span>(<span class="number">2</span> * width, <span class="built_in">int</span>((y2 - intercept) / slope)))</span><br><span class="line">    <span class="keyword">return</span> [[x1, y1, x2, y2]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">display_line</span>(<span class="params">frame, lines, line_color=(<span class="params"><span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span></span>), line_width=<span class="number">2</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    在原图上展示线段</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    line_img = np.zeros_like(frame)</span><br><span class="line">    <span class="keyword">if</span> lines <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line:</span><br><span class="line">                cv2.line(line_img, (x1, y1), (x2, y2), line_color, line_width)</span><br><span class="line">    line_img = cv2.addWeighted(frame, <span class="number">0.8</span>, line_img, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> line_img</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    yimg = cv2.imread(<span class="string">&#x27;yellow_edge_new.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">    wimg = cv2.imread(<span class="string">&#x27;white_edge_new.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#霍夫变换</span></span><br><span class="line">    yimg_detect_line = detect_line(yimg)</span><br><span class="line">    wimg_detect_line = detect_line(wimg)</span><br><span class="line">    <span class="comment">#小线段聚类</span></span><br><span class="line">    yimg_average_lines = average_lines(yimg,yimg_detect_line,direction=<span class="string">&#x27;right&#x27;</span>)</span><br><span class="line">    wimg_average_lines = average_lines(wimg,wimg_detect_line)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#在原图上展示线段</span></span><br><span class="line">    y=cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line">    w=cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line">    yellow_display_line = display_line(y, yimg_average_lines)</span><br><span class="line">    white_display_line = display_line(w, wimg_average_lines)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;yellow_display_line.jpg&#x27;</span>, yellow_display_line)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;white_display_line.jpg&#x27;</span>, white_display_line)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">region_of_interest</span>(<span class="params">edges, color=<span class="string">&#x27;yellow&#x27;</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        感兴趣区域提取</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        height, width = edges.shape</span><br><span class="line">        mask = np.zeros_like(edges)</span><br><span class="line">        <span class="comment"># 定义感兴趣区域掩码轮廓</span></span><br><span class="line">        <span class="keyword">if</span> color == <span class="string">&#x27;yellow&#x27;</span>:</span><br><span class="line">            polygon = np.array([[(width * <span class="number">1</span> / <span class="number">2</span>, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                                 (width, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                                 (width, height),</span><br><span class="line">                                 (width * <span class="number">1</span> / <span class="number">2</span>, height)]], np.int32)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            polygon = np.array([[(<span class="number">0</span>, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                                 (width * <span class="number">1</span> / <span class="number">2</span>, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                                 (width * <span class="number">1</span> / <span class="number">2</span>, height),</span><br><span class="line">                                 (<span class="number">0</span>, height)]], np.int32)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 填充感兴趣区域掩码</span></span><br><span class="line">        cv2.fillPoly(mask, polygon, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))</span><br><span class="line">        <span class="comment"># 提取感兴趣区域</span></span><br><span class="line">        croped_edge = cv2.bitwise_and(edges, mask)</span><br><span class="line">        <span class="keyword">return</span> croped_edge</span><br></pre></td></tr></table></figure>

<p>再编写主函数入口：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入系统库</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> gym_donkeycar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入自定义库</span></span><br><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> region_of_interest, detect_line, make_points, average_lines, display_line</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    主函数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 设置模拟器环境</span></span><br><span class="line">    env = gym.make(<span class="string">&quot;donkey-generated-roads-v0&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重置当前场景</span></span><br><span class="line">    obv = env.reset()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始启动</span></span><br><span class="line">    action = np.array([<span class="number">0</span>, <span class="number">1</span>])  <span class="comment"># 动作控制，第1个转向值，第2个油门值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行动作</span></span><br><span class="line">    obv, reward, done, info = env.step(action)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取图像</span></span><br><span class="line">    frame = cv2.cvtColor(obv, cv2.COLOR_RGB2BGR)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 运行1000次动作</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        <span class="comment"># 转换图像到HSV空间</span></span><br><span class="line">        height, width, _ = frame.shape</span><br><span class="line">        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 黄色区域检测</span></span><br><span class="line">        lower_blue = np.array([<span class="number">15</span>, <span class="number">40</span>, <span class="number">40</span>])</span><br><span class="line">        upper_blue = np.array([<span class="number">45</span>, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line">        yellow_mask = cv2.inRange(hsv, lower_blue, upper_blue)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 白色区域检测</span></span><br><span class="line">        lower_blue = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>])</span><br><span class="line">        upper_blue = np.array([<span class="number">180</span>, <span class="number">30</span>, <span class="number">255</span>])</span><br><span class="line">        white_mask = cv2.inRange(hsv, lower_blue, upper_blue)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 黄色线边缘提取</span></span><br><span class="line">        yellow_edge = cv2.Canny(yellow_mask, <span class="number">200</span>, <span class="number">400</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 白色线边缘提取</span></span><br><span class="line">        white_edge = cv2.Canny(white_mask, <span class="number">200</span>, <span class="number">400</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 黄色线感兴趣区域提取</span></span><br><span class="line">        yellow_roi = region_of_interest(yellow_edge, color=<span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 白色线感兴趣区域提取</span></span><br><span class="line">        white_roi = region_of_interest(white_edge, color=<span class="string">&#x27;white&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 黄色线段检测</span></span><br><span class="line">        yellow_lines = detect_line(yellow_roi)</span><br><span class="line">        yellow_lane = average_lines(frame, yellow_lines, direction=<span class="string">&#x27;right&#x27;</span>)</span><br><span class="line">        <span class="comment"># yellow_show = display_line(frame, yellow_lane)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 白色线段检测</span></span><br><span class="line">        white_lines = detect_line(white_roi)</span><br><span class="line">        white_lane = average_lines(frame, white_lines, direction=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line">        <span class="comment"># white_show = display_line(frame, white_lane, line_color=(255, 0, 0))</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算转向角</span></span><br><span class="line">        x_offset = <span class="number">0</span></span><br><span class="line">        y_offset = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(yellow_lane) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(white_lane) &gt; <span class="number">0</span>:  <span class="comment"># 检测到2条线</span></span><br><span class="line">            _, _, left_x2, _ = yellow_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            _, _, right_x2, _ = white_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            mid = <span class="built_in">int</span>(width / <span class="number">2</span>)</span><br><span class="line">            x_offset = (left_x2 + right_x2) / <span class="number">2</span> - mid</span><br><span class="line">            y_offset = <span class="built_in">int</span>(height / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(yellow_lane) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(yellow_lane[<span class="number">0</span>]) == <span class="number">1</span>:  <span class="comment"># 只检测到黄色行道线</span></span><br><span class="line">            x1, _, x2, _ = yellow_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            x_offset = x2 - x1</span><br><span class="line">            y_offset = <span class="built_in">int</span>(height / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(white_lane) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(white_lane[<span class="number">0</span>]) == <span class="number">1</span>:  <span class="comment"># 只检测到白色行道线</span></span><br><span class="line">            x1, _, x2, _ = white_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            x_offset = x2 - x1</span><br><span class="line">            y_offset = <span class="built_in">int</span>(height / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 一条线都没检测到</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;检测不到行道线，退出程序&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        angle_to_mid_radian = math.atan(x_offset / y_offset)</span><br><span class="line">        angle_to_mid_deg = <span class="built_in">int</span>(angle_to_mid_radian * <span class="number">180.0</span> / math.pi)</span><br><span class="line">        steering_angle = angle_to_mid_deg / <span class="number">45.0</span></span><br><span class="line">        action = np.array([steering_angle, <span class="number">0.3</span>])  <span class="comment"># 油门值恒定</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 执行动作</span></span><br><span class="line">        obv, reward, done, info = env.step(action)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 重新获取图像</span></span><br><span class="line">        frame = cv2.cvtColor(obv, cv2.COLOR_RGB2BGR)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 运行完以后重置当前场景</span></span><br><span class="line">    obv = env.reset()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    主函数入口</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>别忘了要先启动模拟器噢！</p>
<p>到这里本节就已经接近尾声了。我对代码中的很多部分进行了修改，使它适应新版的opencv与实际情况。每一部分都重新编写了完整的测试代码。<strong>跳到这里没看的同学至少把测试代码运行一下，尝试理解原理。</strong></p>
<p>注意：如果当前生成的赛道有“十字路口交叉”（每次重新进入赛道其生成的赛道都是随机绘制的），那么在运行的时候可能会出现失败、跑出赛道的现象。因为这种十字路口我们在程序中没有考虑。如何规避这个问题，有兴趣的同学可以自行研究。</p>
<p>本文更多的关注基于深度学习的图像处理技术，对于传统的图像处理算法（例如霍夫变换等）本文不再深入分析，同学们如果对这些传统图像处理算法不熟悉的可以自行再查阅资料深入研究，上面已经给出了不少资料的链接。</p>
<p>截止到目前为止，我们借助上面这个基于opencv的自动驾驶模拟平台，我们重新巩固了Python、opencv图像处理的基本使用方法，了解了自动驾驶项目的难点，对整个处理流程有了更进一步的认识。需要说明的是，尽管我们上述操作步骤是针对我们这个自动驾驶模拟平台的，但是以上步骤同样适用于很多其他图像处理任务，很多传统的图像处理任务都涵盖颜色空间变换、特定颜色物体提取、感兴趣区域过滤、霍夫变换等步骤，因此掌握上述常规的图像处理技术是非常重要的。</p>
<h2 id="3-基于深度学习的自动驾驶控制"><a href="#3-基于深度学习的自动驾驶控制" class="headerlink" title="3.基于深度学习的自动驾驶控制"></a>3.基于深度学习的自动驾驶控制</h2><p>在上一节中我们通过OpenCV图像处理技术实现了一个简易的自动驾驶小车。但是很明显，这辆自动驾驶小车的适应性很差，当图像中有相同颜色的干扰物出现时，那么对于这辆自动驾驶的小车来说就是顶级灾难。另外，我们需要大量人工定义的参数，例如行道线颜色（黄色或白色）、颜色阈值、霍夫变换阈值等，而且一旦地图环境换了，所有这些参数我们都得重新手工调整，这些参数之间又有一定的耦合性，参数调整很麻烦。很显然，这种处理方法普适性不好。</p>
<p>那么能不能丢给机器一大堆图片，让机器自己去学习如何从当前图像中分析出小车应该转向的合适角度？如果没有接触过深度学习，那么乍一听这个想法简直是天方夜谭，然而深度学习确实做到了。这就是为什么近十年深度学习在图像处理领域取得了全面成功。深度学习能够从大量图像数据中自行学习高层次语义特征，完成媲美人类甚至超越人类的推理水平，整个学习过程不用人为干预，我们要做的就是“喂”一堆图片并且设定好需要优化的目标函数即可。当我们“喂”的图片越多、种类越丰富，那么最终机器学习到的驾驶水平越强，而且适应性越好。</p>
<p>本小节开始我们将正式进入基于深度学习的自动驾驶领域。</p>
<h3 id="3-0一些基础知识"><a href="#3-0一些基础知识" class="headerlink" title="3.0一些基础知识"></a>3.0一些基础知识</h3><p>根据后面要用到的网络，这里放上一些基础知识，篇幅都不(太)长，请同学们阅读。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/243050824">神经网络与深度学习</a> 这种基本的认识想必大家已经有了，但这里还是放一放。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1hE411t7RN?share_source=copy_web">pytorch基础教程</a> pytorch可以使用英伟达NVIDIA的产品进行GPU运算，但AMD锐龙的显卡并不支持。教程后期有教到如何使用。这是非常浅显易懂的课(用张老师的话来说就是傻瓜式的)，因此虽然我们主要用到的是pytorch但这里不进行教学。如果仍有困难，后面我会现场讲解或录视频，加上写文档的方式帮助同学们。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/fanxin_i/article/details/80212906">bp神经网络原理</a> bp神经网络我在导论课上讲的那个就是，忘了的话可以去导论那个群下载对应的excel演示下来玩一下。对应的论文也是非常有趣，预训练现在的应用非常广泛，同学们可以阅读一下。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/47184529">卷积神经网络与池化、全连接、归一化</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/112993440">全连接神经网络</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/424518359">归一化</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/51435499">端到端是什么</a></p>
<p>同时建议大家复习一下我当时给大家讲python的时候说到的os库。</p>
<h3 id="3-1算法原理"><a href="#3-1算法原理" class="headerlink" title="3.1算法原理"></a>3.1算法原理</h3><p>本项目实现思路参考2016年英伟达发表的论文《End to End Learning for Self-Driving Cars》。这篇文章提出的方法核心思想就是使用神经网络自动提取图像特征，从传统的 image -&gt; features -&gt; action变成了image -&gt; action。该论文使用了深度网络结构，大大增强了图像特征提取能力，最终取得了不错的效果，其训练的模型不论是普通道路还是高速路，不论有道路标线还是没有道路标线都非常有效，解决了传统算法泛化性能差的问题。本文方法的测试性能非常好，在16年自动驾驶研究火热时，是一篇影响力很大的文章，即使放到现在，也是作为自动驾驶入门必读的Paper。</p>
<p>整个算法原理很简单，是对真实人类操作的一个模拟。对于我们人类驾驶员来说，假设我们正在驾驶这辆车，我们的执行流程跟上面算法也是一样的。首先我们用眼睛观看路面，然后我们的大脑根据当前眼睛看到的路面情况“下意识”的转动方向盘，转动一个我们认为合适的角度，从而避免车辆开出路面。这篇论文算法实现原理也是这样，具体如下图所示：</p>
<p><img src="/.io//essay1.png"></p>
<p>通过中间摄像头采集图像，然后图像输入到预先训练好的CNN网络，这个网络的输出是一个转向角度（可以理解为方向盘的转向角度），有了这个角度就可以控制小车按照这个角度进行转向。</p>
<p>有了这样一个模式，我们就只需要想办法训练这个CNN模型，针对每帧图像，都有一个我们认为合适的转向角度输出，即输入图像，输出一个回归值。具体模型结构如下图所示：<br><img src="/.io//essay2.png"></p>
<p>整个模型结构并不复杂，就是一堆的普通的CNN卷积神经网络模块按照顺序堆叠，最后使用全连接网络输出回归值。这个模型一共包含30层，由于其输入精度比较低(66x200)，因此推理速度也是比较快的，借助GPU可以实现实时推理。具体的，图像首先经过Normalization标准化，然后经过5组卷积层处理，最后拉平以后通过4个全连接层输出一个回归值，这个回归值就是我们项目中的转向角。</p>
<p>这里我们会遇到一个问题，训练上述深度神经网络我们需要大量的数据，即每帧图像以及对应的最佳转向值，这些数据怎么来呢？这篇论文里提出了一个方法，既然是模拟人类行为，那么只要让驾驶水平高超的“老司机”在相关赛道上进行手动驾驶，驾驶时一边记录每帧图像同时记录当前帧对应的操控的转向角，这样一组组数据记录下来就是我们认为的“最佳”训练数据。训练时，将模型预测的角度与给定图像帧的期望转向角度进行比较，误差通过反向传播反馈到CNN训练过程中，如下图所示。从图可以看出，这个过程在一个循环中重复，直到误差（本例中使用均方误差）足够低，这意味着模型已经学会了如何合理地转向。事实上，这是一个非常典型的图像分类训练过程，只不过这里预测输出是数值（回归值）而不是对象类别（分类概率）。<br> 可以想象，如果能够完全的训练好这个模型，那么最终模型的输出结果是非常接近人类驾驶经验的。这篇论文通过大量实验证明，上述模型能够直接从拍摄的路面图像中有效的学习到最终的转向角，省去了传统算法颜色区域检测、感兴趣区域选择、霍夫变换等一系列复杂的耦合步骤。这篇论文做了一组实验，通过收集不到一百小时的少量训练数据进行训练，最后得到的模型足以支持在各种条件下操控车辆，比如高速公路、普通公路和居民区道路，以及晴天、多云和雨天等天气状况。</p>
<p>需要说明的是，这个模型的输出仅有一个转向角度，这样容易学习成功。如果输出变量再多一些（例如油门值、摄像头角度、行人避障等），那么这个模型还需要再进一步优化，感兴趣的同学可以借鉴近两年的论文进行深入研究（而我们的项目就是要做这个）。<br>接下来我们就按照这个算法流程进行实现。</p>
<p>###3.2数据采集</p>
<p>针对我们采用的自动驾驶模拟平台，为了能够采集到每帧图像及对应的最佳转向角度，我们可以使用前面第2节方法编写控制代码通过键盘控制小车（低匀速运行，仅仅只需要控制转向角度），然后记录每帧数据即可。这种模式是真实自动驾驶使用的，但是需要我们自己把自己练成经验充足的“老司机”，然后再去教会算法怎么驾驶。这样比较麻烦，这里可以有一种“偷懒”的办法。我们使用前面调参调的不错的OpenCV自动驾驶版本，使用OpenCV算法自动驾驶，然后记录每帧图像及对应角度。尽管这个OpenCV自动驾驶水平本身也一般（没有一直控制在两条行道线的绝对正中间），但是胜在能够基本稳定在行道线内。本文只是一个自动驾驶入门项目，可以采用这样的方法收集数据，来快速验证深度学习自动驾驶可行性。真实项目的话还是需要向“老司机”学习的。</p>
<p>先定义自定义tools库，这里对上面的进行了一定的修改。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">region_of_interest</span>(<span class="params">edges, color=<span class="string">&#x27;yellow&#x27;</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    感兴趣区域提取</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    height, width = edges.shape</span><br><span class="line">    mask = np.zeros_like(edges)</span><br><span class="line">    <span class="comment"># 定义感兴趣区域掩码轮廓</span></span><br><span class="line">    <span class="keyword">if</span> color == <span class="string">&#x27;yellow&#x27;</span>:</span><br><span class="line">        polygon = np.array([[(<span class="number">0</span>, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                             (width * <span class="number">1</span> / <span class="number">2</span>, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                             (width * <span class="number">1</span> / <span class="number">2</span>, height),</span><br><span class="line">                             (<span class="number">0</span>, height)]], np.int32)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        polygon = np.array([[(width * <span class="number">1</span> / <span class="number">2</span>, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                             (width, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                             (width, height),</span><br><span class="line">                             (width * <span class="number">1</span> / <span class="number">2</span>, height)]], np.int32)</span><br><span class="line">    <span class="comment"># 填充感兴趣区域掩码</span></span><br><span class="line">    cv2.fillPoly(mask, polygon, <span class="number">255</span>)</span><br><span class="line">    <span class="comment"># 提取感兴趣区域</span></span><br><span class="line">    croped_edge = cv2.bitwise_and(edges, mask)</span><br><span class="line">    <span class="keyword">return</span> croped_edge</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">detect_line</span>(<span class="params">edges</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    基于霍夫变换的直线检测</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    rho = <span class="number">1</span>  <span class="comment"># 距离精度：1像素</span></span><br><span class="line">    angle = np.pi / <span class="number">180</span>  <span class="comment">#角度精度：1度</span></span><br><span class="line">    min_thr = <span class="number">10</span>  <span class="comment">#最少投票数</span></span><br><span class="line">    lines = cv2.HoughLinesP(edges,</span><br><span class="line">                            rho,</span><br><span class="line">                            angle,</span><br><span class="line">                            min_thr,</span><br><span class="line">                            np.array([]),</span><br><span class="line">                            minLineLength=<span class="number">8</span>,</span><br><span class="line">                            maxLineGap=<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">return</span> lines</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">average_lines</span>(<span class="params">frame, lines, direction=<span class="string">&#x27;left&#x27;</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    小线段聚类</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    lane_lines = []</span><br><span class="line">    <span class="keyword">if</span> lines <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(direction + <span class="string">&#x27;没有检测到线段&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> lane_lines</span><br><span class="line">    height, width, _ = frame.shape</span><br><span class="line">    fits = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line:</span><br><span class="line">            <span class="keyword">if</span> x1 == x2:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 计算拟合直线</span></span><br><span class="line">            fit = np.polyfit((x1, x2), (y1, y2), <span class="number">1</span>)</span><br><span class="line">            slope = fit[<span class="number">0</span>]</span><br><span class="line">            intercept = fit[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> direction == <span class="string">&#x27;left&#x27;</span> <span class="keyword">and</span> slope &lt; <span class="number">0</span>:</span><br><span class="line">                fits.append((slope, intercept))</span><br><span class="line">            <span class="keyword">elif</span> direction == <span class="string">&#x27;right&#x27;</span> <span class="keyword">and</span> slope &gt; <span class="number">0</span>:</span><br><span class="line">                fits.append((slope, intercept))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(fits) &gt; <span class="number">0</span>:</span><br><span class="line">        fit_average = np.average(fits, axis=<span class="number">0</span>)</span><br><span class="line">        lane_lines.append(make_points(frame, fit_average))</span><br><span class="line">    <span class="keyword">return</span> lane_lines</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_points</span>(<span class="params">frame, line</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    根据直线斜率和截距计算线段起始坐标</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    height, width, _ = frame.shape</span><br><span class="line">    slope, intercept = line</span><br><span class="line">    y1 = height</span><br><span class="line">    y2 = <span class="built_in">int</span>(y1 * <span class="number">1</span> / <span class="number">2</span>)</span><br><span class="line">    x1 = <span class="built_in">max</span>(-width, <span class="built_in">min</span>(<span class="number">2</span> * width, <span class="built_in">int</span>((y1 - intercept) / slope)))</span><br><span class="line">    x2 = <span class="built_in">max</span>(-width, <span class="built_in">min</span>(<span class="number">2</span> * width, <span class="built_in">int</span>((y2 - intercept) / slope)))</span><br><span class="line">    <span class="keyword">return</span> [[x1, y1, x2, y2]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">display_line</span>(<span class="params">frame, lines, line_color=(<span class="params"><span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span></span>), line_width=<span class="number">2</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    在原图上展示线段</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    line_img = np.zeros_like(frame)</span><br><span class="line">    <span class="keyword">if</span> lines <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line:</span><br><span class="line">                cv2.line(line_img, (x1, y1), (x2, y2), line_color, line_width)</span><br><span class="line">    line_img = cv2.addWeighted(frame, <span class="number">0.8</span>, line_img, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> line_img</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>完整采集代码如下，同样有一定的变化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入系统库</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> gym_donkeycar</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 导入自定义库</span></span><br><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> region_of_interest, detect_line, make_points, average_lines, display_line</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    主函数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 设置模拟器环境</span></span><br><span class="line">    env = gym.make(<span class="string">&quot;donkey-generated-roads-v0&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 重置当前场景</span></span><br><span class="line">    obv = env.reset()</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 开始启动</span></span><br><span class="line">    action = np.array([<span class="number">0</span>, <span class="number">0.3</span>])  <span class="comment"># 动作控制，第1个转向值，第2个油门值</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 执行动作</span></span><br><span class="line">    obv, reward, done, info = env.step(action)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 获取图像</span></span><br><span class="line">    frame = cv2.cvtColor(obv, cv2.COLOR_RGB2BGR)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 运行4000次动作</span></span><br><span class="line">    pic_index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4000</span>):</span><br><span class="line">        <span class="comment"># 转换图像到HSV空间</span></span><br><span class="line">        height, width, _ = frame.shape</span><br><span class="line">        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 黄色区域检测</span></span><br><span class="line">        lower_blue = np.array([<span class="number">15</span>, <span class="number">40</span>, <span class="number">40</span>])</span><br><span class="line">        upper_blue = np.array([<span class="number">45</span>, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line">        yellow_mask = cv2.inRange(hsv, lower_blue, upper_blue)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 白色区域检测</span></span><br><span class="line">        lower_blue = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>])</span><br><span class="line">        upper_blue = np.array([<span class="number">180</span>, <span class="number">30</span>, <span class="number">255</span>])</span><br><span class="line">        white_mask = cv2.inRange(hsv, lower_blue, upper_blue)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 黄色线边缘提取</span></span><br><span class="line">        yellow_edge = cv2.Canny(yellow_mask, <span class="number">200</span>, <span class="number">400</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 白色线边缘提取</span></span><br><span class="line">        white_edge = cv2.Canny(white_mask, <span class="number">200</span>, <span class="number">400</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 黄色线感兴趣区域提取</span></span><br><span class="line">        yellow_roi = region_of_interest(yellow_edge, color=<span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 白色线感兴趣区域提取</span></span><br><span class="line">        white_roi = region_of_interest(white_edge, color=<span class="string">&#x27;white&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 黄色线段检测</span></span><br><span class="line">        yellow_lines = detect_line(yellow_roi)</span><br><span class="line">        yellow_lane = average_lines(frame, yellow_lines, direction=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line">        <span class="comment">#yellow_show = display_line(frame, yellow_lane)</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 白色线段检测</span></span><br><span class="line">        white_lines = detect_line(white_roi)</span><br><span class="line">        white_lane = average_lines(frame, white_lines, direction=<span class="string">&#x27;right&#x27;</span>)</span><br><span class="line">        <span class="comment">#white_show = display_line(frame, white_lane, line_color=(255, 0, 0))</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 计算转向角</span></span><br><span class="line">        x_offset = <span class="number">0</span></span><br><span class="line">        y_offset = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(yellow_lane) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(white_lane) &gt; <span class="number">0</span>:  <span class="comment"># 检测到2条线</span></span><br><span class="line">            _, _, left_x2, _ = yellow_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            _, _, right_x2, _ = white_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            mid = <span class="built_in">int</span>(width / <span class="number">2</span>)</span><br><span class="line">            x_offset = (left_x2 + right_x2) / <span class="number">2</span> - mid</span><br><span class="line">            y_offset = <span class="built_in">int</span>(height / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(yellow_lane) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(yellow_lane[<span class="number">0</span>]) == <span class="number">1</span>:  <span class="comment"># 只检测到黄色行道线</span></span><br><span class="line">            x1, _, x2, _ = yellow_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            x_offset = x2 - x1</span><br><span class="line">            y_offset = <span class="built_in">int</span>(height / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(white_lane) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(white_lane[<span class="number">0</span>]) == <span class="number">1</span>:  <span class="comment"># 只检测到白色行道线</span></span><br><span class="line">            x1, _, x2, _ = white_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            x_offset = x2 - x1</span><br><span class="line">            y_offset = <span class="built_in">int</span>(height / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 一条线都没检测到</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;检测不到行道线，退出程序&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line">        angle_to_mid_radian = math.atan(x_offset / y_offset)</span><br><span class="line">        angle_to_mid_deg = <span class="built_in">int</span>(angle_to_mid_radian * <span class="number">180.0</span> / math.pi)</span><br><span class="line">        steering_angle = angle_to_mid_deg / <span class="number">45.0</span></span><br><span class="line">        action = np.array([steering_angle, <span class="number">0.1</span>])  <span class="comment"># 油门值恒定</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 记录当前图像和转向角度</span></span><br><span class="line">        img_path = <span class="string">&quot;log/&#123;:d&#125;_&#123;:.4f&#125;.jpg&quot;</span>.<span class="built_in">format</span>(pic_index, steering_angle)</span><br><span class="line">        cv2.imwrite(img_path, frame)</span><br><span class="line">        pic_index += <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 执行动作</span></span><br><span class="line">        obv, reward, done, info = env.step(action)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 重新获取图像</span></span><br><span class="line">        frame = cv2.cvtColor(obv, cv2.COLOR_RGB2BGR)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 运行完以后重置当前场景</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;结束本次采集&#x27;</span>)</span><br><span class="line">    obv = env.reset()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    主函数入口</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>图片名采用“图片帧号_转向角度.jpg”的形式命名。上述代码每次跑完会在log目录下生成4000多张图片。由于每次的地图都是随机生成的，因此我们可以多跑几次，多收集一些数据。</p>
<p><img src="/.io//Snipaste_2022-04-30_13-50-48.png"></p>
<p>最终共采集10个文件夹图片，总共4万张图片：</p>
<p><img src="/.io//Snipaste_2022-04-30_17-05-30.png"></p>
<p>接下来我们需要对这些图片进行整理，拆分数据集用于训练和验证。我们把这些文件夹移动到data&#x2F;simulate下，注意这个文件夹<strong>需要自己手动创建</strong>。</p>
<p>详细脚本代码create_data_lists.py如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入系统库</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">creat_data_list</span>(<span class="params">dataset_path, file_list, mode=<span class="string">&#x27;train&#x27;</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    创建txt文件列表</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(dataset_path, (mode + <span class="string">&#x27;.txt&#x27;</span>)), <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> (imgpath, angle) <span class="keyword">in</span> file_list:</span><br><span class="line">            f.write(imgpath + <span class="string">&#x27; &#x27;</span> + <span class="built_in">str</span>(angle) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(mode + <span class="string">&#x27;.txt 已生成&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getFileList</span>(<span class="params"><span class="built_in">dir</span>, Filelist, ext=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取文件夹及其子文件夹中文件列表</span></span><br><span class="line"><span class="string">    输入 dir: 文件夹根目录</span></span><br><span class="line"><span class="string">    输入 ext: 扩展名</span></span><br><span class="line"><span class="string">    返回: 文件路径列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    newDir = <span class="built_in">dir</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(<span class="built_in">dir</span>):</span><br><span class="line">        <span class="keyword">if</span> ext <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            Filelist.append(<span class="built_in">dir</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> ext <span class="keyword">in</span> <span class="built_in">dir</span>[-<span class="number">3</span>:]:</span><br><span class="line">                Filelist.append(<span class="built_in">dir</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">elif</span> os.path.isdir(<span class="built_in">dir</span>):</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> os.listdir(<span class="built_in">dir</span>):</span><br><span class="line">            newDir = os.path.join(<span class="built_in">dir</span>, s)</span><br><span class="line">            getFileList(newDir, Filelist, ext)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> Filelist</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    主函数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 设置参数</span></span><br><span class="line">    org_img_folder = <span class="string">&#x27;./data/simulate&#x27;</span>  <span class="comment"># 数据集根目录</span></span><br><span class="line">    train_ratio = <span class="number">0.8</span>  <span class="comment"># 训练集占比</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 检索jpg文件</span></span><br><span class="line">    jpglist = getFileList(org_img_folder, [], <span class="string">&#x27;jpg&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;本次执行检索到 &#x27;</span> + <span class="built_in">str</span>(<span class="built_in">len</span>(jpglist)) + <span class="string">&#x27; 个jpg文件\n&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">    file_list = <span class="built_in">list</span>()</span><br><span class="line">    <span class="comment"># 解析转向值</span></span><br><span class="line">    <span class="keyword">for</span> jpgpath <span class="keyword">in</span> jpglist:</span><br><span class="line">        <span class="built_in">print</span>(jpgpath)</span><br><span class="line">        curDataDir = os.path.dirname(jpgpath)</span><br><span class="line">        basename = os.path.basename(jpgpath)</span><br><span class="line">        angle = (basename[:-<span class="number">4</span>]).split(<span class="string">&#x27;_&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">        imgPath = os.path.join(curDataDir, basename).replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;/&quot;</span>)</span><br><span class="line">        file_list.append((imgPath, angle))</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 切分数据</span></span><br><span class="line">    random.seed(<span class="number">256</span>)</span><br><span class="line">    random.shuffle(file_list)</span><br><span class="line">    train_num = <span class="built_in">int</span>(<span class="built_in">len</span>(file_list) * train_ratio)</span><br><span class="line">    train_list = file_list[<span class="number">0</span>:train_num]</span><br><span class="line">    val_list = file_list[train_num:]</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 创建列表文件</span></span><br><span class="line">    creat_data_list(org_img_folder, train_list, mode=<span class="string">&#x27;train&#x27;</span>)</span><br><span class="line">    creat_data_list(org_img_folder, val_list, mode=<span class="string">&#x27;val&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    程序入口</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>上述代码我们查找每个log文件夹下的jpg文件，然后解析出对应的转向值。将这些值最后分别保存到train.txt和val.txt文件中。在代码里面，我们设定训练集占比0.8，剩下的0.2则为验证集。</p>
<p>生成的train.txt和val.txt文件每行内容表示一个样本，由图片路径和转向值组成，中间用空格隔开。</p>
<p>接下来我们将使用Pytoch框架实现深度学习算法进行训练、验证。 </p>
<h3 id="3-3模型训练"><a href="#3-3模型训练" class="headerlink" title="3.3模型训练"></a>3.3模型训练</h3><p> 首先定义数据采集器datasets.py，代码如下： </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入系统库</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 导入PyTorch库</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AutoDriveDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    数据集加载器</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data_folder, mode, transform=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :参数 data_folder: # 数据文件所在文件夹根路径(train.txt和val.txt所在文件夹路径)</span></span><br><span class="line"><span class="string">        :参数 mode: &#x27;train&#x27; 或者 &#x27;val&#x27;</span></span><br><span class="line"><span class="string">        :参数 normalize_type: 图像归一化处理方式</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">        self.data_folder = data_folder</span><br><span class="line">        self.mode = mode.lower()</span><br><span class="line">        self.transform = transform</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">assert</span> self.mode <span class="keyword">in</span> &#123;<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;val&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 读取图像列表路径</span></span><br><span class="line">        <span class="keyword">if</span> self.mode == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">            file_path=os.path.join(data_folder, <span class="string">&#x27;train.txt&#x27;</span>)            </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            file_path=os.path.join(data_folder, <span class="string">&#x27;val.txt&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        self.file_list=<span class="built_in">list</span>()      </span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            files = f.readlines()</span><br><span class="line">            <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">                <span class="keyword">if</span> file.strip() <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                self.file_list.append([file.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>],<span class="built_in">float</span>(file.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">1</span>])])</span><br><span class="line">                </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, i</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :参数 i: 图像检索号</span></span><br><span class="line"><span class="string">        :返回: 返回第i个图像和标签</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 读取图像</span></span><br><span class="line">        img = cv2.imread(self.file_list[i][<span class="number">0</span>])</span><br><span class="line">        img = cv2.cvtColor(img,cv2.COLOR_BGR2HSV)</span><br><span class="line">        <span class="keyword">if</span> self.transform:</span><br><span class="line">            img = self.transform(img)</span><br><span class="line">        <span class="comment"># 读取标签</span></span><br><span class="line">        label = self.file_list[i][<span class="number">1</span>]</span><br><span class="line">        label = torch.from_numpy(np.array([label])).<span class="built_in">float</span>()</span><br><span class="line">        <span class="keyword">return</span> img, label</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        为了使用PyTorch的DataLoader,必须提供该方法.</span></span><br><span class="line"><span class="string">        :返回: 加载的图像总数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.file_list)</span><br></pre></td></tr></table></figure>

<p>上述代码比较简单，我们构造了AutoDriveDataset类用于作为自动驾驶小车数据读取类，从train.txt和val.txt中根据每行内容得到每个样本的图像路径和对应的真值标签。这里需要注意下颜色空间，我们最终是使用HSV空间进行训练的，因此需要做一下转化。</p>
<p>这里插播一下一个自定义的方法库utils.py：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AverageMeter</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    平均器类,用于计算平均值、总和</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.reset()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reset</span>(<span class="params">self</span>):</span><br><span class="line">        self.val = <span class="number">0</span></span><br><span class="line">        self.avg = <span class="number">0</span></span><br><span class="line">        self.<span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, val, n=<span class="number">1</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">sum</span> += val * n</span><br><span class="line">        self.count += n</span><br><span class="line">        self.avg = self.<span class="built_in">sum</span> / self.count</span><br></pre></td></tr></table></figure>

<p>虽然这个文件里面只有一个类，但创建这样一个文件是习惯。</p>
<p>有了数据读取类以后我们就下来定义模型，具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入PyTorch库</span></span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AutoDriveNet</span>(nn.Module):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    端到端自动驾驶模型</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>(AutoDriveNet, self).__init__()</span><br><span class="line">        self.conv_layers = nn.Sequential(nn.Conv2d(<span class="number">3</span>, <span class="number">24</span>, <span class="number">5</span>, stride=<span class="number">2</span>),</span><br><span class="line">                                         nn.ELU(),</span><br><span class="line">                                         nn.Conv2d(<span class="number">24</span>, <span class="number">36</span>, <span class="number">5</span>, stride=<span class="number">2</span>),</span><br><span class="line">                                         nn.ELU(),</span><br><span class="line">                                         nn.Conv2d(<span class="number">36</span>, <span class="number">48</span>, <span class="number">5</span>, stride=<span class="number">2</span>),</span><br><span class="line">                                         nn.ELU(), nn.Conv2d(<span class="number">48</span>, <span class="number">64</span>, <span class="number">3</span>),</span><br><span class="line">                                         nn.ELU(), nn.Conv2d(<span class="number">64</span>, <span class="number">64</span>, <span class="number">3</span>),</span><br><span class="line">                                         nn.Dropout(<span class="number">0.5</span>))</span><br><span class="line">        self.linear_layers = nn.Sequential(</span><br><span class="line">            <span class="comment">#nn.Linear(in_features=64 * 2 * 33, out_features=100),</span></span><br><span class="line">            nn.Linear(in_features=<span class="number">64</span> * <span class="number">8</span> * <span class="number">13</span>, out_features=<span class="number">100</span>),</span><br><span class="line">            nn.ELU(),</span><br><span class="line">            nn.Linear(in_features=<span class="number">100</span>, out_features=<span class="number">50</span>),</span><br><span class="line">            nn.ELU(),</span><br><span class="line">            nn.Linear(in_features=<span class="number">50</span>, out_features=<span class="number">10</span>),</span><br><span class="line">            nn.Linear(in_features=<span class="number">10</span>, out_features=<span class="number">1</span>))</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        前向推理</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="built_in">input</span> = <span class="built_in">input</span>.view(<span class="built_in">input</span>.size(<span class="number">0</span>), <span class="number">3</span>, <span class="number">120</span>, <span class="number">160</span>)</span><br><span class="line">        output = self.conv_layers(<span class="built_in">input</span>)</span><br><span class="line">        output = output.view(output.size(<span class="number">0</span>), -<span class="number">1</span>)</span><br><span class="line">        output = self.linear_layers(output)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是我们的模型跟论文里的稍微有点不一样(见下)，主要是因为我们的图像尺寸是120x160的，而论文里使用的是66x200。因此，我们对应的输入需要调整下，另外，在最后全连接层也相应的在维度上要调整。对于实际项目来说，现在很多的摄像头都是使用3:4分辨率的，例如树莓派摄像头典型的分辨率是480x640，因此，修改过后的模型更具有普遍性，还方便后面迁移到真实环境训练。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">self.conv_layers = nn.Sequential(nn.Conv2d(<span class="number">3</span>, <span class="number">24</span>, <span class="number">5</span>, stride=<span class="number">2</span>),</span><br><span class="line">                                         nn.ELU(),</span><br><span class="line">                                         nn.Conv2d(<span class="number">24</span>, <span class="number">36</span>, <span class="number">5</span>, stride=<span class="number">2</span>),</span><br><span class="line">                                         nn.ELU(),</span><br><span class="line">                                         nn.Conv2d(<span class="number">36</span>, <span class="number">48</span>, <span class="number">5</span>, stride=<span class="number">2</span>),</span><br><span class="line">                                         nn.ELU(), nn.Conv2d(<span class="number">48</span>, <span class="number">64</span>, <span class="number">3</span>),</span><br><span class="line">                                         nn.ELU(), nn.Conv2d(<span class="number">64</span>, <span class="number">64</span>, <span class="number">3</span>),</span><br><span class="line">                                         nn.Dropout(<span class="number">0.5</span>))</span><br><span class="line">self.linear_layers = nn.Sequential(</span><br><span class="line">            <span class="comment">#nn.Linear(in_features=64 * 2 * 33, out_features=100),</span></span><br><span class="line">            nn.Linear(in_features=<span class="number">64</span> * <span class="number">8</span> * <span class="number">13</span>, out_features=<span class="number">100</span>),</span><br><span class="line">            nn.ELU(),</span><br><span class="line">            nn.Linear(in_features=<span class="number">100</span>, out_features=<span class="number">50</span>),</span><br><span class="line">            nn.ELU(),</span><br><span class="line">            nn.Linear(in_features=<span class="number">50</span>, out_features=<span class="number">10</span>),</span><br><span class="line">            nn.Linear(in_features=<span class="number">10</span>, out_features=<span class="number">1</span>))                                         </span><br></pre></td></tr></table></figure>

<p>整个模型比较简单，前面是多个cnn，最后接几个全连接网络，输入是3通道图像，输出是一个转向回归值。</p>
<p>训练脚本代码train.py如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入torch库</span></span><br><span class="line"><span class="keyword">import</span> torch.backends.cudnn <span class="keyword">as</span> cudnn</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入自定义库</span></span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> AutoDriveNet</span><br><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> AutoDriveDataset</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    训练.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 数据集路径</span></span><br><span class="line">    data_folder = <span class="string">&#x27;./data/simulate&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 学习参数</span></span><br><span class="line">    checkpoint = <span class="literal">None</span>  <span class="comment"># 预训练模型路径，如果不存在则为None</span></span><br><span class="line">    <span class="comment"># checkpoint = &quot;./results/checkpoint.pth&quot;</span></span><br><span class="line">    batch_size = <span class="number">400</span>  <span class="comment"># 批大小</span></span><br><span class="line">    start_epoch = <span class="number">1</span>  <span class="comment"># 轮数起始位置</span></span><br><span class="line">    epochs = <span class="number">1000</span>  <span class="comment"># 迭代轮数</span></span><br><span class="line">    lr = <span class="number">1e-4</span>  <span class="comment"># 学习率</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设备参数</span></span><br><span class="line">    device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(torch.cuda.is_available(), device)</span><br><span class="line">    <span class="comment">#ngpu = 4  # 用来运行的gpu数量</span></span><br><span class="line">    cudnn.benchmark = <span class="literal">True</span>  <span class="comment"># 对卷积进行加速</span></span><br><span class="line">    writer = SummaryWriter()  <span class="comment"># 实时监控     使用命令 tensorboard --logdir runs  进行查看</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化模型</span></span><br><span class="line">    model = AutoDriveNet()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化优化器</span></span><br><span class="line">    optimizer = torch.optim.Adam(params=<span class="built_in">filter</span>(<span class="keyword">lambda</span> p: p.requires_grad,</span><br><span class="line">                                               model.parameters()),</span><br><span class="line">                                 lr=lr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 迁移至默认设备进行训练</span></span><br><span class="line">    model = model.to(device)</span><br><span class="line">    model = model.cuda()</span><br><span class="line">    criterion = nn.MSELoss().to(device)</span><br><span class="line">    criterion = nn.MSELoss().cuda()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载预训练模型</span></span><br><span class="line">    <span class="keyword">if</span> checkpoint <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        checkpoint = torch.load(checkpoint)</span><br><span class="line">        start_epoch = checkpoint[<span class="string">&#x27;epoch&#x27;</span>] + <span class="number">1</span></span><br><span class="line">        model.load_state_dict(checkpoint[<span class="string">&#x27;model&#x27;</span>])</span><br><span class="line">        optimizer.load_state_dict(checkpoint[<span class="string">&#x27;optimizer&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 单机多卡训练</span></span><br><span class="line">    <span class="comment"># if torch.cuda.is_available():</span></span><br><span class="line">    <span class="comment">#   model = nn.DataParallel(model, device_ids=list(range(ngpu)))</span></span><br><span class="line">    <span class="comment">#   model = nn.DataParallel(model, device_ids=[0])</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定制化的dataloader</span></span><br><span class="line">    transformations = transforms.Compose([</span><br><span class="line">        transforms.ToTensor(),  <span class="comment"># 通道置前并且将0-255RGB值映射至0-1</span></span><br><span class="line">        <span class="comment"># transforms.Normalize(</span></span><br><span class="line">        <span class="comment">#     mean=[0.485, 0.456, 0.406],  # 归一化至[-1,1] mean std 来自imagenet 计算</span></span><br><span class="line">        <span class="comment">#     std=[0.229, 0.224, 0.225])</span></span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    train_dataset = AutoDriveDataset(data_folder,</span><br><span class="line">                                     mode=<span class="string">&#x27;train&#x27;</span>,</span><br><span class="line">                                     transform=transformations)</span><br><span class="line">    train_loader = torch.utils.data.DataLoader(train_dataset,</span><br><span class="line">                                               batch_size=batch_size,</span><br><span class="line">                                               shuffle=<span class="literal">True</span>,</span><br><span class="line">                                               num_workers=<span class="number">0</span>,</span><br><span class="line">                                               pin_memory=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始逐轮训练</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(start_epoch, epochs + <span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">        model.train()  <span class="comment"># 训练模式：允许使用批样本归一化</span></span><br><span class="line">        loss_epoch = AverageMeter()  <span class="comment"># 统计损失函数</span></span><br><span class="line">        n_iter = <span class="built_in">len</span>(train_loader)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 按批处理</span></span><br><span class="line">        <span class="keyword">for</span> i, (imgs, labels) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">            <span class="comment"># 数据移至默认设备进行训练</span></span><br><span class="line">            imgs = imgs.to(device)</span><br><span class="line">            labels = labels.to(device)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 前向传播</span></span><br><span class="line">            pre_labels = model(imgs)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算损失</span></span><br><span class="line">            loss = criterion(pre_labels, labels)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 后向传播</span></span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            loss.backward()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新模型</span></span><br><span class="line">            optimizer.step()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 记录损失值</span></span><br><span class="line">            loss_epoch.update(loss.item(), imgs.size(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 打印结果</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;第 &quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot; 个batch训练结束&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 手动释放内存</span></span><br><span class="line">        <span class="keyword">del</span> imgs, labels, pre_labels</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 监控损失值变化</span></span><br><span class="line">        writer.add_scalar(<span class="string">&#x27;MSE_Loss&#x27;</span>, loss_epoch.avg, epoch)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;epoch:&#x27;</span> + <span class="built_in">str</span>(epoch) + <span class="string">&#x27;  MSE_Loss:&#x27;</span> + <span class="built_in">str</span>(loss_epoch.avg))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保存预训练模型</span></span><br><span class="line">        torch.save(</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&#x27;epoch&#x27;</span>: epoch,</span><br><span class="line">                <span class="comment"># &#x27;model&#x27;: model.module.state_dict(),</span></span><br><span class="line">                <span class="string">&#x27;model&#x27;</span>: model.state_dict(),</span><br><span class="line">                <span class="string">&#x27;optimizer&#x27;</span>: optimizer.state_dict()</span><br><span class="line">            &#125;, <span class="string">&#x27;results/checkpoint.pth&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练结束关闭监控</span></span><br><span class="line">    writer.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    程序入口</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>新旧版更替，不同的运行环境都有可能导致代码报各种错误。这里真是坑到不行qwq。经过我反复测试，大家报错时可以解开就近的注释部分进行尝试，这应该是目前最为稳定的版本了。</p>
<p>注意：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">writer = SummaryWriter()</span><br><span class="line">writer.add_scalar(<span class="string">&#x27;MSE_Loss&#x27;</span>, loss_epoch.avg, epoch)</span><br></pre></td></tr></table></figure>

<p>第一行代码及下面的相关方法使得我们可以在pycharm下方终端使用命令 tensorboard –logdir runs  ，点击出现的网页链接(用edge或者chome)，可以看到误差改变情况。如果这行代码报错了，请在终端运行命令  pip install tensorboard等待安装完成。反复刷新浏览器可以更新。根据网页提示进行使用。如果测试的时候运行过太多次，可以修改第二行代码的字符串，会生成一个新的表。删除根目录下run的文件也可以起到减少的作用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ngpu = 4  # 用来运行的gpu数量</span></span><br><span class="line"><span class="comment"># 单机多卡训练</span></span><br><span class="line">    <span class="comment"># if torch.cuda.is_available():</span></span><br><span class="line">    <span class="comment">#   model = nn.DataParallel(model, device_ids=list(range(ngpu)))</span></span><br><span class="line">    <span class="comment">#   model = nn.DataParallel(model, device_ids=[0])</span></span><br></pre></td></tr></table></figure>

<p>只有一个显卡的同学一定要注意保持所有单机多卡训练的代码处于注释状态(我在这儿被坑惨了)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">torch.save(</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&#x27;epoch&#x27;</span>: epoch,</span><br><span class="line">                <span class="comment"># &#x27;model&#x27;: model.module.state_dict(),</span></span><br><span class="line">                <span class="string">&#x27;model&#x27;</span>: model.state_dict(),</span><br><span class="line">                <span class="string">&#x27;optimizer&#x27;</span>: optimizer.state_dict()</span><br><span class="line">            &#125;, <span class="string">&#x27;results/checkpoint.pth&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>对model字段的保存，有的版本需要用注释里的字段，有的用当前的就行。请注意results文件夹最好手动创建。</p>
<h3 id="3-4模型验证"><a href="#3-4模型验证" class="headerlink" title="3.4模型验证"></a>3.4模型验证</h3><p>上面的代码需要迭代1000次, epoch&#x3D;1000的时候基本处在一个比较好的收敛位置，此时误差下降到1e-5左右。不过在跑到第140次左右时就已经下降到1e-4，让误差下降一个数量级在实际工程中还是非常重要的，不过同学们在使用的时候其实跑到这样也能用了。</p>
<p>验证代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入系统库</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入PyTorch库</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.backends.cudnn <span class="keyword">as</span> cudnn</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入自定义库</span></span><br><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> AutoDriveDataset</span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> AutoDriveNet</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 测试集目录</span></span><br><span class="line">    data_folder = <span class="string">&quot;./data/simulate&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义运行的GPU数量</span></span><br><span class="line">    ngpu = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># cudnn.benchmark = True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义设备运行环境</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;定义设备环境&quot;</span>)</span><br><span class="line">    device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载预训练模型</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;加载预训练模型&quot;</span>)</span><br><span class="line">    checkpoint = torch.load(<span class="string">&quot;./results/checkpoint.pth&quot;</span>)</span><br><span class="line">    model = AutoDriveNet()</span><br><span class="line">    model = model.to(device)</span><br><span class="line">    model.load_state_dict(checkpoint[<span class="string">&#x27;model&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 多GPU封装</span></span><br><span class="line">    <span class="comment">#if torch.cuda.is_available():</span></span><br><span class="line">     <span class="comment">#   model = nn.DataParallel(model, device_ids=list(range(ngpu)))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定制化的dataloader</span></span><br><span class="line">    <span class="comment"># 定制dataloader</span></span><br><span class="line">    transformations = transforms.Compose([</span><br><span class="line">        transforms.ToTensor(),  <span class="comment"># 通道置前并且将0-255RGB值映射至0-1</span></span><br><span class="line">        <span class="comment"># transforms.Normalize(</span></span><br><span class="line">        <span class="comment">#     mean=[0.485, 0.456, 0.406],  # 归一化至[-1,1] mean std 来自imagenet 计算</span></span><br><span class="line">        <span class="comment">#     std=[0.229, 0.224, 0.225])</span></span><br><span class="line">    ])</span><br><span class="line">    val_dataset = AutoDriveDataset(data_folder,</span><br><span class="line">                                   mode=<span class="string">&#x27;val&#x27;</span>,</span><br><span class="line">                                   transform=transformations</span><br><span class="line">                                   )</span><br><span class="line"></span><br><span class="line">    val_loader = torch.utils.data.DataLoader(val_dataset, batch_size=<span class="number">1</span>, shuffle=<span class="literal">False</span>, num_workers=<span class="number">1</span>,</span><br><span class="line">                                             pin_memory=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义评估指标</span></span><br><span class="line">    criterion = nn.MSELoss().to(device)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 记录误差值</span></span><br><span class="line">    MSEs = AverageMeter()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 记录测试时间</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    start = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;开始进行测试&quot;</span>)</span><br><span class="line">        <span class="comment"># 逐批样本进行推理计算</span></span><br><span class="line">        <span class="keyword">for</span> i, (imgs, labels) <span class="keyword">in</span> <span class="built_in">enumerate</span>(val_loader):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;第&#123;&#125;次计算进行中&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">            <span class="comment"># 数据移至默认设备进行推理</span></span><br><span class="line">            imgs = imgs.to(device)</span><br><span class="line">            labels = labels.to(device)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 前向传播</span></span><br><span class="line">            pre_labels = model(imgs)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算误差</span></span><br><span class="line">            loss = criterion(pre_labels, labels)</span><br><span class="line">            MSEs.update(loss.item(), imgs.size(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出平均均方误差</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;MSE  &#123;mses.avg: .3f&#125;&#x27;</span>.<span class="built_in">format</span>(mses=MSEs))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;平均单张样本用时  &#123;:.3f&#125; 秒&#x27;</span>.<span class="built_in">format</span>((time.time() - start) / <span class="built_in">len</span>(val_dataset)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    程序入口</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="/.io//Snipaste_2022-05-01_12-49-31.png"></p>
<p>我们的转向角度取值范围是[-1, 1]，这样的误差比较小，是可以接受的。请注意多卡训练的同学，一定要解开nn.DataParallel的注释，否则是无法运行的。</p>
<p>这里等待的时间比较长，所以我增加了一些print输出来判断到底是电脑卡了还是程序在运行。同学们如果配置比较低，也建议这样自行增加一些print。</p>
<h3 id="3-5单张图片预测"><a href="#3-5单张图片预测" class="headerlink" title="3.5单张图片预测"></a>3.5单张图片预测</h3><p>为什么上一步已经用8000张图片进行预测了，这里还要用单张图片来尝试呢？真实的自动驾驶的时候，我们是要对每一张图片进行分析的。所以这里来尝试一下用单张图片来分析。</p>
<p>我们选取一张比较有代表性的图片:</p>
<p><img src="/.io//3976_0.2444.jpg"></p>
<p>大家可以先猜测一下这个转向角度。</p>
<p>下面是测试代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入OpenCV库</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 导入PyTorch库</span></span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 导入自定义库</span></span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> AutoDriveNet</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    主函数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 测试图像</span></span><br><span class="line">    imgPath = <span class="string">&#x27;./results/test.jpg&#x27;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 推理环境</span></span><br><span class="line">    device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 加载训练好的模型</span></span><br><span class="line">    checkpoint = torch.load(<span class="string">&#x27;./results/checkpoint.pth&#x27;</span>)</span><br><span class="line">    model = AutoDriveNet()</span><br><span class="line">    model = model.to(device)</span><br><span class="line">    model.load_state_dict(checkpoint[<span class="string">&#x27;model&#x27;</span>],strict=<span class="literal">False</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 加载图像</span></span><br><span class="line">    img = cv2.imread(imgPath)</span><br><span class="line">    img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 图像预处理</span></span><br><span class="line">    <span class="comment"># PIXEL_MEANS = (0.485, 0.456, 0.406)  # RGB格式的均值和方差</span></span><br><span class="line">    <span class="comment"># PIXEL_STDS = (0.229, 0.224, 0.225)</span></span><br><span class="line">    img = torch.from_numpy(img.copy()).<span class="built_in">float</span>()</span><br><span class="line">    img /= <span class="number">255.0</span></span><br><span class="line">    <span class="comment"># img -= torch.tensor(PIXEL_MEANS)</span></span><br><span class="line">    <span class="comment"># img /= torch.tensor(PIXEL_STDS)</span></span><br><span class="line">    img = img.permute(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    img.unsqueeze_(<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 转移数据至设备</span></span><br><span class="line">    img = img.to(device)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 模型推理</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        prelabel = model(img).squeeze(<span class="number">0</span>).cpu().detach().numpy()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;预测结果  &#123;:.3f&#125; &#x27;</span>.<span class="built_in">format</span>(prelabel[<span class="number">0</span>]))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    程序入口</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>请注意一定要把测试的图片移动到result目录下，且命名为test.jpg，或修改代码中对应行。</p>
<p>测试结果：</p>
<p><img src="/.io//Snipaste_2022-05-01_13-03-45.png"></p>
<p>而实际上这台小车正准备右转，转向值为0.244。趋势上是正确的，而效果上也是可以接受的。</p>
<h3 id="3-6系统集成，自动驾驶"><a href="#3-6系统集成，自动驾驶" class="headerlink" title="3.6系统集成，自动驾驶"></a>3.6系统集成，自动驾驶</h3><p>我们现在可以使用pytorch逐帧分析图像，然后直接给出转向值用于小车控制，不再需要复杂的、分散的图像处理步骤。</p>
<p>只需要把上一小节的代码和之前的控制代码合并即可实现。编程能力强的同学可以留作练习。</p>
<p>运行auto_drive.py文件，其完整代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入系统库</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> gym_donkeycar</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 导入PyTorch库</span></span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 导入自定义库</span></span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> AutoDriveNet</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    主函数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 设置模拟器环境</span></span><br><span class="line">    env = gym.make(<span class="string">&quot;donkey-generated-roads-v0&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置推理环境</span></span><br><span class="line">    device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 加载训练好的模型</span></span><br><span class="line">    checkpoint = torch.load(<span class="string">&#x27;./results/checkpoint.pth&#x27;</span>)</span><br><span class="line">    model = AutoDriveNet()</span><br><span class="line">    model = model.to(device)</span><br><span class="line">    model.load_state_dict(checkpoint[<span class="string">&#x27;model&#x27;</span>])</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 重置当前场景</span></span><br><span class="line">    obv = env.reset()</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 开始启动</span></span><br><span class="line">    action = np.array([<span class="number">0</span>, <span class="number">0.1</span>])  <span class="comment"># 动作控制，第1个转向值，第2个油门值</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 执行动作并获取图像</span></span><br><span class="line">    img, reward, done, info = env.step(action)</span><br><span class="line">    img = cv2.cvtColor(img, cv2.COLOR_RGB2HSV)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 运行5000次动作</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5000</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 图像预处理</span></span><br><span class="line">        img = torch.from_numpy(img.copy()).<span class="built_in">float</span>()</span><br><span class="line">        img /= <span class="number">255.0</span></span><br><span class="line">        img = img.permute(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        img.unsqueeze_(<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 转移数据至设备</span></span><br><span class="line">        img = img.to(device)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 模型推理</span></span><br><span class="line">        steering_angle = <span class="number">0</span></span><br><span class="line">        factor=<span class="number">1</span></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            <span class="comment"># 计算转向角度</span></span><br><span class="line">            steering_angle = (model(img).squeeze(<span class="number">0</span>).cpu().detach().numpy())[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> steering_angle*factor&lt;-<span class="number">1</span>:</span><br><span class="line">                steering_angle=-<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> steering_angle*factor&gt;<span class="number">1</span>:</span><br><span class="line">                steering_angle=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                steering_angle=steering_angle*factor</span><br><span class="line">            <span class="built_in">print</span>(steering_angle)</span><br><span class="line">            action = np.array([steering_angle, <span class="number">0.1</span>])  <span class="comment"># 油门值恒定</span></span><br><span class="line"> </span><br><span class="line">            <span class="comment"># 执行动作并更新图像</span></span><br><span class="line">            img, reward, done, info = env.step(action)</span><br><span class="line">            img = cv2.cvtColor(img, cv2.COLOR_RGB2HSV)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 运行完以后重置当前场景</span></span><br><span class="line">    obv = env.reset()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    主函数入口</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>从视频效果上看，通过深度学习的自动驾驶小车其操控流畅性感觉上超过了它的“师傅”OpenCV版本。可能的原因在于纯粹的OpenCV图像处理方法对每帧单独处理，没有一个整体的去噪概念，容易在某一帧出现偏差。但是基于深度学习的方法更多的是学习整个数据集的操作体验，某种意义上做了一定的概率去噪，或者说是平均化，因此，整个的操控才会显得更加流畅。</p>
<p>到这里，这个简单的教程就结束了。恭喜你，你已经入门了end to end自动驾驶(大概)。希望我的拙见可以帮助到大家学习。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://qianmuoy.github.io">qianmu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://qianmuoy.github.io/2024/02/04/%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%AB%AF%E5%88%B0%E7%AB%AF%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/">https://qianmuoy.github.io/2024/02/04/%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%AB%AF%E5%88%B0%E7%AB%AF%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/02/04/%E5%9F%BA%E4%BA%8ECALRA%E5%92%8CDQN%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E7%9A%84%E4%BB%BF%E7%9C%9F/" title="基于CALRA和DQN实现自动驾驶的仿真"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">基于CALRA和DQN实现自动驾驶的仿真</div></div></a></div><div class="next-post pull-right"><a href="/2024/02/04/%E6%A0%88%E6%BA%A2%E5%87%BA/" title="栈溢出"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">栈溢出</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">qianmu</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/QianMuOY"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%AB%AF%E5%88%B0%E7%AB%AF%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6"><span class="toc-number">1.</span> <span class="toc-text">基于深度学习的端到端自动驾驶</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A8%A1%E6%8B%9F%E5%B9%B3%E5%8F%B0%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.</span> <span class="toc-text">1.模拟平台安装和基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1模拟器的安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2git%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2git工具的安装与配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1%E6%B3%A8%E5%86%8Cgithub%E8%B4%A6%E5%8F%B7"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1.2.1注册github账号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2%E5%AE%89%E8%A3%85git"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">1.2.2安装git</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3%E9%85%8D%E7%BD%AEgit"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">1.2.3配置git</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4%E5%9C%A8pycharm%E4%B8%AD%E9%85%8D%E7%BD%AEgit"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">1.2.4在pycharm中配置git</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%9F%BA%E4%BA%8EOpenCV%E7%9A%84%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E6%8E%A7%E5%88%B6"><span class="toc-number">1.2.</span> <span class="toc-text">2.基于OpenCV的自动驾驶控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E5%9F%BA%E4%BA%8EHSV%E7%A9%BA%E9%97%B4%E7%9A%84%E7%89%B9%E5%AE%9A%E9%A2%9C%E8%89%B2%E5%8C%BA%E5%9F%9F%E6%8F%90%E5%8F%96"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1基于HSV空间的特定颜色区域提取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E5%9F%BA%E4%BA%8Ecanny%E7%AE%97%E5%AD%90%E7%9A%84%E8%BE%B9%E7%BC%98%E8%BD%AE%E5%BB%93%E6%8F%90%E5%8F%96"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2基于canny算子的边缘轮廓提取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E6%84%9F%E5%85%B4%E8%B6%A3%E5%8C%BA%E5%9F%9F-ROI-%E5%AE%9A%E4%BD%8D"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3感兴趣区域(ROI)定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5%E5%8A%A8%E4%BD%9C%E6%8E%A7%E5%88%B6%EF%BC%9A%E8%BD%AC%E5%90%91%E8%A7%92"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.5动作控制：转向角</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E6%8E%A7%E5%88%B6"><span class="toc-number">1.3.</span> <span class="toc-text">3.基于深度学习的自动驾驶控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-0%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.0一些基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.1算法原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3模型训练</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4%E6%A8%A1%E5%9E%8B%E9%AA%8C%E8%AF%81"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4模型验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5%E5%8D%95%E5%BC%A0%E5%9B%BE%E7%89%87%E9%A2%84%E6%B5%8B"><span class="toc-number">1.3.5.</span> <span class="toc-text">3.5单张图片预测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6%E7%B3%BB%E7%BB%9F%E9%9B%86%E6%88%90%EF%BC%8C%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6"><span class="toc-number">1.3.6.</span> <span class="toc-text">3.6系统集成，自动驾驶</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/04/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8ASLR%E6%9C%BA%E5%88%B6%E4%B8%8BDLL%E6%96%87%E4%BB%B6%E5%9C%A8%E4%B8%8D%E5%90%8C%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%9F%BA%E5%9D%80%E7%9B%B8%E5%90%8C%EF%BC%9F/" title="为什么在ASLR机制下DLL文件在不同进程中的加载基址相同？">为什么在ASLR机制下DLL文件在不同进程中的加载基址相同？</a><time datetime="2024-02-04T13:17:35.000Z" title="Created 2024-02-04 21:17:35">2024-02-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/04/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="线程池">线程池</a><time datetime="2024-02-04T13:08:39.000Z" title="Created 2024-02-04 21:08:39">2024-02-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/04/VT-x/" title="VT-x">VT-x</a><time datetime="2024-02-04T13:02:40.000Z" title="Created 2024-02-04 21:02:40">2024-02-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/04/TLS/" title="TLS">TLS</a><time datetime="2024-02-04T13:01:16.000Z" title="Created 2024-02-04 21:01:16">2024-02-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/04/Hook%E8%AE%A1%E7%AE%97%E5%99%A8%E4%BB%A5%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97/" title="Hook计算器以显示中文数字">Hook计算器以显示中文数字</a><time datetime="2024-02-04T12:55:21.000Z" title="Created 2024-02-04 20:55:21">2024-02-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By qianmu</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async src="https://www.liuzehe.top/upload/bkjs/yinghua.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":100,"height":220},"mobile":{"show":"flase"},"log":false});</script></body></html>